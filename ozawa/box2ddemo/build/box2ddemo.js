
(function() {
var __main_module_name__ = "main";
var __resources__ = {};
var __remote_resources__ = {};
function __imageResource(data) { var img = new Image(); img.src = data; return img; };
var FLIP_Y_AXIS = false;
var ENABLE_WEB_GL = false;
var SHOW_REDRAW_REGIONS = false;

__resources__["/__builtin__/event.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*global module exports require*/
/*jslint white: true, undef: true, nomen: true, bitwise: true, regexp: true, newcap: true*/


/**
 * @namespace
 * Support for listening for and triggering events
 */
var event = {};

/**
 * @private
 * @ignore
 * Returns the event listener property of an object, creating it if it doesn't
 * already exist.
 *
 * @returns {Object}
 */
function getListeners(obj, eventName) {
    if (!obj.js_listeners_) {
        obj.js_listeners_ = {};
    }
    if (!eventName) {
        return obj.js_listeners_;
    }
    if (!obj.js_listeners_[eventName]) {
        obj.js_listeners_[eventName] = {};
    }
    return obj.js_listeners_[eventName];
}

/**
 * @private
 * @ignore
 * Keep track of the next ID for each new EventListener
 */
var eventID = 0;

/**
 * @class
 * Represents an event being listened to. You should not create instances of
 * this directly, it is instead returned by event.addListener
 *
 * @extends Object
 * 
 * @param {Object} source Object to listen to for an event
 * @param {String} eventName Name of the event to listen for
 * @param {Function} handler Callback to fire when the event triggers
 */
event.EventListener = function (source, eventName, handler) {
    /**
     * Object to listen to for an event
     * @type Object 
     */
    this.source = source;
    
    /**
     * Name of the event to listen for
     * @type String
     */
    this.eventName = eventName;

    /**
     * Callback to fire when the event triggers
     * @type Function
     */
    this.handler = handler;

    /**
     * Unique ID number for this instance
     * @type Integer 
     */
    this.id = ++eventID;

    getListeners(source, eventName)[this.id] = this;
};

/**
 * Register an event listener
 *
 * @param {Object} source Object to listen to for an event
 * @param {String} eventName Name of the event to listen for
 * @param {Function} handler Callback to fire when the event triggers
 *
 * @returns {event.EventListener} The event listener. Pass to removeListener to destroy it.
 */
event.addListener = function (source, eventName, handler) {
    return new event.EventListener(source, eventName, handler);
};

/**
 * Trigger an event. All listeners will be notified.
 *
 * @param {Object} source Object to trigger the event on
 * @param {String} eventName Name of the event to trigger
 */
event.trigger = function (source, eventName) {
    var listeners = getListeners(source, eventName),
        args = Array.prototype.slice.call(arguments, 2),
        eventID,
        l;

    for (eventID in listeners) {
        if (listeners.hasOwnProperty(eventID)) {
            l = listeners[eventID];
            if (l) {
                l.handler.apply(undefined, args);
            }
        }
    }
};

/**
 * Remove a previously registered event listener
 *
 * @param {event.EventListener} listener EventListener to remove, as returned by event.addListener
 */
event.removeListener = function (listener) {
    delete getListeners(listener.source, listener.eventName)[listener.eventID];
};

/**
 * Remove a all event listeners for a given event
 *
 * @param {Object} source Object to remove listeners from
 * @param {String} eventName Name of event to remove listeners from
 */
event.clearListeners = function (source, eventName) {
    var listeners = getListeners(source, eventName),
        eventID;


    for (eventID in listeners) {
        if (listeners.hasOwnProperty(eventID)) {
            var l = listeners[eventID];
            if (l) {
                event.removeListener(l);
            }
        }
    }
};

/**
 * Remove all event listeners on an object
 *
 * @param {Object} source Object to remove listeners from
 */
event.clearInstanceListeners = function (source, eventName) {
    var listeners = getListeners(source),
        eventID;

    for (eventName in listeners) {
        if (listeners.hasOwnProperty(eventName)) {
            var el = listeners[eventName];
            for (eventID in el) {
                if (el.hasOwnProperty(eventID)) {
                    var l = el[eventID];
                    if (l) {
                        event.removeListener(l);
                    }
                }
            }
        }
    }
};

module.exports = event;

}};
__resources__["/__builtin__/events.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*global module exports require*/
/*jslint white: true, undef: true, nomen: true, bitwise: true, regexp: true, newcap: true*/

/**
 * @namespace
 * Support for listening for and triggering events
 */
var events = {};

/**
 * @private
 * @ignore
 * Returns the event listener property of an object, creating it if it doesn't
 * already exist.
 *
 * @returns {Object}
 */
function getListeners(obj, eventName) {
    if (!obj.js_listeners_) {
        obj.js_listeners_ = {};
    }
    if (!eventName) {
        return obj.js_listeners_;
    }
    if (!obj.js_listeners_[eventName]) {
        obj.js_listeners_[eventName] = {};
    }
    return obj.js_listeners_[eventName];
}

/**
 * @private
 * @ignore
 * Keep track of the next ID for each new EventListener
 */
var eventID = 0;

/**
 * @class
 * Represents an event being listened to. You should not create instances of
 * this directly, it is instead returned by events.addListener
 *
 * @extends Object
 * 
 * @param {Object} source Object to listen to for an event
 * @param {String} eventName Name of the event to listen for
 * @param {Function} handler Callback to fire when the event triggers
 */
events.EventListener = function (source, eventName, handler) {
    /**
     * Object to listen to for an event
     * @type Object 
     */
    this.source = source;
    
    /**
     * Name of the event to listen for
     * @type String
     */
    this.eventName = eventName;

    /**
     * Callback to fire when the event triggers
     * @type Function
     */
    this.handler = handler;

    /**
     * Unique ID number for this instance
     * @type Integer 
     */
    this.id = ++eventID;

    getListeners(source, eventName)[this.id] = this;
};

/**
 * Register an event listener
 *
 * @param {Object} source Object to listen to for an event
 * @param {String|Stringp[} eventName Name or Array of names of the event(s) to listen for
 * @param {Function} handler Callback to fire when the event triggers
 *
 * @returns {events.EventListener|events.EventListener[]} The event listener(s). Pass to removeListener to destroy it.
 */
events.addListener = function (source, eventName, handler) {
    if (eventName instanceof Array) {
        var listeners = [];
        for (var i = 0, len = eventName.length; i < len; i++) {
            listeners.push(new events.EventListener(source, eventName[i], handler));
        }
        return listeners;
    } else {
        return new events.EventListener(source, eventName, handler);
    }
};

/**
 * Trigger an event. All listeners will be notified.
 *
 * @param {Object} source Object to trigger the event on
 * @param {String} eventName Name of the event to trigger
 */
events.trigger = function (source, eventName) {
    var listeners = getListeners(source, eventName),
        args = Array.prototype.slice.call(arguments, 2),
        eventID,
        l;

    for (eventID in listeners) {
        if (listeners.hasOwnProperty(eventID)) {
            l = listeners[eventID];
            if (l) {
                l.handler.apply(undefined, args);
            }
        }
    }
};

/**
 * Remove a previously registered event listener
 *
 * @param {events.EventListener} listener EventListener to remove, as returned by events.addListener
 */
events.removeListener = function (listener) {
    delete getListeners(listener.source, listener.eventName)[listener.eventID];
};

/**
 * Remove a all event listeners for a given event
 *
 * @param {Object} source Object to remove listeners from
 * @param {String} eventName Name of event to remove listeners from
 */
events.clearListeners = function (source, eventName) {
    var listeners = getListeners(source, eventName),
        eventID;


    for (eventID in listeners) {
        if (listeners.hasOwnProperty(eventID)) {
            var l = listeners[eventID];
            if (l) {
                events.removeListener(l);
            }
        }
    }
};

/**
 * Remove all event listeners on an object
 *
 * @param {Object} source Object to remove listeners from
 */
events.clearInstanceListeners = function (source) {
    var listeners = getListeners(source),
        eventID;

    for (var eventName in listeners) {
        if (listeners.hasOwnProperty(eventName)) {
            var el = listeners[eventName];
            for (eventID in el) {
                if (el.hasOwnProperty(eventID)) {
                    var l = el[eventID];
                    if (l) {
                        events.removeListener(l);
                    }
                }
            }
        }
    }
};

module.exports = events;

}};
__resources__["/__builtin__/global.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    events = require('events');


/**
 * @ignore
 */
function getAccessors(obj) {
    if (!obj.js_accessors_) {
        obj.js_accessors_ = {};
    }
    return obj.js_accessors_;
}

/**
 * @ignore
 */
function getBindings(obj) {
    if (!obj.js_bindings_) {
        obj.js_bindings_ = {};
    }
    return obj.js_bindings_;
}

/**
 * @ignore
 */
function addAccessor(obj, key, target, targetKey, noNotify) {
    getAccessors(obj)[key] = {
        key: targetKey,
        target: target
    };

    if (!noNotify) {
        obj.triggerChanged(key);
    }
}


/**
 * @ignore
 */
var objectID = 0;

/**
 * @class
 * A bindable object. Allows observing and binding to its properties.
 */
var BObject = function () {};
BObject.prototype = util.extend(BObject.prototype, /** @lends BObject# */{
    /**
     * Unique ID
     * @type Integer
     */
    _id: 0,
    

    /**
     * The constructor for subclasses. Overwrite this for any initalisation you
     * need to do.
     * @ignore
     */
    init: function () {},

    /**
     * Get a property from the object. Always use this instead of trying to
     * access the property directly. This will ensure all bindings, setters and
     * getters work correctly.
     * 
     * @param {String} key Name of property to get or dot (.) separated path to a property
     * @returns {*} Value of the property
     */
    get: function (key) {
        var next = false
        if (~key.indexOf('.')) {
            var tokens = key.split('.');
            key = tokens.shift();
            next = tokens.join('.');
        }


        var accessor = getAccessors(this)[key],
            val;
        if (accessor) {
            val = accessor.target.get(accessor.key);
        } else {
            // Call getting function
            if (this['get_' + key]) {
                val = this['get_' + key]();
            } else {
                val = this[key];
            }
        }

        if (next) {
            return val.get(next);
        } else {
            return val;
        }
    },


    /**
     * Set a property on the object. Always use this instead of trying to
     * access the property directly. This will ensure all bindings, setters and
     * getters work correctly.
     * 
     * @param {String} key Name of property to get
     * @param {*} value New value for the property
     */
    set: function (key, value) {
        var accessor = getAccessors(this)[key],
            oldVal = this.get(key);


        this.triggerBeforeChanged(key, oldVal);

        if (accessor) {
            accessor.target.set(accessor.key, value);
        } else {

            if (this['set_' + key]) {
                this['set_' + key](value);
            } else {
                this[key] = value;
            }
        }
        this.triggerChanged(key, oldVal);
    },

    /**
     * Set multiple propertys in one go
     *
     * @param {Object} kvp An Object where the key is a property name and the value is the value to assign to the property
     *
     * @example
     * var props = {
     *   monkey: 'ook',
     *   cat: 'meow',
     *   dog: 'woof'
     * };
     * foo.setValues(props);
     * console.log(foo.get('cat')); // Logs 'meow'
     */
    setValues: function (kvp) {
        for (var x in kvp) {
            if (kvp.hasOwnProperty(x)) {
                this.set(x, kvp[x]);
            }
        }
    },

    changed: function (key) {
    },

    /**
     * @private
     */
    notify: function (key, oldVal) {
        var accessor = getAccessors(this)[key];
        if (accessor) {
            accessor.target.notify(accessor.key, oldVal);
        }
    },

    /**
     * @private
     */
    triggerBeforeChanged: function (key, oldVal) {
        events.trigger(this, key.toLowerCase() + '_before_changed', oldVal);
    },

    /**
     * @private
     */
    triggerChanged: function (key, oldVal) {
        events.trigger(this, key.toLowerCase() + '_changed', oldVal);
    },

    /**
     * Bind the value of a property on this object to that of another object so
     * they always have the same value. Setting the value on either object will update
     * the other too.
     *
     * @param {String} key Name of the property on this object that should be bound
     * @param {BOject} target Object to bind to
     * @param {String} [targetKey=key] Key on the target object to bind to
     * @param {Boolean} [noNotify=false] Set to true to prevent this object's property triggering a 'changed' event when adding the binding
     */
    bindTo: function (key, target, targetKey, noNotify) {
        targetKey = targetKey || key;
        var self = this;
        this.unbind(key);

        var oldVal = this.get(key);

        // When bound property changes, trigger a 'changed' event on this one too
        getBindings(this)[key] = events.addListener(target, targetKey.toLowerCase() + '_changed', function (oldVal) {
            self.triggerChanged(key, oldVal);
        });

        addAccessor(this, key, target, targetKey, noNotify);
    },

    /**
     * Remove binding from a property which set setup using BObject#bindTo.
     *
     * @param {String} key Name of the property on this object to unbind
     */
    unbind: function (key) {
        var binding = getBindings(this)[key];
        if (!binding) {
            return;
        }

        delete getBindings(this)[key];
        events.removeListener(binding);
        // Grab current value from bound property
        var val = this.get(key);
        delete getAccessors(this)[key];
        // Set bound value
        this[key] = val;
    },

    /**
     * Remove all bindings on this object
     */
    unbindAll: function () {
        var keys = [],
            bindings = getBindings(this);
        for (var k in bindings) {
            if (bindings.hasOwnProperty(k)) {
                this.unbind(k);
            }
        }
    },

    /**
     * Unique ID for this object
     * @getter id
     * @type Integer
     */
    get_id: function () {
        if (!this._id) {
            this._id = ++objectID;
        }

        return this._id;
    }
});


/**
 * Create a new instance of this object
 * @returns {BObject} New instance of this object
 */
BObject.create = function () {
    var ret = new this();
    ret.init.apply(ret, arguments);
    return ret;
};

/**
 * Create a new subclass by extending this one
 * @returns {Object} A new subclass of this object
 */
BObject.extend = function() {
    var newObj = function() {},
        args = [],
        i,
        x;

    // Copy 'class' methods
    for (x in this) {
        if (this.hasOwnProperty(x)) {
            newObj[x] = this[x];
        }
    }


    // Add given properties to the prototype
    newObj.prototype = util.beget(this.prototype);
    args.push(newObj.prototype);
    for (i = 0; i<arguments.length; i++) {
        args.push(arguments[i]);
    }
    util.extend.apply(null, args);

    newObj.superclass = this.prototype;
    // Create new instance
    return newObj;
};

/**
 * Get a property from the class. Always use this instead of trying to
 * access the property directly. This will ensure all bindings, setters and
 * getters work correctly.
 * 
 * @function
 * @param {String} key Name of property to get
 * @returns {*} Value of the property
 */
BObject.get = BObject.prototype.get;

/**
 * Set a property on the class. Always use this instead of trying to
 * access the property directly. This will ensure all bindings, setters and
 * getters work correctly.
 * 
 * @function
 * @param {String} key Name of property to get
 * @param {*} value New value for the property
 */
BObject.set = BObject.prototype.set;

var BArray = BObject.extend(/** @lends BArray# */{

    /**
     * @constructs 
     * A bindable array. Allows observing for changes made to its contents
     *
     * @extends BObject
     * @param {Array} [array=[]] A normal JS array to use for data
     */
    init: function (array) {
        this.array = array || [];
        this.set('length', this.array.length);
    },

    /**
     * Get an item
     *
     * @param {Integer} i Index to get item from
     * @returns {*} Value stored in the array at index 'i'
     */
    getAt: function (i) {
        return this.array[i];
    },

    /**
     * Set an item -- Overwrites any existing item at index
     *
     * @param {Integer} i Index to set item to
     * @param {*} value Value to assign to index
     */
    setAt: function (i, value) {
        var oldVal = this.array[i];
        this.array[i] = value;

        events.trigger(this, 'set_at', i, oldVal);
    },

    /**
     * Insert a new item into the array without overwriting anything
     *
     * @param {Integer} i Index to insert item at
     * @param {*} value Value to insert
     */
    insertAt: function (i, value) {
        this.array.splice(i, 0, value);
        this.set('length', this.array.length);
        events.trigger(this, 'insert_at', i);
    },

    /**
     * Remove item from the array and return it
     *
     * @param {Integer} i Index to remove
     * @returns {*} Value that was removed
     */
    removeAt: function (i) {
        var oldVal = this.array[i];
        this.array.splice(i, 1);
        this.set('length', this.array.length);
        events.trigger(this, 'remove_at', i, oldVal);

        return oldVal;
    },

    /**
     * Get the internal Javascript Array instance
     *
     * @returns {Array} Internal Javascript Array
     */
    getArray: function () {
        return this.array;
    },

    /**
     * Append a value to the end of the array and return its new length
     *
     * @param {*} value Value to append to the array
     * @returns {Integer} New length of the array
     */
    push: function (value) {
        this.insertAt(this.array.length, value);
        return this.array.length;
    },

    /**
     * Remove value from the end of the array and return it
     *
     * @returns {*} Value that was removed
     */
    pop: function () {
        return this.removeAt(this.array.length - 1);
    }
});

exports.BObject = BObject;
exports.BArray = BArray;

}};
__resources__["/__builtin__/libs/base64.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/**
 * Thin wrapper around JXG's Base64 utils
 */

/** @ignore */
var JXG = require('JXGUtil');

/** @namespace */
var base64 = {
    /**
     * Decode a base64 encoded string into a binary string
     *
     * @param {String} input Base64 encoded data
     * @returns {String} Binary string
     */
    decode: function(input) {
        return JXG.Util.Base64.decode(input);
    },

    /**
     * Decode a base64 encoded string into a byte array
     *
     * @param {String} input Base64 encoded data
     * @returns {Integer[]} Array of bytes
     */
    decodeAsArray: function(input, bytes) {
        bytes = bytes || 1;

        var dec = JXG.Util.Base64.decode(input),
            ar = [], i, j, len;

        for (i = 0, len = dec.length/bytes; i < len; i++){
            ar[i] = 0;
            for (j = bytes-1; j >= 0; --j){
                ar[i] += dec.charCodeAt((i *bytes) +j) << (j *8);
            }
        }
        return ar;
    },

    /**
     * Encode a binary string into base64
     *
     * @param {String} input Binary string
     * @returns {String} Base64 encoded data
     */
    encode: function(input) {
        return JXG.Util.Base64.encode(input);
    }
};

module.exports = base64;

}};
__resources__["/__builtin__/libs/box2d.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
function extend(a, b) {
  for(var c in b) {
    a[c] = b[c]
  }
}
function isInstanceOf(obj, _constructor) {
  while(typeof obj === "object") {
    if(obj.constructor === _constructor) {
      return true
    }
    obj = obj._super
  }
  return false
}
;var b2BoundValues = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2BoundValues.prototype.__constructor = function() {
  this.lowerValues = new Array;
  this.lowerValues[0] = 0;
  this.lowerValues[1] = 0;
  this.upperValues = new Array;
  this.upperValues[0] = 0;
  this.upperValues[1] = 0
};
b2BoundValues.prototype.__varz = function() {
};
b2BoundValues.prototype.lowerValues = null;
b2BoundValues.prototype.upperValues = null;var b2PairManager = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2PairManager.prototype.__constructor = function() {
  this.m_pairs = new Array;
  this.m_pairBuffer = new Array;
  this.m_pairCount = 0;
  this.m_pairBufferCount = 0;
  this.m_freePair = null
};
b2PairManager.prototype.__varz = function() {
};
b2PairManager.prototype.AddPair = function(proxy1, proxy2) {
  var pair = proxy1.pairs[proxy2];
  if(pair != null) {
    return pair
  }
  if(this.m_freePair == null) {
    this.m_freePair = new b2Pair;
    this.m_pairs.push(this.m_freePair)
  }
  pair = this.m_freePair;
  this.m_freePair = pair.next;
  pair.proxy1 = proxy1;
  pair.proxy2 = proxy2;
  pair.status = 0;
  pair.userData = null;
  pair.next = null;
  proxy1.pairs[proxy2] = pair;
  proxy2.pairs[proxy1] = pair;
  ++this.m_pairCount;
  return pair
};
b2PairManager.prototype.RemovePair = function(proxy1, proxy2) {
  var pair = proxy1.pairs[proxy2];
  if(pair == null) {
    return null
  }
  var userData = pair.userData;
  delete proxy1.pairs[proxy2];
  delete proxy2.pairs[proxy1];
  pair.next = this.m_freePair;
  pair.proxy1 = null;
  pair.proxy2 = null;
  pair.userData = null;
  pair.status = 0;
  this.m_freePair = pair;
  --this.m_pairCount;
  return userData
};
b2PairManager.prototype.Find = function(proxy1, proxy2) {
  return proxy1.pairs[proxy2]
};
b2PairManager.prototype.ValidateBuffer = function() {
};
b2PairManager.prototype.ValidateTable = function() {
};
b2PairManager.prototype.Initialize = function(broadPhase) {
  this.m_broadPhase = broadPhase
};
b2PairManager.prototype.AddBufferedPair = function(proxy1, proxy2) {
  var pair = this.AddPair(proxy1, proxy2);
  if(pair.IsBuffered() == false) {
    pair.SetBuffered();
    this.m_pairBuffer[this.m_pairBufferCount] = pair;
    ++this.m_pairBufferCount
  }
  pair.ClearRemoved();
  if(b2BroadPhase.s_validate) {
    this.ValidateBuffer()
  }
};
b2PairManager.prototype.RemoveBufferedPair = function(proxy1, proxy2) {
  var pair = this.Find(proxy1, proxy2);
  if(pair == null) {
    return
  }
  if(pair.IsBuffered() == false) {
    pair.SetBuffered();
    this.m_pairBuffer[this.m_pairBufferCount] = pair;
    ++this.m_pairBufferCount
  }
  pair.SetRemoved();
  if(b2BroadPhase.s_validate) {
    this.ValidateBuffer()
  }
};
b2PairManager.prototype.Commit = function(callback) {
  var i = 0;
  var removeCount = 0;
  for(i = 0;i < this.m_pairBufferCount;++i) {
    var pair = this.m_pairBuffer[i];
    pair.ClearBuffered();
    var proxy1 = pair.proxy1;
    var proxy2 = pair.proxy2;
    if(pair.IsRemoved()) {
    }else {
      if(pair.IsFinal() == false) {
        callback(proxy1.userData, proxy2.userData)
      }
    }
  }
  this.m_pairBufferCount = 0;
  if(b2BroadPhase.s_validate) {
    this.ValidateTable()
  }
};
b2PairManager.prototype.m_broadPhase = null;
b2PairManager.prototype.m_pairs = null;
b2PairManager.prototype.m_freePair = null;
b2PairManager.prototype.m_pairCount = 0;
b2PairManager.prototype.m_pairBuffer = null;
b2PairManager.prototype.m_pairBufferCount = 0;var b2TimeStep = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2TimeStep.prototype.__constructor = function() {
};
b2TimeStep.prototype.__varz = function() {
};
b2TimeStep.prototype.Set = function(step) {
  this.dt = step.dt;
  this.inv_dt = step.inv_dt;
  this.positionIterations = step.positionIterations;
  this.velocityIterations = step.velocityIterations;
  this.warmStarting = step.warmStarting
};
b2TimeStep.prototype.dt = null;
b2TimeStep.prototype.inv_dt = null;
b2TimeStep.prototype.dtRatio = null;
b2TimeStep.prototype.velocityIterations = 0;
b2TimeStep.prototype.positionIterations = 0;
b2TimeStep.prototype.warmStarting = null;var b2Controller = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Controller.prototype.__constructor = function() {
};
b2Controller.prototype.__varz = function() {
};
b2Controller.prototype.Step = function(step) {
};
b2Controller.prototype.Draw = function(debugDraw) {
};
b2Controller.prototype.AddBody = function(body) {
  var edge = new b2ControllerEdge;
  edge.controller = this;
  edge.body = body;
  edge.nextBody = m_bodyList;
  edge.prevBody = null;
  m_bodyList = edge;
  if(edge.nextBody) {
    edge.nextBody.prevBody = edge
  }
  m_bodyCount++;
  edge.nextController = body.m_controllerList;
  edge.prevController = null;
  body.m_controllerList = edge;
  if(edge.nextController) {
    edge.nextController.prevController = edge
  }
  body.m_controllerCount++
};
b2Controller.prototype.RemoveBody = function(body) {
  var edge = body.m_controllerList;
  while(edge && edge.controller != this) {
    edge = edge.nextController
  }
  if(edge.prevBody) {
    edge.prevBody.nextBody = edge.nextBody
  }
  if(edge.nextBody) {
    edge.nextBody.prevBody = edge.prevBody
  }
  if(edge.nextController) {
    edge.nextController.prevController = edge.prevController
  }
  if(edge.prevController) {
    edge.prevController.nextController = edge.nextController
  }
  if(m_bodyList == edge) {
    m_bodyList = edge.nextBody
  }
  if(body.m_controllerList == edge) {
    body.m_controllerList = edge.nextController
  }
  body.m_controllerCount--;
  m_bodyCount--
};
b2Controller.prototype.Clear = function() {
  while(m_bodyList) {
    this.RemoveBody(m_bodyList.body)
  }
};
b2Controller.prototype.GetNext = function() {
  return this.m_next
};
b2Controller.prototype.GetWorld = function() {
  return this.m_world
};
b2Controller.prototype.GetBodyList = function() {
  return m_bodyList
};
b2Controller.prototype.m_next = null;
b2Controller.prototype.m_prev = null;
b2Controller.prototype.m_world = null;var b2GravityController = function() {
  b2Controller.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2GravityController.prototype, b2Controller.prototype);
b2GravityController.prototype._super = b2Controller.prototype;
b2GravityController.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2GravityController.prototype.__varz = function() {
};
b2GravityController.prototype.Step = function(step) {
  var i = null;
  var body1 = null;
  var p1 = null;
  var mass1 = 0;
  var j = null;
  var body2 = null;
  var p2 = null;
  var dx = 0;
  var dy = 0;
  var r2 = 0;
  var f = null;
  if(this.invSqr) {
    for(i = m_bodyList;i;i = i.nextBody) {
      body1 = i.body;
      p1 = body1.GetWorldCenter();
      mass1 = body1.GetMass();
      for(j = m_bodyList;j != i;j = j.nextBody) {
        body2 = j.body;
        p2 = body2.GetWorldCenter();
        dx = p2.x - p1.x;
        dy = p2.y - p1.y;
        r2 = dx * dx + dy * dy;
        if(r2 < Number.MIN_VALUE) {
          continue
        }
        f = new b2Vec2(dx, dy);
        f.Multiply(this.G / r2 / Math.sqrt(r2) * mass1 * body2.GetMass());
        if(body1.IsAwake()) {
          body1.ApplyForce(f, p1)
        }
        f.Multiply(-1);
        if(body2.IsAwake()) {
          body2.ApplyForce(f, p2)
        }
      }
    }
  }else {
    for(i = m_bodyList;i;i = i.nextBody) {
      body1 = i.body;
      p1 = body1.GetWorldCenter();
      mass1 = body1.GetMass();
      for(j = m_bodyList;j != i;j = j.nextBody) {
        body2 = j.body;
        p2 = body2.GetWorldCenter();
        dx = p2.x - p1.x;
        dy = p2.y - p1.y;
        r2 = dx * dx + dy * dy;
        if(r2 < Number.MIN_VALUE) {
          continue
        }
        f = new b2Vec2(dx, dy);
        f.Multiply(this.G / r2 * mass1 * body2.GetMass());
        if(body1.IsAwake()) {
          body1.ApplyForce(f, p1)
        }
        f.Multiply(-1);
        if(body2.IsAwake()) {
          body2.ApplyForce(f, p2)
        }
      }
    }
  }
};
b2GravityController.prototype.G = 1;
b2GravityController.prototype.invSqr = true;var b2DestructionListener = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DestructionListener.prototype.__constructor = function() {
};
b2DestructionListener.prototype.__varz = function() {
};
b2DestructionListener.prototype.SayGoodbyeJoint = function(joint) {
};
b2DestructionListener.prototype.SayGoodbyeFixture = function(fixture) {
};var b2ContactEdge = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactEdge.prototype.__constructor = function() {
};
b2ContactEdge.prototype.__varz = function() {
};
b2ContactEdge.prototype.other = null;
b2ContactEdge.prototype.contact = null;
b2ContactEdge.prototype.prev = null;
b2ContactEdge.prototype.next = null;var b2EdgeChainDef = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2EdgeChainDef.prototype.__constructor = function() {
  this.vertexCount = 0;
  this.isALoop = true;
  this.vertices = []
};
b2EdgeChainDef.prototype.__varz = function() {
};
b2EdgeChainDef.prototype.vertices = null;
b2EdgeChainDef.prototype.vertexCount = null;
b2EdgeChainDef.prototype.isALoop = null;var b2Vec2 = function(x_, y_) {
  if(arguments.length == 2) {
    this.x = x_;
    this.y = y_
  }
};
b2Vec2.Make = function(x_, y_) {
  return new b2Vec2(x_, y_)
};
b2Vec2.prototype.SetZero = function() {
  this.x = 0;
  this.y = 0
};
b2Vec2.prototype.Set = function(x_, y_) {
  this.x = x_;
  this.y = y_
};
b2Vec2.prototype.SetV = function(v) {
  this.x = v.x;
  this.y = v.y
};
b2Vec2.prototype.GetNegative = function() {
  return new b2Vec2(-this.x, -this.y)
};
b2Vec2.prototype.NegativeSelf = function() {
  this.x = -this.x;
  this.y = -this.y
};
b2Vec2.prototype.Copy = function() {
  return new b2Vec2(this.x, this.y)
};
b2Vec2.prototype.Add = function(v) {
  this.x += v.x;
  this.y += v.y
};
b2Vec2.prototype.Subtract = function(v) {
  this.x -= v.x;
  this.y -= v.y
};
b2Vec2.prototype.Multiply = function(a) {
  this.x *= a;
  this.y *= a
};
b2Vec2.prototype.MulM = function(A) {
  var tX = this.x;
  this.x = A.col1.x * tX + A.col2.x * this.y;
  this.y = A.col1.y * tX + A.col2.y * this.y
};
b2Vec2.prototype.MulTM = function(A) {
  var tX = b2Math.Dot(this, A.col1);
  this.y = b2Math.Dot(this, A.col2);
  this.x = tX
};
b2Vec2.prototype.CrossVF = function(s) {
  var tX = this.x;
  this.x = s * this.y;
  this.y = -s * tX
};
b2Vec2.prototype.CrossFV = function(s) {
  var tX = this.x;
  this.x = -s * this.y;
  this.y = s * tX
};
b2Vec2.prototype.MinV = function(b) {
  this.x = this.x < b.x ? this.x : b.x;
  this.y = this.y < b.y ? this.y : b.y
};
b2Vec2.prototype.MaxV = function(b) {
  this.x = this.x > b.x ? this.x : b.x;
  this.y = this.y > b.y ? this.y : b.y
};
b2Vec2.prototype.Abs = function() {
  if(this.x < 0) {
    this.x = -this.x
  }
  if(this.y < 0) {
    this.y = -this.y
  }
};
b2Vec2.prototype.Length = function() {
  return Math.sqrt(this.x * this.x + this.y * this.y)
};
b2Vec2.prototype.LengthSquared = function() {
  return this.x * this.x + this.y * this.y
};
b2Vec2.prototype.Normalize = function() {
  var length = Math.sqrt(this.x * this.x + this.y * this.y);
  if(length < Number.MIN_VALUE) {
    return 0
  }
  var invLength = 1 / length;
  this.x *= invLength;
  this.y *= invLength;
  return length
};
b2Vec2.prototype.IsValid = function() {
  return b2Math.IsValid(this.x) && b2Math.IsValid(this.y)
};
b2Vec2.prototype.x = 0;
b2Vec2.prototype.y = 0;var b2Vec3 = function(x, y, z) {
  if(arguments.length == 3) {
    this.x = x;
    this.y = y;
    this.z = z
  }
};
b2Vec3.prototype.SetZero = function() {
  this.x = this.y = this.z = 0
};
b2Vec3.prototype.Set = function(x, y, z) {
  this.x = x;
  this.y = y;
  this.z = z
};
b2Vec3.prototype.SetV = function(v) {
  this.x = v.x;
  this.y = v.y;
  this.z = v.z
};
b2Vec3.prototype.GetNegative = function() {
  return new b2Vec3(-this.x, -this.y, -this.z)
};
b2Vec3.prototype.NegativeSelf = function() {
  this.x = -this.x;
  this.y = -this.y;
  this.z = -this.z
};
b2Vec3.prototype.Copy = function() {
  return new b2Vec3(this.x, this.y, this.z)
};
b2Vec3.prototype.Add = function(v) {
  this.x += v.x;
  this.y += v.y;
  this.z += v.z
};
b2Vec3.prototype.Subtract = function(v) {
  this.x -= v.x;
  this.y -= v.y;
  this.z -= v.z
};
b2Vec3.prototype.Multiply = function(a) {
  this.x *= a;
  this.y *= a;
  this.z *= a
};
b2Vec3.prototype.x = 0;
b2Vec3.prototype.y = 0;
b2Vec3.prototype.z = 0;var b2DistanceProxy = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DistanceProxy.prototype.__constructor = function() {
};
b2DistanceProxy.prototype.__varz = function() {
};
b2DistanceProxy.prototype.Set = function(shape) {
  switch(shape.GetType()) {
    case b2Shape.e_circleShape:
      var circle = shape;
      this.m_vertices = new Array(1);
      this.m_vertices[0] = circle.m_p;
      this.m_count = 1;
      this.m_radius = circle.m_radius;
      break;
    case b2Shape.e_polygonShape:
      var polygon = shape;
      this.m_vertices = polygon.m_vertices;
      this.m_count = polygon.m_vertexCount;
      this.m_radius = polygon.m_radius;
      break;
    default:
      b2Settings.b2Assert(false)
  }
};
b2DistanceProxy.prototype.GetSupport = function(d) {
  var bestIndex = 0;
  var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
  for(var i = 1;i < this.m_count;++i) {
    var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
    if(value > bestValue) {
      bestIndex = i;
      bestValue = value
    }
  }
  return bestIndex
};
b2DistanceProxy.prototype.GetSupportVertex = function(d) {
  var bestIndex = 0;
  var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
  for(var i = 1;i < this.m_count;++i) {
    var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
    if(value > bestValue) {
      bestIndex = i;
      bestValue = value
    }
  }
  return this.m_vertices[bestIndex]
};
b2DistanceProxy.prototype.GetVertexCount = function() {
  return this.m_count
};
b2DistanceProxy.prototype.GetVertex = function(index) {
  b2Settings.b2Assert(0 <= index && index < this.m_count);
  return this.m_vertices[index]
};
b2DistanceProxy.prototype.m_vertices = null;
b2DistanceProxy.prototype.m_count = 0;
b2DistanceProxy.prototype.m_radius = null;var b2ContactFactory = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactFactory.prototype.__constructor = function() {
};
b2ContactFactory.prototype.__varz = function() {
  this.InitializeRegisters()
};
b2ContactFactory.prototype.AddType = function(createFcn, destroyFcn, type1, type2) {
  this.m_registers[type1][type2].createFcn = createFcn;
  this.m_registers[type1][type2].destroyFcn = destroyFcn;
  this.m_registers[type1][type2].primary = true;
  if(type1 != type2) {
    this.m_registers[type2][type1].createFcn = createFcn;
    this.m_registers[type2][type1].destroyFcn = destroyFcn;
    this.m_registers[type2][type1].primary = false
  }
};
b2ContactFactory.prototype.InitializeRegisters = function() {
  this.m_registers = new Array(b2Shape.e_shapeTypeCount);
  for(var i = 0;i < b2Shape.e_shapeTypeCount;i++) {
    this.m_registers[i] = new Array(b2Shape.e_shapeTypeCount);
    for(var j = 0;j < b2Shape.e_shapeTypeCount;j++) {
      this.m_registers[i][j] = new b2ContactRegister
    }
  }
  this.AddType(b2CircleContact.Create, b2CircleContact.Destroy, b2Shape.e_circleShape, b2Shape.e_circleShape);
  this.AddType(b2PolyAndCircleContact.Create, b2PolyAndCircleContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_circleShape);
  this.AddType(b2PolygonContact.Create, b2PolygonContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_polygonShape);
  this.AddType(b2EdgeAndCircleContact.Create, b2EdgeAndCircleContact.Destroy, b2Shape.e_edgeShape, b2Shape.e_circleShape);
  this.AddType(b2PolyAndEdgeContact.Create, b2PolyAndEdgeContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_edgeShape)
};
b2ContactFactory.prototype.Create = function(fixtureA, fixtureB) {
  var type1 = fixtureA.GetType();
  var type2 = fixtureB.GetType();
  var reg = this.m_registers[type1][type2];
  var c;
  if(reg.pool) {
    c = reg.pool;
    reg.pool = c.m_next;
    reg.poolCount--;
    c.Reset(fixtureA, fixtureB);
    return c
  }
  var createFcn = reg.createFcn;
  if(createFcn != null) {
    if(reg.primary) {
      c = createFcn(this.m_allocator);
      c.Reset(fixtureA, fixtureB);
      return c
    }else {
      c = createFcn(this.m_allocator);
      c.Reset(fixtureB, fixtureA);
      return c
    }
  }else {
    return null
  }
};
b2ContactFactory.prototype.Destroy = function(contact) {
  if(contact.m_manifold.m_pointCount > 0) {
    contact.m_fixtureA.m_body.SetAwake(true);
    contact.m_fixtureB.m_body.SetAwake(true)
  }
  var type1 = contact.m_fixtureA.GetType();
  var type2 = contact.m_fixtureB.GetType();
  var reg = this.m_registers[type1][type2];
  if(true) {
    reg.poolCount++;
    contact.m_next = reg.pool;
    reg.pool = contact
  }
  var destroyFcn = reg.destroyFcn;
  destroyFcn(contact, this.m_allocator)
};
b2ContactFactory.prototype.m_registers = null;
b2ContactFactory.prototype.m_allocator = null;var b2ConstantAccelController = function() {
  b2Controller.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2ConstantAccelController.prototype, b2Controller.prototype);
b2ConstantAccelController.prototype._super = b2Controller.prototype;
b2ConstantAccelController.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2ConstantAccelController.prototype.__varz = function() {
  this.A = new b2Vec2(0, 0)
};
b2ConstantAccelController.prototype.Step = function(step) {
  var smallA = new b2Vec2(this.A.x * step.dt, this.A.y * step.dt);
  for(var i = m_bodyList;i;i = i.nextBody) {
    var body = i.body;
    if(!body.IsAwake()) {
      continue
    }
    body.SetLinearVelocity(new b2Vec2(body.GetLinearVelocity().x + smallA.x, body.GetLinearVelocity().y + smallA.y))
  }
};
b2ConstantAccelController.prototype.A = new b2Vec2(0, 0);var b2SeparationFunction = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2SeparationFunction.prototype.__constructor = function() {
};
b2SeparationFunction.prototype.__varz = function() {
  this.m_localPoint = new b2Vec2;
  this.m_axis = new b2Vec2
};
b2SeparationFunction.e_points = 1;
b2SeparationFunction.e_faceA = 2;
b2SeparationFunction.e_faceB = 4;
b2SeparationFunction.prototype.Initialize = function(cache, proxyA, transformA, proxyB, transformB) {
  this.m_proxyA = proxyA;
  this.m_proxyB = proxyB;
  var count = cache.count;
  b2Settings.b2Assert(0 < count && count < 3);
  var localPointA;
  var localPointA1;
  var localPointA2;
  var localPointB;
  var localPointB1;
  var localPointB2;
  var pointAX;
  var pointAY;
  var pointBX;
  var pointBY;
  var normalX;
  var normalY;
  var tMat;
  var tVec;
  var s;
  var sgn;
  if(count == 1) {
    this.m_type = b2SeparationFunction.e_points;
    localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);
    localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);
    tVec = localPointA;
    tMat = transformA.R;
    pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
    pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
    tVec = localPointB;
    tMat = transformB.R;
    pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
    pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
    this.m_axis.x = pointBX - pointAX;
    this.m_axis.y = pointBY - pointAY;
    this.m_axis.Normalize()
  }else {
    if(cache.indexB[0] == cache.indexB[1]) {
      this.m_type = b2SeparationFunction.e_faceA;
      localPointA1 = this.m_proxyA.GetVertex(cache.indexA[0]);
      localPointA2 = this.m_proxyA.GetVertex(cache.indexA[1]);
      localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);
      this.m_localPoint.x = 0.5 * (localPointA1.x + localPointA2.x);
      this.m_localPoint.y = 0.5 * (localPointA1.y + localPointA2.y);
      this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointA2, localPointA1), 1);
      this.m_axis.Normalize();
      tVec = this.m_axis;
      tMat = transformA.R;
      normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      tVec = this.m_localPoint;
      tMat = transformA.R;
      pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tVec = localPointB;
      tMat = transformB.R;
      pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      s = (pointBX - pointAX) * normalX + (pointBY - pointAY) * normalY;
      if(s < 0) {
        this.m_axis.NegativeSelf()
      }
    }else {
      if(cache.indexA[0] == cache.indexA[0]) {
        this.m_type = b2SeparationFunction.e_faceB;
        localPointB1 = this.m_proxyB.GetVertex(cache.indexB[0]);
        localPointB2 = this.m_proxyB.GetVertex(cache.indexB[1]);
        localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);
        this.m_localPoint.x = 0.5 * (localPointB1.x + localPointB2.x);
        this.m_localPoint.y = 0.5 * (localPointB1.y + localPointB2.y);
        this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointB2, localPointB1), 1);
        this.m_axis.Normalize();
        tVec = this.m_axis;
        tMat = transformB.R;
        normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
        normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
        tVec = this.m_localPoint;
        tMat = transformB.R;
        pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        tVec = localPointA;
        tMat = transformA.R;
        pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        s = (pointAX - pointBX) * normalX + (pointAY - pointBY) * normalY;
        if(s < 0) {
          this.m_axis.NegativeSelf()
        }
      }else {
        localPointA1 = this.m_proxyA.GetVertex(cache.indexA[0]);
        localPointA2 = this.m_proxyA.GetVertex(cache.indexA[1]);
        localPointB1 = this.m_proxyB.GetVertex(cache.indexB[0]);
        localPointB2 = this.m_proxyB.GetVertex(cache.indexB[1]);
        var pA = b2Math.MulX(transformA, localPointA);
        var dA = b2Math.MulMV(transformA.R, b2Math.SubtractVV(localPointA2, localPointA1));
        var pB = b2Math.MulX(transformB, localPointB);
        var dB = b2Math.MulMV(transformB.R, b2Math.SubtractVV(localPointB2, localPointB1));
        var a = dA.x * dA.x + dA.y * dA.y;
        var e = dB.x * dB.x + dB.y * dB.y;
        var r = b2Math.SubtractVV(dB, dA);
        var c = dA.x * r.x + dA.y * r.y;
        var f = dB.x * r.x + dB.y * r.y;
        var b = dA.x * dB.x + dA.y * dB.y;
        var denom = a * e - b * b;
        s = 0;
        if(denom != 0) {
          s = b2Math.Clamp((b * f - c * e) / denom, 0, 1)
        }
        var t = (b * s + f) / e;
        if(t < 0) {
          t = 0;
          s = b2Math.Clamp((b - c) / a, 0, 1)
        }
        localPointA = new b2Vec2;
        localPointA.x = localPointA1.x + s * (localPointA2.x - localPointA1.x);
        localPointA.y = localPointA1.y + s * (localPointA2.y - localPointA1.y);
        localPointB = new b2Vec2;
        localPointB.x = localPointB1.x + s * (localPointB2.x - localPointB1.x);
        localPointB.y = localPointB1.y + s * (localPointB2.y - localPointB1.y);
        if(s == 0 || s == 1) {
          this.m_type = b2SeparationFunction.e_faceB;
          this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointB2, localPointB1), 1);
          this.m_axis.Normalize();
          this.m_localPoint = localPointB;
          tVec = this.m_axis;
          tMat = transformB.R;
          normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
          normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
          tVec = this.m_localPoint;
          tMat = transformB.R;
          pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
          pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
          tVec = localPointA;
          tMat = transformA.R;
          pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
          pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
          sgn = (pointAX - pointBX) * normalX + (pointAY - pointBY) * normalY;
          if(s < 0) {
            this.m_axis.NegativeSelf()
          }
        }else {
          this.m_type = b2SeparationFunction.e_faceA;
          this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointA2, localPointA1), 1);
          this.m_localPoint = localPointA;
          tVec = this.m_axis;
          tMat = transformA.R;
          normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
          normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
          tVec = this.m_localPoint;
          tMat = transformA.R;
          pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
          pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
          tVec = localPointB;
          tMat = transformB.R;
          pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
          pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
          sgn = (pointBX - pointAX) * normalX + (pointBY - pointAY) * normalY;
          if(s < 0) {
            this.m_axis.NegativeSelf()
          }
        }
      }
    }
  }
};
b2SeparationFunction.prototype.Evaluate = function(transformA, transformB) {
  var axisA;
  var axisB;
  var localPointA;
  var localPointB;
  var pointA;
  var pointB;
  var seperation;
  var normal;
  switch(this.m_type) {
    case b2SeparationFunction.e_points:
      axisA = b2Math.MulTMV(transformA.R, this.m_axis);
      axisB = b2Math.MulTMV(transformB.R, this.m_axis.GetNegative());
      localPointA = this.m_proxyA.GetSupportVertex(axisA);
      localPointB = this.m_proxyB.GetSupportVertex(axisB);
      pointA = b2Math.MulX(transformA, localPointA);
      pointB = b2Math.MulX(transformB, localPointB);
      seperation = (pointB.x - pointA.x) * this.m_axis.x + (pointB.y - pointA.y) * this.m_axis.y;
      return seperation;
    case b2SeparationFunction.e_faceA:
      normal = b2Math.MulMV(transformA.R, this.m_axis);
      pointA = b2Math.MulX(transformA, this.m_localPoint);
      axisB = b2Math.MulTMV(transformB.R, normal.GetNegative());
      localPointB = this.m_proxyB.GetSupportVertex(axisB);
      pointB = b2Math.MulX(transformB, localPointB);
      seperation = (pointB.x - pointA.x) * normal.x + (pointB.y - pointA.y) * normal.y;
      return seperation;
    case b2SeparationFunction.e_faceB:
      normal = b2Math.MulMV(transformB.R, this.m_axis);
      pointB = b2Math.MulX(transformB, this.m_localPoint);
      axisA = b2Math.MulTMV(transformA.R, normal.GetNegative());
      localPointA = this.m_proxyA.GetSupportVertex(axisA);
      pointA = b2Math.MulX(transformA, localPointA);
      seperation = (pointA.x - pointB.x) * normal.x + (pointA.y - pointB.y) * normal.y;
      return seperation;
    default:
      b2Settings.b2Assert(false);
      return 0
  }
};
b2SeparationFunction.prototype.m_proxyA = null;
b2SeparationFunction.prototype.m_proxyB = null;
b2SeparationFunction.prototype.m_type = 0;
b2SeparationFunction.prototype.m_localPoint = new b2Vec2;
b2SeparationFunction.prototype.m_axis = new b2Vec2;var b2DynamicTreePair = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DynamicTreePair.prototype.__constructor = function() {
};
b2DynamicTreePair.prototype.__varz = function() {
};
b2DynamicTreePair.prototype.proxyA = null;
b2DynamicTreePair.prototype.proxyB = null;var b2ContactConstraintPoint = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactConstraintPoint.prototype.__constructor = function() {
};
b2ContactConstraintPoint.prototype.__varz = function() {
  this.localPoint = new b2Vec2;
  this.rA = new b2Vec2;
  this.rB = new b2Vec2
};
b2ContactConstraintPoint.prototype.localPoint = new b2Vec2;
b2ContactConstraintPoint.prototype.rA = new b2Vec2;
b2ContactConstraintPoint.prototype.rB = new b2Vec2;
b2ContactConstraintPoint.prototype.normalImpulse = null;
b2ContactConstraintPoint.prototype.tangentImpulse = null;
b2ContactConstraintPoint.prototype.normalMass = null;
b2ContactConstraintPoint.prototype.tangentMass = null;
b2ContactConstraintPoint.prototype.equalizedMass = null;
b2ContactConstraintPoint.prototype.velocityBias = null;var b2ControllerEdge = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ControllerEdge.prototype.__constructor = function() {
};
b2ControllerEdge.prototype.__varz = function() {
};
b2ControllerEdge.prototype.controller = null;
b2ControllerEdge.prototype.body = null;
b2ControllerEdge.prototype.prevBody = null;
b2ControllerEdge.prototype.nextBody = null;
b2ControllerEdge.prototype.prevController = null;
b2ControllerEdge.prototype.nextController = null;var b2DistanceInput = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DistanceInput.prototype.__constructor = function() {
};
b2DistanceInput.prototype.__varz = function() {
};
b2DistanceInput.prototype.proxyA = null;
b2DistanceInput.prototype.proxyB = null;
b2DistanceInput.prototype.transformA = null;
b2DistanceInput.prototype.transformB = null;
b2DistanceInput.prototype.useRadii = null;var b2Settings = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Settings.prototype.__constructor = function() {
};
b2Settings.prototype.__varz = function() {
};
b2Settings.b2MixFriction = function(friction1, friction2) {
  return Math.sqrt(friction1 * friction2)
};
b2Settings.b2MixRestitution = function(restitution1, restitution2) {
  return restitution1 > restitution2 ? restitution1 : restitution2
};
b2Settings.b2Assert = function(a) {
  if(!a) {
    throw"Assertion Failed";
  }
};
b2Settings.VERSION = "2.1alpha";
b2Settings.USHRT_MAX = 65535;
b2Settings.b2_pi = Math.PI;
b2Settings.b2_maxManifoldPoints = 2;
b2Settings.b2_aabbExtension = 0.1;
b2Settings.b2_aabbMultiplier = 2;
b2Settings.b2_polygonRadius = 2 * b2Settings.b2_linearSlop;
b2Settings.b2_linearSlop = 0.0050;
b2Settings.b2_angularSlop = 2 / 180 * b2Settings.b2_pi;
b2Settings.b2_toiSlop = 8 * b2Settings.b2_linearSlop;
b2Settings.b2_maxTOIContactsPerIsland = 32;
b2Settings.b2_maxTOIJointsPerIsland = 32;
b2Settings.b2_velocityThreshold = 1;
b2Settings.b2_maxLinearCorrection = 0.2;
b2Settings.b2_maxAngularCorrection = 8 / 180 * b2Settings.b2_pi;
b2Settings.b2_maxTranslation = 2;
b2Settings.b2_maxTranslationSquared = b2Settings.b2_maxTranslation * b2Settings.b2_maxTranslation;
b2Settings.b2_maxRotation = 0.5 * b2Settings.b2_pi;
b2Settings.b2_maxRotationSquared = b2Settings.b2_maxRotation * b2Settings.b2_maxRotation;
b2Settings.b2_contactBaumgarte = 0.2;
b2Settings.b2_timeToSleep = 0.5;
b2Settings.b2_linearSleepTolerance = 0.01;
b2Settings.b2_angularSleepTolerance = 2 / 180 * b2Settings.b2_pi;var b2Proxy = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Proxy.prototype.__constructor = function() {
};
b2Proxy.prototype.__varz = function() {
  this.lowerBounds = new Array(2);
  this.upperBounds = new Array(2);
  this.pairs = new Object
};
b2Proxy.prototype.IsValid = function() {
  return this.overlapCount != b2BroadPhase.b2_invalid
};
b2Proxy.prototype.lowerBounds = new Array(2);
b2Proxy.prototype.upperBounds = new Array(2);
b2Proxy.prototype.overlapCount = 0;
b2Proxy.prototype.timeStamp = 0;
b2Proxy.prototype.pairs = new Object;
b2Proxy.prototype.next = null;
b2Proxy.prototype.userData = null;var b2Point = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Point.prototype.__constructor = function() {
};
b2Point.prototype.__varz = function() {
  this.p = new b2Vec2
};
b2Point.prototype.Support = function(xf, vX, vY) {
  return this.p
};
b2Point.prototype.GetFirstVertex = function(xf) {
  return this.p
};
b2Point.prototype.p = new b2Vec2;var b2WorldManifold = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2WorldManifold.prototype.__constructor = function() {
  this.m_points = new Array(b2Settings.b2_maxManifoldPoints);
  for(var i = 0;i < b2Settings.b2_maxManifoldPoints;i++) {
    this.m_points[i] = new b2Vec2
  }
};
b2WorldManifold.prototype.__varz = function() {
  this.m_normal = new b2Vec2
};
b2WorldManifold.prototype.Initialize = function(manifold, xfA, radiusA, xfB, radiusB) {
  if(manifold.m_pointCount == 0) {
    return
  }
  var i = 0;
  var tVec;
  var tMat;
  var normalX;
  var normalY;
  var planePointX;
  var planePointY;
  var clipPointX;
  var clipPointY;
  switch(manifold.m_type) {
    case b2Manifold.e_circles:
      tMat = xfA.R;
      tVec = manifold.m_localPoint;
      var pointAX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      var pointAY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      tMat = xfB.R;
      tVec = manifold.m_points[0].m_localPoint;
      var pointBX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      var pointBY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      var dX = pointBX - pointAX;
      var dY = pointBY - pointAY;
      var d2 = dX * dX + dY * dY;
      if(d2 > Number.MIN_VALUE * Number.MIN_VALUE) {
        var d = Math.sqrt(d2);
        this.m_normal.x = dX / d;
        this.m_normal.y = dY / d
      }else {
        this.m_normal.x = 1;
        this.m_normal.y = 0
      }
      var cAX = pointAX + radiusA * this.m_normal.x;
      var cAY = pointAY + radiusA * this.m_normal.y;
      var cBX = pointBX - radiusB * this.m_normal.x;
      var cBY = pointBY - radiusB * this.m_normal.y;
      this.m_points[0].x = 0.5 * (cAX + cBX);
      this.m_points[0].y = 0.5 * (cAY + cBY);
      break;
    case b2Manifold.e_faceA:
      tMat = xfA.R;
      tVec = manifold.m_localPlaneNormal;
      normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      tMat = xfA.R;
      tVec = manifold.m_localPoint;
      planePointX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      planePointY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      this.m_normal.x = normalX;
      this.m_normal.y = normalY;
      for(i = 0;i < manifold.m_pointCount;i++) {
        tMat = xfB.R;
        tVec = manifold.m_points[i].m_localPoint;
        clipPointX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
        clipPointY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
        this.m_points[i].x = clipPointX + 0.5 * (radiusA - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusB) * normalX;
        this.m_points[i].y = clipPointY + 0.5 * (radiusA - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusB) * normalY
      }
      break;
    case b2Manifold.e_faceB:
      tMat = xfB.R;
      tVec = manifold.m_localPlaneNormal;
      normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      tMat = xfB.R;
      tVec = manifold.m_localPoint;
      planePointX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      planePointY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      this.m_normal.x = -normalX;
      this.m_normal.y = -normalY;
      for(i = 0;i < manifold.m_pointCount;i++) {
        tMat = xfA.R;
        tVec = manifold.m_points[i].m_localPoint;
        clipPointX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
        clipPointY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
        this.m_points[i].x = clipPointX + 0.5 * (radiusB - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusA) * normalX;
        this.m_points[i].y = clipPointY + 0.5 * (radiusB - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusA) * normalY
      }
      break
  }
};
b2WorldManifold.prototype.m_normal = new b2Vec2;
b2WorldManifold.prototype.m_points = null;var b2RayCastOutput = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2RayCastOutput.prototype.__constructor = function() {
};
b2RayCastOutput.prototype.__varz = function() {
  this.normal = new b2Vec2
};
b2RayCastOutput.prototype.normal = new b2Vec2;
b2RayCastOutput.prototype.fraction = null;var b2ConstantForceController = function() {
  b2Controller.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2ConstantForceController.prototype, b2Controller.prototype);
b2ConstantForceController.prototype._super = b2Controller.prototype;
b2ConstantForceController.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2ConstantForceController.prototype.__varz = function() {
  this.F = new b2Vec2(0, 0)
};
b2ConstantForceController.prototype.Step = function(step) {
  for(var i = m_bodyList;i;i = i.nextBody) {
    var body = i.body;
    if(!body.IsAwake()) {
      continue
    }
    body.ApplyForce(this.F, body.GetWorldCenter())
  }
};
b2ConstantForceController.prototype.F = new b2Vec2(0, 0);var b2MassData = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2MassData.prototype.__constructor = function() {
};
b2MassData.prototype.__varz = function() {
  this.center = new b2Vec2(0, 0)
};
b2MassData.prototype.mass = 0;
b2MassData.prototype.center = new b2Vec2(0, 0);
b2MassData.prototype.I = 0;var b2DynamicTree = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DynamicTree.prototype.__constructor = function() {
  this.m_root = null;
  this.m_freeList = null;
  this.m_path = 0;
  this.m_insertionCount = 0
};
b2DynamicTree.prototype.__varz = function() {
};
b2DynamicTree.prototype.AllocateNode = function() {
  if(this.m_freeList) {
    var node = this.m_freeList;
    this.m_freeList = node.parent;
    node.parent = null;
    node.child1 = null;
    node.child2 = null;
    return node
  }
  return new b2DynamicTreeNode
};
b2DynamicTree.prototype.FreeNode = function(node) {
  node.parent = this.m_freeList;
  this.m_freeList = node
};
b2DynamicTree.prototype.InsertLeaf = function(leaf) {
  ++this.m_insertionCount;
  if(this.m_root == null) {
    this.m_root = leaf;
    this.m_root.parent = null;
    return
  }
  var center = leaf.aabb.GetCenter();
  var sibling = this.m_root;
  if(sibling.IsLeaf() == false) {
    do {
      var child1 = sibling.child1;
      var child2 = sibling.child2;
      var norm1 = Math.abs((child1.aabb.lowerBound.x + child1.aabb.upperBound.x) / 2 - center.x) + Math.abs((child1.aabb.lowerBound.y + child1.aabb.upperBound.y) / 2 - center.y);
      var norm2 = Math.abs((child2.aabb.lowerBound.x + child2.aabb.upperBound.x) / 2 - center.x) + Math.abs((child2.aabb.lowerBound.y + child2.aabb.upperBound.y) / 2 - center.y);
      if(norm1 < norm2) {
        sibling = child1
      }else {
        sibling = child2
      }
    }while(sibling.IsLeaf() == false)
  }
  var node1 = sibling.parent;
  var node2 = this.AllocateNode();
  node2.parent = node1;
  node2.userData = null;
  node2.aabb.Combine(leaf.aabb, sibling.aabb);
  if(node1) {
    if(sibling.parent.child1 == sibling) {
      node1.child1 = node2
    }else {
      node1.child2 = node2
    }
    node2.child1 = sibling;
    node2.child2 = leaf;
    sibling.parent = node2;
    leaf.parent = node2;
    do {
      if(node1.aabb.Contains(node2.aabb)) {
        break
      }
      node1.aabb.Combine(node1.child1.aabb, node1.child2.aabb);
      node2 = node1;
      node1 = node1.parent
    }while(node1)
  }else {
    node2.child1 = sibling;
    node2.child2 = leaf;
    sibling.parent = node2;
    leaf.parent = node2;
    this.m_root = node2
  }
};
b2DynamicTree.prototype.RemoveLeaf = function(leaf) {
  if(leaf == this.m_root) {
    this.m_root = null;
    return
  }
  var node2 = leaf.parent;
  var node1 = node2.parent;
  var sibling;
  if(node2.child1 == leaf) {
    sibling = node2.child2
  }else {
    sibling = node2.child1
  }
  if(node1) {
    if(node1.child1 == node2) {
      node1.child1 = sibling
    }else {
      node1.child2 = sibling
    }
    sibling.parent = node1;
    this.FreeNode(node2);
    while(node1) {
      var oldAABB = node1.aabb;
      node1.aabb = b2AABB.Combine(node1.child1.aabb, node1.child2.aabb);
      if(oldAABB.Contains(node1.aabb)) {
        break
      }
      node1 = node1.parent
    }
  }else {
    this.m_root = sibling;
    sibling.parent = null;
    this.FreeNode(node2)
  }
};
b2DynamicTree.prototype.CreateProxy = function(aabb, userData) {
  var node = this.AllocateNode();
  var extendX = b2Settings.b2_aabbExtension;
  var extendY = b2Settings.b2_aabbExtension;
  node.aabb.lowerBound.x = aabb.lowerBound.x - extendX;
  node.aabb.lowerBound.y = aabb.lowerBound.y - extendY;
  node.aabb.upperBound.x = aabb.upperBound.x + extendX;
  node.aabb.upperBound.y = aabb.upperBound.y + extendY;
  node.userData = userData;
  this.InsertLeaf(node);
  return node
};
b2DynamicTree.prototype.DestroyProxy = function(proxy) {
  this.RemoveLeaf(proxy);
  this.FreeNode(proxy)
};
b2DynamicTree.prototype.MoveProxy = function(proxy, aabb, displacement) {
  b2Settings.b2Assert(proxy.IsLeaf());
  if(proxy.aabb.Contains(aabb)) {
    return false
  }
  this.RemoveLeaf(proxy);
  var extendX = b2Settings.b2_aabbExtension + b2Settings.b2_aabbMultiplier * (displacement.x > 0 ? displacement.x : -displacement.x);
  var extendY = b2Settings.b2_aabbExtension + b2Settings.b2_aabbMultiplier * (displacement.y > 0 ? displacement.y : -displacement.y);
  proxy.aabb.lowerBound.x = aabb.lowerBound.x - extendX;
  proxy.aabb.lowerBound.y = aabb.lowerBound.y - extendY;
  proxy.aabb.upperBound.x = aabb.upperBound.x + extendX;
  proxy.aabb.upperBound.y = aabb.upperBound.y + extendY;
  this.InsertLeaf(proxy);
  return true
};
b2DynamicTree.prototype.Rebalance = function(iterations) {
  if(this.m_root == null) {
    return
  }
  for(var i = 0;i < iterations;i++) {
    var node = this.m_root;
    var bit = 0;
    while(node.IsLeaf() == false) {
      node = this.m_path >> bit & 1 ? node.child2 : node.child1;
      bit = bit + 1 & 31
    }
    ++this.m_path;
    this.RemoveLeaf(node);
    this.InsertLeaf(node)
  }
};
b2DynamicTree.prototype.GetFatAABB = function(proxy) {
  return proxy.aabb
};
b2DynamicTree.prototype.GetUserData = function(proxy) {
  return proxy.userData
};
b2DynamicTree.prototype.Query = function(callback, aabb) {
  if(this.m_root == null) {
    return
  }
  var stack = new Array;
  var count = 0;
  stack[count++] = this.m_root;
  while(count > 0) {
    var node = stack[--count];
    if(node.aabb.TestOverlap(aabb)) {
      if(node.IsLeaf()) {
        var proceed = callback(node);
        if(!proceed) {
          return
        }
      }else {
        stack[count++] = node.child1;
        stack[count++] = node.child2
      }
    }
  }
};
b2DynamicTree.prototype.RayCast = function(callback, input) {
  if(this.m_root == null) {
    return
  }
  var p1 = input.p1;
  var p2 = input.p2;
  var r = b2Math.SubtractVV(p1, p2);
  r.Normalize();
  var v = b2Math.CrossFV(1, r);
  var abs_v = b2Math.AbsV(v);
  var maxFraction = input.maxFraction;
  var segmentAABB = new b2AABB;
  var tX;
  var tY;
  tX = p1.x + maxFraction * (p2.x - p1.x);
  tY = p1.y + maxFraction * (p2.y - p1.y);
  segmentAABB.lowerBound.x = Math.min(p1.x, tX);
  segmentAABB.lowerBound.y = Math.min(p1.y, tY);
  segmentAABB.upperBound.x = Math.max(p1.x, tX);
  segmentAABB.upperBound.y = Math.max(p1.y, tY);
  var stack = new Array;
  var count = 0;
  stack[count++] = this.m_root;
  while(count > 0) {
    var node = stack[--count];
    if(node.aabb.TestOverlap(segmentAABB) == false) {
      continue
    }
    var c = node.aabb.GetCenter();
    var h = node.aabb.GetExtents();
    var separation = Math.abs(v.x * (p1.x - c.x) + v.y * (p1.y - c.y)) - abs_v.x * h.x - abs_v.y * h.y;
    if(separation > 0) {
      continue
    }
    if(node.IsLeaf()) {
      var subInput = new b2RayCastInput;
      subInput.p1 = input.p1;
      subInput.p2 = input.p2;
      subInput.maxFraction = input.maxFraction;
      maxFraction = callback(subInput, node);
      if(maxFraction == 0) {
        return
      }
      tX = p1.x + maxFraction * (p2.x - p1.x);
      tY = p1.y + maxFraction * (p2.y - p1.y);
      segmentAABB.lowerBound.x = Math.min(p1.x, tX);
      segmentAABB.lowerBound.y = Math.min(p1.y, tY);
      segmentAABB.upperBound.x = Math.max(p1.x, tX);
      segmentAABB.upperBound.y = Math.max(p1.y, tY)
    }else {
      stack[count++] = node.child1;
      stack[count++] = node.child2
    }
  }
};
b2DynamicTree.prototype.m_root = null;
b2DynamicTree.prototype.m_freeList = null;
b2DynamicTree.prototype.m_path = 0;
b2DynamicTree.prototype.m_insertionCount = 0;var b2JointEdge = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2JointEdge.prototype.__constructor = function() {
};
b2JointEdge.prototype.__varz = function() {
};
b2JointEdge.prototype.other = null;
b2JointEdge.prototype.joint = null;
b2JointEdge.prototype.prev = null;
b2JointEdge.prototype.next = null;var b2RayCastInput = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2RayCastInput.prototype.__constructor = function() {
};
b2RayCastInput.prototype.__varz = function() {
  this.p1 = new b2Vec2;
  this.p2 = new b2Vec2
};
b2RayCastInput.prototype.p1 = new b2Vec2;
b2RayCastInput.prototype.p2 = new b2Vec2;
b2RayCastInput.prototype.maxFraction = null;var Features = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
Features.prototype.__constructor = function() {
};
Features.prototype.__varz = function() {
};
Features.prototype.__defineGetter__("referenceEdge", function() {
  return this._referenceEdge
});
Features.prototype.__defineSetter__("referenceEdge", function(value) {
  this._referenceEdge = value;
  this._m_id._key = this._m_id._key & 4294967040 | this._referenceEdge & 255
});
Features.prototype.__defineGetter__("incidentEdge", function() {
  return this._incidentEdge
});
Features.prototype.__defineSetter__("incidentEdge", function(value) {
  this._incidentEdge = value;
  this._m_id._key = this._m_id._key & 4294902015 | this._incidentEdge << 8 & 65280
});
Features.prototype.__defineGetter__("incidentVertex", function() {
  return this._incidentVertex
});
Features.prototype.__defineSetter__("incidentVertex", function(value) {
  this._incidentVertex = value;
  this._m_id._key = this._m_id._key & 4278255615 | this._incidentVertex << 16 & 16711680
});
Features.prototype.__defineGetter__("flip", function() {
  return this._flip
});
Features.prototype.__defineSetter__("flip", function(value) {
  this._flip = value;
  this._m_id._key = this._m_id._key & 16777215 | this._flip << 24 & 4278190080
});
Features.prototype._referenceEdge = 0;
Features.prototype._incidentEdge = 0;
Features.prototype._incidentVertex = 0;
Features.prototype._flip = 0;
Features.prototype._m_id = null;var b2FilterData = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2FilterData.prototype.__constructor = function() {
};
b2FilterData.prototype.__varz = function() {
  this.categoryBits = 1;
  this.maskBits = 65535
};
b2FilterData.prototype.Copy = function() {
  var copy = new b2FilterData;
  copy.categoryBits = this.categoryBits;
  copy.maskBits = this.maskBits;
  copy.groupIndex = this.groupIndex;
  return copy
};
b2FilterData.prototype.categoryBits = 1;
b2FilterData.prototype.maskBits = 65535;
b2FilterData.prototype.groupIndex = 0;var b2AABB = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2AABB.prototype.__constructor = function() {
};
b2AABB.prototype.__varz = function() {
  this.lowerBound = new b2Vec2;
  this.upperBound = new b2Vec2
};
b2AABB.Combine = function(aabb1, aabb2) {
  var aabb = new b2AABB;
  aabb.Combine(aabb1, aabb2);
  return aabb
};
b2AABB.prototype.IsValid = function() {
  var dX = this.upperBound.x - this.lowerBound.x;
  var dY = this.upperBound.y - this.lowerBound.y;
  var valid = dX >= 0 && dY >= 0;
  valid = valid && this.lowerBound.IsValid() && this.upperBound.IsValid();
  return valid
};
b2AABB.prototype.GetCenter = function() {
  return new b2Vec2((this.lowerBound.x + this.upperBound.x) / 2, (this.lowerBound.y + this.upperBound.y) / 2)
};
b2AABB.prototype.GetExtents = function() {
  return new b2Vec2((this.upperBound.x - this.lowerBound.x) / 2, (this.upperBound.y - this.lowerBound.y) / 2)
};
b2AABB.prototype.Contains = function(aabb) {
  var result = true && this.lowerBound.x <= aabb.lowerBound.x && this.lowerBound.y <= aabb.lowerBound.y && aabb.upperBound.x <= this.upperBound.x && aabb.upperBound.y <= this.upperBound.y;
  return result
};
b2AABB.prototype.RayCast = function(output, input) {
  var tmin = -Number.MAX_VALUE;
  var tmax = Number.MAX_VALUE;
  var pX = input.p1.x;
  var pY = input.p1.y;
  var dX = input.p2.x - input.p1.x;
  var dY = input.p2.y - input.p1.y;
  var absDX = Math.abs(dX);
  var absDY = Math.abs(dY);
  var normal = output.normal;
  var inv_d;
  var t1;
  var t2;
  var t3;
  var s;
  if(absDX < Number.MIN_VALUE) {
    if(pX < this.lowerBound.x || this.upperBound.x < pX) {
      return false
    }
  }else {
    inv_d = 1 / dX;
    t1 = (this.lowerBound.x - pX) * inv_d;
    t2 = (this.upperBound.x - pX) * inv_d;
    s = -1;
    if(t1 > t2) {
      t3 = t1;
      t1 = t2;
      t2 = t3;
      s = 1
    }
    if(t1 > tmin) {
      normal.x = s;
      normal.y = 0;
      tmin = t1
    }
    tmax = Math.min(tmax, t2);
    if(tmin > tmax) {
      return false
    }
  }
  if(absDY < Number.MIN_VALUE) {
    if(pY < this.lowerBound.y || this.upperBound.y < pY) {
      return false
    }
  }else {
    inv_d = 1 / dY;
    t1 = (this.lowerBound.y - pY) * inv_d;
    t2 = (this.upperBound.y - pY) * inv_d;
    s = -1;
    if(t1 > t2) {
      t3 = t1;
      t1 = t2;
      t2 = t3;
      s = 1
    }
    if(t1 > tmin) {
      normal.y = s;
      normal.x = 0;
      tmin = t1
    }
    tmax = Math.min(tmax, t2);
    if(tmin > tmax) {
      return false
    }
  }
  output.fraction = tmin;
  return true
};
b2AABB.prototype.TestOverlap = function(other) {
  var d1X = other.lowerBound.x - this.upperBound.x;
  var d1Y = other.lowerBound.y - this.upperBound.y;
  var d2X = this.lowerBound.x - other.upperBound.x;
  var d2Y = this.lowerBound.y - other.upperBound.y;
  if(d1X > 0 || d1Y > 0) {
    return false
  }
  if(d2X > 0 || d2Y > 0) {
    return false
  }
  return true
};
b2AABB.prototype.Combine = function(aabb1, aabb2) {
  this.lowerBound.x = Math.min(aabb1.lowerBound.x, aabb2.lowerBound.x);
  this.lowerBound.y = Math.min(aabb1.lowerBound.y, aabb2.lowerBound.y);
  this.upperBound.x = Math.max(aabb1.upperBound.x, aabb2.upperBound.x);
  this.upperBound.y = Math.max(aabb1.upperBound.y, aabb2.upperBound.y)
};
b2AABB.prototype.lowerBound = new b2Vec2;
b2AABB.prototype.upperBound = new b2Vec2;var b2Jacobian = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Jacobian.prototype.__constructor = function() {
};
b2Jacobian.prototype.__varz = function() {
  this.linearA = new b2Vec2;
  this.linearB = new b2Vec2
};
b2Jacobian.prototype.SetZero = function() {
  this.linearA.SetZero();
  this.angularA = 0;
  this.linearB.SetZero();
  this.angularB = 0
};
b2Jacobian.prototype.Set = function(x1, a1, x2, a2) {
  this.linearA.SetV(x1);
  this.angularA = a1;
  this.linearB.SetV(x2);
  this.angularB = a2
};
b2Jacobian.prototype.Compute = function(x1, a1, x2, a2) {
  return this.linearA.x * x1.x + this.linearA.y * x1.y + this.angularA * a1 + (this.linearB.x * x2.x + this.linearB.y * x2.y) + this.angularB * a2
};
b2Jacobian.prototype.linearA = new b2Vec2;
b2Jacobian.prototype.angularA = null;
b2Jacobian.prototype.linearB = new b2Vec2;
b2Jacobian.prototype.angularB = null;var b2Bound = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Bound.prototype.__constructor = function() {
};
b2Bound.prototype.__varz = function() {
};
b2Bound.prototype.IsLower = function() {
  return(this.value & 1) == 0
};
b2Bound.prototype.IsUpper = function() {
  return(this.value & 1) == 1
};
b2Bound.prototype.Swap = function(b) {
  var tempValue = this.value;
  var tempProxy = this.proxy;
  var tempStabbingCount = this.stabbingCount;
  this.value = b.value;
  this.proxy = b.proxy;
  this.stabbingCount = b.stabbingCount;
  b.value = tempValue;
  b.proxy = tempProxy;
  b.stabbingCount = tempStabbingCount
};
b2Bound.prototype.value = 0;
b2Bound.prototype.proxy = null;
b2Bound.prototype.stabbingCount = 0;var b2SimplexVertex = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2SimplexVertex.prototype.__constructor = function() {
};
b2SimplexVertex.prototype.__varz = function() {
};
b2SimplexVertex.prototype.Set = function(other) {
  this.wA.SetV(other.wA);
  this.wB.SetV(other.wB);
  this.w.SetV(other.w);
  this.a = other.a;
  this.indexA = other.indexA;
  this.indexB = other.indexB
};
b2SimplexVertex.prototype.wA = null;
b2SimplexVertex.prototype.wB = null;
b2SimplexVertex.prototype.w = null;
b2SimplexVertex.prototype.a = null;
b2SimplexVertex.prototype.indexA = 0;
b2SimplexVertex.prototype.indexB = 0;var b2Mat22 = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Mat22.prototype.__constructor = function() {
  this.col1.x = this.col2.y = 1
};
b2Mat22.prototype.__varz = function() {
  this.col1 = new b2Vec2;
  this.col2 = new b2Vec2
};
b2Mat22.FromAngle = function(angle) {
  var mat = new b2Mat22;
  mat.Set(angle);
  return mat
};
b2Mat22.FromVV = function(c1, c2) {
  var mat = new b2Mat22;
  mat.SetVV(c1, c2);
  return mat
};
b2Mat22.prototype.Set = function(angle) {
  var c = Math.cos(angle);
  var s = Math.sin(angle);
  this.col1.x = c;
  this.col2.x = -s;
  this.col1.y = s;
  this.col2.y = c
};
b2Mat22.prototype.SetVV = function(c1, c2) {
  this.col1.SetV(c1);
  this.col2.SetV(c2)
};
b2Mat22.prototype.Copy = function() {
  var mat = new b2Mat22;
  mat.SetM(this);
  return mat
};
b2Mat22.prototype.SetM = function(m) {
  this.col1.SetV(m.col1);
  this.col2.SetV(m.col2)
};
b2Mat22.prototype.AddM = function(m) {
  this.col1.x += m.col1.x;
  this.col1.y += m.col1.y;
  this.col2.x += m.col2.x;
  this.col2.y += m.col2.y
};
b2Mat22.prototype.SetIdentity = function() {
  this.col1.x = 1;
  this.col2.x = 0;
  this.col1.y = 0;
  this.col2.y = 1
};
b2Mat22.prototype.SetZero = function() {
  this.col1.x = 0;
  this.col2.x = 0;
  this.col1.y = 0;
  this.col2.y = 0
};
b2Mat22.prototype.GetAngle = function() {
  return Math.atan2(this.col1.y, this.col1.x)
};
b2Mat22.prototype.GetInverse = function(out) {
  var a = this.col1.x;
  var b = this.col2.x;
  var c = this.col1.y;
  var d = this.col2.y;
  var det = a * d - b * c;
  if(det != 0) {
    det = 1 / det
  }
  out.col1.x = det * d;
  out.col2.x = -det * b;
  out.col1.y = -det * c;
  out.col2.y = det * a;
  return out
};
b2Mat22.prototype.Solve = function(out, bX, bY) {
  var a11 = this.col1.x;
  var a12 = this.col2.x;
  var a21 = this.col1.y;
  var a22 = this.col2.y;
  var det = a11 * a22 - a12 * a21;
  if(det != 0) {
    det = 1 / det
  }
  out.x = det * (a22 * bX - a12 * bY);
  out.y = det * (a11 * bY - a21 * bX);
  return out
};
b2Mat22.prototype.Abs = function() {
  this.col1.Abs();
  this.col2.Abs()
};
b2Mat22.prototype.col1 = new b2Vec2;
b2Mat22.prototype.col2 = new b2Vec2;var b2SimplexCache = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2SimplexCache.prototype.__constructor = function() {
};
b2SimplexCache.prototype.__varz = function() {
  this.indexA = new Array(3);
  this.indexB = new Array(3)
};
b2SimplexCache.prototype.metric = null;
b2SimplexCache.prototype.count = 0;
b2SimplexCache.prototype.indexA = new Array(3);
b2SimplexCache.prototype.indexB = new Array(3);var b2Shape = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Shape.prototype.__constructor = function() {
  this.m_type = b2Shape.e_unknownShape;
  this.m_radius = b2Settings.b2_linearSlop
};
b2Shape.prototype.__varz = function() {
};
b2Shape.TestOverlap = function(shape1, transform1, shape2, transform2) {
  var input = new b2DistanceInput;
  input.proxyA = new b2DistanceProxy;
  input.proxyA.Set(shape1);
  input.proxyB = new b2DistanceProxy;
  input.proxyB.Set(shape2);
  input.transformA = transform1;
  input.transformB = transform2;
  input.useRadii = true;
  var simplexCache = new b2SimplexCache;
  simplexCache.count = 0;
  var output = new b2DistanceOutput;
  b2Distance.Distance(output, simplexCache, input);
  return output.distance < 10 * Number.MIN_VALUE
};
b2Shape.e_hitCollide = 1;
b2Shape.e_missCollide = 0;
b2Shape.e_startsInsideCollide = -1;
b2Shape.e_unknownShape = -1;
b2Shape.e_circleShape = 0;
b2Shape.e_polygonShape = 1;
b2Shape.e_edgeShape = 2;
b2Shape.e_shapeTypeCount = 3;
b2Shape.prototype.Copy = function() {
  return null
};
b2Shape.prototype.Set = function(other) {
  this.m_radius = other.m_radius
};
b2Shape.prototype.GetType = function() {
  return this.m_type
};
b2Shape.prototype.TestPoint = function(xf, p) {
  return false
};
b2Shape.prototype.RayCast = function(output, input, transform) {
  return false
};
b2Shape.prototype.ComputeAABB = function(aabb, xf) {
};
b2Shape.prototype.ComputeMass = function(massData, density) {
};
b2Shape.prototype.ComputeSubmergedArea = function(normal, offset, xf, c) {
  return 0
};
b2Shape.prototype.m_type = 0;
b2Shape.prototype.m_radius = null;var b2Segment = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Segment.prototype.__constructor = function() {
};
b2Segment.prototype.__varz = function() {
  this.p1 = new b2Vec2;
  this.p2 = new b2Vec2
};
b2Segment.prototype.TestSegment = function(lambda, normal, segment, maxLambda) {
  var s = segment.p1;
  var rX = segment.p2.x - s.x;
  var rY = segment.p2.y - s.y;
  var dX = this.p2.x - this.p1.x;
  var dY = this.p2.y - this.p1.y;
  var nX = dY;
  var nY = -dX;
  var k_slop = 100 * Number.MIN_VALUE;
  var denom = -(rX * nX + rY * nY);
  if(denom > k_slop) {
    var bX = s.x - this.p1.x;
    var bY = s.y - this.p1.y;
    var a = bX * nX + bY * nY;
    if(0 <= a && a <= maxLambda * denom) {
      var mu2 = -rX * bY + rY * bX;
      if(-k_slop * denom <= mu2 && mu2 <= denom * (1 + k_slop)) {
        a /= denom;
        var nLen = Math.sqrt(nX * nX + nY * nY);
        nX /= nLen;
        nY /= nLen;
        lambda[0] = a;
        normal.Set(nX, nY);
        return true
      }
    }
  }
  return false
};
b2Segment.prototype.Extend = function(aabb) {
  this.ExtendForward(aabb);
  this.ExtendBackward(aabb)
};
b2Segment.prototype.ExtendForward = function(aabb) {
  var dX = this.p2.x - this.p1.x;
  var dY = this.p2.y - this.p1.y;
  var lambda = Math.min(dX > 0 ? (aabb.upperBound.x - this.p1.x) / dX : dX < 0 ? (aabb.lowerBound.x - this.p1.x) / dX : Number.POSITIVE_INFINITY, dY > 0 ? (aabb.upperBound.y - this.p1.y) / dY : dY < 0 ? (aabb.lowerBound.y - this.p1.y) / dY : Number.POSITIVE_INFINITY);
  this.p2.x = this.p1.x + dX * lambda;
  this.p2.y = this.p1.y + dY * lambda
};
b2Segment.prototype.ExtendBackward = function(aabb) {
  var dX = -this.p2.x + this.p1.x;
  var dY = -this.p2.y + this.p1.y;
  var lambda = Math.min(dX > 0 ? (aabb.upperBound.x - this.p2.x) / dX : dX < 0 ? (aabb.lowerBound.x - this.p2.x) / dX : Number.POSITIVE_INFINITY, dY > 0 ? (aabb.upperBound.y - this.p2.y) / dY : dY < 0 ? (aabb.lowerBound.y - this.p2.y) / dY : Number.POSITIVE_INFINITY);
  this.p1.x = this.p2.x + dX * lambda;
  this.p1.y = this.p2.y + dY * lambda
};
b2Segment.prototype.p1 = new b2Vec2;
b2Segment.prototype.p2 = new b2Vec2;var b2ContactRegister = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactRegister.prototype.__constructor = function() {
};
b2ContactRegister.prototype.__varz = function() {
};
b2ContactRegister.prototype.createFcn = null;
b2ContactRegister.prototype.destroyFcn = null;
b2ContactRegister.prototype.primary = null;
b2ContactRegister.prototype.pool = null;
b2ContactRegister.prototype.poolCount = 0;var b2DebugDraw = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DebugDraw.prototype.__constructor = function() {
  this.m_drawFlags = 0
};
b2DebugDraw.prototype.__varz = function() {
};
b2DebugDraw.e_shapeBit = 1;
b2DebugDraw.e_jointBit = 2;
b2DebugDraw.e_aabbBit = 4;
b2DebugDraw.e_pairBit = 8;
b2DebugDraw.e_centerOfMassBit = 16;
b2DebugDraw.e_controllerBit = 32;
b2DebugDraw.prototype.SetFlags = function(flags) {
  this.m_drawFlags = flags
};
b2DebugDraw.prototype.GetFlags = function() {
  return this.m_drawFlags
};
b2DebugDraw.prototype.AppendFlags = function(flags) {
  this.m_drawFlags |= flags
};
b2DebugDraw.prototype.ClearFlags = function(flags) {
  this.m_drawFlags &= ~flags
};
b2DebugDraw.prototype.SetSprite = function(sprite) {
  this.m_sprite = sprite
};
b2DebugDraw.prototype.GetSprite = function() {
  return this.m_sprite
};
b2DebugDraw.prototype.SetDrawScale = function(drawScale) {
  this.m_drawScale = drawScale
};
b2DebugDraw.prototype.GetDrawScale = function() {
  return this.m_drawScale
};
b2DebugDraw.prototype.SetLineThickness = function(lineThickness) {
  this.m_lineThickness = lineThickness
};
b2DebugDraw.prototype.GetLineThickness = function() {
  return this.m_lineThickness
};
b2DebugDraw.prototype.SetAlpha = function(alpha) {
  this.m_alpha = alpha
};
b2DebugDraw.prototype.GetAlpha = function() {
  return this.m_alpha
};
b2DebugDraw.prototype.SetFillAlpha = function(alpha) {
  this.m_fillAlpha = alpha
};
b2DebugDraw.prototype.GetFillAlpha = function() {
  return this.m_fillAlpha
};
b2DebugDraw.prototype.SetXFormScale = function(xformScale) {
  this.m_xformScale = xformScale
};
b2DebugDraw.prototype.GetXFormScale = function() {
  return this.m_xformScale
};
b2DebugDraw.prototype.Clear = function() {
  this.m_sprite.clearRect(0, 0, this.m_sprite.canvas.width, this.m_sprite.canvas.height)
};
b2DebugDraw.prototype.Y = function(y) {
  return this.m_sprite.canvas.height - y
};
b2DebugDraw.prototype.ToWorldPoint = function(localPoint) {
  return new b2Vec2(localPoint.x / this.m_drawScale, this.Y(localPoint.y) / this.m_drawScale)
};
b2DebugDraw.prototype.ColorStyle = function(color, alpha) {
  return"rgba(" + color.r + ", " + color.g + ", " + color.b + ", " + alpha + ")"
};
b2DebugDraw.prototype.DrawPolygon = function(vertices, vertexCount, color) {
  this.m_sprite.graphics.lineStyle(this.m_lineThickness, color.color, this.m_alpha);
  this.m_sprite.graphics.moveTo(vertices[0].x * this.m_drawScale, vertices[0].y * this.m_drawScale);
  for(var i = 1;i < vertexCount;i++) {
    this.m_sprite.graphics.lineTo(vertices[i].x * this.m_drawScale, vertices[i].y * this.m_drawScale)
  }
  this.m_sprite.graphics.lineTo(vertices[0].x * this.m_drawScale, vertices[0].y * this.m_drawScale)
};
b2DebugDraw.prototype.DrawSolidPolygon = function(vertices, vertexCount, color) {
  this.m_sprite.strokeSyle = this.ColorStyle(color, this.m_alpha);
  this.m_sprite.lineWidth = this.m_lineThickness;
  this.m_sprite.fillStyle = this.ColorStyle(color, this.m_fillAlpha);
  this.m_sprite.beginPath();
  this.m_sprite.moveTo(vertices[0].x * this.m_drawScale, this.Y(vertices[0].y * this.m_drawScale));
  for(var i = 1;i < vertexCount;i++) {
    this.m_sprite.lineTo(vertices[i].x * this.m_drawScale, this.Y(vertices[i].y * this.m_drawScale))
  }
  this.m_sprite.lineTo(vertices[0].x * this.m_drawScale, this.Y(vertices[0].y * this.m_drawScale));
  this.m_sprite.fill();
  this.m_sprite.stroke();
  this.m_sprite.closePath()
};
b2DebugDraw.prototype.DrawCircle = function(center, radius, color) {
  this.m_sprite.graphics.lineStyle(this.m_lineThickness, color.color, this.m_alpha);
  this.m_sprite.graphics.drawCircle(center.x * this.m_drawScale, center.y * this.m_drawScale, radius * this.m_drawScale)
};
b2DebugDraw.prototype.DrawSolidCircle = function(center, radius, axis, color) {
  this.m_sprite.strokeSyle = this.ColorStyle(color, this.m_alpha);
  this.m_sprite.lineWidth = this.m_lineThickness;
  this.m_sprite.fillStyle = this.ColorStyle(color, this.m_fillAlpha);
  this.m_sprite.beginPath();
  this.m_sprite.arc(center.x * this.m_drawScale, this.Y(center.y * this.m_drawScale), radius * this.m_drawScale, 0, Math.PI * 2, true);
  this.m_sprite.fill();
  this.m_sprite.stroke();
  this.m_sprite.closePath()
};
b2DebugDraw.prototype.DrawSegment = function(p1, p2, color) {
  this.m_sprite.lineWidth = this.m_lineThickness;
  this.m_sprite.strokeSyle = this.ColorStyle(color, this.m_alpha);
  this.m_sprite.beginPath();
  this.m_sprite.moveTo(p1.x * this.m_drawScale, this.Y(p1.y * this.m_drawScale));
  this.m_sprite.lineTo(p2.x * this.m_drawScale, this.Y(p2.y * this.m_drawScale));
  this.m_sprite.stroke();
  this.m_sprite.closePath()
};
b2DebugDraw.prototype.DrawTransform = function(xf) {
  this.m_sprite.lineWidth = this.m_lineThickness;
  this.m_sprite.strokeSyle = this.ColorStyle(new b2Color(255, 0, 0), this.m_alpha);
  this.m_sprite.beginPath();
  this.m_sprite.moveTo(xf.position.x * this.m_drawScale, this.Y(xf.position.y * this.m_drawScale));
  this.m_sprite.lineTo((xf.position.x + this.m_xformScale * xf.R.col1.x) * this.m_drawScale, this.Y((xf.position.y + this.m_xformScale * xf.R.col1.y) * this.m_drawScale));
  this.m_sprite.stroke();
  this.m_sprite.closePath();
  this.m_sprite.strokeSyle = this.ColorStyle(new b2Color(0, 255, 0), this.m_alpha);
  this.m_sprite.beginPath();
  this.m_sprite.moveTo(xf.position.x * this.m_drawScale, this.Y(xf.position.y * this.m_drawScale));
  this.m_sprite.lineTo((xf.position.x + this.m_xformScale * xf.R.col2.x) * this.m_drawScale, this.Y((xf.position.y + this.m_xformScale * xf.R.col2.y) * this.m_drawScale));
  this.m_sprite.stroke();
  this.m_sprite.closePath()
};
b2DebugDraw.prototype.m_drawFlags = 0;
b2DebugDraw.prototype.m_sprite = null;
b2DebugDraw.prototype.m_drawScale = 1;
b2DebugDraw.prototype.m_lineThickness = 1;
b2DebugDraw.prototype.m_alpha = 1;
b2DebugDraw.prototype.m_fillAlpha = 1;
b2DebugDraw.prototype.m_xformScale = 1;var b2Sweep = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Sweep.prototype.__constructor = function() {
};
b2Sweep.prototype.__varz = function() {
  this.localCenter = new b2Vec2;
  this.c0 = new b2Vec2;
  this.c = new b2Vec2
};
b2Sweep.prototype.Set = function(other) {
  this.localCenter.SetV(other.localCenter);
  this.c0.SetV(other.c0);
  this.c.SetV(other.c);
  this.a0 = other.a0;
  this.a = other.a;
  this.t0 = other.t0
};
b2Sweep.prototype.Copy = function() {
  var copy = new b2Sweep;
  copy.localCenter.SetV(this.localCenter);
  copy.c0.SetV(this.c0);
  copy.c.SetV(this.c);
  copy.a0 = this.a0;
  copy.a = this.a;
  copy.t0 = this.t0;
  return copy
};
b2Sweep.prototype.GetTransform = function(xf, alpha) {
  xf.position.x = (1 - alpha) * this.c0.x + alpha * this.c.x;
  xf.position.y = (1 - alpha) * this.c0.y + alpha * this.c.y;
  var angle = (1 - alpha) * this.a0 + alpha * this.a;
  xf.R.Set(angle);
  var tMat = xf.R;
  xf.position.x -= tMat.col1.x * this.localCenter.x + tMat.col2.x * this.localCenter.y;
  xf.position.y -= tMat.col1.y * this.localCenter.x + tMat.col2.y * this.localCenter.y
};
b2Sweep.prototype.Advance = function(t) {
  if(this.t0 < t && 1 - this.t0 > Number.MIN_VALUE) {
    var alpha = (t - this.t0) / (1 - this.t0);
    this.c0.x = (1 - alpha) * this.c0.x + alpha * this.c.x;
    this.c0.y = (1 - alpha) * this.c0.y + alpha * this.c.y;
    this.a0 = (1 - alpha) * this.a0 + alpha * this.a;
    this.t0 = t
  }
};
b2Sweep.prototype.localCenter = new b2Vec2;
b2Sweep.prototype.c0 = new b2Vec2;
b2Sweep.prototype.c = new b2Vec2;
b2Sweep.prototype.a0 = null;
b2Sweep.prototype.a = null;
b2Sweep.prototype.t0 = null;var b2DistanceOutput = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DistanceOutput.prototype.__constructor = function() {
};
b2DistanceOutput.prototype.__varz = function() {
  this.pointA = new b2Vec2;
  this.pointB = new b2Vec2
};
b2DistanceOutput.prototype.pointA = new b2Vec2;
b2DistanceOutput.prototype.pointB = new b2Vec2;
b2DistanceOutput.prototype.distance = null;
b2DistanceOutput.prototype.iterations = 0;var b2Mat33 = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Mat33.prototype.__constructor = function(c1, c2, c3) {
  if(!c1 && !c2 && !c3) {
    this.col1.SetZero();
    this.col2.SetZero();
    this.col3.SetZero()
  }else {
    this.col1.SetV(c1);
    this.col2.SetV(c2);
    this.col3.SetV(c3)
  }
};
b2Mat33.prototype.__varz = function() {
  this.col1 = new b2Vec3;
  this.col2 = new b2Vec3;
  this.col3 = new b2Vec3
};
b2Mat33.prototype.SetVVV = function(c1, c2, c3) {
  this.col1.SetV(c1);
  this.col2.SetV(c2);
  this.col3.SetV(c3)
};
b2Mat33.prototype.Copy = function() {
  return new b2Mat33(this.col1, this.col2, this.col3)
};
b2Mat33.prototype.SetM = function(m) {
  this.col1.SetV(m.col1);
  this.col2.SetV(m.col2);
  this.col3.SetV(m.col3)
};
b2Mat33.prototype.AddM = function(m) {
  this.col1.x += m.col1.x;
  this.col1.y += m.col1.y;
  this.col1.z += m.col1.z;
  this.col2.x += m.col2.x;
  this.col2.y += m.col2.y;
  this.col2.z += m.col2.z;
  this.col3.x += m.col3.x;
  this.col3.y += m.col3.y;
  this.col3.z += m.col3.z
};
b2Mat33.prototype.SetIdentity = function() {
  this.col1.x = 1;
  this.col2.x = 0;
  this.col3.x = 0;
  this.col1.y = 0;
  this.col2.y = 1;
  this.col3.y = 0;
  this.col1.z = 0;
  this.col2.z = 0;
  this.col3.z = 1
};
b2Mat33.prototype.SetZero = function() {
  this.col1.x = 0;
  this.col2.x = 0;
  this.col3.x = 0;
  this.col1.y = 0;
  this.col2.y = 0;
  this.col3.y = 0;
  this.col1.z = 0;
  this.col2.z = 0;
  this.col3.z = 0
};
b2Mat33.prototype.Solve22 = function(out, bX, bY) {
  var a11 = this.col1.x;
  var a12 = this.col2.x;
  var a21 = this.col1.y;
  var a22 = this.col2.y;
  var det = a11 * a22 - a12 * a21;
  if(det != 0) {
    det = 1 / det
  }
  out.x = det * (a22 * bX - a12 * bY);
  out.y = det * (a11 * bY - a21 * bX);
  return out
};
b2Mat33.prototype.Solve33 = function(out, bX, bY, bZ) {
  var a11 = this.col1.x;
  var a21 = this.col1.y;
  var a31 = this.col1.z;
  var a12 = this.col2.x;
  var a22 = this.col2.y;
  var a32 = this.col2.z;
  var a13 = this.col3.x;
  var a23 = this.col3.y;
  var a33 = this.col3.z;
  var det = a11 * (a22 * a33 - a32 * a23) + a21 * (a32 * a13 - a12 * a33) + a31 * (a12 * a23 - a22 * a13);
  if(det != 0) {
    det = 1 / det
  }
  out.x = det * (bX * (a22 * a33 - a32 * a23) + bY * (a32 * a13 - a12 * a33) + bZ * (a12 * a23 - a22 * a13));
  out.y = det * (a11 * (bY * a33 - bZ * a23) + a21 * (bZ * a13 - bX * a33) + a31 * (bX * a23 - bY * a13));
  out.z = det * (a11 * (a22 * bZ - a32 * bY) + a21 * (a32 * bX - a12 * bZ) + a31 * (a12 * bY - a22 * bX));
  return out
};
b2Mat33.prototype.col1 = new b2Vec3;
b2Mat33.prototype.col2 = new b2Vec3;
b2Mat33.prototype.col3 = new b2Vec3;var b2PositionSolverManifold = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2PositionSolverManifold.prototype.__constructor = function() {
  this.m_normal = new b2Vec2;
  this.m_separations = new Array(b2Settings.b2_maxManifoldPoints);
  this.m_points = new Array(b2Settings.b2_maxManifoldPoints);
  for(var i = 0;i < b2Settings.b2_maxManifoldPoints;i++) {
    this.m_points[i] = new b2Vec2
  }
};
b2PositionSolverManifold.prototype.__varz = function() {
};
b2PositionSolverManifold.circlePointA = new b2Vec2;
b2PositionSolverManifold.circlePointB = new b2Vec2;
b2PositionSolverManifold.prototype.Initialize = function(cc) {
  b2Settings.b2Assert(cc.pointCount > 0);
  var i = 0;
  var clipPointX;
  var clipPointY;
  var tMat;
  var tVec;
  var planePointX;
  var planePointY;
  switch(cc.type) {
    case b2Manifold.e_circles:
      tMat = cc.bodyA.m_xf.R;
      tVec = cc.localPoint;
      var pointAX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var pointAY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tMat = cc.bodyB.m_xf.R;
      tVec = cc.points[0].localPoint;
      var pointBX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var pointBY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      var dX = pointBX - pointAX;
      var dY = pointBY - pointAY;
      var d2 = dX * dX + dY * dY;
      if(d2 > Number.MIN_VALUE * Number.MIN_VALUE) {
        var d = Math.sqrt(d2);
        this.m_normal.x = dX / d;
        this.m_normal.y = dY / d
      }else {
        this.m_normal.x = 1;
        this.m_normal.y = 0
      }
      this.m_points[0].x = 0.5 * (pointAX + pointBX);
      this.m_points[0].y = 0.5 * (pointAY + pointBY);
      this.m_separations[0] = dX * this.m_normal.x + dY * this.m_normal.y - cc.radius;
      break;
    case b2Manifold.e_faceA:
      tMat = cc.bodyA.m_xf.R;
      tVec = cc.localPlaneNormal;
      this.m_normal.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      this.m_normal.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      tMat = cc.bodyA.m_xf.R;
      tVec = cc.localPoint;
      planePointX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      planePointY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tMat = cc.bodyB.m_xf.R;
      for(i = 0;i < cc.pointCount;++i) {
        tVec = cc.points[i].localPoint;
        clipPointX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        clipPointY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        this.m_separations[i] = (clipPointX - planePointX) * this.m_normal.x + (clipPointY - planePointY) * this.m_normal.y - cc.radius;
        this.m_points[i].x = clipPointX;
        this.m_points[i].y = clipPointY
      }
      break;
    case b2Manifold.e_faceB:
      tMat = cc.bodyB.m_xf.R;
      tVec = cc.localPlaneNormal;
      this.m_normal.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      this.m_normal.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      tMat = cc.bodyB.m_xf.R;
      tVec = cc.localPoint;
      planePointX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      planePointY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tMat = cc.bodyA.m_xf.R;
      for(i = 0;i < cc.pointCount;++i) {
        tVec = cc.points[i].localPoint;
        clipPointX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        clipPointY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        this.m_separations[i] = (clipPointX - planePointX) * this.m_normal.x + (clipPointY - planePointY) * this.m_normal.y - cc.radius;
        this.m_points[i].Set(clipPointX, clipPointY)
      }
      this.m_normal.x *= -1;
      this.m_normal.y *= -1;
      break
  }
};
b2PositionSolverManifold.prototype.m_normal = null;
b2PositionSolverManifold.prototype.m_points = null;
b2PositionSolverManifold.prototype.m_separations = null;var b2OBB = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2OBB.prototype.__constructor = function() {
};
b2OBB.prototype.__varz = function() {
  this.R = new b2Mat22;
  this.center = new b2Vec2;
  this.extents = new b2Vec2
};
b2OBB.prototype.R = new b2Mat22;
b2OBB.prototype.center = new b2Vec2;
b2OBB.prototype.extents = new b2Vec2;var b2Pair = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Pair.prototype.__constructor = function() {
};
b2Pair.prototype.__varz = function() {
};
b2Pair.b2_nullProxy = b2Settings.USHRT_MAX;
b2Pair.e_pairBuffered = 1;
b2Pair.e_pairRemoved = 2;
b2Pair.e_pairFinal = 4;
b2Pair.prototype.SetBuffered = function() {
  this.status |= b2Pair.e_pairBuffered
};
b2Pair.prototype.ClearBuffered = function() {
  this.status &= ~b2Pair.e_pairBuffered
};
b2Pair.prototype.IsBuffered = function() {
  return(this.status & b2Pair.e_pairBuffered) == b2Pair.e_pairBuffered
};
b2Pair.prototype.SetRemoved = function() {
  this.status |= b2Pair.e_pairRemoved
};
b2Pair.prototype.ClearRemoved = function() {
  this.status &= ~b2Pair.e_pairRemoved
};
b2Pair.prototype.IsRemoved = function() {
  return(this.status & b2Pair.e_pairRemoved) == b2Pair.e_pairRemoved
};
b2Pair.prototype.SetFinal = function() {
  this.status |= b2Pair.e_pairFinal
};
b2Pair.prototype.IsFinal = function() {
  return(this.status & b2Pair.e_pairFinal) == b2Pair.e_pairFinal
};
b2Pair.prototype.userData = null;
b2Pair.prototype.proxy1 = null;
b2Pair.prototype.proxy2 = null;
b2Pair.prototype.next = null;
b2Pair.prototype.status = 0;var b2FixtureDef = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2FixtureDef.prototype.__constructor = function() {
  this.shape = null;
  this.userData = null;
  this.friction = 0.2;
  this.restitution = 0;
  this.density = 0;
  this.filter.categoryBits = 1;
  this.filter.maskBits = 65535;
  this.filter.groupIndex = 0;
  this.isSensor = false
};
b2FixtureDef.prototype.__varz = function() {
  this.filter = new b2FilterData
};
b2FixtureDef.prototype.shape = null;
b2FixtureDef.prototype.userData = null;
b2FixtureDef.prototype.friction = null;
b2FixtureDef.prototype.restitution = null;
b2FixtureDef.prototype.density = null;
b2FixtureDef.prototype.isSensor = null;
b2FixtureDef.prototype.filter = new b2FilterData;var b2ContactID = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactID.prototype.__constructor = function() {
  this.features._m_id = this
};
b2ContactID.prototype.__varz = function() {
  this.features = new Features
};
b2ContactID.prototype.Set = function(id) {
  key = id._key
};
b2ContactID.prototype.Copy = function() {
  var id = new b2ContactID;
  id.key = key;
  return id
};
b2ContactID.prototype.__defineSetter__("key", function() {
  return this._key
});
b2ContactID.prototype.__defineSetter__("key", function(value) {
  this._key = value;
  this.features._referenceEdge = this._key & 255;
  this.features._incidentEdge = (this._key & 65280) >> 8 & 255;
  this.features._incidentVertex = (this._key & 16711680) >> 16 & 255;
  this.features._flip = (this._key & 4278190080) >> 24 & 255
});
b2ContactID.prototype._key = 0;
b2ContactID.prototype.features = new Features;var b2Transform = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Transform.prototype.__constructor = function(pos, r) {
  if(pos) {
    this.position.SetV(pos);
    this.R.SetM(r)
  }
};
b2Transform.prototype.__varz = function() {
  this.position = new b2Vec2;
  this.R = new b2Mat22
};
b2Transform.prototype.Initialize = function(pos, r) {
  this.position.SetV(pos);
  this.R.SetM(r)
};
b2Transform.prototype.SetIdentity = function() {
  this.position.SetZero();
  this.R.SetIdentity()
};
b2Transform.prototype.Set = function(x) {
  this.position.SetV(x.position);
  this.R.SetM(x.R)
};
b2Transform.prototype.GetAngle = function() {
  return Math.atan2(this.R.col1.y, this.R.col1.x)
};
b2Transform.prototype.position = new b2Vec2;
b2Transform.prototype.R = new b2Mat22;var b2EdgeShape = function() {
  b2Shape.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2EdgeShape.prototype, b2Shape.prototype);
b2EdgeShape.prototype._super = b2Shape.prototype;
b2EdgeShape.prototype.__constructor = function(v1, v2) {
  this._super.__constructor.apply(this, []);
  this.m_type = b2Shape.e_edgeShape;
  this.m_prevEdge = null;
  this.m_nextEdge = null;
  this.m_v1 = v1;
  this.m_v2 = v2;
  this.m_direction.Set(this.m_v2.x - this.m_v1.x, this.m_v2.y - this.m_v1.y);
  this.m_length = this.m_direction.Normalize();
  this.m_normal.Set(this.m_direction.y, -this.m_direction.x);
  this.m_coreV1.Set(-b2Settings.b2_toiSlop * (this.m_normal.x - this.m_direction.x) + this.m_v1.x, -b2Settings.b2_toiSlop * (this.m_normal.y - this.m_direction.y) + this.m_v1.y);
  this.m_coreV2.Set(-b2Settings.b2_toiSlop * (this.m_normal.x + this.m_direction.x) + this.m_v2.x, -b2Settings.b2_toiSlop * (this.m_normal.y + this.m_direction.y) + this.m_v2.y);
  this.m_cornerDir1 = this.m_normal;
  this.m_cornerDir2.Set(-this.m_normal.x, -this.m_normal.y)
};
b2EdgeShape.prototype.__varz = function() {
  this.s_supportVec = new b2Vec2;
  this.m_v1 = new b2Vec2;
  this.m_v2 = new b2Vec2;
  this.m_coreV1 = new b2Vec2;
  this.m_coreV2 = new b2Vec2;
  this.m_normal = new b2Vec2;
  this.m_direction = new b2Vec2;
  this.m_cornerDir1 = new b2Vec2;
  this.m_cornerDir2 = new b2Vec2
};
b2EdgeShape.prototype.SetPrevEdge = function(edge, core, cornerDir, convex) {
  this.m_prevEdge = edge;
  this.m_coreV1 = core;
  this.m_cornerDir1 = cornerDir;
  this.m_cornerConvex1 = convex
};
b2EdgeShape.prototype.SetNextEdge = function(edge, core, cornerDir, convex) {
  this.m_nextEdge = edge;
  this.m_coreV2 = core;
  this.m_cornerDir2 = cornerDir;
  this.m_cornerConvex2 = convex
};
b2EdgeShape.prototype.TestPoint = function(transform, p) {
  return false
};
b2EdgeShape.prototype.RayCast = function(output, input, transform) {
  var tMat;
  var rX = input.p2.x - input.p1.x;
  var rY = input.p2.y - input.p1.y;
  tMat = transform.R;
  var v1X = transform.position.x + (tMat.col1.x * this.m_v1.x + tMat.col2.x * this.m_v1.y);
  var v1Y = transform.position.y + (tMat.col1.y * this.m_v1.x + tMat.col2.y * this.m_v1.y);
  var nX = transform.position.y + (tMat.col1.y * this.m_v2.x + tMat.col2.y * this.m_v2.y) - v1Y;
  var nY = -(transform.position.x + (tMat.col1.x * this.m_v2.x + tMat.col2.x * this.m_v2.y) - v1X);
  var k_slop = 100 * Number.MIN_VALUE;
  var denom = -(rX * nX + rY * nY);
  if(denom > k_slop) {
    var bX = input.p1.x - v1X;
    var bY = input.p1.y - v1Y;
    var a = bX * nX + bY * nY;
    if(0 <= a && a <= input.maxFraction * denom) {
      var mu2 = -rX * bY + rY * bX;
      if(-k_slop * denom <= mu2 && mu2 <= denom * (1 + k_slop)) {
        a /= denom;
        output.fraction = a;
        var nLen = Math.sqrt(nX * nX + nY * nY);
        output.normal.x = nX / nLen;
        output.normal.y = nY / nLen;
        return true
      }
    }
  }
  return false
};
b2EdgeShape.prototype.ComputeAABB = function(aabb, transform) {
  var tMat = transform.R;
  var v1X = transform.position.x + (tMat.col1.x * this.m_v1.x + tMat.col2.x * this.m_v1.y);
  var v1Y = transform.position.y + (tMat.col1.y * this.m_v1.x + tMat.col2.y * this.m_v1.y);
  var v2X = transform.position.x + (tMat.col1.x * this.m_v2.x + tMat.col2.x * this.m_v2.y);
  var v2Y = transform.position.y + (tMat.col1.y * this.m_v2.x + tMat.col2.y * this.m_v2.y);
  if(v1X < v2X) {
    aabb.lowerBound.x = v1X;
    aabb.upperBound.x = v2X
  }else {
    aabb.lowerBound.x = v2X;
    aabb.upperBound.x = v1X
  }
  if(v1Y < v2Y) {
    aabb.lowerBound.y = v1Y;
    aabb.upperBound.y = v2Y
  }else {
    aabb.lowerBound.y = v2Y;
    aabb.upperBound.y = v1Y
  }
};
b2EdgeShape.prototype.ComputeMass = function(massData, density) {
  massData.mass = 0;
  massData.center.SetV(this.m_v1);
  massData.I = 0
};
b2EdgeShape.prototype.ComputeSubmergedArea = function(normal, offset, xf, c) {
  var v0 = new b2Vec2(normal.x * offset, normal.y * offset);
  var v1 = b2Math.MulX(xf, this.m_v1);
  var v2 = b2Math.MulX(xf, this.m_v2);
  var d1 = b2Math.Dot(normal, v1) - offset;
  var d2 = b2Math.Dot(normal, v2) - offset;
  if(d1 > 0) {
    if(d2 > 0) {
      return 0
    }else {
      v1.x = -d2 / (d1 - d2) * v1.x + d1 / (d1 - d2) * v2.x;
      v1.y = -d2 / (d1 - d2) * v1.y + d1 / (d1 - d2) * v2.y
    }
  }else {
    if(d2 > 0) {
      v2.x = -d2 / (d1 - d2) * v1.x + d1 / (d1 - d2) * v2.x;
      v2.y = -d2 / (d1 - d2) * v1.y + d1 / (d1 - d2) * v2.y
    }else {
    }
  }
  c.x = (v0.x + v1.x + v2.x) / 3;
  c.y = (v0.y + v1.y + v2.y) / 3;
  return 0.5 * ((v1.x - v0.x) * (v2.y - v0.y) - (v1.y - v0.y) * (v2.x - v0.x))
};
b2EdgeShape.prototype.GetLength = function() {
  return this.m_length
};
b2EdgeShape.prototype.GetVertex1 = function() {
  return this.m_v1
};
b2EdgeShape.prototype.GetVertex2 = function() {
  return this.m_v2
};
b2EdgeShape.prototype.GetCoreVertex1 = function() {
  return this.m_coreV1
};
b2EdgeShape.prototype.GetCoreVertex2 = function() {
  return this.m_coreV2
};
b2EdgeShape.prototype.GetNormalVector = function() {
  return this.m_normal
};
b2EdgeShape.prototype.GetDirectionVector = function() {
  return this.m_direction
};
b2EdgeShape.prototype.GetCorner1Vector = function() {
  return this.m_cornerDir1
};
b2EdgeShape.prototype.GetCorner2Vector = function() {
  return this.m_cornerDir2
};
b2EdgeShape.prototype.Corner1IsConvex = function() {
  return this.m_cornerConvex1
};
b2EdgeShape.prototype.Corner2IsConvex = function() {
  return this.m_cornerConvex2
};
b2EdgeShape.prototype.GetFirstVertex = function(xf) {
  var tMat = xf.R;
  return new b2Vec2(xf.position.x + (tMat.col1.x * this.m_coreV1.x + tMat.col2.x * this.m_coreV1.y), xf.position.y + (tMat.col1.y * this.m_coreV1.x + tMat.col2.y * this.m_coreV1.y))
};
b2EdgeShape.prototype.GetNextEdge = function() {
  return this.m_nextEdge
};
b2EdgeShape.prototype.GetPrevEdge = function() {
  return this.m_prevEdge
};
b2EdgeShape.prototype.Support = function(xf, dX, dY) {
  var tMat = xf.R;
  var v1X = xf.position.x + (tMat.col1.x * this.m_coreV1.x + tMat.col2.x * this.m_coreV1.y);
  var v1Y = xf.position.y + (tMat.col1.y * this.m_coreV1.x + tMat.col2.y * this.m_coreV1.y);
  var v2X = xf.position.x + (tMat.col1.x * this.m_coreV2.x + tMat.col2.x * this.m_coreV2.y);
  var v2Y = xf.position.y + (tMat.col1.y * this.m_coreV2.x + tMat.col2.y * this.m_coreV2.y);
  if(v1X * dX + v1Y * dY > v2X * dX + v2Y * dY) {
    this.s_supportVec.x = v1X;
    this.s_supportVec.y = v1Y
  }else {
    this.s_supportVec.x = v2X;
    this.s_supportVec.y = v2Y
  }
  return this.s_supportVec
};
b2EdgeShape.prototype.s_supportVec = new b2Vec2;
b2EdgeShape.prototype.m_v1 = new b2Vec2;
b2EdgeShape.prototype.m_v2 = new b2Vec2;
b2EdgeShape.prototype.m_coreV1 = new b2Vec2;
b2EdgeShape.prototype.m_coreV2 = new b2Vec2;
b2EdgeShape.prototype.m_length = null;
b2EdgeShape.prototype.m_normal = new b2Vec2;
b2EdgeShape.prototype.m_direction = new b2Vec2;
b2EdgeShape.prototype.m_cornerDir1 = new b2Vec2;
b2EdgeShape.prototype.m_cornerDir2 = new b2Vec2;
b2EdgeShape.prototype.m_cornerConvex1 = null;
b2EdgeShape.prototype.m_cornerConvex2 = null;
b2EdgeShape.prototype.m_nextEdge = null;
b2EdgeShape.prototype.m_prevEdge = null;var b2BuoyancyController = function() {
  b2Controller.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2BuoyancyController.prototype, b2Controller.prototype);
b2BuoyancyController.prototype._super = b2Controller.prototype;
b2BuoyancyController.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2BuoyancyController.prototype.__varz = function() {
  this.normal = new b2Vec2(0, -1);
  this.velocity = new b2Vec2(0, 0)
};
b2BuoyancyController.prototype.Step = function(step) {
  if(!m_bodyList) {
    return
  }
  if(this.useWorldGravity) {
    this.gravity = this.GetWorld().GetGravity().Copy()
  }
  for(var i = m_bodyList;i;i = i.nextBody) {
    var body = i.body;
    if(body.IsAwake() == false) {
      continue
    }
    var areac = new b2Vec2;
    var massc = new b2Vec2;
    var area = 0;
    var mass = 0;
    for(var fixture = body.GetFixtureList();fixture;fixture = fixture.GetNext()) {
      var sc = new b2Vec2;
      var sarea = fixture.GetShape().ComputeSubmergedArea(this.normal, this.offset, body.GetTransform(), sc);
      area += sarea;
      areac.x += sarea * sc.x;
      areac.y += sarea * sc.y;
      var shapeDensity;
      if(this.useDensity) {
        shapeDensity = 1
      }else {
        shapeDensity = 1
      }
      mass += sarea * shapeDensity;
      massc.x += sarea * sc.x * shapeDensity;
      massc.y += sarea * sc.y * shapeDensity
    }
    areac.x /= area;
    areac.y /= area;
    massc.x /= mass;
    massc.y /= mass;
    if(area < Number.MIN_VALUE) {
      continue
    }
    var buoyancyForce = this.gravity.GetNegative();
    buoyancyForce.Multiply(this.density * area);
    body.ApplyForce(buoyancyForce, massc);
    var dragForce = body.GetLinearVelocityFromWorldPoint(areac);
    dragForce.Subtract(this.velocity);
    dragForce.Multiply(-this.linearDrag * area);
    body.ApplyForce(dragForce, areac);
    body.ApplyTorque(-body.GetInertia() / body.GetMass() * area * body.GetAngularVelocity() * this.angularDrag)
  }
};
b2BuoyancyController.prototype.Draw = function(debugDraw) {
  var r = 1E3;
  var p1 = new b2Vec2;
  var p2 = new b2Vec2;
  p1.x = this.normal.x * this.offset + this.normal.y * r;
  p1.y = this.normal.y * this.offset - this.normal.x * r;
  p2.x = this.normal.x * this.offset - this.normal.y * r;
  p2.y = this.normal.y * this.offset + this.normal.x * r;
  var color = new b2Color(0, 0, 1);
  debugDraw.DrawSegment(p1, p2, color)
};
b2BuoyancyController.prototype.normal = new b2Vec2(0, -1);
b2BuoyancyController.prototype.offset = 0;
b2BuoyancyController.prototype.density = 0;
b2BuoyancyController.prototype.velocity = new b2Vec2(0, 0);
b2BuoyancyController.prototype.linearDrag = 2;
b2BuoyancyController.prototype.angularDrag = 1;
b2BuoyancyController.prototype.useDensity = false;
b2BuoyancyController.prototype.useWorldGravity = true;
b2BuoyancyController.prototype.gravity = null;var b2Body = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Body.prototype.__constructor = function(bd, world) {
  this.m_flags = 0;
  if(bd.bullet) {
    this.m_flags |= b2Body.e_bulletFlag
  }
  if(bd.fixedRotation) {
    this.m_flags |= b2Body.e_fixedRotationFlag
  }
  if(bd.allowSleep) {
    this.m_flags |= b2Body.e_allowSleepFlag
  }
  if(bd.awake) {
    this.m_flags |= b2Body.e_awakeFlag
  }
  if(bd.active) {
    this.m_flags |= b2Body.e_activeFlag
  }
  this.m_world = world;
  this.m_xf.position.SetV(bd.position);
  this.m_xf.R.Set(bd.angle);
  this.m_sweep.localCenter.SetZero();
  this.m_sweep.t0 = 1;
  this.m_sweep.a0 = this.m_sweep.a = bd.angle;
  var tMat = this.m_xf.R;
  var tVec = this.m_sweep.localCenter;
  this.m_sweep.c.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
  this.m_sweep.c.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
  this.m_sweep.c.x += this.m_xf.position.x;
  this.m_sweep.c.y += this.m_xf.position.y;
  this.m_sweep.c0.SetV(this.m_sweep.c);
  this.m_jointList = null;
  this.m_controllerList = null;
  this.m_contactList = null;
  this.m_controllerCount = 0;
  this.m_prev = null;
  this.m_next = null;
  this.m_linearVelocity.SetV(bd.linearVelocity);
  this.m_angularVelocity = bd.angularVelocity;
  this.m_linearDamping = bd.linearDamping;
  this.m_angularDamping = bd.angularDamping;
  this.m_force.Set(0, 0);
  this.m_torque = 0;
  this.m_sleepTime = 0;
  this.m_type = bd.type;
  if(this.m_type == b2Body.b2_dynamicBody) {
    this.m_mass = 1;
    this.m_invMass = 1
  }else {
    this.m_mass = 0;
    this.m_invMass = 0
  }
  this.m_I = 0;
  this.m_invI = 0;
  this.m_inertiaScale = bd.inertiaScale;
  this.m_userData = bd.userData;
  this.m_fixtureList = null;
  this.m_fixtureCount = 0
};
b2Body.prototype.__varz = function() {
  this.m_xf = new b2Transform;
  this.m_sweep = new b2Sweep;
  this.m_linearVelocity = new b2Vec2;
  this.m_force = new b2Vec2
};
b2Body.b2_staticBody = 0;
b2Body.b2_kinematicBody = 1;
b2Body.b2_dynamicBody = 2;
b2Body.s_xf1 = new b2Transform;
b2Body.e_islandFlag = 1;
b2Body.e_awakeFlag = 2;
b2Body.e_allowSleepFlag = 4;
b2Body.e_bulletFlag = 8;
b2Body.e_fixedRotationFlag = 16;
b2Body.e_activeFlag = 32;
b2Body.prototype.connectEdges = function(s1, s2, angle1) {
  var angle2 = Math.atan2(s2.GetDirectionVector().y, s2.GetDirectionVector().x);
  var coreOffset = Math.tan((angle2 - angle1) * 0.5);
  var core = b2Math.MulFV(coreOffset, s2.GetDirectionVector());
  core = b2Math.SubtractVV(core, s2.GetNormalVector());
  core = b2Math.MulFV(b2Settings.b2_toiSlop, core);
  core = b2Math.AddVV(core, s2.GetVertex1());
  var cornerDir = b2Math.AddVV(s1.GetDirectionVector(), s2.GetDirectionVector());
  cornerDir.Normalize();
  var convex = b2Math.Dot(s1.GetDirectionVector(), s2.GetNormalVector()) > 0;
  s1.SetNextEdge(s2, core, cornerDir, convex);
  s2.SetPrevEdge(s1, core, cornerDir, convex);
  return angle2
};
b2Body.prototype.SynchronizeFixtures = function() {
  var xf1 = b2Body.s_xf1;
  xf1.R.Set(this.m_sweep.a0);
  var tMat = xf1.R;
  var tVec = this.m_sweep.localCenter;
  xf1.position.x = this.m_sweep.c0.x - (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  xf1.position.y = this.m_sweep.c0.y - (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  var f;
  var broadPhase = this.m_world.m_contactManager.m_broadPhase;
  for(f = this.m_fixtureList;f;f = f.m_next) {
    f.Synchronize(broadPhase, xf1, this.m_xf)
  }
};
b2Body.prototype.SynchronizeTransform = function() {
  this.m_xf.R.Set(this.m_sweep.a);
  var tMat = this.m_xf.R;
  var tVec = this.m_sweep.localCenter;
  this.m_xf.position.x = this.m_sweep.c.x - (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  this.m_xf.position.y = this.m_sweep.c.y - (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y)
};
b2Body.prototype.ShouldCollide = function(other) {
  if(this.m_type != b2Body.b2_dynamicBody && other.m_type != b2Body.b2_dynamicBody) {
    return false
  }
  for(var jn = this.m_jointList;jn;jn = jn.next) {
    if(jn.other == other) {
      if(jn.joint.m_collideConnected == false) {
        return false
      }
    }
  }
  return true
};
b2Body.prototype.Advance = function(t) {
  this.m_sweep.Advance(t);
  this.m_sweep.c.SetV(this.m_sweep.c0);
  this.m_sweep.a = this.m_sweep.a0;
  this.SynchronizeTransform()
};
b2Body.prototype.CreateFixture = function(def) {
  if(this.m_world.IsLocked() == true) {
    return null
  }
  var fixture = new b2Fixture;
  fixture.Create(this, this.m_xf, def);
  if(this.m_flags & b2Body.e_activeFlag) {
    var broadPhase = this.m_world.m_contactManager.m_broadPhase;
    fixture.CreateProxy(broadPhase, this.m_xf)
  }
  fixture.m_next = this.m_fixtureList;
  this.m_fixtureList = fixture;
  ++this.m_fixtureCount;
  fixture.m_body = this;
  if(fixture.m_density > 0) {
    this.ResetMassData()
  }
  this.m_world.m_flags |= b2World.e_newFixture;
  return fixture
};
b2Body.prototype.CreateFixture2 = function(shape, density) {
  var def = new b2FixtureDef;
  def.shape = shape;
  def.density = density;
  return this.CreateFixture(def)
};
b2Body.prototype.DestroyFixture = function(fixture) {
  if(this.m_world.IsLocked() == true) {
    return
  }
  var node = this.m_fixtureList;
  var ppF = null;
  var found = false;
  while(node != null) {
    if(node == fixture) {
      if(ppF) {
        ppF.m_next = fixture.m_next
      }else {
        this.m_fixtureList = fixture.m_next
      }
      found = true;
      break
    }
    ppF = node;
    node = node.m_next
  }
  var edge = this.m_contactList;
  while(edge) {
    var c = edge.contact;
    edge = edge.next;
    var fixtureA = c.GetFixtureA();
    var fixtureB = c.GetFixtureB();
    if(fixture == fixtureA || fixture == fixtureB) {
      this.m_world.m_contactManager.Destroy(c)
    }
  }
  if(this.m_flags & b2Body.e_activeFlag) {
    var broadPhase = this.m_world.m_contactManager.m_broadPhase;
    fixture.DestroyProxy(broadPhase)
  }else {
  }
  fixture.Destroy();
  fixture.m_body = null;
  fixture.m_next = null;
  --this.m_fixtureCount;
  this.ResetMassData()
};
b2Body.prototype.SetPositionAndAngle = function(position, angle) {
  var f;
  if(this.m_world.IsLocked() == true) {
    return
  }
  this.m_xf.R.Set(angle);
  this.m_xf.position.SetV(position);
  var tMat = this.m_xf.R;
  var tVec = this.m_sweep.localCenter;
  this.m_sweep.c.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
  this.m_sweep.c.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
  this.m_sweep.c.x += this.m_xf.position.x;
  this.m_sweep.c.y += this.m_xf.position.y;
  this.m_sweep.c0.SetV(this.m_sweep.c);
  this.m_sweep.a0 = this.m_sweep.a = angle;
  var broadPhase = this.m_world.m_contactManager.m_broadPhase;
  for(f = this.m_fixtureList;f;f = f.m_next) {
    f.Synchronize(broadPhase, this.m_xf, this.m_xf)
  }
  this.m_world.m_contactManager.FindNewContacts()
};
b2Body.prototype.SetTransform = function(xf) {
  this.SetPositionAndAngle(xf.position, xf.GetAngle())
};
b2Body.prototype.GetTransform = function() {
  return this.m_xf
};
b2Body.prototype.GetPosition = function() {
  return this.m_xf.position
};
b2Body.prototype.SetPosition = function(position) {
  this.SetPositionAndAngle(position, this.GetAngle())
};
b2Body.prototype.GetAngle = function() {
  return this.m_sweep.a
};
b2Body.prototype.SetAngle = function(angle) {
  this.SetPositionAndAngle(this.GetPosition(), angle)
};
b2Body.prototype.GetWorldCenter = function() {
  return this.m_sweep.c
};
b2Body.prototype.GetLocalCenter = function() {
  return this.m_sweep.localCenter
};
b2Body.prototype.SetLinearVelocity = function(v) {
  if(this.m_type == b2Body.b2_staticBody) {
    return
  }
  this.m_linearVelocity.SetV(v)
};
b2Body.prototype.GetLinearVelocity = function() {
  return this.m_linearVelocity
};
b2Body.prototype.SetAngularVelocity = function(omega) {
  if(this.m_type == b2Body.b2_staticBody) {
    return
  }
  this.m_angularVelocity = omega
};
b2Body.prototype.GetAngularVelocity = function() {
  return this.m_angularVelocity
};
b2Body.prototype.GetDefinition = function() {
  var bd = new b2BodyDef;
  bd.type = this.GetType();
  bd.allowSleep = (this.m_flags & b2Body.e_allowSleepFlag) == b2Body.e_allowSleepFlag;
  bd.angle = this.GetAngle();
  bd.angularDamping = this.m_angularDamping;
  bd.angularVelocity = this.m_angularVelocity;
  bd.fixedRotation = (this.m_flags & b2Body.e_fixedRotationFlag) == b2Body.e_fixedRotationFlag;
  bd.bullet = (this.m_flags & b2Body.e_bulletFlag) == b2Body.e_bulletFlag;
  bd.awake = (this.m_flags & b2Body.e_awakeFlag) == b2Body.e_awakeFlag;
  bd.linearDamping = this.m_linearDamping;
  bd.linearVelocity.SetV(this.GetLinearVelocity());
  bd.position = this.GetPosition();
  bd.userData = this.GetUserData();
  return bd
};
b2Body.prototype.ApplyForce = function(force, point) {
  if(this.m_type != b2Body.b2_dynamicBody) {
    return
  }
  if(this.IsAwake() == false) {
    this.SetAwake(true)
  }
  this.m_force.x += force.x;
  this.m_force.y += force.y;
  this.m_torque += (point.x - this.m_sweep.c.x) * force.y - (point.y - this.m_sweep.c.y) * force.x
};
b2Body.prototype.ApplyTorque = function(torque) {
  if(this.m_type != b2Body.b2_dynamicBody) {
    return
  }
  if(this.IsAwake() == false) {
    this.SetAwake(true)
  }
  this.m_torque += torque
};
b2Body.prototype.ApplyImpulse = function(impulse, point) {
  if(this.m_type != b2Body.b2_dynamicBody) {
    return
  }
  if(this.IsAwake() == false) {
    this.SetAwake(true)
  }
  this.m_linearVelocity.x += this.m_invMass * impulse.x;
  this.m_linearVelocity.y += this.m_invMass * impulse.y;
  this.m_angularVelocity += this.m_invI * ((point.x - this.m_sweep.c.x) * impulse.y - (point.y - this.m_sweep.c.y) * impulse.x)
};
b2Body.prototype.Split = function(callback) {
  var linearVelocity = this.GetLinearVelocity().Copy();
  var angularVelocity = this.GetAngularVelocity();
  var center = this.GetWorldCenter();
  var body1 = this;
  var body2 = this.m_world.CreateBody(this.GetDefinition());
  var prev;
  for(var f = body1.m_fixtureList;f;) {
    if(callback(f)) {
      var next = f.m_next;
      if(prev) {
        prev.m_next = next
      }else {
        body1.m_fixtureList = next
      }
      body1.m_fixtureCount--;
      f.m_next = body2.m_fixtureList;
      body2.m_fixtureList = f;
      body2.m_fixtureCount++;
      f.m_body = body2;
      f = next
    }else {
      prev = f;
      f = f.m_next
    }
  }
  body1.ResetMassData();
  body2.ResetMassData();
  var center1 = body1.GetWorldCenter();
  var center2 = body2.GetWorldCenter();
  var velocity1 = b2Math.AddVV(linearVelocity, b2Math.CrossFV(angularVelocity, b2Math.SubtractVV(center1, center)));
  var velocity2 = b2Math.AddVV(linearVelocity, b2Math.CrossFV(angularVelocity, b2Math.SubtractVV(center2, center)));
  body1.SetLinearVelocity(velocity1);
  body2.SetLinearVelocity(velocity2);
  body1.SetAngularVelocity(angularVelocity);
  body2.SetAngularVelocity(angularVelocity);
  body1.SynchronizeFixtures();
  body2.SynchronizeFixtures();
  return body2
};
b2Body.prototype.Merge = function(other) {
  var f;
  for(f = other.m_fixtureList;f;) {
    var next = f.m_next;
    other.m_fixtureCount--;
    f.m_next = this.m_fixtureList;
    this.m_fixtureList = f;
    this.m_fixtureCount++;
    f.m_body = body2;
    f = next
  }
  body1.m_fixtureCount = 0;
  var body1 = this;
  var body2 = other;
  var center1 = body1.GetWorldCenter();
  var center2 = body2.GetWorldCenter();
  var velocity1 = body1.GetLinearVelocity().Copy();
  var velocity2 = body2.GetLinearVelocity().Copy();
  var angular1 = body1.GetAngularVelocity();
  var angular = body2.GetAngularVelocity();
  body1.ResetMassData();
  this.SynchronizeFixtures()
};
b2Body.prototype.GetMass = function() {
  return this.m_mass
};
b2Body.prototype.GetInertia = function() {
  return this.m_I
};
b2Body.prototype.GetMassData = function(data) {
  data.mass = this.m_mass;
  data.I = this.m_I;
  data.center.SetV(this.m_sweep.localCenter)
};
b2Body.prototype.SetMassData = function(massData) {
  b2Settings.b2Assert(this.m_world.IsLocked() == false);
  if(this.m_world.IsLocked() == true) {
    return
  }
  if(this.m_type != b2Body.b2_dynamicBody) {
    return
  }
  this.m_invMass = 0;
  this.m_I = 0;
  this.m_invI = 0;
  this.m_mass = massData.mass;
  if(this.m_mass <= 0) {
    this.m_mass = 1
  }
  this.m_invMass = 1 / this.m_mass;
  if(massData.I > 0 && (this.m_flags & b2Body.e_fixedRotationFlag) == 0) {
    this.m_I = massData.I - this.m_mass * (massData.center.x * massData.center.x + massData.center.y * massData.center.y);
    this.m_invI = 1 / this.m_I
  }
  var oldCenter = this.m_sweep.c.Copy();
  this.m_sweep.localCenter.SetV(massData.center);
  this.m_sweep.c0.SetV(b2Math.MulX(this.m_xf, this.m_sweep.localCenter));
  this.m_sweep.c.SetV(this.m_sweep.c0);
  this.m_linearVelocity.x += this.m_angularVelocity * -(this.m_sweep.c.y - oldCenter.y);
  this.m_linearVelocity.y += this.m_angularVelocity * +(this.m_sweep.c.x - oldCenter.x)
};
b2Body.prototype.ResetMassData = function() {
  this.m_mass = 0;
  this.m_invMass = 0;
  this.m_I = 0;
  this.m_invI = 0;
  this.m_sweep.localCenter.SetZero();
  if(this.m_type == b2Body.b2_staticBody || this.m_type == b2Body.b2_kinematicBody) {
    return
  }
  var center = b2Vec2.Make(0, 0);
  for(var f = this.m_fixtureList;f;f = f.m_next) {
    if(f.m_density == 0) {
      continue
    }
    var massData = f.GetMassData();
    this.m_mass += massData.mass;
    center.x += massData.center.x * massData.mass;
    center.y += massData.center.y * massData.mass;
    this.m_I += massData.I
  }
  if(this.m_mass > 0) {
    this.m_invMass = 1 / this.m_mass;
    center.x *= this.m_invMass;
    center.y *= this.m_invMass
  }else {
    this.m_mass = 1;
    this.m_invMass = 1
  }
  if(this.m_I > 0 && (this.m_flags & b2Body.e_fixedRotationFlag) == 0) {
    this.m_I -= this.m_mass * (center.x * center.x + center.y * center.y);
    this.m_I *= this.m_inertiaScale;
    b2Settings.b2Assert(this.m_I > 0);
    this.m_invI = 1 / this.m_I
  }else {
    this.m_I = 0;
    this.m_invI = 0
  }
  var oldCenter = this.m_sweep.c.Copy();
  this.m_sweep.localCenter.SetV(center);
  this.m_sweep.c0.SetV(b2Math.MulX(this.m_xf, this.m_sweep.localCenter));
  this.m_sweep.c.SetV(this.m_sweep.c0);
  this.m_linearVelocity.x += this.m_angularVelocity * -(this.m_sweep.c.y - oldCenter.y);
  this.m_linearVelocity.y += this.m_angularVelocity * +(this.m_sweep.c.x - oldCenter.x)
};
b2Body.prototype.GetWorldPoint = function(localPoint) {
  var A = this.m_xf.R;
  var u = new b2Vec2(A.col1.x * localPoint.x + A.col2.x * localPoint.y, A.col1.y * localPoint.x + A.col2.y * localPoint.y);
  u.x += this.m_xf.position.x;
  u.y += this.m_xf.position.y;
  return u
};
b2Body.prototype.GetWorldVector = function(localVector) {
  return b2Math.MulMV(this.m_xf.R, localVector)
};
b2Body.prototype.GetLocalPoint = function(worldPoint) {
  return b2Math.MulXT(this.m_xf, worldPoint)
};
b2Body.prototype.GetLocalVector = function(worldVector) {
  return b2Math.MulTMV(this.m_xf.R, worldVector)
};
b2Body.prototype.GetLinearVelocityFromWorldPoint = function(worldPoint) {
  return new b2Vec2(this.m_linearVelocity.x - this.m_angularVelocity * (worldPoint.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (worldPoint.x - this.m_sweep.c.x))
};
b2Body.prototype.GetLinearVelocityFromLocalPoint = function(localPoint) {
  var A = this.m_xf.R;
  var worldPoint = new b2Vec2(A.col1.x * localPoint.x + A.col2.x * localPoint.y, A.col1.y * localPoint.x + A.col2.y * localPoint.y);
  worldPoint.x += this.m_xf.position.x;
  worldPoint.y += this.m_xf.position.y;
  return new b2Vec2(this.m_linearVelocity.x - this.m_angularVelocity * (worldPoint.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (worldPoint.x - this.m_sweep.c.x))
};
b2Body.prototype.GetLinearDamping = function() {
  return this.m_linearDamping
};
b2Body.prototype.SetLinearDamping = function(linearDamping) {
  this.m_linearDamping = linearDamping
};
b2Body.prototype.GetAngularDamping = function() {
  return this.m_angularDamping
};
b2Body.prototype.SetAngularDamping = function(angularDamping) {
  this.m_angularDamping = angularDamping
};
b2Body.prototype.SetType = function(type) {
  if(this.m_type == type) {
    return
  }
  this.m_type = type;
  this.ResetMassData();
  if(this.m_type == b2Body.b2_staticBody) {
    this.m_linearVelocity.SetZero();
    this.m_angularVelocity = 0
  }
  this.SetAwake(true);
  this.m_force.SetZero();
  this.m_torque = 0;
  for(var ce = this.m_contactList;ce;ce = ce.next) {
    ce.contact.FlagForFiltering()
  }
};
b2Body.prototype.GetType = function() {
  return this.m_type
};
b2Body.prototype.SetBullet = function(flag) {
  if(flag) {
    this.m_flags |= b2Body.e_bulletFlag
  }else {
    this.m_flags &= ~b2Body.e_bulletFlag
  }
};
b2Body.prototype.IsBullet = function() {
  return(this.m_flags & b2Body.e_bulletFlag) == b2Body.e_bulletFlag
};
b2Body.prototype.SetSleepingAllowed = function(flag) {
  if(flag) {
    this.m_flags |= b2Body.e_allowSleepFlag
  }else {
    this.m_flags &= ~b2Body.e_allowSleepFlag;
    this.SetAwake(true)
  }
};
b2Body.prototype.SetAwake = function(flag) {
  if(flag) {
    this.m_flags |= b2Body.e_awakeFlag;
    this.m_sleepTime = 0
  }else {
    this.m_flags &= ~b2Body.e_awakeFlag;
    this.m_sleepTime = 0;
    this.m_linearVelocity.SetZero();
    this.m_angularVelocity = 0;
    this.m_force.SetZero();
    this.m_torque = 0
  }
};
b2Body.prototype.IsAwake = function() {
  return(this.m_flags & b2Body.e_awakeFlag) == b2Body.e_awakeFlag
};
b2Body.prototype.SetFixedRotation = function(fixed) {
  if(fixed) {
    this.m_flags |= b2Body.e_fixedRotationFlag
  }else {
    this.m_flags &= ~b2Body.e_fixedRotationFlag
  }
  this.ResetMassData()
};
b2Body.prototype.IsFixedRotation = function() {
  return(this.m_flags & b2Body.e_fixedRotationFlag) == b2Body.e_fixedRotationFlag
};
b2Body.prototype.SetActive = function(flag) {
  if(flag == this.IsActive()) {
    return
  }
  var broadPhase;
  var f;
  if(flag) {
    this.m_flags |= b2Body.e_activeFlag;
    broadPhase = this.m_world.m_contactManager.m_broadPhase;
    for(f = this.m_fixtureList;f;f = f.m_next) {
      f.CreateProxy(broadPhase, this.m_xf)
    }
  }else {
    this.m_flags &= ~b2Body.e_activeFlag;
    broadPhase = this.m_world.m_contactManager.m_broadPhase;
    for(f = this.m_fixtureList;f;f = f.m_next) {
      f.DestroyProxy(broadPhase)
    }
    var ce = this.m_contactList;
    while(ce) {
      var ce0 = ce;
      ce = ce.next;
      this.m_world.m_contactManager.Destroy(ce0.contact)
    }
    this.m_contactList = null
  }
};
b2Body.prototype.IsActive = function() {
  return(this.m_flags & b2Body.e_activeFlag) == b2Body.e_activeFlag
};
b2Body.prototype.IsSleepingAllowed = function() {
  return(this.m_flags & b2Body.e_allowSleepFlag) == b2Body.e_allowSleepFlag
};
b2Body.prototype.GetFixtureList = function() {
  return this.m_fixtureList
};
b2Body.prototype.GetJointList = function() {
  return this.m_jointList
};
b2Body.prototype.GetControllerList = function() {
  return this.m_controllerList
};
b2Body.prototype.GetContactList = function() {
  return this.m_contactList
};
b2Body.prototype.GetNext = function() {
  return this.m_next
};
b2Body.prototype.GetUserData = function() {
  return this.m_userData
};
b2Body.prototype.SetUserData = function(data) {
  this.m_userData = data
};
b2Body.prototype.GetWorld = function() {
  return this.m_world
};
b2Body.prototype.m_flags = 0;
b2Body.prototype.m_type = 0;
b2Body.prototype.m_islandIndex = 0;
b2Body.prototype.m_xf = new b2Transform;
b2Body.prototype.m_sweep = new b2Sweep;
b2Body.prototype.m_linearVelocity = new b2Vec2;
b2Body.prototype.m_angularVelocity = null;
b2Body.prototype.m_force = new b2Vec2;
b2Body.prototype.m_torque = null;
b2Body.prototype.m_world = null;
b2Body.prototype.m_prev = null;
b2Body.prototype.m_next = null;
b2Body.prototype.m_fixtureList = null;
b2Body.prototype.m_fixtureCount = 0;
b2Body.prototype.m_controllerList = null;
b2Body.prototype.m_controllerCount = 0;
b2Body.prototype.m_jointList = null;
b2Body.prototype.m_contactList = null;
b2Body.prototype.m_mass = null;
b2Body.prototype.m_invMass = null;
b2Body.prototype.m_I = null;
b2Body.prototype.m_invI = null;
b2Body.prototype.m_inertiaScale = null;
b2Body.prototype.m_linearDamping = null;
b2Body.prototype.m_angularDamping = null;
b2Body.prototype.m_sleepTime = null;
b2Body.prototype.m_userData = null;var b2ContactImpulse = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactImpulse.prototype.__constructor = function() {
};
b2ContactImpulse.prototype.__varz = function() {
  this.normalImpulses = new Array(b2Settings.b2_maxManifoldPoints);
  this.tangentImpulses = new Array(b2Settings.b2_maxManifoldPoints)
};
b2ContactImpulse.prototype.normalImpulses = new Array(b2Settings.b2_maxManifoldPoints);
b2ContactImpulse.prototype.tangentImpulses = new Array(b2Settings.b2_maxManifoldPoints);var b2TensorDampingController = function() {
  b2Controller.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2TensorDampingController.prototype, b2Controller.prototype);
b2TensorDampingController.prototype._super = b2Controller.prototype;
b2TensorDampingController.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2TensorDampingController.prototype.__varz = function() {
  this.T = new b2Mat22
};
b2TensorDampingController.prototype.SetAxisAligned = function(xDamping, yDamping) {
  this.T.col1.x = -xDamping;
  this.T.col1.y = 0;
  this.T.col2.x = 0;
  this.T.col2.y = -yDamping;
  if(xDamping > 0 || yDamping > 0) {
    this.maxTimestep = 1 / Math.max(xDamping, yDamping)
  }else {
    this.maxTimestep = 0
  }
};
b2TensorDampingController.prototype.Step = function(step) {
  var timestep = step.dt;
  if(timestep <= Number.MIN_VALUE) {
    return
  }
  if(timestep > this.maxTimestep && this.maxTimestep > 0) {
    timestep = this.maxTimestep
  }
  for(var i = m_bodyList;i;i = i.nextBody) {
    var body = i.body;
    if(!body.IsAwake()) {
      continue
    }
    var damping = body.GetWorldVector(b2Math.MulMV(this.T, body.GetLocalVector(body.GetLinearVelocity())));
    body.SetLinearVelocity(new b2Vec2(body.GetLinearVelocity().x + damping.x * timestep, body.GetLinearVelocity().y + damping.y * timestep))
  }
};
b2TensorDampingController.prototype.T = new b2Mat22;
b2TensorDampingController.prototype.maxTimestep = 0;var b2ManifoldPoint = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ManifoldPoint.prototype.__constructor = function() {
  this.Reset()
};
b2ManifoldPoint.prototype.__varz = function() {
  this.m_localPoint = new b2Vec2;
  this.m_id = new b2ContactID
};
b2ManifoldPoint.prototype.Reset = function() {
  this.m_localPoint.SetZero();
  this.m_normalImpulse = 0;
  this.m_tangentImpulse = 0;
  this.m_id.key = 0
};
b2ManifoldPoint.prototype.Set = function(m) {
  this.m_localPoint.SetV(m.m_localPoint);
  this.m_normalImpulse = m.m_normalImpulse;
  this.m_tangentImpulse = m.m_tangentImpulse;
  this.m_id.Set(m.m_id)
};
b2ManifoldPoint.prototype.m_localPoint = new b2Vec2;
b2ManifoldPoint.prototype.m_normalImpulse = null;
b2ManifoldPoint.prototype.m_tangentImpulse = null;
b2ManifoldPoint.prototype.m_id = new b2ContactID;var b2PolygonShape = function() {
  b2Shape.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2PolygonShape.prototype, b2Shape.prototype);
b2PolygonShape.prototype._super = b2Shape.prototype;
b2PolygonShape.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.m_type = b2Shape.e_polygonShape;
  this.m_centroid = new b2Vec2;
  this.m_vertices = new Array;
  this.m_normals = new Array
};
b2PolygonShape.prototype.__varz = function() {
};
b2PolygonShape.AsArray = function(vertices, vertexCount) {
  var polygonShape = new b2PolygonShape;
  polygonShape.SetAsArray(vertices, vertexCount);
  return polygonShape
};
b2PolygonShape.AsVector = function(vertices, vertexCount) {
  var polygonShape = new b2PolygonShape;
  polygonShape.SetAsVector(vertices, vertexCount);
  return polygonShape
};
b2PolygonShape.AsBox = function(hx, hy) {
  var polygonShape = new b2PolygonShape;
  polygonShape.SetAsBox(hx, hy);
  return polygonShape
};
b2PolygonShape.AsOrientedBox = function(hx, hy, center, angle) {
  var polygonShape = new b2PolygonShape;
  polygonShape.SetAsOrientedBox(hx, hy, center, angle);
  return polygonShape
};
b2PolygonShape.AsEdge = function(v1, v2) {
  var polygonShape = new b2PolygonShape;
  polygonShape.SetAsEdge(v1, v2);
  return polygonShape
};
b2PolygonShape.ComputeCentroid = function(vs, count) {
  var c = new b2Vec2;
  var area = 0;
  var p1X = 0;
  var p1Y = 0;
  var inv3 = 1 / 3;
  for(var i = 0;i < count;++i) {
    var p2 = vs[i];
    var p3 = i + 1 < count ? vs[parseInt(i + 1)] : vs[0];
    var e1X = p2.x - p1X;
    var e1Y = p2.y - p1Y;
    var e2X = p3.x - p1X;
    var e2Y = p3.y - p1Y;
    var D = e1X * e2Y - e1Y * e2X;
    var triangleArea = 0.5 * D;
    area += triangleArea;
    c.x += triangleArea * inv3 * (p1X + p2.x + p3.x);
    c.y += triangleArea * inv3 * (p1Y + p2.y + p3.y)
  }
  c.x *= 1 / area;
  c.y *= 1 / area;
  return c
};
b2PolygonShape.ComputeOBB = function(obb, vs, count) {
  var i = 0;
  var p = new Array(count + 1);
  for(i = 0;i < count;++i) {
    p[i] = vs[i]
  }
  p[count] = p[0];
  var minArea = Number.MAX_VALUE;
  for(i = 1;i <= count;++i) {
    var root = p[parseInt(i - 1)];
    var uxX = p[i].x - root.x;
    var uxY = p[i].y - root.y;
    var length = Math.sqrt(uxX * uxX + uxY * uxY);
    uxX /= length;
    uxY /= length;
    var uyX = -uxY;
    var uyY = uxX;
    var lowerX = Number.MAX_VALUE;
    var lowerY = Number.MAX_VALUE;
    var upperX = -Number.MAX_VALUE;
    var upperY = -Number.MAX_VALUE;
    for(var j = 0;j < count;++j) {
      var dX = p[j].x - root.x;
      var dY = p[j].y - root.y;
      var rX = uxX * dX + uxY * dY;
      var rY = uyX * dX + uyY * dY;
      if(rX < lowerX) {
        lowerX = rX
      }
      if(rY < lowerY) {
        lowerY = rY
      }
      if(rX > upperX) {
        upperX = rX
      }
      if(rY > upperY) {
        upperY = rY
      }
    }
    var area = (upperX - lowerX) * (upperY - lowerY);
    if(area < 0.95 * minArea) {
      minArea = area;
      obb.R.col1.x = uxX;
      obb.R.col1.y = uxY;
      obb.R.col2.x = uyX;
      obb.R.col2.y = uyY;
      var centerX = 0.5 * (lowerX + upperX);
      var centerY = 0.5 * (lowerY + upperY);
      var tMat = obb.R;
      obb.center.x = root.x + (tMat.col1.x * centerX + tMat.col2.x * centerY);
      obb.center.y = root.y + (tMat.col1.y * centerX + tMat.col2.y * centerY);
      obb.extents.x = 0.5 * (upperX - lowerX);
      obb.extents.y = 0.5 * (upperY - lowerY)
    }
  }
};
b2PolygonShape.s_mat = new b2Mat22;
b2PolygonShape.prototype.Validate = function() {
  return false
};
b2PolygonShape.prototype.Reserve = function(count) {
  for(var i = this.m_vertices.length;i < count;i++) {
    this.m_vertices[i] = new b2Vec2;
    this.m_normals[i] = new b2Vec2
  }
};
b2PolygonShape.prototype.Copy = function() {
  var s = new b2PolygonShape;
  s.Set(this);
  return s
};
b2PolygonShape.prototype.Set = function(other) {
  this._super.Set.apply(this, [other]);
  if(isInstanceOf(other, b2PolygonShape)) {
    var other2 = other;
    this.m_centroid.SetV(other2.m_centroid);
    this.m_vertexCount = other2.m_vertexCount;
    this.Reserve(this.m_vertexCount);
    for(var i = 0;i < this.m_vertexCount;i++) {
      this.m_vertices[i].SetV(other2.m_vertices[i]);
      this.m_normals[i].SetV(other2.m_normals[i])
    }
  }
};
b2PolygonShape.prototype.SetAsArray = function(vertices, vertexCount) {
  var v = new Array;
  for(var i = 0, tVec = null;i < vertices.length, tVec = vertices[i];i++) {
    v.push(tVec)
  }
  this.SetAsVector(v, vertexCount)
};
b2PolygonShape.prototype.SetAsVector = function(vertices, vertexCount) {
  if(typeof vertexCount == "undefined") {
    vertexCount = vertices.length
  }
  b2Settings.b2Assert(2 <= vertexCount);
  this.m_vertexCount = vertexCount;
  this.Reserve(vertexCount);
  var i = 0;
  for(i = 0;i < this.m_vertexCount;i++) {
    this.m_vertices[i].SetV(vertices[i])
  }
  for(i = 0;i < this.m_vertexCount;++i) {
    var i1 = i;
    var i2 = i + 1 < this.m_vertexCount ? i + 1 : 0;
    var edge = b2Math.SubtractVV(this.m_vertices[i2], this.m_vertices[i1]);
    b2Settings.b2Assert(edge.LengthSquared() > Number.MIN_VALUE);
    this.m_normals[i].SetV(b2Math.CrossVF(edge, 1));
    this.m_normals[i].Normalize()
  }
  this.m_centroid = b2PolygonShape.ComputeCentroid(this.m_vertices, this.m_vertexCount)
};
b2PolygonShape.prototype.SetAsBox = function(hx, hy) {
  this.m_vertexCount = 4;
  this.Reserve(4);
  this.m_vertices[0].Set(-hx, -hy);
  this.m_vertices[1].Set(hx, -hy);
  this.m_vertices[2].Set(hx, hy);
  this.m_vertices[3].Set(-hx, hy);
  this.m_normals[0].Set(0, -1);
  this.m_normals[1].Set(1, 0);
  this.m_normals[2].Set(0, 1);
  this.m_normals[3].Set(-1, 0);
  this.m_centroid.SetZero()
};
b2PolygonShape.prototype.SetAsOrientedBox = function(hx, hy, center, angle) {
  this.m_vertexCount = 4;
  this.Reserve(4);
  this.m_vertices[0].Set(-hx, -hy);
  this.m_vertices[1].Set(hx, -hy);
  this.m_vertices[2].Set(hx, hy);
  this.m_vertices[3].Set(-hx, hy);
  this.m_normals[0].Set(0, -1);
  this.m_normals[1].Set(1, 0);
  this.m_normals[2].Set(0, 1);
  this.m_normals[3].Set(-1, 0);
  this.m_centroid = center;
  var xf = new b2Transform;
  xf.position = center;
  xf.R.Set(angle);
  for(var i = 0;i < this.m_vertexCount;++i) {
    this.m_vertices[i] = b2Math.MulX(xf, this.m_vertices[i]);
    this.m_normals[i] = b2Math.MulMV(xf.R, this.m_normals[i])
  }
};
b2PolygonShape.prototype.SetAsEdge = function(v1, v2) {
  this.m_vertexCount = 2;
  this.Reserve(2);
  this.m_vertices[0].SetV(v1);
  this.m_vertices[1].SetV(v2);
  this.m_centroid.x = 0.5 * (v1.x + v2.x);
  this.m_centroid.y = 0.5 * (v1.y + v2.y);
  this.m_normals[0] = b2Math.CrossVF(b2Math.SubtractVV(v2, v1), 1);
  this.m_normals[0].Normalize();
  this.m_normals[1].x = -this.m_normals[0].x;
  this.m_normals[1].y = -this.m_normals[0].y
};
b2PolygonShape.prototype.TestPoint = function(xf, p) {
  var tVec;
  var tMat = xf.R;
  var tX = p.x - xf.position.x;
  var tY = p.y - xf.position.y;
  var pLocalX = tX * tMat.col1.x + tY * tMat.col1.y;
  var pLocalY = tX * tMat.col2.x + tY * tMat.col2.y;
  for(var i = 0;i < this.m_vertexCount;++i) {
    tVec = this.m_vertices[i];
    tX = pLocalX - tVec.x;
    tY = pLocalY - tVec.y;
    tVec = this.m_normals[i];
    var dot = tVec.x * tX + tVec.y * tY;
    if(dot > 0) {
      return false
    }
  }
  return true
};
b2PolygonShape.prototype.RayCast = function(output, input, transform) {
  var lower = 0;
  var upper = input.maxFraction;
  var tX;
  var tY;
  var tMat;
  var tVec;
  tX = input.p1.x - transform.position.x;
  tY = input.p1.y - transform.position.y;
  tMat = transform.R;
  var p1X = tX * tMat.col1.x + tY * tMat.col1.y;
  var p1Y = tX * tMat.col2.x + tY * tMat.col2.y;
  tX = input.p2.x - transform.position.x;
  tY = input.p2.y - transform.position.y;
  tMat = transform.R;
  var p2X = tX * tMat.col1.x + tY * tMat.col1.y;
  var p2Y = tX * tMat.col2.x + tY * tMat.col2.y;
  var dX = p2X - p1X;
  var dY = p2Y - p1Y;
  var index = -1;
  for(var i = 0;i < this.m_vertexCount;++i) {
    tVec = this.m_vertices[i];
    tX = tVec.x - p1X;
    tY = tVec.y - p1Y;
    tVec = this.m_normals[i];
    var numerator = tVec.x * tX + tVec.y * tY;
    var denominator = tVec.x * dX + tVec.y * dY;
    if(denominator == 0) {
      if(numerator < 0) {
        return false
      }
    }else {
      if(denominator < 0 && numerator < lower * denominator) {
        lower = numerator / denominator;
        index = i
      }else {
        if(denominator > 0 && numerator < upper * denominator) {
          upper = numerator / denominator
        }
      }
    }
    if(upper < lower - Number.MIN_VALUE) {
      return false
    }
  }
  if(index >= 0) {
    output.fraction = lower;
    tMat = transform.R;
    tVec = this.m_normals[index];
    output.normal.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
    output.normal.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
    return true
  }
  return false
};
b2PolygonShape.prototype.ComputeAABB = function(aabb, xf) {
  var tMat = xf.R;
  var tVec = this.m_vertices[0];
  var lowerX = xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  var lowerY = xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  var upperX = lowerX;
  var upperY = lowerY;
  for(var i = 1;i < this.m_vertexCount;++i) {
    tVec = this.m_vertices[i];
    var vX = xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
    var vY = xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
    lowerX = lowerX < vX ? lowerX : vX;
    lowerY = lowerY < vY ? lowerY : vY;
    upperX = upperX > vX ? upperX : vX;
    upperY = upperY > vY ? upperY : vY
  }
  aabb.lowerBound.x = lowerX - this.m_radius;
  aabb.lowerBound.y = lowerY - this.m_radius;
  aabb.upperBound.x = upperX + this.m_radius;
  aabb.upperBound.y = upperY + this.m_radius
};
b2PolygonShape.prototype.ComputeMass = function(massData, density) {
  if(this.m_vertexCount == 2) {
    massData.center.x = 0.5 * (this.m_vertices[0].x + this.m_vertices[1].x);
    massData.center.y = 0.5 * (this.m_vertices[0].y + this.m_vertices[1].y);
    massData.mass = 0;
    massData.I = 0;
    return
  }
  var centerX = 0;
  var centerY = 0;
  var area = 0;
  var I = 0;
  var p1X = 0;
  var p1Y = 0;
  var k_inv3 = 1 / 3;
  for(var i = 0;i < this.m_vertexCount;++i) {
    var p2 = this.m_vertices[i];
    var p3 = i + 1 < this.m_vertexCount ? this.m_vertices[parseInt(i + 1)] : this.m_vertices[0];
    var e1X = p2.x - p1X;
    var e1Y = p2.y - p1Y;
    var e2X = p3.x - p1X;
    var e2Y = p3.y - p1Y;
    var D = e1X * e2Y - e1Y * e2X;
    var triangleArea = 0.5 * D;
    area += triangleArea;
    centerX += triangleArea * k_inv3 * (p1X + p2.x + p3.x);
    centerY += triangleArea * k_inv3 * (p1Y + p2.y + p3.y);
    var px = p1X;
    var py = p1Y;
    var ex1 = e1X;
    var ey1 = e1Y;
    var ex2 = e2X;
    var ey2 = e2Y;
    var intx2 = k_inv3 * (0.25 * (ex1 * ex1 + ex2 * ex1 + ex2 * ex2) + (px * ex1 + px * ex2)) + 0.5 * px * px;
    var inty2 = k_inv3 * (0.25 * (ey1 * ey1 + ey2 * ey1 + ey2 * ey2) + (py * ey1 + py * ey2)) + 0.5 * py * py;
    I += D * (intx2 + inty2)
  }
  massData.mass = density * area;
  centerX *= 1 / area;
  centerY *= 1 / area;
  massData.center.Set(centerX, centerY);
  massData.I = density * I
};
b2PolygonShape.prototype.ComputeSubmergedArea = function(normal, offset, xf, c) {
  var normalL = b2Math.MulTMV(xf.R, normal);
  var offsetL = offset - b2Math.Dot(normal, xf.position);
  var depths = new Array;
  var diveCount = 0;
  var intoIndex = -1;
  var outoIndex = -1;
  var lastSubmerged = false;
  var i = 0;
  for(i = 0;i < this.m_vertexCount;++i) {
    depths[i] = b2Math.Dot(normalL, this.m_vertices[i]) - offsetL;
    var isSubmerged = depths[i] < -Number.MIN_VALUE;
    if(i > 0) {
      if(isSubmerged) {
        if(!lastSubmerged) {
          intoIndex = i - 1;
          diveCount++
        }
      }else {
        if(lastSubmerged) {
          outoIndex = i - 1;
          diveCount++
        }
      }
    }
    lastSubmerged = isSubmerged
  }
  switch(diveCount) {
    case 0:
      if(lastSubmerged) {
        var md = new b2MassData;
        this.ComputeMass(md, 1);
        c.SetV(b2Math.MulX(xf, md.center));
        return md.mass
      }else {
        return 0
      }
      break;
    case 1:
      if(intoIndex == -1) {
        intoIndex = this.m_vertexCount - 1
      }else {
        outoIndex = this.m_vertexCount - 1
      }
      break
  }
  var intoIndex2 = (intoIndex + 1) % this.m_vertexCount;
  var outoIndex2 = (outoIndex + 1) % this.m_vertexCount;
  var intoLamdda = (0 - depths[intoIndex]) / (depths[intoIndex2] - depths[intoIndex]);
  var outoLamdda = (0 - depths[outoIndex]) / (depths[outoIndex2] - depths[outoIndex]);
  var intoVec = new b2Vec2(this.m_vertices[intoIndex].x * (1 - intoLamdda) + this.m_vertices[intoIndex2].x * intoLamdda, this.m_vertices[intoIndex].y * (1 - intoLamdda) + this.m_vertices[intoIndex2].y * intoLamdda);
  var outoVec = new b2Vec2(this.m_vertices[outoIndex].x * (1 - outoLamdda) + this.m_vertices[outoIndex2].x * outoLamdda, this.m_vertices[outoIndex].y * (1 - outoLamdda) + this.m_vertices[outoIndex2].y * outoLamdda);
  var area = 0;
  var center = new b2Vec2;
  var p2 = this.m_vertices[intoIndex2];
  var p3;
  i = intoIndex2;
  while(i != outoIndex2) {
    i = (i + 1) % this.m_vertexCount;
    if(i == outoIndex2) {
      p3 = outoVec
    }else {
      p3 = this.m_vertices[i]
    }
    var triangleArea = 0.5 * ((p2.x - intoVec.x) * (p3.y - intoVec.y) - (p2.y - intoVec.y) * (p3.x - intoVec.x));
    area += triangleArea;
    center.x += triangleArea * (intoVec.x + p2.x + p3.x) / 3;
    center.y += triangleArea * (intoVec.y + p2.y + p3.y) / 3;
    p2 = p3
  }
  center.Multiply(1 / area);
  c.SetV(b2Math.MulX(xf, center));
  return area
};
b2PolygonShape.prototype.GetVertexCount = function() {
  return this.m_vertexCount
};
b2PolygonShape.prototype.GetVertices = function() {
  return this.m_vertices
};
b2PolygonShape.prototype.GetNormals = function() {
  return this.m_normals
};
b2PolygonShape.prototype.GetSupport = function(d) {
  var bestIndex = 0;
  var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
  for(var i = 1;i < this.m_vertexCount;++i) {
    var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
    if(value > bestValue) {
      bestIndex = i;
      bestValue = value
    }
  }
  return bestIndex
};
b2PolygonShape.prototype.GetSupportVertex = function(d) {
  var bestIndex = 0;
  var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
  for(var i = 1;i < this.m_vertexCount;++i) {
    var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
    if(value > bestValue) {
      bestIndex = i;
      bestValue = value
    }
  }
  return this.m_vertices[bestIndex]
};
b2PolygonShape.prototype.m_centroid = null;
b2PolygonShape.prototype.m_vertices = null;
b2PolygonShape.prototype.m_normals = null;
b2PolygonShape.prototype.m_vertexCount = 0;var b2Fixture = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Fixture.prototype.__constructor = function() {
  this.m_aabb = new b2AABB;
  this.m_userData = null;
  this.m_body = null;
  this.m_next = null;
  this.m_shape = null;
  this.m_density = 0;
  this.m_friction = 0;
  this.m_restitution = 0
};
b2Fixture.prototype.__varz = function() {
  this.m_filter = new b2FilterData
};
b2Fixture.prototype.Create = function(body, xf, def) {
  this.m_userData = def.userData;
  this.m_friction = def.friction;
  this.m_restitution = def.restitution;
  this.m_body = body;
  this.m_next = null;
  this.m_filter = def.filter.Copy();
  this.m_isSensor = def.isSensor;
  this.m_shape = def.shape.Copy();
  this.m_density = def.density
};
b2Fixture.prototype.Destroy = function() {
  this.m_shape = null
};
b2Fixture.prototype.CreateProxy = function(broadPhase, xf) {
  this.m_shape.ComputeAABB(this.m_aabb, xf);
  this.m_proxy = broadPhase.CreateProxy(this.m_aabb, this)
};
b2Fixture.prototype.DestroyProxy = function(broadPhase) {
  if(this.m_proxy == null) {
    return
  }
  broadPhase.DestroyProxy(this.m_proxy);
  this.m_proxy = null
};
b2Fixture.prototype.Synchronize = function(broadPhase, transform1, transform2) {
  if(!this.m_proxy) {
    return
  }
  var aabb1 = new b2AABB;
  var aabb2 = new b2AABB;
  this.m_shape.ComputeAABB(aabb1, transform1);
  this.m_shape.ComputeAABB(aabb2, transform2);
  this.m_aabb.Combine(aabb1, aabb2);
  var displacement = b2Math.SubtractVV(transform2.position, transform1.position);
  broadPhase.MoveProxy(this.m_proxy, this.m_aabb, displacement)
};
b2Fixture.prototype.GetType = function() {
  return this.m_shape.GetType()
};
b2Fixture.prototype.GetShape = function() {
  return this.m_shape
};
b2Fixture.prototype.SetSensor = function(sensor) {
  if(this.m_isSensor == sensor) {
    return
  }
  this.m_isSensor = sensor;
  if(this.m_body == null) {
    return
  }
  var edge = this.m_body.GetContactList();
  while(edge) {
    var contact = edge.contact;
    var fixtureA = contact.GetFixtureA();
    var fixtureB = contact.GetFixtureB();
    if(fixtureA == this || fixtureB == this) {
      contact.SetSensor(fixtureA.IsSensor() || fixtureB.IsSensor())
    }
    edge = edge.next
  }
};
b2Fixture.prototype.IsSensor = function() {
  return this.m_isSensor
};
b2Fixture.prototype.SetFilterData = function(filter) {
  this.m_filter = filter.Copy();
  if(this.m_body) {
    return
  }
  var edge = this.m_body.GetContactList();
  while(edge) {
    var contact = edge.contact;
    var fixtureA = contact.GetFixtureA();
    var fixtureB = contact.GetFixtureB();
    if(fixtureA == this || fixtureB == this) {
      contact.FlagForFiltering()
    }
    edge = edge.next
  }
};
b2Fixture.prototype.GetFilterData = function() {
  return this.m_filter.Copy()
};
b2Fixture.prototype.GetBody = function() {
  return this.m_body
};
b2Fixture.prototype.GetNext = function() {
  return this.m_next
};
b2Fixture.prototype.GetUserData = function() {
  return this.m_userData
};
b2Fixture.prototype.SetUserData = function(data) {
  this.m_userData = data
};
b2Fixture.prototype.TestPoint = function(p) {
  return this.m_shape.TestPoint(this.m_body.GetTransform(), p)
};
b2Fixture.prototype.RayCast = function(output, input) {
  return this.m_shape.RayCast(output, input, this.m_body.GetTransform())
};
b2Fixture.prototype.GetMassData = function(massData) {
  if(massData == null) {
    massData = new b2MassData
  }
  this.m_shape.ComputeMass(massData, this.m_density);
  return massData
};
b2Fixture.prototype.SetDensity = function(density) {
  this.m_density = density
};
b2Fixture.prototype.GetDensity = function() {
  return this.m_density
};
b2Fixture.prototype.GetFriction = function() {
  return this.m_friction
};
b2Fixture.prototype.SetFriction = function(friction) {
  this.m_friction = friction
};
b2Fixture.prototype.GetRestitution = function() {
  return this.m_restitution
};
b2Fixture.prototype.SetRestitution = function(restitution) {
  this.m_restitution = restitution
};
b2Fixture.prototype.GetAABB = function() {
  return this.m_aabb
};
b2Fixture.prototype.m_massData = null;
b2Fixture.prototype.m_aabb = null;
b2Fixture.prototype.m_density = null;
b2Fixture.prototype.m_next = null;
b2Fixture.prototype.m_body = null;
b2Fixture.prototype.m_shape = null;
b2Fixture.prototype.m_friction = null;
b2Fixture.prototype.m_restitution = null;
b2Fixture.prototype.m_proxy = null;
b2Fixture.prototype.m_filter = new b2FilterData;
b2Fixture.prototype.m_isSensor = null;
b2Fixture.prototype.m_userData = null;var b2DynamicTreeNode = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DynamicTreeNode.prototype.__constructor = function() {
};
b2DynamicTreeNode.prototype.__varz = function() {
  this.aabb = new b2AABB
};
b2DynamicTreeNode.prototype.IsLeaf = function() {
  return this.child1 == null
};
b2DynamicTreeNode.prototype.userData = null;
b2DynamicTreeNode.prototype.aabb = new b2AABB;
b2DynamicTreeNode.prototype.parent = null;
b2DynamicTreeNode.prototype.child1 = null;
b2DynamicTreeNode.prototype.child2 = null;var b2BodyDef = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2BodyDef.prototype.__constructor = function() {
  this.userData = null;
  this.position.Set(0, 0);
  this.angle = 0;
  this.linearVelocity.Set(0, 0);
  this.angularVelocity = 0;
  this.linearDamping = 0;
  this.angularDamping = 0;
  this.allowSleep = true;
  this.awake = true;
  this.fixedRotation = false;
  this.bullet = false;
  this.type = b2Body.b2_staticBody;
  this.active = true;
  this.inertiaScale = 1
};
b2BodyDef.prototype.__varz = function() {
  this.position = new b2Vec2;
  this.linearVelocity = new b2Vec2
};
b2BodyDef.prototype.type = 0;
b2BodyDef.prototype.position = new b2Vec2;
b2BodyDef.prototype.angle = null;
b2BodyDef.prototype.linearVelocity = new b2Vec2;
b2BodyDef.prototype.angularVelocity = null;
b2BodyDef.prototype.linearDamping = null;
b2BodyDef.prototype.angularDamping = null;
b2BodyDef.prototype.allowSleep = null;
b2BodyDef.prototype.awake = null;
b2BodyDef.prototype.fixedRotation = null;
b2BodyDef.prototype.bullet = null;
b2BodyDef.prototype.active = null;
b2BodyDef.prototype.userData = null;
b2BodyDef.prototype.inertiaScale = null;var b2DynamicTreeBroadPhase = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DynamicTreeBroadPhase.prototype.__constructor = function() {
};
b2DynamicTreeBroadPhase.prototype.__varz = function() {
  this.m_tree = new b2DynamicTree;
  this.m_moveBuffer = new Array;
  this.m_pairBuffer = new Array
};
b2DynamicTreeBroadPhase.prototype.BufferMove = function(proxy) {
  this.m_moveBuffer[this.m_moveBuffer.length] = proxy
};
b2DynamicTreeBroadPhase.prototype.UnBufferMove = function(proxy) {
  var i = this.m_moveBuffer.indexOf(proxy);
  this.m_moveBuffer.splice(i, 1)
};
b2DynamicTreeBroadPhase.prototype.ComparePairs = function(pair1, pair2) {
  return 0
};
b2DynamicTreeBroadPhase.prototype.CreateProxy = function(aabb, userData) {
  var proxy = this.m_tree.CreateProxy(aabb, userData);
  ++this.m_proxyCount;
  this.BufferMove(proxy);
  return proxy
};
b2DynamicTreeBroadPhase.prototype.DestroyProxy = function(proxy) {
  this.UnBufferMove(proxy);
  --this.m_proxyCount;
  this.m_tree.DestroyProxy(proxy)
};
b2DynamicTreeBroadPhase.prototype.MoveProxy = function(proxy, aabb, displacement) {
  var buffer = this.m_tree.MoveProxy(proxy, aabb, displacement);
  if(buffer) {
    this.BufferMove(proxy)
  }
};
b2DynamicTreeBroadPhase.prototype.TestOverlap = function(proxyA, proxyB) {
  var aabbA = this.m_tree.GetFatAABB(proxyA);
  var aabbB = this.m_tree.GetFatAABB(proxyB);
  return aabbA.TestOverlap(aabbB)
};
b2DynamicTreeBroadPhase.prototype.GetUserData = function(proxy) {
  return this.m_tree.GetUserData(proxy)
};
b2DynamicTreeBroadPhase.prototype.GetFatAABB = function(proxy) {
  return this.m_tree.GetFatAABB(proxy)
};
b2DynamicTreeBroadPhase.prototype.GetProxyCount = function() {
  return this.m_proxyCount
};
b2DynamicTreeBroadPhase.prototype.UpdatePairs = function(callback) {
  this.m_pairCount = 0;
  for(var i = 0, queryProxy = null;i < this.m_moveBuffer.length, queryProxy = this.m_moveBuffer[i];i++) {
    var that = this;
    function QueryCallback(proxy) {
      if(proxy == queryProxy) {
        return true
      }
      if(that.m_pairCount == that.m_pairBuffer.length) {
        that.m_pairBuffer[that.m_pairCount] = new b2DynamicTreePair
      }
      var pair = that.m_pairBuffer[that.m_pairCount];
      pair.proxyA = proxy < queryProxy ? proxy : queryProxy;
      pair.proxyB = proxy >= queryProxy ? proxy : queryProxy;
      ++that.m_pairCount;
      return true
    }
    var fatAABB = this.m_tree.GetFatAABB(queryProxy);
    this.m_tree.Query(QueryCallback, fatAABB)
  }
  this.m_moveBuffer.length = 0;
  for(var i = 0;i < this.m_pairCount;) {
    var primaryPair = this.m_pairBuffer[i];
    var userDataA = this.m_tree.GetUserData(primaryPair.proxyA);
    var userDataB = this.m_tree.GetUserData(primaryPair.proxyB);
    callback(userDataA, userDataB);
    ++i;
    while(i < this.m_pairCount) {
      var pair = this.m_pairBuffer[i];
      if(pair.proxyA != primaryPair.proxyA || pair.proxyB != primaryPair.proxyB) {
        break
      }
      ++i
    }
  }
};
b2DynamicTreeBroadPhase.prototype.Query = function(callback, aabb) {
  this.m_tree.Query(callback, aabb)
};
b2DynamicTreeBroadPhase.prototype.RayCast = function(callback, input) {
  this.m_tree.RayCast(callback, input)
};
b2DynamicTreeBroadPhase.prototype.Validate = function() {
};
b2DynamicTreeBroadPhase.prototype.Rebalance = function(iterations) {
  this.m_tree.Rebalance(iterations)
};
b2DynamicTreeBroadPhase.prototype.m_tree = new b2DynamicTree;
b2DynamicTreeBroadPhase.prototype.m_proxyCount = 0;
b2DynamicTreeBroadPhase.prototype.m_moveBuffer = new Array;
b2DynamicTreeBroadPhase.prototype.m_pairBuffer = new Array;
b2DynamicTreeBroadPhase.prototype.m_pairCount = 0;var b2BroadPhase = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2BroadPhase.prototype.__constructor = function(worldAABB) {
  var i = 0;
  this.m_pairManager.Initialize(this);
  this.m_worldAABB = worldAABB;
  this.m_proxyCount = 0;
  this.m_bounds = new Array;
  for(i = 0;i < 2;i++) {
    this.m_bounds[i] = new Array
  }
  var dX = worldAABB.upperBound.x - worldAABB.lowerBound.x;
  var dY = worldAABB.upperBound.y - worldAABB.lowerBound.y;
  this.m_quantizationFactor.x = b2Settings.USHRT_MAX / dX;
  this.m_quantizationFactor.y = b2Settings.USHRT_MAX / dY;
  this.m_timeStamp = 1;
  this.m_queryResultCount = 0
};
b2BroadPhase.prototype.__varz = function() {
  this.m_pairManager = new b2PairManager;
  this.m_proxyPool = new Array;
  this.m_querySortKeys = new Array;
  this.m_queryResults = new Array;
  this.m_quantizationFactor = new b2Vec2
};
b2BroadPhase.BinarySearch = function(bounds, count, value) {
  var low = 0;
  var high = count - 1;
  while(low <= high) {
    var mid = Math.round((low + high) / 2);
    var bound = bounds[mid];
    if(bound.value > value) {
      high = mid - 1
    }else {
      if(bound.value < value) {
        low = mid + 1
      }else {
        return parseInt(mid)
      }
    }
  }
  return parseInt(low)
};
b2BroadPhase.s_validate = false;
b2BroadPhase.b2_invalid = b2Settings.USHRT_MAX;
b2BroadPhase.b2_nullEdge = b2Settings.USHRT_MAX;
b2BroadPhase.prototype.ComputeBounds = function(lowerValues, upperValues, aabb) {
  var minVertexX = aabb.lowerBound.x;
  var minVertexY = aabb.lowerBound.y;
  minVertexX = b2Math.Min(minVertexX, this.m_worldAABB.upperBound.x);
  minVertexY = b2Math.Min(minVertexY, this.m_worldAABB.upperBound.y);
  minVertexX = b2Math.Max(minVertexX, this.m_worldAABB.lowerBound.x);
  minVertexY = b2Math.Max(minVertexY, this.m_worldAABB.lowerBound.y);
  var maxVertexX = aabb.upperBound.x;
  var maxVertexY = aabb.upperBound.y;
  maxVertexX = b2Math.Min(maxVertexX, this.m_worldAABB.upperBound.x);
  maxVertexY = b2Math.Min(maxVertexY, this.m_worldAABB.upperBound.y);
  maxVertexX = b2Math.Max(maxVertexX, this.m_worldAABB.lowerBound.x);
  maxVertexY = b2Math.Max(maxVertexY, this.m_worldAABB.lowerBound.y);
  lowerValues[0] = parseInt(this.m_quantizationFactor.x * (minVertexX - this.m_worldAABB.lowerBound.x)) & b2Settings.USHRT_MAX - 1;
  upperValues[0] = parseInt(this.m_quantizationFactor.x * (maxVertexX - this.m_worldAABB.lowerBound.x)) % 65535 | 1;
  lowerValues[1] = parseInt(this.m_quantizationFactor.y * (minVertexY - this.m_worldAABB.lowerBound.y)) & b2Settings.USHRT_MAX - 1;
  upperValues[1] = parseInt(this.m_quantizationFactor.y * (maxVertexY - this.m_worldAABB.lowerBound.y)) % 65535 | 1
};
b2BroadPhase.prototype.TestOverlapValidate = function(p1, p2) {
  for(var axis = 0;axis < 2;++axis) {
    var bounds = this.m_bounds[axis];
    var bound1 = bounds[p1.lowerBounds[axis]];
    var bound2 = bounds[p2.upperBounds[axis]];
    if(bound1.value > bound2.value) {
      return false
    }
    bound1 = bounds[p1.upperBounds[axis]];
    bound2 = bounds[p2.lowerBounds[axis]];
    if(bound1.value < bound2.value) {
      return false
    }
  }
  return true
};
b2BroadPhase.prototype.QueryAxis = function(lowerQueryOut, upperQueryOut, lowerValue, upperValue, bounds, boundCount, axis) {
  var lowerQuery = b2BroadPhase.BinarySearch(bounds, boundCount, lowerValue);
  var upperQuery = b2BroadPhase.BinarySearch(bounds, boundCount, upperValue);
  var bound;
  for(var j = lowerQuery;j < upperQuery;++j) {
    bound = bounds[j];
    if(bound.IsLower()) {
      this.IncrementOverlapCount(bound.proxy)
    }
  }
  if(lowerQuery > 0) {
    var i = lowerQuery - 1;
    bound = bounds[i];
    var s = bound.stabbingCount;
    while(s) {
      bound = bounds[i];
      if(bound.IsLower()) {
        var proxy = bound.proxy;
        if(lowerQuery <= proxy.upperBounds[axis]) {
          this.IncrementOverlapCount(bound.proxy);
          --s
        }
      }
      --i
    }
  }
  lowerQueryOut[0] = lowerQuery;
  upperQueryOut[0] = upperQuery
};
b2BroadPhase.prototype.IncrementOverlapCount = function(proxy) {
  if(proxy.timeStamp < this.m_timeStamp) {
    proxy.timeStamp = this.m_timeStamp;
    proxy.overlapCount = 1
  }else {
    proxy.overlapCount = 2;
    this.m_queryResults[this.m_queryResultCount] = proxy;
    ++this.m_queryResultCount
  }
};
b2BroadPhase.prototype.IncrementTimeStamp = function() {
  if(this.m_timeStamp == b2Settings.USHRT_MAX) {
    for(var i = 0;i < this.m_proxyPool.length;++i) {
      this.m_proxyPool[i].timeStamp = 0
    }
    this.m_timeStamp = 1
  }else {
    ++this.m_timeStamp
  }
};
b2BroadPhase.prototype.InRange = function(aabb) {
  var dX;
  var dY;
  var d2X;
  var d2Y;
  dX = aabb.lowerBound.x;
  dY = aabb.lowerBound.y;
  dX -= this.m_worldAABB.upperBound.x;
  dY -= this.m_worldAABB.upperBound.y;
  d2X = this.m_worldAABB.lowerBound.x;
  d2Y = this.m_worldAABB.lowerBound.y;
  d2X -= aabb.upperBound.x;
  d2Y -= aabb.upperBound.y;
  dX = b2Math.Max(dX, d2X);
  dY = b2Math.Max(dY, d2Y);
  return b2Math.Max(dX, dY) < 0
};
b2BroadPhase.prototype.CreateProxy = function(aabb, userData) {
  var index = 0;
  var proxy;
  var i = 0;
  var j = 0;
  if(!this.m_freeProxy) {
    this.m_freeProxy = this.m_proxyPool[this.m_proxyCount] = new b2Proxy;
    this.m_freeProxy.next = null;
    this.m_freeProxy.timeStamp = 0;
    this.m_freeProxy.overlapCount = b2BroadPhase.b2_invalid;
    this.m_freeProxy.userData = null;
    for(i = 0;i < 2;i++) {
      j = this.m_proxyCount * 2;
      this.m_bounds[i][j++] = new b2Bound;
      this.m_bounds[i][j] = new b2Bound
    }
  }
  proxy = this.m_freeProxy;
  this.m_freeProxy = proxy.next;
  proxy.overlapCount = 0;
  proxy.userData = userData;
  var boundCount = 2 * this.m_proxyCount;
  var lowerValues = new Array;
  var upperValues = new Array;
  this.ComputeBounds(lowerValues, upperValues, aabb);
  for(var axis = 0;axis < 2;++axis) {
    var bounds = this.m_bounds[axis];
    var lowerIndex = 0;
    var upperIndex = 0;
    var lowerIndexOut = new Array;
    lowerIndexOut.push(lowerIndex);
    var upperIndexOut = new Array;
    upperIndexOut.push(upperIndex);
    this.QueryAxis(lowerIndexOut, upperIndexOut, lowerValues[axis], upperValues[axis], bounds, boundCount, axis);
    lowerIndex = lowerIndexOut[0];
    upperIndex = upperIndexOut[0];
    bounds.splice(upperIndex, 0, bounds[bounds.length - 1]);
    bounds.length--;
    bounds.splice(lowerIndex, 0, bounds[bounds.length - 1]);
    bounds.length--;
    ++upperIndex;
    var tBound1 = bounds[lowerIndex];
    var tBound2 = bounds[upperIndex];
    tBound1.value = lowerValues[axis];
    tBound1.proxy = proxy;
    tBound2.value = upperValues[axis];
    tBound2.proxy = proxy;
    var tBoundAS3 = bounds[parseInt(lowerIndex - 1)];
    tBound1.stabbingCount = lowerIndex == 0 ? 0 : tBoundAS3.stabbingCount;
    tBoundAS3 = bounds[parseInt(upperIndex - 1)];
    tBound2.stabbingCount = tBoundAS3.stabbingCount;
    for(index = lowerIndex;index < upperIndex;++index) {
      tBoundAS3 = bounds[index];
      tBoundAS3.stabbingCount++
    }
    for(index = lowerIndex;index < boundCount + 2;++index) {
      tBound1 = bounds[index];
      var proxy2 = tBound1.proxy;
      if(tBound1.IsLower()) {
        proxy2.lowerBounds[axis] = index
      }else {
        proxy2.upperBounds[axis] = index
      }
    }
  }
  ++this.m_proxyCount;
  for(i = 0;i < this.m_queryResultCount;++i) {
    this.m_pairManager.AddBufferedPair(proxy, this.m_queryResults[i])
  }
  this.m_queryResultCount = 0;
  this.IncrementTimeStamp();
  return proxy
};
b2BroadPhase.prototype.DestroyProxy = function(proxy_) {
  var proxy = proxy_;
  var tBound1;
  var tBound2;
  var boundCount = 2 * this.m_proxyCount;
  for(var axis = 0;axis < 2;++axis) {
    var bounds = this.m_bounds[axis];
    var lowerIndex = proxy.lowerBounds[axis];
    var upperIndex = proxy.upperBounds[axis];
    tBound1 = bounds[lowerIndex];
    var lowerValue = tBound1.value;
    tBound2 = bounds[upperIndex];
    var upperValue = tBound2.value;
    bounds.splice(upperIndex, 1);
    bounds.splice(lowerIndex, 1);
    bounds.push(tBound1);
    bounds.push(tBound2);
    var tEnd = boundCount - 2;
    for(var index = lowerIndex;index < tEnd;++index) {
      tBound1 = bounds[index];
      var proxy2 = tBound1.proxy;
      if(tBound1.IsLower()) {
        proxy2.lowerBounds[axis] = index
      }else {
        proxy2.upperBounds[axis] = index
      }
    }
    tEnd = upperIndex - 1;
    for(var index2 = lowerIndex;index2 < tEnd;++index2) {
      tBound1 = bounds[index2];
      tBound1.stabbingCount--
    }
    var ignore = new Array;
    this.QueryAxis(ignore, ignore, lowerValue, upperValue, bounds, boundCount - 2, axis)
  }
  for(var i = 0;i < this.m_queryResultCount;++i) {
    this.m_pairManager.RemoveBufferedPair(proxy, this.m_queryResults[i])
  }
  this.m_queryResultCount = 0;
  this.IncrementTimeStamp();
  proxy.userData = null;
  proxy.overlapCount = b2BroadPhase.b2_invalid;
  proxy.lowerBounds[0] = b2BroadPhase.b2_invalid;
  proxy.lowerBounds[1] = b2BroadPhase.b2_invalid;
  proxy.upperBounds[0] = b2BroadPhase.b2_invalid;
  proxy.upperBounds[1] = b2BroadPhase.b2_invalid;
  proxy.next = this.m_freeProxy;
  this.m_freeProxy = proxy;
  --this.m_proxyCount
};
b2BroadPhase.prototype.MoveProxy = function(proxy_, aabb, displacement) {
  var proxy = proxy_;
  var as3arr;
  var as3int = 0;
  var axis = 0;
  var index = 0;
  var bound;
  var prevBound;
  var nextBound;
  var nextProxyId = 0;
  var nextProxy;
  if(proxy == null) {
    return
  }
  if(aabb.IsValid() == false) {
    return
  }
  var boundCount = 2 * this.m_proxyCount;
  var newValues = new b2BoundValues;
  this.ComputeBounds(newValues.lowerValues, newValues.upperValues, aabb);
  var oldValues = new b2BoundValues;
  for(axis = 0;axis < 2;++axis) {
    bound = this.m_bounds[axis][proxy.lowerBounds[axis]];
    oldValues.lowerValues[axis] = bound.value;
    bound = this.m_bounds[axis][proxy.upperBounds[axis]];
    oldValues.upperValues[axis] = bound.value
  }
  for(axis = 0;axis < 2;++axis) {
    var bounds = this.m_bounds[axis];
    var lowerIndex = proxy.lowerBounds[axis];
    var upperIndex = proxy.upperBounds[axis];
    var lowerValue = newValues.lowerValues[axis];
    var upperValue = newValues.upperValues[axis];
    bound = bounds[lowerIndex];
    var deltaLower = lowerValue - bound.value;
    bound.value = lowerValue;
    bound = bounds[upperIndex];
    var deltaUpper = upperValue - bound.value;
    bound.value = upperValue;
    if(deltaLower < 0) {
      index = lowerIndex;
      while(index > 0 && lowerValue < bounds[parseInt(index - 1)].value) {
        bound = bounds[index];
        prevBound = bounds[parseInt(index - 1)];
        var prevProxy = prevBound.proxy;
        prevBound.stabbingCount++;
        if(prevBound.IsUpper() == true) {
          if(this.TestOverlapBound(newValues, prevProxy)) {
            this.m_pairManager.AddBufferedPair(proxy, prevProxy)
          }
          as3arr = prevProxy.upperBounds;
          as3int = as3arr[axis];
          as3int++;
          as3arr[axis] = as3int;
          bound.stabbingCount++
        }else {
          as3arr = prevProxy.lowerBounds;
          as3int = as3arr[axis];
          as3int++;
          as3arr[axis] = as3int;
          bound.stabbingCount--
        }
        as3arr = proxy.lowerBounds;
        as3int = as3arr[axis];
        as3int--;
        as3arr[axis] = as3int;
        bound.Swap(prevBound);
        --index
      }
    }
    if(deltaUpper > 0) {
      index = upperIndex;
      while(index < boundCount - 1 && bounds[parseInt(index + 1)].value <= upperValue) {
        bound = bounds[index];
        nextBound = bounds[parseInt(index + 1)];
        nextProxy = nextBound.proxy;
        nextBound.stabbingCount++;
        if(nextBound.IsLower() == true) {
          if(this.TestOverlapBound(newValues, nextProxy)) {
            this.m_pairManager.AddBufferedPair(proxy, nextProxy)
          }
          as3arr = nextProxy.lowerBounds;
          as3int = as3arr[axis];
          as3int--;
          as3arr[axis] = as3int;
          bound.stabbingCount++
        }else {
          as3arr = nextProxy.upperBounds;
          as3int = as3arr[axis];
          as3int--;
          as3arr[axis] = as3int;
          bound.stabbingCount--
        }
        as3arr = proxy.upperBounds;
        as3int = as3arr[axis];
        as3int++;
        as3arr[axis] = as3int;
        bound.Swap(nextBound);
        index++
      }
    }
    if(deltaLower > 0) {
      index = lowerIndex;
      while(index < boundCount - 1 && bounds[parseInt(index + 1)].value <= lowerValue) {
        bound = bounds[index];
        nextBound = bounds[parseInt(index + 1)];
        nextProxy = nextBound.proxy;
        nextBound.stabbingCount--;
        if(nextBound.IsUpper()) {
          if(this.TestOverlapBound(oldValues, nextProxy)) {
            this.m_pairManager.RemoveBufferedPair(proxy, nextProxy)
          }
          as3arr = nextProxy.upperBounds;
          as3int = as3arr[axis];
          as3int--;
          as3arr[axis] = as3int;
          bound.stabbingCount--
        }else {
          as3arr = nextProxy.lowerBounds;
          as3int = as3arr[axis];
          as3int--;
          as3arr[axis] = as3int;
          bound.stabbingCount++
        }
        as3arr = proxy.lowerBounds;
        as3int = as3arr[axis];
        as3int++;
        as3arr[axis] = as3int;
        bound.Swap(nextBound);
        index++
      }
    }
    if(deltaUpper < 0) {
      index = upperIndex;
      while(index > 0 && upperValue < bounds[parseInt(index - 1)].value) {
        bound = bounds[index];
        prevBound = bounds[parseInt(index - 1)];
        prevProxy = prevBound.proxy;
        prevBound.stabbingCount--;
        if(prevBound.IsLower() == true) {
          if(this.TestOverlapBound(oldValues, prevProxy)) {
            this.m_pairManager.RemoveBufferedPair(proxy, prevProxy)
          }
          as3arr = prevProxy.lowerBounds;
          as3int = as3arr[axis];
          as3int++;
          as3arr[axis] = as3int;
          bound.stabbingCount--
        }else {
          as3arr = prevProxy.upperBounds;
          as3int = as3arr[axis];
          as3int++;
          as3arr[axis] = as3int;
          bound.stabbingCount++
        }
        as3arr = proxy.upperBounds;
        as3int = as3arr[axis];
        as3int--;
        as3arr[axis] = as3int;
        bound.Swap(prevBound);
        index--
      }
    }
  }
};
b2BroadPhase.prototype.UpdatePairs = function(callback) {
  this.m_pairManager.Commit(callback)
};
b2BroadPhase.prototype.TestOverlap = function(proxyA, proxyB) {
  var proxyA_ = proxyA;
  var proxyB_ = proxyB;
  if(proxyA_.lowerBounds[0] > proxyB_.upperBounds[0]) {
    return false
  }
  if(proxyB_.lowerBounds[0] > proxyA_.upperBounds[0]) {
    return false
  }
  if(proxyA_.lowerBounds[1] > proxyB_.upperBounds[1]) {
    return false
  }
  if(proxyB_.lowerBounds[1] > proxyA_.upperBounds[1]) {
    return false
  }
  return true
};
b2BroadPhase.prototype.GetUserData = function(proxy) {
  return proxy.userData
};
b2BroadPhase.prototype.GetFatAABB = function(proxy_) {
  var aabb = new b2AABB;
  var proxy = proxy_;
  aabb.lowerBound.x = this.m_worldAABB.lowerBound.x + this.m_bounds[0][proxy.lowerBounds[0]].value / this.m_quantizationFactor.x;
  aabb.lowerBound.y = this.m_worldAABB.lowerBound.y + this.m_bounds[1][proxy.lowerBounds[1]].value / this.m_quantizationFactor.y;
  aabb.upperBound.x = this.m_worldAABB.lowerBound.x + this.m_bounds[0][proxy.upperBounds[0]].value / this.m_quantizationFactor.x;
  aabb.upperBound.y = this.m_worldAABB.lowerBound.y + this.m_bounds[1][proxy.upperBounds[1]].value / this.m_quantizationFactor.y;
  return aabb
};
b2BroadPhase.prototype.GetProxyCount = function() {
  return this.m_proxyCount
};
b2BroadPhase.prototype.Query = function(callback, aabb) {
  var lowerValues = new Array;
  var upperValues = new Array;
  this.ComputeBounds(lowerValues, upperValues, aabb);
  var lowerIndex = 0;
  var upperIndex = 0;
  var lowerIndexOut = new Array;
  lowerIndexOut.push(lowerIndex);
  var upperIndexOut = new Array;
  upperIndexOut.push(upperIndex);
  this.QueryAxis(lowerIndexOut, upperIndexOut, lowerValues[0], upperValues[0], this.m_bounds[0], 2 * this.m_proxyCount, 0);
  this.QueryAxis(lowerIndexOut, upperIndexOut, lowerValues[1], upperValues[1], this.m_bounds[1], 2 * this.m_proxyCount, 1);
  for(var i = 0;i < this.m_queryResultCount;++i) {
    var proxy = this.m_queryResults[i];
    if(!callback(proxy)) {
      break
    }
  }
  this.m_queryResultCount = 0;
  this.IncrementTimeStamp()
};
b2BroadPhase.prototype.Validate = function() {
  var pair;
  var proxy1;
  var proxy2;
  var overlap;
  for(var axis = 0;axis < 2;++axis) {
    var bounds = this.m_bounds[axis];
    var boundCount = 2 * this.m_proxyCount;
    var stabbingCount = 0;
    for(var i = 0;i < boundCount;++i) {
      var bound = bounds[i];
      if(bound.IsLower() == true) {
        stabbingCount++
      }else {
        stabbingCount--
      }
    }
  }
};
b2BroadPhase.prototype.Rebalance = function(iterations) {
};
b2BroadPhase.prototype.RayCast = function(callback, input) {
  var subInput = new b2RayCastInput;
  subInput.p1.SetV(input.p1);
  subInput.p2.SetV(input.p2);
  subInput.maxFraction = input.maxFraction;
  var dx = (input.p2.x - input.p1.x) * this.m_quantizationFactor.x;
  var dy = (input.p2.y - input.p1.y) * this.m_quantizationFactor.y;
  var sx = dx < -Number.MIN_VALUE ? -1 : dx > Number.MIN_VALUE ? 1 : 0;
  var sy = dy < -Number.MIN_VALUE ? -1 : dy > Number.MIN_VALUE ? 1 : 0;
  var p1x = this.m_quantizationFactor.x * (input.p1.x - this.m_worldAABB.lowerBound.x);
  var p1y = this.m_quantizationFactor.y * (input.p1.y - this.m_worldAABB.lowerBound.y);
  var startValues = new Array;
  var startValues2 = new Array;
  startValues[0] = parseInt(p1x) & b2Settings.USHRT_MAX - 1;
  startValues[1] = parseInt(p1y) & b2Settings.USHRT_MAX - 1;
  startValues2[0] = startValues[0] + 1;
  startValues2[1] = startValues[1] + 1;
  var startIndices = new Array;
  var xIndex = 0;
  var yIndex = 0;
  var proxy;
  var lowerIndex = 0;
  var upperIndex = 0;
  var lowerIndexOut = new Array;
  lowerIndexOut.push(lowerIndex);
  var upperIndexOut = new Array;
  upperIndexOut.push(upperIndex);
  this.QueryAxis(lowerIndexOut, upperIndexOut, startValues[0], startValues2[0], this.m_bounds[0], 2 * this.m_proxyCount, 0);
  if(sx >= 0) {
    xIndex = upperIndexOut[0] - 1
  }else {
    xIndex = lowerIndexOut[0]
  }
  this.QueryAxis(lowerIndexOut, upperIndexOut, startValues[1], startValues2[1], this.m_bounds[1], 2 * this.m_proxyCount, 1);
  if(sy >= 0) {
    yIndex = upperIndexOut[0] - 1
  }else {
    yIndex = lowerIndexOut[0]
  }
  for(var i = 0;i < this.m_queryResultCount;i++) {
    subInput.maxFraction = callback(this.m_queryResults[i], subInput)
  }
  for(;;) {
    var xProgress = 0;
    var yProgress = 0;
    xIndex += sx >= 0 ? 1 : -1;
    if(xIndex < 0 || xIndex >= this.m_proxyCount * 2) {
      break
    }
    if(sx != 0) {
      xProgress = (this.m_bounds[0][xIndex].value - p1x) / dx
    }
    yIndex += sy >= 0 ? 1 : -1;
    if(yIndex < 0 || yIndex >= this.m_proxyCount * 2) {
      break
    }
    if(sy != 0) {
      yProgress = (this.m_bounds[1][yIndex].value - p1y) / dy
    }
    for(;;) {
      if(sy == 0 || sx != 0 && xProgress < yProgress) {
        if(xProgress > subInput.maxFraction) {
          break
        }
        if(sx > 0 ? this.m_bounds[0][xIndex].IsLower() : this.m_bounds[0][xIndex].IsUpper()) {
          proxy = this.m_bounds[0][xIndex].proxy;
          if(sy >= 0) {
            if(proxy.lowerBounds[1] <= yIndex - 1 && proxy.upperBounds[1] >= yIndex) {
              subInput.maxFraction = callback(proxy, subInput)
            }
          }else {
            if(proxy.lowerBounds[1] <= yIndex && proxy.upperBounds[1] >= yIndex + 1) {
              subInput.maxFraction = callback(proxy, subInput)
            }
          }
        }
        if(subInput.maxFraction == 0) {
          break
        }
        if(sx > 0) {
          xIndex++;
          if(xIndex == this.m_proxyCount * 2) {
            break
          }
        }else {
          xIndex--;
          if(xIndex < 0) {
            break
          }
        }
        xProgress = (this.m_bounds[0][xIndex].value - p1x) / dx
      }else {
        if(yProgress > subInput.maxFraction) {
          break
        }
        if(sy > 0 ? this.m_bounds[1][yIndex].IsLower() : this.m_bounds[1][yIndex].IsUpper()) {
          proxy = this.m_bounds[1][yIndex].proxy;
          if(sx >= 0) {
            if(proxy.lowerBounds[0] <= xIndex - 1 && proxy.upperBounds[0] >= xIndex) {
              subInput.maxFraction = callback(proxy, subInput)
            }
          }else {
            if(proxy.lowerBounds[0] <= xIndex && proxy.upperBounds[0] >= xIndex + 1) {
              subInput.maxFraction = callback(proxy, subInput)
            }
          }
        }
        if(subInput.maxFraction == 0) {
          break
        }
        if(sy > 0) {
          yIndex++;
          if(yIndex == this.m_proxyCount * 2) {
            break
          }
        }else {
          yIndex--;
          if(yIndex < 0) {
            break
          }
        }
        yProgress = (this.m_bounds[1][yIndex].value - p1y) / dy
      }
    }
    break
  }
  this.m_queryResultCount = 0;
  this.IncrementTimeStamp();
  return
};
b2BroadPhase.prototype.TestOverlapBound = function(b, p) {
  for(var axis = 0;axis < 2;++axis) {
    var bounds = this.m_bounds[axis];
    var bound = bounds[p.upperBounds[axis]];
    if(b.lowerValues[axis] > bound.value) {
      return false
    }
    bound = bounds[p.lowerBounds[axis]];
    if(b.upperValues[axis] < bound.value) {
      return false
    }
  }
  return true
};
b2BroadPhase.prototype.m_pairManager = new b2PairManager;
b2BroadPhase.prototype.m_proxyPool = new Array;
b2BroadPhase.prototype.m_freeProxy = null;
b2BroadPhase.prototype.m_bounds = null;
b2BroadPhase.prototype.m_querySortKeys = new Array;
b2BroadPhase.prototype.m_queryResults = new Array;
b2BroadPhase.prototype.m_queryResultCount = 0;
b2BroadPhase.prototype.m_worldAABB = null;
b2BroadPhase.prototype.m_quantizationFactor = new b2Vec2;
b2BroadPhase.prototype.m_proxyCount = 0;
b2BroadPhase.prototype.m_timeStamp = 0;var b2Manifold = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Manifold.prototype.__constructor = function() {
  this.m_points = new Array(b2Settings.b2_maxManifoldPoints);
  for(var i = 0;i < b2Settings.b2_maxManifoldPoints;i++) {
    this.m_points[i] = new b2ManifoldPoint
  }
  this.m_localPlaneNormal = new b2Vec2;
  this.m_localPoint = new b2Vec2
};
b2Manifold.prototype.__varz = function() {
};
b2Manifold.e_circles = 1;
b2Manifold.e_faceA = 2;
b2Manifold.e_faceB = 4;
b2Manifold.prototype.Reset = function() {
  for(var i = 0;i < b2Settings.b2_maxManifoldPoints;i++) {
    this.m_points[i].Reset()
  }
  this.m_localPlaneNormal.SetZero();
  this.m_localPoint.SetZero();
  this.m_type = 0;
  this.m_pointCount = 0
};
b2Manifold.prototype.Set = function(m) {
  this.m_pointCount = m.m_pointCount;
  for(var i = 0;i < b2Settings.b2_maxManifoldPoints;i++) {
    this.m_points[i].Set(m.m_points[i])
  }
  this.m_localPlaneNormal.SetV(m.m_localPlaneNormal);
  this.m_localPoint.SetV(m.m_localPoint);
  this.m_type = m.m_type
};
b2Manifold.prototype.Copy = function() {
  var copy = new b2Manifold;
  copy.Set(this);
  return copy
};
b2Manifold.prototype.m_points = null;
b2Manifold.prototype.m_localPlaneNormal = null;
b2Manifold.prototype.m_localPoint = null;
b2Manifold.prototype.m_type = 0;
b2Manifold.prototype.m_pointCount = 0;var b2CircleShape = function() {
  b2Shape.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2CircleShape.prototype, b2Shape.prototype);
b2CircleShape.prototype._super = b2Shape.prototype;
b2CircleShape.prototype.__constructor = function(radius) {
  this._super.__constructor.apply(this, []);
  this.m_type = b2Shape.e_circleShape;
  this.m_radius = radius
};
b2CircleShape.prototype.__varz = function() {
  this.m_p = new b2Vec2
};
b2CircleShape.prototype.Copy = function() {
  var s = new b2CircleShape;
  s.Set(this);
  return s
};
b2CircleShape.prototype.Set = function(other) {
  this._super.Set.apply(this, [other]);
  if(isInstanceOf(other, b2CircleShape)) {
    var other2 = other;
    this.m_p.SetV(other2.m_p)
  }
};
b2CircleShape.prototype.TestPoint = function(transform, p) {
  var tMat = transform.R;
  var dX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
  var dY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
  dX = p.x - dX;
  dY = p.y - dY;
  return dX * dX + dY * dY <= this.m_radius * this.m_radius
};
b2CircleShape.prototype.RayCast = function(output, input, transform) {
  var tMat = transform.R;
  var positionX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
  var positionY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
  var sX = input.p1.x - positionX;
  var sY = input.p1.y - positionY;
  var b = sX * sX + sY * sY - this.m_radius * this.m_radius;
  var rX = input.p2.x - input.p1.x;
  var rY = input.p2.y - input.p1.y;
  var c = sX * rX + sY * rY;
  var rr = rX * rX + rY * rY;
  var sigma = c * c - rr * b;
  if(sigma < 0 || rr < Number.MIN_VALUE) {
    return false
  }
  var a = -(c + Math.sqrt(sigma));
  if(0 <= a && a <= input.maxFraction * rr) {
    a /= rr;
    output.fraction = a;
    output.normal.x = sX + a * rX;
    output.normal.y = sY + a * rY;
    output.normal.Normalize();
    return true
  }
  return false
};
b2CircleShape.prototype.ComputeAABB = function(aabb, transform) {
  var tMat = transform.R;
  var pX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
  var pY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
  aabb.lowerBound.Set(pX - this.m_radius, pY - this.m_radius);
  aabb.upperBound.Set(pX + this.m_radius, pY + this.m_radius)
};
b2CircleShape.prototype.ComputeMass = function(massData, density) {
  massData.mass = density * b2Settings.b2_pi * this.m_radius * this.m_radius;
  massData.center.SetV(this.m_p);
  massData.I = massData.mass * (0.5 * this.m_radius * this.m_radius + (this.m_p.x * this.m_p.x + this.m_p.y * this.m_p.y))
};
b2CircleShape.prototype.ComputeSubmergedArea = function(normal, offset, xf, c) {
  var p = b2Math.MulX(xf, this.m_p);
  var l = -(b2Math.Dot(normal, p) - offset);
  if(l < -this.m_radius + Number.MIN_VALUE) {
    return 0
  }
  if(l > this.m_radius) {
    c.SetV(p);
    return Math.PI * this.m_radius * this.m_radius
  }
  var r2 = this.m_radius * this.m_radius;
  var l2 = l * l;
  var area = r2 * (Math.asin(l / this.m_radius) + Math.PI / 2) + l * Math.sqrt(r2 - l2);
  var com = -2 / 3 * Math.pow(r2 - l2, 1.5) / area;
  c.x = p.x + normal.x * com;
  c.y = p.y + normal.y * com;
  return area
};
b2CircleShape.prototype.GetLocalPosition = function() {
  return this.m_p
};
b2CircleShape.prototype.SetLocalPosition = function(position) {
  this.m_p.SetV(position)
};
b2CircleShape.prototype.GetRadius = function() {
  return this.m_radius
};
b2CircleShape.prototype.SetRadius = function(radius) {
  this.m_radius = radius
};
b2CircleShape.prototype.m_p = new b2Vec2;var b2Joint = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Joint.prototype.__constructor = function(def) {
  b2Settings.b2Assert(def.bodyA != def.bodyB);
  this.m_type = def.type;
  this.m_prev = null;
  this.m_next = null;
  this.m_bodyA = def.bodyA;
  this.m_bodyB = def.bodyB;
  this.m_collideConnected = def.collideConnected;
  this.m_islandFlag = false;
  this.m_userData = def.userData
};
b2Joint.prototype.__varz = function() {
  this.m_edgeA = new b2JointEdge;
  this.m_edgeB = new b2JointEdge;
  this.m_localCenterA = new b2Vec2;
  this.m_localCenterB = new b2Vec2
};
b2Joint.Create = function(def, allocator) {
  var joint = null;
  switch(def.type) {
    case b2Joint.e_distanceJoint:
      joint = new b2DistanceJoint(def);
      break;
    case b2Joint.e_mouseJoint:
      joint = new b2MouseJoint(def);
      break;
    case b2Joint.e_prismaticJoint:
      joint = new b2PrismaticJoint(def);
      break;
    case b2Joint.e_revoluteJoint:
      joint = new b2RevoluteJoint(def);
      break;
    case b2Joint.e_pulleyJoint:
      joint = new b2PulleyJoint(def);
      break;
    case b2Joint.e_gearJoint:
      joint = new b2GearJoint(def);
      break;
    case b2Joint.e_lineJoint:
      joint = new b2LineJoint(def);
      break;
    case b2Joint.e_weldJoint:
      joint = new b2WeldJoint(def);
      break;
    case b2Joint.e_frictionJoint:
      joint = new b2FrictionJoint(def);
      break;
    default:
      break
  }
  return joint
};
b2Joint.Destroy = function(joint, allocator) {
};
b2Joint.e_unknownJoint = 0;
b2Joint.e_revoluteJoint = 1;
b2Joint.e_prismaticJoint = 2;
b2Joint.e_distanceJoint = 3;
b2Joint.e_pulleyJoint = 4;
b2Joint.e_mouseJoint = 5;
b2Joint.e_gearJoint = 6;
b2Joint.e_lineJoint = 7;
b2Joint.e_weldJoint = 8;
b2Joint.e_frictionJoint = 9;
b2Joint.e_inactiveLimit = 0;
b2Joint.e_atLowerLimit = 1;
b2Joint.e_atUpperLimit = 2;
b2Joint.e_equalLimits = 3;
b2Joint.prototype.InitVelocityConstraints = function(step) {
};
b2Joint.prototype.SolveVelocityConstraints = function(step) {
};
b2Joint.prototype.FinalizeVelocityConstraints = function() {
};
b2Joint.prototype.SolvePositionConstraints = function(baumgarte) {
  return false
};
b2Joint.prototype.GetType = function() {
  return this.m_type
};
b2Joint.prototype.GetAnchorA = function() {
  return null
};
b2Joint.prototype.GetAnchorB = function() {
  return null
};
b2Joint.prototype.GetReactionForce = function(inv_dt) {
  return null
};
b2Joint.prototype.GetReactionTorque = function(inv_dt) {
  return 0
};
b2Joint.prototype.GetBodyA = function() {
  return this.m_bodyA
};
b2Joint.prototype.GetBodyB = function() {
  return this.m_bodyB
};
b2Joint.prototype.GetNext = function() {
  return this.m_next
};
b2Joint.prototype.GetUserData = function() {
  return this.m_userData
};
b2Joint.prototype.SetUserData = function(data) {
  this.m_userData = data
};
b2Joint.prototype.IsActive = function() {
  return this.m_bodyA.IsActive() && this.m_bodyB.IsActive()
};
b2Joint.prototype.m_type = 0;
b2Joint.prototype.m_prev = null;
b2Joint.prototype.m_next = null;
b2Joint.prototype.m_edgeA = new b2JointEdge;
b2Joint.prototype.m_edgeB = new b2JointEdge;
b2Joint.prototype.m_bodyA = null;
b2Joint.prototype.m_bodyB = null;
b2Joint.prototype.m_islandFlag = null;
b2Joint.prototype.m_collideConnected = null;
b2Joint.prototype.m_userData = null;
b2Joint.prototype.m_localCenterA = new b2Vec2;
b2Joint.prototype.m_localCenterB = new b2Vec2;
b2Joint.prototype.m_invMassA = null;
b2Joint.prototype.m_invMassB = null;
b2Joint.prototype.m_invIA = null;
b2Joint.prototype.m_invIB = null;var b2LineJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2LineJoint.prototype, b2Joint.prototype);
b2LineJoint.prototype._super = b2Joint.prototype;
b2LineJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  var tMat;
  var tX;
  var tY;
  this.m_localAnchor1.SetV(def.localAnchorA);
  this.m_localAnchor2.SetV(def.localAnchorB);
  this.m_localXAxis1.SetV(def.localAxisA);
  this.m_localYAxis1.x = -this.m_localXAxis1.y;
  this.m_localYAxis1.y = this.m_localXAxis1.x;
  this.m_impulse.SetZero();
  this.m_motorMass = 0;
  this.m_motorImpulse = 0;
  this.m_lowerTranslation = def.lowerTranslation;
  this.m_upperTranslation = def.upperTranslation;
  this.m_maxMotorForce = def.maxMotorForce;
  this.m_motorSpeed = def.motorSpeed;
  this.m_enableLimit = def.enableLimit;
  this.m_enableMotor = def.enableMotor;
  this.m_limitState = b2Joint.e_inactiveLimit;
  this.m_axis.SetZero();
  this.m_perp.SetZero()
};
b2LineJoint.prototype.__varz = function() {
  this.m_localAnchor1 = new b2Vec2;
  this.m_localAnchor2 = new b2Vec2;
  this.m_localXAxis1 = new b2Vec2;
  this.m_localYAxis1 = new b2Vec2;
  this.m_axis = new b2Vec2;
  this.m_perp = new b2Vec2;
  this.m_K = new b2Mat22;
  this.m_impulse = new b2Vec2
};
b2LineJoint.prototype.InitVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  var tX;
  this.m_localCenterA.SetV(bA.GetLocalCenter());
  this.m_localCenterB.SetV(bB.GetLocalCenter());
  var xf1 = bA.GetTransform();
  var xf2 = bB.GetTransform();
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
  var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
  tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
  var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
  var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
  this.m_invMassA = bA.m_invMass;
  this.m_invMassB = bB.m_invMass;
  this.m_invIA = bA.m_invI;
  this.m_invIB = bB.m_invI;
  this.m_axis.SetV(b2Math.MulMV(xf1.R, this.m_localXAxis1));
  this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
  this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
  this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2;
  this.m_motorMass = this.m_motorMass > Number.MIN_VALUE ? 1 / this.m_motorMass : 0;
  this.m_perp.SetV(b2Math.MulMV(xf1.R, this.m_localYAxis1));
  this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
  this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
  var m1 = this.m_invMassA;
  var m2 = this.m_invMassB;
  var i1 = this.m_invIA;
  var i2 = this.m_invIB;
  this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
  this.m_K.col1.y = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
  this.m_K.col2.x = this.m_K.col1.y;
  this.m_K.col2.y = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
  if(this.m_enableLimit) {
    var jointTransition = this.m_axis.x * dX + this.m_axis.y * dY;
    if(b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * b2Settings.b2_linearSlop) {
      this.m_limitState = b2Joint.e_equalLimits
    }else {
      if(jointTransition <= this.m_lowerTranslation) {
        if(this.m_limitState != b2Joint.e_atLowerLimit) {
          this.m_limitState = b2Joint.e_atLowerLimit;
          this.m_impulse.y = 0
        }
      }else {
        if(jointTransition >= this.m_upperTranslation) {
          if(this.m_limitState != b2Joint.e_atUpperLimit) {
            this.m_limitState = b2Joint.e_atUpperLimit;
            this.m_impulse.y = 0
          }
        }else {
          this.m_limitState = b2Joint.e_inactiveLimit;
          this.m_impulse.y = 0
        }
      }
    }
  }else {
    this.m_limitState = b2Joint.e_inactiveLimit
  }
  if(this.m_enableMotor == false) {
    this.m_motorImpulse = 0
  }
  if(step.warmStarting) {
    this.m_impulse.x *= step.dtRatio;
    this.m_impulse.y *= step.dtRatio;
    this.m_motorImpulse *= step.dtRatio;
    var PX = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x;
    var PY = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y;
    var L1 = this.m_impulse.x * this.m_s1 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a1;
    var L2 = this.m_impulse.x * this.m_s2 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a2;
    bA.m_linearVelocity.x -= this.m_invMassA * PX;
    bA.m_linearVelocity.y -= this.m_invMassA * PY;
    bA.m_angularVelocity -= this.m_invIA * L1;
    bB.m_linearVelocity.x += this.m_invMassB * PX;
    bB.m_linearVelocity.y += this.m_invMassB * PY;
    bB.m_angularVelocity += this.m_invIB * L2
  }else {
    this.m_impulse.SetZero();
    this.m_motorImpulse = 0
  }
};
b2LineJoint.prototype.SolveVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var v1 = bA.m_linearVelocity;
  var w1 = bA.m_angularVelocity;
  var v2 = bB.m_linearVelocity;
  var w2 = bB.m_angularVelocity;
  var PX;
  var PY;
  var L1;
  var L2;
  if(this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
    var Cdot = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
    var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);
    var oldImpulse = this.m_motorImpulse;
    var maxImpulse = step.dt * this.m_maxMotorForce;
    this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);
    impulse = this.m_motorImpulse - oldImpulse;
    PX = impulse * this.m_axis.x;
    PY = impulse * this.m_axis.y;
    L1 = impulse * this.m_a1;
    L2 = impulse * this.m_a2;
    v1.x -= this.m_invMassA * PX;
    v1.y -= this.m_invMassA * PY;
    w1 -= this.m_invIA * L1;
    v2.x += this.m_invMassB * PX;
    v2.y += this.m_invMassB * PY;
    w2 += this.m_invIB * L2
  }
  var Cdot1 = this.m_perp.x * (v2.x - v1.x) + this.m_perp.y * (v2.y - v1.y) + this.m_s2 * w2 - this.m_s1 * w1;
  if(this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
    var Cdot2 = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
    var f1 = this.m_impulse.Copy();
    var df = this.m_K.Solve(new b2Vec2, -Cdot1, -Cdot2);
    this.m_impulse.Add(df);
    if(this.m_limitState == b2Joint.e_atLowerLimit) {
      this.m_impulse.y = b2Math.Max(this.m_impulse.y, 0)
    }else {
      if(this.m_limitState == b2Joint.e_atUpperLimit) {
        this.m_impulse.y = b2Math.Min(this.m_impulse.y, 0)
      }
    }
    var b = -Cdot1 - (this.m_impulse.y - f1.y) * this.m_K.col2.x;
    var f2r;
    if(this.m_K.col1.x != 0) {
      f2r = b / this.m_K.col1.x + f1.x
    }else {
      f2r = f1.x
    }
    this.m_impulse.x = f2r;
    df.x = this.m_impulse.x - f1.x;
    df.y = this.m_impulse.y - f1.y;
    PX = df.x * this.m_perp.x + df.y * this.m_axis.x;
    PY = df.x * this.m_perp.y + df.y * this.m_axis.y;
    L1 = df.x * this.m_s1 + df.y * this.m_a1;
    L2 = df.x * this.m_s2 + df.y * this.m_a2;
    v1.x -= this.m_invMassA * PX;
    v1.y -= this.m_invMassA * PY;
    w1 -= this.m_invIA * L1;
    v2.x += this.m_invMassB * PX;
    v2.y += this.m_invMassB * PY;
    w2 += this.m_invIB * L2
  }else {
    var df2;
    if(this.m_K.col1.x != 0) {
      df2 = -Cdot1 / this.m_K.col1.x
    }else {
      df2 = 0
    }
    this.m_impulse.x += df2;
    PX = df2 * this.m_perp.x;
    PY = df2 * this.m_perp.y;
    L1 = df2 * this.m_s1;
    L2 = df2 * this.m_s2;
    v1.x -= this.m_invMassA * PX;
    v1.y -= this.m_invMassA * PY;
    w1 -= this.m_invIA * L1;
    v2.x += this.m_invMassB * PX;
    v2.y += this.m_invMassB * PY;
    w2 += this.m_invIB * L2
  }
  bA.m_linearVelocity.SetV(v1);
  bA.m_angularVelocity = w1;
  bB.m_linearVelocity.SetV(v2);
  bB.m_angularVelocity = w2
};
b2LineJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  var limitC;
  var oldLimitImpulse;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var c1 = bA.m_sweep.c;
  var a1 = bA.m_sweep.a;
  var c2 = bB.m_sweep.c;
  var a2 = bB.m_sweep.a;
  var tMat;
  var tX;
  var m1;
  var m2;
  var i1;
  var i2;
  var linearError = 0;
  var angularError = 0;
  var active = false;
  var C2 = 0;
  var R1 = b2Mat22.FromAngle(a1);
  var R2 = b2Mat22.FromAngle(a2);
  tMat = R1;
  var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
  var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
  tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = R2;
  var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
  var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var dX = c2.x + r2X - c1.x - r1X;
  var dY = c2.y + r2Y - c1.y - r1Y;
  if(this.m_enableLimit) {
    this.m_axis = b2Math.MulMV(R1, this.m_localXAxis1);
    this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
    this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
    var translation = this.m_axis.x * dX + this.m_axis.y * dY;
    if(b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * b2Settings.b2_linearSlop) {
      C2 = b2Math.Clamp(translation, -b2Settings.b2_maxLinearCorrection, b2Settings.b2_maxLinearCorrection);
      linearError = b2Math.Abs(translation);
      active = true
    }else {
      if(translation <= this.m_lowerTranslation) {
        C2 = b2Math.Clamp(translation - this.m_lowerTranslation + b2Settings.b2_linearSlop, -b2Settings.b2_maxLinearCorrection, 0);
        linearError = this.m_lowerTranslation - translation;
        active = true
      }else {
        if(translation >= this.m_upperTranslation) {
          C2 = b2Math.Clamp(translation - this.m_upperTranslation + b2Settings.b2_linearSlop, 0, b2Settings.b2_maxLinearCorrection);
          linearError = translation - this.m_upperTranslation;
          active = true
        }
      }
    }
  }
  this.m_perp = b2Math.MulMV(R1, this.m_localYAxis1);
  this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
  this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
  var impulse = new b2Vec2;
  var C1 = this.m_perp.x * dX + this.m_perp.y * dY;
  linearError = b2Math.Max(linearError, b2Math.Abs(C1));
  angularError = 0;
  if(active) {
    m1 = this.m_invMassA;
    m2 = this.m_invMassB;
    i1 = this.m_invIA;
    i2 = this.m_invIB;
    this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
    this.m_K.col1.y = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
    this.m_K.col2.x = this.m_K.col1.y;
    this.m_K.col2.y = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
    this.m_K.Solve(impulse, -C1, -C2)
  }else {
    m1 = this.m_invMassA;
    m2 = this.m_invMassB;
    i1 = this.m_invIA;
    i2 = this.m_invIB;
    var k11 = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
    var impulse1;
    if(k11 != 0) {
      impulse1 = -C1 / k11
    }else {
      impulse1 = 0
    }
    impulse.x = impulse1;
    impulse.y = 0
  }
  var PX = impulse.x * this.m_perp.x + impulse.y * this.m_axis.x;
  var PY = impulse.x * this.m_perp.y + impulse.y * this.m_axis.y;
  var L1 = impulse.x * this.m_s1 + impulse.y * this.m_a1;
  var L2 = impulse.x * this.m_s2 + impulse.y * this.m_a2;
  c1.x -= this.m_invMassA * PX;
  c1.y -= this.m_invMassA * PY;
  a1 -= this.m_invIA * L1;
  c2.x += this.m_invMassB * PX;
  c2.y += this.m_invMassB * PY;
  a2 += this.m_invIB * L2;
  bA.m_sweep.a = a1;
  bB.m_sweep.a = a2;
  bA.SynchronizeTransform();
  bB.SynchronizeTransform();
  return linearError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop
};
b2LineJoint.prototype.GetAnchorA = function() {
  return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
};
b2LineJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
};
b2LineJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x), inv_dt * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y))
};
b2LineJoint.prototype.GetReactionTorque = function(inv_dt) {
  return inv_dt * this.m_impulse.y
};
b2LineJoint.prototype.GetJointTranslation = function() {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  var p1 = bA.GetWorldPoint(this.m_localAnchor1);
  var p2 = bB.GetWorldPoint(this.m_localAnchor2);
  var dX = p2.x - p1.x;
  var dY = p2.y - p1.y;
  var axis = bA.GetWorldVector(this.m_localXAxis1);
  var translation = axis.x * dX + axis.y * dY;
  return translation
};
b2LineJoint.prototype.GetJointSpeed = function() {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var p1X = bA.m_sweep.c.x + r1X;
  var p1Y = bA.m_sweep.c.y + r1Y;
  var p2X = bB.m_sweep.c.x + r2X;
  var p2Y = bB.m_sweep.c.y + r2Y;
  var dX = p2X - p1X;
  var dY = p2Y - p1Y;
  var axis = bA.GetWorldVector(this.m_localXAxis1);
  var v1 = bA.m_linearVelocity;
  var v2 = bB.m_linearVelocity;
  var w1 = bA.m_angularVelocity;
  var w2 = bB.m_angularVelocity;
  var speed = dX * -w1 * axis.y + dY * w1 * axis.x + (axis.x * (v2.x + -w2 * r2Y - v1.x - -w1 * r1Y) + axis.y * (v2.y + w2 * r2X - v1.y - w1 * r1X));
  return speed
};
b2LineJoint.prototype.IsLimitEnabled = function() {
  return this.m_enableLimit
};
b2LineJoint.prototype.EnableLimit = function(flag) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_enableLimit = flag
};
b2LineJoint.prototype.GetLowerLimit = function() {
  return this.m_lowerTranslation
};
b2LineJoint.prototype.GetUpperLimit = function() {
  return this.m_upperTranslation
};
b2LineJoint.prototype.SetLimits = function(lower, upper) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_lowerTranslation = lower;
  this.m_upperTranslation = upper
};
b2LineJoint.prototype.IsMotorEnabled = function() {
  return this.m_enableMotor
};
b2LineJoint.prototype.EnableMotor = function(flag) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_enableMotor = flag
};
b2LineJoint.prototype.SetMotorSpeed = function(speed) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_motorSpeed = speed
};
b2LineJoint.prototype.GetMotorSpeed = function() {
  return this.m_motorSpeed
};
b2LineJoint.prototype.SetMaxMotorForce = function(force) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_maxMotorForce = force
};
b2LineJoint.prototype.GetMaxMotorForce = function() {
  return this.m_maxMotorForce
};
b2LineJoint.prototype.GetMotorForce = function() {
  return this.m_motorImpulse
};
b2LineJoint.prototype.m_localAnchor1 = new b2Vec2;
b2LineJoint.prototype.m_localAnchor2 = new b2Vec2;
b2LineJoint.prototype.m_localXAxis1 = new b2Vec2;
b2LineJoint.prototype.m_localYAxis1 = new b2Vec2;
b2LineJoint.prototype.m_axis = new b2Vec2;
b2LineJoint.prototype.m_perp = new b2Vec2;
b2LineJoint.prototype.m_s1 = null;
b2LineJoint.prototype.m_s2 = null;
b2LineJoint.prototype.m_a1 = null;
b2LineJoint.prototype.m_a2 = null;
b2LineJoint.prototype.m_K = new b2Mat22;
b2LineJoint.prototype.m_impulse = new b2Vec2;
b2LineJoint.prototype.m_motorMass = null;
b2LineJoint.prototype.m_motorImpulse = null;
b2LineJoint.prototype.m_lowerTranslation = null;
b2LineJoint.prototype.m_upperTranslation = null;
b2LineJoint.prototype.m_maxMotorForce = null;
b2LineJoint.prototype.m_motorSpeed = null;
b2LineJoint.prototype.m_enableLimit = null;
b2LineJoint.prototype.m_enableMotor = null;
b2LineJoint.prototype.m_limitState = 0;var b2ContactSolver = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactSolver.prototype.__constructor = function() {
};
b2ContactSolver.prototype.__varz = function() {
  this.m_step = new b2TimeStep;
  this.m_constraints = new Array
};
b2ContactSolver.s_worldManifold = new b2WorldManifold;
b2ContactSolver.s_psm = new b2PositionSolverManifold;
b2ContactSolver.prototype.Initialize = function(step, contacts, contactCount, allocator) {
  var contact;
  this.m_step.Set(step);
  this.m_allocator = allocator;
  var i = 0;
  var tVec;
  var tMat;
  this.m_constraintCount = contactCount;
  while(this.m_constraints.length < this.m_constraintCount) {
    this.m_constraints[this.m_constraints.length] = new b2ContactConstraint
  }
  for(i = 0;i < contactCount;++i) {
    contact = contacts[i];
    var fixtureA = contact.m_fixtureA;
    var fixtureB = contact.m_fixtureB;
    var shapeA = fixtureA.m_shape;
    var shapeB = fixtureB.m_shape;
    var radiusA = shapeA.m_radius;
    var radiusB = shapeB.m_radius;
    var bodyA = fixtureA.m_body;
    var bodyB = fixtureB.m_body;
    var manifold = contact.GetManifold();
    var friction = b2Settings.b2MixFriction(fixtureA.GetFriction(), fixtureB.GetFriction());
    var restitution = b2Settings.b2MixRestitution(fixtureA.GetRestitution(), fixtureB.GetRestitution());
    var vAX = bodyA.m_linearVelocity.x;
    var vAY = bodyA.m_linearVelocity.y;
    var vBX = bodyB.m_linearVelocity.x;
    var vBY = bodyB.m_linearVelocity.y;
    var wA = bodyA.m_angularVelocity;
    var wB = bodyB.m_angularVelocity;
    b2Settings.b2Assert(manifold.m_pointCount > 0);
    b2ContactSolver.s_worldManifold.Initialize(manifold, bodyA.m_xf, radiusA, bodyB.m_xf, radiusB);
    var normalX = b2ContactSolver.s_worldManifold.m_normal.x;
    var normalY = b2ContactSolver.s_worldManifold.m_normal.y;
    var cc = this.m_constraints[i];
    cc.bodyA = bodyA;
    cc.bodyB = bodyB;
    cc.manifold = manifold;
    cc.normal.x = normalX;
    cc.normal.y = normalY;
    cc.pointCount = manifold.m_pointCount;
    cc.friction = friction;
    cc.restitution = restitution;
    cc.localPlaneNormal.x = manifold.m_localPlaneNormal.x;
    cc.localPlaneNormal.y = manifold.m_localPlaneNormal.y;
    cc.localPoint.x = manifold.m_localPoint.x;
    cc.localPoint.y = manifold.m_localPoint.y;
    cc.radius = radiusA + radiusB;
    cc.type = manifold.m_type;
    for(var k = 0;k < cc.pointCount;++k) {
      var cp = manifold.m_points[k];
      var ccp = cc.points[k];
      ccp.normalImpulse = cp.m_normalImpulse;
      ccp.tangentImpulse = cp.m_tangentImpulse;
      ccp.localPoint.SetV(cp.m_localPoint);
      var rAX = ccp.rA.x = b2ContactSolver.s_worldManifold.m_points[k].x - bodyA.m_sweep.c.x;
      var rAY = ccp.rA.y = b2ContactSolver.s_worldManifold.m_points[k].y - bodyA.m_sweep.c.y;
      var rBX = ccp.rB.x = b2ContactSolver.s_worldManifold.m_points[k].x - bodyB.m_sweep.c.x;
      var rBY = ccp.rB.y = b2ContactSolver.s_worldManifold.m_points[k].y - bodyB.m_sweep.c.y;
      var rnA = rAX * normalY - rAY * normalX;
      var rnB = rBX * normalY - rBY * normalX;
      rnA *= rnA;
      rnB *= rnB;
      var kNormal = bodyA.m_invMass + bodyB.m_invMass + bodyA.m_invI * rnA + bodyB.m_invI * rnB;
      ccp.normalMass = 1 / kNormal;
      var kEqualized = bodyA.m_mass * bodyA.m_invMass + bodyB.m_mass * bodyB.m_invMass;
      kEqualized += bodyA.m_mass * bodyA.m_invI * rnA + bodyB.m_mass * bodyB.m_invI * rnB;
      ccp.equalizedMass = 1 / kEqualized;
      var tangentX = normalY;
      var tangentY = -normalX;
      var rtA = rAX * tangentY - rAY * tangentX;
      var rtB = rBX * tangentY - rBY * tangentX;
      rtA *= rtA;
      rtB *= rtB;
      var kTangent = bodyA.m_invMass + bodyB.m_invMass + bodyA.m_invI * rtA + bodyB.m_invI * rtB;
      ccp.tangentMass = 1 / kTangent;
      ccp.velocityBias = 0;
      var tX = vBX + -wB * rBY - vAX - -wA * rAY;
      var tY = vBY + wB * rBX - vAY - wA * rAX;
      var vRel = cc.normal.x * tX + cc.normal.y * tY;
      if(vRel < -b2Settings.b2_velocityThreshold) {
        ccp.velocityBias += -cc.restitution * vRel
      }
    }
    if(cc.pointCount == 2) {
      var ccp1 = cc.points[0];
      var ccp2 = cc.points[1];
      var invMassA = bodyA.m_invMass;
      var invIA = bodyA.m_invI;
      var invMassB = bodyB.m_invMass;
      var invIB = bodyB.m_invI;
      var rn1A = ccp1.rA.x * normalY - ccp1.rA.y * normalX;
      var rn1B = ccp1.rB.x * normalY - ccp1.rB.y * normalX;
      var rn2A = ccp2.rA.x * normalY - ccp2.rA.y * normalX;
      var rn2B = ccp2.rB.x * normalY - ccp2.rB.y * normalX;
      var k11 = invMassA + invMassB + invIA * rn1A * rn1A + invIB * rn1B * rn1B;
      var k22 = invMassA + invMassB + invIA * rn2A * rn2A + invIB * rn2B * rn2B;
      var k12 = invMassA + invMassB + invIA * rn1A * rn2A + invIB * rn1B * rn2B;
      var k_maxConditionNumber = 100;
      if(k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12)) {
        cc.K.col1.Set(k11, k12);
        cc.K.col2.Set(k12, k22);
        cc.K.GetInverse(cc.normalMass)
      }else {
        cc.pointCount = 1
      }
    }
  }
};
b2ContactSolver.prototype.InitVelocityConstraints = function(step) {
  var tVec;
  var tVec2;
  var tMat;
  for(var i = 0;i < this.m_constraintCount;++i) {
    var c = this.m_constraints[i];
    var bodyA = c.bodyA;
    var bodyB = c.bodyB;
    var invMassA = bodyA.m_invMass;
    var invIA = bodyA.m_invI;
    var invMassB = bodyB.m_invMass;
    var invIB = bodyB.m_invI;
    var normalX = c.normal.x;
    var normalY = c.normal.y;
    var tangentX = normalY;
    var tangentY = -normalX;
    var tX;
    var j = 0;
    var tCount = 0;
    if(step.warmStarting) {
      tCount = c.pointCount;
      for(j = 0;j < tCount;++j) {
        var ccp = c.points[j];
        ccp.normalImpulse *= step.dtRatio;
        ccp.tangentImpulse *= step.dtRatio;
        var PX = ccp.normalImpulse * normalX + ccp.tangentImpulse * tangentX;
        var PY = ccp.normalImpulse * normalY + ccp.tangentImpulse * tangentY;
        bodyA.m_angularVelocity -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
        bodyA.m_linearVelocity.x -= invMassA * PX;
        bodyA.m_linearVelocity.y -= invMassA * PY;
        bodyB.m_angularVelocity += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
        bodyB.m_linearVelocity.x += invMassB * PX;
        bodyB.m_linearVelocity.y += invMassB * PY
      }
    }else {
      tCount = c.pointCount;
      for(j = 0;j < tCount;++j) {
        var ccp2 = c.points[j];
        ccp2.normalImpulse = 0;
        ccp2.tangentImpulse = 0
      }
    }
  }
};
b2ContactSolver.prototype.SolveVelocityConstraints = function() {
  var j = 0;
  var ccp;
  var rAX;
  var rAY;
  var rBX;
  var rBY;
  var dvX;
  var dvY;
  var vn;
  var vt;
  var lambda;
  var maxFriction;
  var newImpulse;
  var PX;
  var PY;
  var dX;
  var dY;
  var P1X;
  var P1Y;
  var P2X;
  var P2Y;
  var tMat;
  var tVec;
  for(var i = 0;i < this.m_constraintCount;++i) {
    var c = this.m_constraints[i];
    var bodyA = c.bodyA;
    var bodyB = c.bodyB;
    var wA = bodyA.m_angularVelocity;
    var wB = bodyB.m_angularVelocity;
    var vA = bodyA.m_linearVelocity;
    var vB = bodyB.m_linearVelocity;
    var invMassA = bodyA.m_invMass;
    var invIA = bodyA.m_invI;
    var invMassB = bodyB.m_invMass;
    var invIB = bodyB.m_invI;
    var normalX = c.normal.x;
    var normalY = c.normal.y;
    var tangentX = normalY;
    var tangentY = -normalX;
    var friction = c.friction;
    var tX;
    for(j = 0;j < c.pointCount;j++) {
      ccp = c.points[j];
      dvX = vB.x - wB * ccp.rB.y - vA.x + wA * ccp.rA.y;
      dvY = vB.y + wB * ccp.rB.x - vA.y - wA * ccp.rA.x;
      vt = dvX * tangentX + dvY * tangentY;
      lambda = ccp.tangentMass * -vt;
      maxFriction = friction * ccp.normalImpulse;
      newImpulse = b2Math.Clamp(ccp.tangentImpulse + lambda, -maxFriction, maxFriction);
      lambda = newImpulse - ccp.tangentImpulse;
      PX = lambda * tangentX;
      PY = lambda * tangentY;
      vA.x -= invMassA * PX;
      vA.y -= invMassA * PY;
      wA -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
      vB.x += invMassB * PX;
      vB.y += invMassB * PY;
      wB += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
      ccp.tangentImpulse = newImpulse
    }
    var tCount = c.pointCount;
    if(c.pointCount == 1) {
      ccp = c.points[0];
      dvX = vB.x + -wB * ccp.rB.y - vA.x - -wA * ccp.rA.y;
      dvY = vB.y + wB * ccp.rB.x - vA.y - wA * ccp.rA.x;
      vn = dvX * normalX + dvY * normalY;
      lambda = -ccp.normalMass * (vn - ccp.velocityBias);
      newImpulse = ccp.normalImpulse + lambda;
      newImpulse = newImpulse > 0 ? newImpulse : 0;
      lambda = newImpulse - ccp.normalImpulse;
      PX = lambda * normalX;
      PY = lambda * normalY;
      vA.x -= invMassA * PX;
      vA.y -= invMassA * PY;
      wA -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
      vB.x += invMassB * PX;
      vB.y += invMassB * PY;
      wB += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
      ccp.normalImpulse = newImpulse
    }else {
      var cp1 = c.points[0];
      var cp2 = c.points[1];
      var aX = cp1.normalImpulse;
      var aY = cp2.normalImpulse;
      var dv1X = vB.x - wB * cp1.rB.y - vA.x + wA * cp1.rA.y;
      var dv1Y = vB.y + wB * cp1.rB.x - vA.y - wA * cp1.rA.x;
      var dv2X = vB.x - wB * cp2.rB.y - vA.x + wA * cp2.rA.y;
      var dv2Y = vB.y + wB * cp2.rB.x - vA.y - wA * cp2.rA.x;
      var vn1 = dv1X * normalX + dv1Y * normalY;
      var vn2 = dv2X * normalX + dv2Y * normalY;
      var bX = vn1 - cp1.velocityBias;
      var bY = vn2 - cp2.velocityBias;
      tMat = c.K;
      bX -= tMat.col1.x * aX + tMat.col2.x * aY;
      bY -= tMat.col1.y * aX + tMat.col2.y * aY;
      var k_errorTol = 0.0010;
      for(;;) {
        tMat = c.normalMass;
        var xX = -(tMat.col1.x * bX + tMat.col2.x * bY);
        var xY = -(tMat.col1.y * bX + tMat.col2.y * bY);
        if(xX >= 0 && xY >= 0) {
          dX = xX - aX;
          dY = xY - aY;
          P1X = dX * normalX;
          P1Y = dX * normalY;
          P2X = dY * normalX;
          P2Y = dY * normalY;
          vA.x -= invMassA * (P1X + P2X);
          vA.y -= invMassA * (P1Y + P2Y);
          wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
          vB.x += invMassB * (P1X + P2X);
          vB.y += invMassB * (P1Y + P2Y);
          wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
          cp1.normalImpulse = xX;
          cp2.normalImpulse = xY;
          break
        }
        xX = -cp1.normalMass * bX;
        xY = 0;
        vn1 = 0;
        vn2 = c.K.col1.y * xX + bY;
        if(xX >= 0 && vn2 >= 0) {
          dX = xX - aX;
          dY = xY - aY;
          P1X = dX * normalX;
          P1Y = dX * normalY;
          P2X = dY * normalX;
          P2Y = dY * normalY;
          vA.x -= invMassA * (P1X + P2X);
          vA.y -= invMassA * (P1Y + P2Y);
          wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
          vB.x += invMassB * (P1X + P2X);
          vB.y += invMassB * (P1Y + P2Y);
          wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
          cp1.normalImpulse = xX;
          cp2.normalImpulse = xY;
          break
        }
        xX = 0;
        xY = -cp2.normalMass * bY;
        vn1 = c.K.col2.x * xY + bX;
        vn2 = 0;
        if(xY >= 0 && vn1 >= 0) {
          dX = xX - aX;
          dY = xY - aY;
          P1X = dX * normalX;
          P1Y = dX * normalY;
          P2X = dY * normalX;
          P2Y = dY * normalY;
          vA.x -= invMassA * (P1X + P2X);
          vA.y -= invMassA * (P1Y + P2Y);
          wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
          vB.x += invMassB * (P1X + P2X);
          vB.y += invMassB * (P1Y + P2Y);
          wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
          cp1.normalImpulse = xX;
          cp2.normalImpulse = xY;
          break
        }
        xX = 0;
        xY = 0;
        vn1 = bX;
        vn2 = bY;
        if(vn1 >= 0 && vn2 >= 0) {
          dX = xX - aX;
          dY = xY - aY;
          P1X = dX * normalX;
          P1Y = dX * normalY;
          P2X = dY * normalX;
          P2Y = dY * normalY;
          vA.x -= invMassA * (P1X + P2X);
          vA.y -= invMassA * (P1Y + P2Y);
          wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
          vB.x += invMassB * (P1X + P2X);
          vB.y += invMassB * (P1Y + P2Y);
          wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
          cp1.normalImpulse = xX;
          cp2.normalImpulse = xY;
          break
        }
        break
      }
    }
    bodyA.m_angularVelocity = wA;
    bodyB.m_angularVelocity = wB
  }
};
b2ContactSolver.prototype.FinalizeVelocityConstraints = function() {
  for(var i = 0;i < this.m_constraintCount;++i) {
    var c = this.m_constraints[i];
    var m = c.manifold;
    for(var j = 0;j < c.pointCount;++j) {
      var point1 = m.m_points[j];
      var point2 = c.points[j];
      point1.m_normalImpulse = point2.normalImpulse;
      point1.m_tangentImpulse = point2.tangentImpulse
    }
  }
};
b2ContactSolver.prototype.SolvePositionConstraints = function(baumgarte) {
  var minSeparation = 0;
  for(var i = 0;i < this.m_constraintCount;i++) {
    var c = this.m_constraints[i];
    var bodyA = c.bodyA;
    var bodyB = c.bodyB;
    var invMassA = bodyA.m_mass * bodyA.m_invMass;
    var invIA = bodyA.m_mass * bodyA.m_invI;
    var invMassB = bodyB.m_mass * bodyB.m_invMass;
    var invIB = bodyB.m_mass * bodyB.m_invI;
    b2ContactSolver.s_psm.Initialize(c);
    var normal = b2ContactSolver.s_psm.m_normal;
    for(var j = 0;j < c.pointCount;j++) {
      var ccp = c.points[j];
      var point = b2ContactSolver.s_psm.m_points[j];
      var separation = b2ContactSolver.s_psm.m_separations[j];
      var rAX = point.x - bodyA.m_sweep.c.x;
      var rAY = point.y - bodyA.m_sweep.c.y;
      var rBX = point.x - bodyB.m_sweep.c.x;
      var rBY = point.y - bodyB.m_sweep.c.y;
      minSeparation = minSeparation < separation ? minSeparation : separation;
      var C = b2Math.Clamp(baumgarte * (separation + b2Settings.b2_linearSlop), -b2Settings.b2_maxLinearCorrection, 0);
      var impulse = -ccp.equalizedMass * C;
      var PX = impulse * normal.x;
      var PY = impulse * normal.y;
      bodyA.m_sweep.c.x -= invMassA * PX;
      bodyA.m_sweep.c.y -= invMassA * PY;
      bodyA.m_sweep.a -= invIA * (rAX * PY - rAY * PX);
      bodyA.SynchronizeTransform();
      bodyB.m_sweep.c.x += invMassB * PX;
      bodyB.m_sweep.c.y += invMassB * PY;
      bodyB.m_sweep.a += invIB * (rBX * PY - rBY * PX);
      bodyB.SynchronizeTransform()
    }
  }
  return minSeparation > -1.5 * b2Settings.b2_linearSlop
};
b2ContactSolver.prototype.m_step = new b2TimeStep;
b2ContactSolver.prototype.m_allocator = null;
b2ContactSolver.prototype.m_constraints = new Array;
b2ContactSolver.prototype.m_constraintCount = 0;var b2Simplex = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Simplex.prototype.__constructor = function() {
  this.m_vertices[0] = this.m_v1;
  this.m_vertices[1] = this.m_v2;
  this.m_vertices[2] = this.m_v3
};
b2Simplex.prototype.__varz = function() {
  this.m_v1 = new b2SimplexVertex;
  this.m_v2 = new b2SimplexVertex;
  this.m_v3 = new b2SimplexVertex;
  this.m_vertices = new Array(3)
};
b2Simplex.prototype.ReadCache = function(cache, proxyA, transformA, proxyB, transformB) {
  b2Settings.b2Assert(0 <= cache.count && cache.count <= 3);
  var wALocal;
  var wBLocal;
  this.m_count = cache.count;
  var vertices = this.m_vertices;
  for(var i = 0;i < this.m_count;i++) {
    var v = vertices[i];
    v.indexA = cache.indexA[i];
    v.indexB = cache.indexB[i];
    wALocal = proxyA.GetVertex(v.indexA);
    wBLocal = proxyB.GetVertex(v.indexB);
    v.wA = b2Math.MulX(transformA, wALocal);
    v.wB = b2Math.MulX(transformB, wBLocal);
    v.w = b2Math.SubtractVV(v.wB, v.wA);
    v.a = 0
  }
  if(this.m_count > 1) {
    var metric1 = cache.metric;
    var metric2 = this.GetMetric();
    if(metric2 < 0.5 * metric1 || 2 * metric1 < metric2 || metric2 < Number.MIN_VALUE) {
      this.m_count = 0
    }
  }
  if(this.m_count == 0) {
    v = vertices[0];
    v.indexA = 0;
    v.indexB = 0;
    wALocal = proxyA.GetVertex(0);
    wBLocal = proxyB.GetVertex(0);
    v.wA = b2Math.MulX(transformA, wALocal);
    v.wB = b2Math.MulX(transformB, wBLocal);
    v.w = b2Math.SubtractVV(v.wB, v.wA);
    this.m_count = 1
  }
};
b2Simplex.prototype.WriteCache = function(cache) {
  cache.metric = this.GetMetric();
  cache.count = parseInt(this.m_count);
  var vertices = this.m_vertices;
  for(var i = 0;i < this.m_count;i++) {
    cache.indexA[i] = parseInt(vertices[i].indexA);
    cache.indexB[i] = parseInt(vertices[i].indexB)
  }
};
b2Simplex.prototype.GetSearchDirection = function() {
  switch(this.m_count) {
    case 1:
      return this.m_v1.w.GetNegative();
    case 2:
      var e12 = b2Math.SubtractVV(this.m_v2.w, this.m_v1.w);
      var sgn = b2Math.CrossVV(e12, this.m_v1.w.GetNegative());
      if(sgn > 0) {
        return b2Math.CrossFV(1, e12)
      }else {
        return b2Math.CrossVF(e12, 1)
      }
    ;
    default:
      b2Settings.b2Assert(false);
      return new b2Vec2
  }
};
b2Simplex.prototype.GetClosestPoint = function() {
  switch(this.m_count) {
    case 0:
      b2Settings.b2Assert(false);
      return new b2Vec2;
    case 1:
      return this.m_v1.w;
    case 2:
      return new b2Vec2(this.m_v1.a * this.m_v1.w.x + this.m_v2.a * this.m_v2.w.x, this.m_v1.a * this.m_v1.w.y + this.m_v2.a * this.m_v2.w.y);
    default:
      b2Settings.b2Assert(false);
      return new b2Vec2
  }
};
b2Simplex.prototype.GetWitnessPoints = function(pA, pB) {
  switch(this.m_count) {
    case 0:
      b2Settings.b2Assert(false);
      break;
    case 1:
      pA.SetV(this.m_v1.wA);
      pB.SetV(this.m_v1.wB);
      break;
    case 2:
      pA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x;
      pA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y;
      pB.x = this.m_v1.a * this.m_v1.wB.x + this.m_v2.a * this.m_v2.wB.x;
      pB.y = this.m_v1.a * this.m_v1.wB.y + this.m_v2.a * this.m_v2.wB.y;
      break;
    case 3:
      pB.x = pA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x + this.m_v3.a * this.m_v3.wA.x;
      pB.y = pA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y + this.m_v3.a * this.m_v3.wA.y;
      break;
    default:
      b2Settings.b2Assert(false);
      break
  }
};
b2Simplex.prototype.GetMetric = function() {
  switch(this.m_count) {
    case 0:
      b2Settings.b2Assert(false);
      return 0;
    case 1:
      return 0;
    case 2:
      return b2Math.SubtractVV(this.m_v1.w, this.m_v2.w).Length();
    case 3:
      return b2Math.CrossVV(b2Math.SubtractVV(this.m_v2.w, this.m_v1.w), b2Math.SubtractVV(this.m_v3.w, this.m_v1.w));
    default:
      b2Settings.b2Assert(false);
      return 0
  }
};
b2Simplex.prototype.Solve2 = function() {
  var w1 = this.m_v1.w;
  var w2 = this.m_v2.w;
  var e12 = b2Math.SubtractVV(w2, w1);
  var d12_2 = -(w1.x * e12.x + w1.y * e12.y);
  if(d12_2 <= 0) {
    this.m_v1.a = 1;
    this.m_count = 1;
    return
  }
  var d12_1 = w2.x * e12.x + w2.y * e12.y;
  if(d12_1 <= 0) {
    this.m_v2.a = 1;
    this.m_count = 1;
    this.m_v1.Set(this.m_v2);
    return
  }
  var inv_d12 = 1 / (d12_1 + d12_2);
  this.m_v1.a = d12_1 * inv_d12;
  this.m_v2.a = d12_2 * inv_d12;
  this.m_count = 2
};
b2Simplex.prototype.Solve3 = function() {
  var w1 = this.m_v1.w;
  var w2 = this.m_v2.w;
  var w3 = this.m_v3.w;
  var e12 = b2Math.SubtractVV(w2, w1);
  var w1e12 = b2Math.Dot(w1, e12);
  var w2e12 = b2Math.Dot(w2, e12);
  var d12_1 = w2e12;
  var d12_2 = -w1e12;
  var e13 = b2Math.SubtractVV(w3, w1);
  var w1e13 = b2Math.Dot(w1, e13);
  var w3e13 = b2Math.Dot(w3, e13);
  var d13_1 = w3e13;
  var d13_2 = -w1e13;
  var e23 = b2Math.SubtractVV(w3, w2);
  var w2e23 = b2Math.Dot(w2, e23);
  var w3e23 = b2Math.Dot(w3, e23);
  var d23_1 = w3e23;
  var d23_2 = -w2e23;
  var n123 = b2Math.CrossVV(e12, e13);
  var d123_1 = n123 * b2Math.CrossVV(w2, w3);
  var d123_2 = n123 * b2Math.CrossVV(w3, w1);
  var d123_3 = n123 * b2Math.CrossVV(w1, w2);
  if(d12_2 <= 0 && d13_2 <= 0) {
    this.m_v1.a = 1;
    this.m_count = 1;
    return
  }
  if(d12_1 > 0 && d12_2 > 0 && d123_3 <= 0) {
    var inv_d12 = 1 / (d12_1 + d12_2);
    this.m_v1.a = d12_1 * inv_d12;
    this.m_v2.a = d12_2 * inv_d12;
    this.m_count = 2;
    return
  }
  if(d13_1 > 0 && d13_2 > 0 && d123_2 <= 0) {
    var inv_d13 = 1 / (d13_1 + d13_2);
    this.m_v1.a = d13_1 * inv_d13;
    this.m_v3.a = d13_2 * inv_d13;
    this.m_count = 2;
    this.m_v2.Set(this.m_v3);
    return
  }
  if(d12_1 <= 0 && d23_2 <= 0) {
    this.m_v2.a = 1;
    this.m_count = 1;
    this.m_v1.Set(this.m_v2);
    return
  }
  if(d13_1 <= 0 && d23_1 <= 0) {
    this.m_v3.a = 1;
    this.m_count = 1;
    this.m_v1.Set(this.m_v3);
    return
  }
  if(d23_1 > 0 && d23_2 > 0 && d123_1 <= 0) {
    var inv_d23 = 1 / (d23_1 + d23_2);
    this.m_v2.a = d23_1 * inv_d23;
    this.m_v3.a = d23_2 * inv_d23;
    this.m_count = 2;
    this.m_v1.Set(this.m_v3);
    return
  }
  var inv_d123 = 1 / (d123_1 + d123_2 + d123_3);
  this.m_v1.a = d123_1 * inv_d123;
  this.m_v2.a = d123_2 * inv_d123;
  this.m_v3.a = d123_3 * inv_d123;
  this.m_count = 3
};
b2Simplex.prototype.m_v1 = new b2SimplexVertex;
b2Simplex.prototype.m_v2 = new b2SimplexVertex;
b2Simplex.prototype.m_v3 = new b2SimplexVertex;
b2Simplex.prototype.m_vertices = new Array(3);
b2Simplex.prototype.m_count = 0;var b2WeldJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2WeldJoint.prototype, b2Joint.prototype);
b2WeldJoint.prototype._super = b2Joint.prototype;
b2WeldJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  this.m_localAnchorA.SetV(def.localAnchorA);
  this.m_localAnchorB.SetV(def.localAnchorB);
  this.m_referenceAngle = def.referenceAngle;
  this.m_impulse.SetZero();
  this.m_mass = new b2Mat33
};
b2WeldJoint.prototype.__varz = function() {
  this.m_localAnchorA = new b2Vec2;
  this.m_localAnchorB = new b2Vec2;
  this.m_impulse = new b2Vec3;
  this.m_mass = new b2Mat33
};
b2WeldJoint.prototype.InitVelocityConstraints = function(step) {
  var tMat;
  var tX;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  tMat = bA.m_xf.R;
  var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
  var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
  tX = tMat.col1.x * rAX + tMat.col2.x * rAY;
  rAY = tMat.col1.y * rAX + tMat.col2.y * rAY;
  rAX = tX;
  tMat = bB.m_xf.R;
  var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
  var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * rBX + tMat.col2.x * rBY;
  rBY = tMat.col1.y * rBX + tMat.col2.y * rBY;
  rBX = tX;
  var mA = bA.m_invMass;
  var mB = bB.m_invMass;
  var iA = bA.m_invI;
  var iB = bB.m_invI;
  this.m_mass.col1.x = mA + mB + rAY * rAY * iA + rBY * rBY * iB;
  this.m_mass.col2.x = -rAY * rAX * iA - rBY * rBX * iB;
  this.m_mass.col3.x = -rAY * iA - rBY * iB;
  this.m_mass.col1.y = this.m_mass.col2.x;
  this.m_mass.col2.y = mA + mB + rAX * rAX * iA + rBX * rBX * iB;
  this.m_mass.col3.y = rAX * iA + rBX * iB;
  this.m_mass.col1.z = this.m_mass.col3.x;
  this.m_mass.col2.z = this.m_mass.col3.y;
  this.m_mass.col3.z = iA + iB;
  if(step.warmStarting) {
    this.m_impulse.x *= step.dtRatio;
    this.m_impulse.y *= step.dtRatio;
    this.m_impulse.z *= step.dtRatio;
    bA.m_linearVelocity.x -= mA * this.m_impulse.x;
    bA.m_linearVelocity.y -= mA * this.m_impulse.y;
    bA.m_angularVelocity -= iA * (rAX * this.m_impulse.y - rAY * this.m_impulse.x + this.m_impulse.z);
    bB.m_linearVelocity.x += mB * this.m_impulse.x;
    bB.m_linearVelocity.y += mB * this.m_impulse.y;
    bB.m_angularVelocity += iB * (rBX * this.m_impulse.y - rBY * this.m_impulse.x + this.m_impulse.z)
  }else {
    this.m_impulse.SetZero()
  }
};
b2WeldJoint.prototype.SolveVelocityConstraints = function(step) {
  var tMat;
  var tX;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var vA = bA.m_linearVelocity;
  var wA = bA.m_angularVelocity;
  var vB = bB.m_linearVelocity;
  var wB = bB.m_angularVelocity;
  var mA = bA.m_invMass;
  var mB = bB.m_invMass;
  var iA = bA.m_invI;
  var iB = bB.m_invI;
  tMat = bA.m_xf.R;
  var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
  var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
  tX = tMat.col1.x * rAX + tMat.col2.x * rAY;
  rAY = tMat.col1.y * rAX + tMat.col2.y * rAY;
  rAX = tX;
  tMat = bB.m_xf.R;
  var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
  var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * rBX + tMat.col2.x * rBY;
  rBY = tMat.col1.y * rBX + tMat.col2.y * rBY;
  rBX = tX;
  var Cdot1X = vB.x - wB * rBY - vA.x + wA * rAY;
  var Cdot1Y = vB.y + wB * rBX - vA.y - wA * rAX;
  var Cdot2 = wB - wA;
  var impulse = new b2Vec3;
  this.m_mass.Solve33(impulse, -Cdot1X, -Cdot1Y, -Cdot2);
  this.m_impulse.Add(impulse);
  vA.x -= mA * impulse.x;
  vA.y -= mA * impulse.y;
  wA -= iA * (rAX * impulse.y - rAY * impulse.x + impulse.z);
  vB.x += mB * impulse.x;
  vB.y += mB * impulse.y;
  wB += iB * (rBX * impulse.y - rBY * impulse.x + impulse.z);
  bA.m_angularVelocity = wA;
  bB.m_angularVelocity = wB
};
b2WeldJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  var tMat;
  var tX;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  tMat = bA.m_xf.R;
  var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
  var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
  tX = tMat.col1.x * rAX + tMat.col2.x * rAY;
  rAY = tMat.col1.y * rAX + tMat.col2.y * rAY;
  rAX = tX;
  tMat = bB.m_xf.R;
  var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
  var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * rBX + tMat.col2.x * rBY;
  rBY = tMat.col1.y * rBX + tMat.col2.y * rBY;
  rBX = tX;
  var mA = bA.m_invMass;
  var mB = bB.m_invMass;
  var iA = bA.m_invI;
  var iB = bB.m_invI;
  var C1X = bB.m_sweep.c.x + rBX - bA.m_sweep.c.x - rAX;
  var C1Y = bB.m_sweep.c.y + rBY - bA.m_sweep.c.y - rAY;
  var C2 = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
  var k_allowedStretch = 10 * b2Settings.b2_linearSlop;
  var positionError = Math.sqrt(C1X * C1X + C1Y * C1Y);
  var angularError = b2Math.Abs(C2);
  if(positionError > k_allowedStretch) {
    iA *= 1;
    iB *= 1
  }
  this.m_mass.col1.x = mA + mB + rAY * rAY * iA + rBY * rBY * iB;
  this.m_mass.col2.x = -rAY * rAX * iA - rBY * rBX * iB;
  this.m_mass.col3.x = -rAY * iA - rBY * iB;
  this.m_mass.col1.y = this.m_mass.col2.x;
  this.m_mass.col2.y = mA + mB + rAX * rAX * iA + rBX * rBX * iB;
  this.m_mass.col3.y = rAX * iA + rBX * iB;
  this.m_mass.col1.z = this.m_mass.col3.x;
  this.m_mass.col2.z = this.m_mass.col3.y;
  this.m_mass.col3.z = iA + iB;
  var impulse = new b2Vec3;
  this.m_mass.Solve33(impulse, -C1X, -C1Y, -C2);
  bA.m_sweep.c.x -= mA * impulse.x;
  bA.m_sweep.c.y -= mA * impulse.y;
  bA.m_sweep.a -= iA * (rAX * impulse.y - rAY * impulse.x + impulse.z);
  bB.m_sweep.c.x += mB * impulse.x;
  bB.m_sweep.c.y += mB * impulse.y;
  bB.m_sweep.a += iB * (rBX * impulse.y - rBY * impulse.x + impulse.z);
  bA.SynchronizeTransform();
  bB.SynchronizeTransform();
  return positionError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop
};
b2WeldJoint.prototype.GetAnchorA = function() {
  return this.m_bodyA.GetWorldPoint(this.m_localAnchorA)
};
b2WeldJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchorB)
};
b2WeldJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y)
};
b2WeldJoint.prototype.GetReactionTorque = function(inv_dt) {
  return inv_dt * this.m_impulse.z
};
b2WeldJoint.prototype.m_localAnchorA = new b2Vec2;
b2WeldJoint.prototype.m_localAnchorB = new b2Vec2;
b2WeldJoint.prototype.m_referenceAngle = null;
b2WeldJoint.prototype.m_impulse = new b2Vec3;
b2WeldJoint.prototype.m_mass = new b2Mat33;var b2Math = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Math.prototype.__constructor = function() {
};
b2Math.prototype.__varz = function() {
};
b2Math.IsValid = function(x) {
  return isFinite(x)
};
b2Math.Dot = function(a, b) {
  return a.x * b.x + a.y * b.y
};
b2Math.CrossVV = function(a, b) {
  return a.x * b.y - a.y * b.x
};
b2Math.CrossVF = function(a, s) {
  var v = new b2Vec2(s * a.y, -s * a.x);
  return v
};
b2Math.CrossFV = function(s, a) {
  var v = new b2Vec2(-s * a.y, s * a.x);
  return v
};
b2Math.MulMV = function(A, v) {
  var u = new b2Vec2(A.col1.x * v.x + A.col2.x * v.y, A.col1.y * v.x + A.col2.y * v.y);
  return u
};
b2Math.MulTMV = function(A, v) {
  var u = new b2Vec2(b2Math.Dot(v, A.col1), b2Math.Dot(v, A.col2));
  return u
};
b2Math.MulX = function(T, v) {
  var a = b2Math.MulMV(T.R, v);
  a.x += T.position.x;
  a.y += T.position.y;
  return a
};
b2Math.MulXT = function(T, v) {
  var a = b2Math.SubtractVV(v, T.position);
  var tX = a.x * T.R.col1.x + a.y * T.R.col1.y;
  a.y = a.x * T.R.col2.x + a.y * T.R.col2.y;
  a.x = tX;
  return a
};
b2Math.AddVV = function(a, b) {
  var v = new b2Vec2(a.x + b.x, a.y + b.y);
  return v
};
b2Math.SubtractVV = function(a, b) {
  var v = new b2Vec2(a.x - b.x, a.y - b.y);
  return v
};
b2Math.Distance = function(a, b) {
  var cX = a.x - b.x;
  var cY = a.y - b.y;
  return Math.sqrt(cX * cX + cY * cY)
};
b2Math.DistanceSquared = function(a, b) {
  var cX = a.x - b.x;
  var cY = a.y - b.y;
  return cX * cX + cY * cY
};
b2Math.MulFV = function(s, a) {
  var v = new b2Vec2(s * a.x, s * a.y);
  return v
};
b2Math.AddMM = function(A, B) {
  var C = b2Mat22.FromVV(b2Math.AddVV(A.col1, B.col1), b2Math.AddVV(A.col2, B.col2));
  return C
};
b2Math.MulMM = function(A, B) {
  var C = b2Mat22.FromVV(b2Math.MulMV(A, B.col1), b2Math.MulMV(A, B.col2));
  return C
};
b2Math.MulTMM = function(A, B) {
  var c1 = new b2Vec2(b2Math.Dot(A.col1, B.col1), b2Math.Dot(A.col2, B.col1));
  var c2 = new b2Vec2(b2Math.Dot(A.col1, B.col2), b2Math.Dot(A.col2, B.col2));
  var C = b2Mat22.FromVV(c1, c2);
  return C
};
b2Math.Abs = function(a) {
  return a > 0 ? a : -a
};
b2Math.AbsV = function(a) {
  var b = new b2Vec2(b2Math.Abs(a.x), b2Math.Abs(a.y));
  return b
};
b2Math.AbsM = function(A) {
  var B = b2Mat22.FromVV(b2Math.AbsV(A.col1), b2Math.AbsV(A.col2));
  return B
};
b2Math.Min = function(a, b) {
  return a < b ? a : b
};
b2Math.MinV = function(a, b) {
  var c = new b2Vec2(b2Math.Min(a.x, b.x), b2Math.Min(a.y, b.y));
  return c
};
b2Math.Max = function(a, b) {
  return a > b ? a : b
};
b2Math.MaxV = function(a, b) {
  var c = new b2Vec2(b2Math.Max(a.x, b.x), b2Math.Max(a.y, b.y));
  return c
};
b2Math.Clamp = function(a, low, high) {
  return a < low ? low : a > high ? high : a
};
b2Math.ClampV = function(a, low, high) {
  return b2Math.MaxV(low, b2Math.MinV(a, high))
};
b2Math.Swap = function(a, b) {
  var tmp = a[0];
  a[0] = b[0];
  b[0] = tmp
};
b2Math.Random = function() {
  return Math.random() * 2 - 1
};
b2Math.RandomRange = function(lo, hi) {
  var r = Math.random();
  r = (hi - lo) * r + lo;
  return r
};
b2Math.NextPowerOfTwo = function(x) {
  x |= x >> 1 & 2147483647;
  x |= x >> 2 & 1073741823;
  x |= x >> 4 & 268435455;
  x |= x >> 8 & 16777215;
  x |= x >> 16 & 65535;
  return x + 1
};
b2Math.IsPowerOfTwo = function(x) {
  var result = x > 0 && (x & x - 1) == 0;
  return result
};
b2Math.b2Vec2_zero = new b2Vec2(0, 0);
b2Math.b2Mat22_identity = b2Mat22.FromVV(new b2Vec2(1, 0), new b2Vec2(0, 1));
b2Math.b2Transform_identity = new b2Transform(b2Math.b2Vec2_zero, b2Math.b2Mat22_identity);var b2PulleyJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2PulleyJoint.prototype, b2Joint.prototype);
b2PulleyJoint.prototype._super = b2Joint.prototype;
b2PulleyJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  var tMat;
  var tX;
  var tY;
  this.m_ground = this.m_bodyA.m_world.m_groundBody;
  this.m_groundAnchor1.x = def.groundAnchorA.x - this.m_ground.m_xf.position.x;
  this.m_groundAnchor1.y = def.groundAnchorA.y - this.m_ground.m_xf.position.y;
  this.m_groundAnchor2.x = def.groundAnchorB.x - this.m_ground.m_xf.position.x;
  this.m_groundAnchor2.y = def.groundAnchorB.y - this.m_ground.m_xf.position.y;
  this.m_localAnchor1.SetV(def.localAnchorA);
  this.m_localAnchor2.SetV(def.localAnchorB);
  this.m_ratio = def.ratio;
  this.m_constant = def.lengthA + this.m_ratio * def.lengthB;
  this.m_maxLength1 = b2Math.Min(def.maxLengthA, this.m_constant - this.m_ratio * b2PulleyJoint.b2_minPulleyLength);
  this.m_maxLength2 = b2Math.Min(def.maxLengthB, (this.m_constant - b2PulleyJoint.b2_minPulleyLength) / this.m_ratio);
  this.m_impulse = 0;
  this.m_limitImpulse1 = 0;
  this.m_limitImpulse2 = 0
};
b2PulleyJoint.prototype.__varz = function() {
  this.m_groundAnchor1 = new b2Vec2;
  this.m_groundAnchor2 = new b2Vec2;
  this.m_localAnchor1 = new b2Vec2;
  this.m_localAnchor2 = new b2Vec2;
  this.m_u1 = new b2Vec2;
  this.m_u2 = new b2Vec2
};
b2PulleyJoint.b2_minPulleyLength = 2;
b2PulleyJoint.prototype.InitVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var p1X = bA.m_sweep.c.x + r1X;
  var p1Y = bA.m_sweep.c.y + r1Y;
  var p2X = bB.m_sweep.c.x + r2X;
  var p2Y = bB.m_sweep.c.y + r2Y;
  var s1X = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
  var s1Y = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
  var s2X = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
  var s2Y = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
  this.m_u1.Set(p1X - s1X, p1Y - s1Y);
  this.m_u2.Set(p2X - s2X, p2Y - s2Y);
  var length1 = this.m_u1.Length();
  var length2 = this.m_u2.Length();
  if(length1 > b2Settings.b2_linearSlop) {
    this.m_u1.Multiply(1 / length1)
  }else {
    this.m_u1.SetZero()
  }
  if(length2 > b2Settings.b2_linearSlop) {
    this.m_u2.Multiply(1 / length2)
  }else {
    this.m_u2.SetZero()
  }
  var C = this.m_constant - length1 - this.m_ratio * length2;
  if(C > 0) {
    this.m_state = b2Joint.e_inactiveLimit;
    this.m_impulse = 0
  }else {
    this.m_state = b2Joint.e_atUpperLimit
  }
  if(length1 < this.m_maxLength1) {
    this.m_limitState1 = b2Joint.e_inactiveLimit;
    this.m_limitImpulse1 = 0
  }else {
    this.m_limitState1 = b2Joint.e_atUpperLimit
  }
  if(length2 < this.m_maxLength2) {
    this.m_limitState2 = b2Joint.e_inactiveLimit;
    this.m_limitImpulse2 = 0
  }else {
    this.m_limitState2 = b2Joint.e_atUpperLimit
  }
  var cr1u1 = r1X * this.m_u1.y - r1Y * this.m_u1.x;
  var cr2u2 = r2X * this.m_u2.y - r2Y * this.m_u2.x;
  this.m_limitMass1 = bA.m_invMass + bA.m_invI * cr1u1 * cr1u1;
  this.m_limitMass2 = bB.m_invMass + bB.m_invI * cr2u2 * cr2u2;
  this.m_pulleyMass = this.m_limitMass1 + this.m_ratio * this.m_ratio * this.m_limitMass2;
  this.m_limitMass1 = 1 / this.m_limitMass1;
  this.m_limitMass2 = 1 / this.m_limitMass2;
  this.m_pulleyMass = 1 / this.m_pulleyMass;
  if(step.warmStarting) {
    this.m_impulse *= step.dtRatio;
    this.m_limitImpulse1 *= step.dtRatio;
    this.m_limitImpulse2 *= step.dtRatio;
    var P1X = (-this.m_impulse - this.m_limitImpulse1) * this.m_u1.x;
    var P1Y = (-this.m_impulse - this.m_limitImpulse1) * this.m_u1.y;
    var P2X = (-this.m_ratio * this.m_impulse - this.m_limitImpulse2) * this.m_u2.x;
    var P2Y = (-this.m_ratio * this.m_impulse - this.m_limitImpulse2) * this.m_u2.y;
    bA.m_linearVelocity.x += bA.m_invMass * P1X;
    bA.m_linearVelocity.y += bA.m_invMass * P1Y;
    bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
    bB.m_linearVelocity.x += bB.m_invMass * P2X;
    bB.m_linearVelocity.y += bB.m_invMass * P2Y;
    bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X)
  }else {
    this.m_impulse = 0;
    this.m_limitImpulse1 = 0;
    this.m_limitImpulse2 = 0
  }
};
b2PulleyJoint.prototype.SolveVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var v1X;
  var v1Y;
  var v2X;
  var v2Y;
  var P1X;
  var P1Y;
  var P2X;
  var P2Y;
  var Cdot;
  var impulse;
  var oldImpulse;
  if(this.m_state == b2Joint.e_atUpperLimit) {
    v1X = bA.m_linearVelocity.x + -bA.m_angularVelocity * r1Y;
    v1Y = bA.m_linearVelocity.y + bA.m_angularVelocity * r1X;
    v2X = bB.m_linearVelocity.x + -bB.m_angularVelocity * r2Y;
    v2Y = bB.m_linearVelocity.y + bB.m_angularVelocity * r2X;
    Cdot = -(this.m_u1.x * v1X + this.m_u1.y * v1Y) - this.m_ratio * (this.m_u2.x * v2X + this.m_u2.y * v2Y);
    impulse = this.m_pulleyMass * -Cdot;
    oldImpulse = this.m_impulse;
    this.m_impulse = b2Math.Max(0, this.m_impulse + impulse);
    impulse = this.m_impulse - oldImpulse;
    P1X = -impulse * this.m_u1.x;
    P1Y = -impulse * this.m_u1.y;
    P2X = -this.m_ratio * impulse * this.m_u2.x;
    P2Y = -this.m_ratio * impulse * this.m_u2.y;
    bA.m_linearVelocity.x += bA.m_invMass * P1X;
    bA.m_linearVelocity.y += bA.m_invMass * P1Y;
    bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
    bB.m_linearVelocity.x += bB.m_invMass * P2X;
    bB.m_linearVelocity.y += bB.m_invMass * P2Y;
    bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X)
  }
  if(this.m_limitState1 == b2Joint.e_atUpperLimit) {
    v1X = bA.m_linearVelocity.x + -bA.m_angularVelocity * r1Y;
    v1Y = bA.m_linearVelocity.y + bA.m_angularVelocity * r1X;
    Cdot = -(this.m_u1.x * v1X + this.m_u1.y * v1Y);
    impulse = -this.m_limitMass1 * Cdot;
    oldImpulse = this.m_limitImpulse1;
    this.m_limitImpulse1 = b2Math.Max(0, this.m_limitImpulse1 + impulse);
    impulse = this.m_limitImpulse1 - oldImpulse;
    P1X = -impulse * this.m_u1.x;
    P1Y = -impulse * this.m_u1.y;
    bA.m_linearVelocity.x += bA.m_invMass * P1X;
    bA.m_linearVelocity.y += bA.m_invMass * P1Y;
    bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X)
  }
  if(this.m_limitState2 == b2Joint.e_atUpperLimit) {
    v2X = bB.m_linearVelocity.x + -bB.m_angularVelocity * r2Y;
    v2Y = bB.m_linearVelocity.y + bB.m_angularVelocity * r2X;
    Cdot = -(this.m_u2.x * v2X + this.m_u2.y * v2Y);
    impulse = -this.m_limitMass2 * Cdot;
    oldImpulse = this.m_limitImpulse2;
    this.m_limitImpulse2 = b2Math.Max(0, this.m_limitImpulse2 + impulse);
    impulse = this.m_limitImpulse2 - oldImpulse;
    P2X = -impulse * this.m_u2.x;
    P2Y = -impulse * this.m_u2.y;
    bB.m_linearVelocity.x += bB.m_invMass * P2X;
    bB.m_linearVelocity.y += bB.m_invMass * P2Y;
    bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X)
  }
};
b2PulleyJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  var s1X = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
  var s1Y = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
  var s2X = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
  var s2Y = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
  var r1X;
  var r1Y;
  var r2X;
  var r2Y;
  var p1X;
  var p1Y;
  var p2X;
  var p2Y;
  var length1;
  var length2;
  var C;
  var impulse;
  var oldImpulse;
  var oldLimitPositionImpulse;
  var tX;
  var linearError = 0;
  if(this.m_state == b2Joint.e_atUpperLimit) {
    tMat = bA.m_xf.R;
    r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
    r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
    tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
    r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
    r1X = tX;
    tMat = bB.m_xf.R;
    r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
    r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
    tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
    r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
    r2X = tX;
    p1X = bA.m_sweep.c.x + r1X;
    p1Y = bA.m_sweep.c.y + r1Y;
    p2X = bB.m_sweep.c.x + r2X;
    p2Y = bB.m_sweep.c.y + r2Y;
    this.m_u1.Set(p1X - s1X, p1Y - s1Y);
    this.m_u2.Set(p2X - s2X, p2Y - s2Y);
    length1 = this.m_u1.Length();
    length2 = this.m_u2.Length();
    if(length1 > b2Settings.b2_linearSlop) {
      this.m_u1.Multiply(1 / length1)
    }else {
      this.m_u1.SetZero()
    }
    if(length2 > b2Settings.b2_linearSlop) {
      this.m_u2.Multiply(1 / length2)
    }else {
      this.m_u2.SetZero()
    }
    C = this.m_constant - length1 - this.m_ratio * length2;
    linearError = b2Math.Max(linearError, -C);
    C = b2Math.Clamp(C + b2Settings.b2_linearSlop, -b2Settings.b2_maxLinearCorrection, 0);
    impulse = -this.m_pulleyMass * C;
    p1X = -impulse * this.m_u1.x;
    p1Y = -impulse * this.m_u1.y;
    p2X = -this.m_ratio * impulse * this.m_u2.x;
    p2Y = -this.m_ratio * impulse * this.m_u2.y;
    bA.m_sweep.c.x += bA.m_invMass * p1X;
    bA.m_sweep.c.y += bA.m_invMass * p1Y;
    bA.m_sweep.a += bA.m_invI * (r1X * p1Y - r1Y * p1X);
    bB.m_sweep.c.x += bB.m_invMass * p2X;
    bB.m_sweep.c.y += bB.m_invMass * p2Y;
    bB.m_sweep.a += bB.m_invI * (r2X * p2Y - r2Y * p2X);
    bA.SynchronizeTransform();
    bB.SynchronizeTransform()
  }
  if(this.m_limitState1 == b2Joint.e_atUpperLimit) {
    tMat = bA.m_xf.R;
    r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
    r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
    tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
    r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
    r1X = tX;
    p1X = bA.m_sweep.c.x + r1X;
    p1Y = bA.m_sweep.c.y + r1Y;
    this.m_u1.Set(p1X - s1X, p1Y - s1Y);
    length1 = this.m_u1.Length();
    if(length1 > b2Settings.b2_linearSlop) {
      this.m_u1.x *= 1 / length1;
      this.m_u1.y *= 1 / length1
    }else {
      this.m_u1.SetZero()
    }
    C = this.m_maxLength1 - length1;
    linearError = b2Math.Max(linearError, -C);
    C = b2Math.Clamp(C + b2Settings.b2_linearSlop, -b2Settings.b2_maxLinearCorrection, 0);
    impulse = -this.m_limitMass1 * C;
    p1X = -impulse * this.m_u1.x;
    p1Y = -impulse * this.m_u1.y;
    bA.m_sweep.c.x += bA.m_invMass * p1X;
    bA.m_sweep.c.y += bA.m_invMass * p1Y;
    bA.m_sweep.a += bA.m_invI * (r1X * p1Y - r1Y * p1X);
    bA.SynchronizeTransform()
  }
  if(this.m_limitState2 == b2Joint.e_atUpperLimit) {
    tMat = bB.m_xf.R;
    r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
    r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
    tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
    r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
    r2X = tX;
    p2X = bB.m_sweep.c.x + r2X;
    p2Y = bB.m_sweep.c.y + r2Y;
    this.m_u2.Set(p2X - s2X, p2Y - s2Y);
    length2 = this.m_u2.Length();
    if(length2 > b2Settings.b2_linearSlop) {
      this.m_u2.x *= 1 / length2;
      this.m_u2.y *= 1 / length2
    }else {
      this.m_u2.SetZero()
    }
    C = this.m_maxLength2 - length2;
    linearError = b2Math.Max(linearError, -C);
    C = b2Math.Clamp(C + b2Settings.b2_linearSlop, -b2Settings.b2_maxLinearCorrection, 0);
    impulse = -this.m_limitMass2 * C;
    p2X = -impulse * this.m_u2.x;
    p2Y = -impulse * this.m_u2.y;
    bB.m_sweep.c.x += bB.m_invMass * p2X;
    bB.m_sweep.c.y += bB.m_invMass * p2Y;
    bB.m_sweep.a += bB.m_invI * (r2X * p2Y - r2Y * p2X);
    bB.SynchronizeTransform()
  }
  return linearError < b2Settings.b2_linearSlop
};
b2PulleyJoint.prototype.GetAnchorA = function() {
  return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
};
b2PulleyJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
};
b2PulleyJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * this.m_impulse * this.m_u2.x, inv_dt * this.m_impulse * this.m_u2.y)
};
b2PulleyJoint.prototype.GetReactionTorque = function(inv_dt) {
  return 0
};
b2PulleyJoint.prototype.GetGroundAnchorA = function() {
  var a = this.m_ground.m_xf.position.Copy();
  a.Add(this.m_groundAnchor1);
  return a
};
b2PulleyJoint.prototype.GetGroundAnchorB = function() {
  var a = this.m_ground.m_xf.position.Copy();
  a.Add(this.m_groundAnchor2);
  return a
};
b2PulleyJoint.prototype.GetLength1 = function() {
  var p = this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
  var sX = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
  var sY = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
  var dX = p.x - sX;
  var dY = p.y - sY;
  return Math.sqrt(dX * dX + dY * dY)
};
b2PulleyJoint.prototype.GetLength2 = function() {
  var p = this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
  var sX = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
  var sY = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
  var dX = p.x - sX;
  var dY = p.y - sY;
  return Math.sqrt(dX * dX + dY * dY)
};
b2PulleyJoint.prototype.GetRatio = function() {
  return this.m_ratio
};
b2PulleyJoint.prototype.m_ground = null;
b2PulleyJoint.prototype.m_groundAnchor1 = new b2Vec2;
b2PulleyJoint.prototype.m_groundAnchor2 = new b2Vec2;
b2PulleyJoint.prototype.m_localAnchor1 = new b2Vec2;
b2PulleyJoint.prototype.m_localAnchor2 = new b2Vec2;
b2PulleyJoint.prototype.m_u1 = new b2Vec2;
b2PulleyJoint.prototype.m_u2 = new b2Vec2;
b2PulleyJoint.prototype.m_constant = null;
b2PulleyJoint.prototype.m_ratio = null;
b2PulleyJoint.prototype.m_maxLength1 = null;
b2PulleyJoint.prototype.m_maxLength2 = null;
b2PulleyJoint.prototype.m_pulleyMass = null;
b2PulleyJoint.prototype.m_limitMass1 = null;
b2PulleyJoint.prototype.m_limitMass2 = null;
b2PulleyJoint.prototype.m_impulse = null;
b2PulleyJoint.prototype.m_limitImpulse1 = null;
b2PulleyJoint.prototype.m_limitImpulse2 = null;
b2PulleyJoint.prototype.m_state = 0;
b2PulleyJoint.prototype.m_limitState1 = 0;
b2PulleyJoint.prototype.m_limitState2 = 0;var b2PrismaticJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2PrismaticJoint.prototype, b2Joint.prototype);
b2PrismaticJoint.prototype._super = b2Joint.prototype;
b2PrismaticJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  var tMat;
  var tX;
  var tY;
  this.m_localAnchor1.SetV(def.localAnchorA);
  this.m_localAnchor2.SetV(def.localAnchorB);
  this.m_localXAxis1.SetV(def.localAxisA);
  this.m_localYAxis1.x = -this.m_localXAxis1.y;
  this.m_localYAxis1.y = this.m_localXAxis1.x;
  this.m_refAngle = def.referenceAngle;
  this.m_impulse.SetZero();
  this.m_motorMass = 0;
  this.m_motorImpulse = 0;
  this.m_lowerTranslation = def.lowerTranslation;
  this.m_upperTranslation = def.upperTranslation;
  this.m_maxMotorForce = def.maxMotorForce;
  this.m_motorSpeed = def.motorSpeed;
  this.m_enableLimit = def.enableLimit;
  this.m_enableMotor = def.enableMotor;
  this.m_limitState = b2Joint.e_inactiveLimit;
  this.m_axis.SetZero();
  this.m_perp.SetZero()
};
b2PrismaticJoint.prototype.__varz = function() {
  this.m_localAnchor1 = new b2Vec2;
  this.m_localAnchor2 = new b2Vec2;
  this.m_localXAxis1 = new b2Vec2;
  this.m_localYAxis1 = new b2Vec2;
  this.m_axis = new b2Vec2;
  this.m_perp = new b2Vec2;
  this.m_K = new b2Mat33;
  this.m_impulse = new b2Vec3
};
b2PrismaticJoint.prototype.InitVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  var tX;
  this.m_localCenterA.SetV(bA.GetLocalCenter());
  this.m_localCenterB.SetV(bB.GetLocalCenter());
  var xf1 = bA.GetTransform();
  var xf2 = bB.GetTransform();
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
  var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
  tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
  var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
  var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
  this.m_invMassA = bA.m_invMass;
  this.m_invMassB = bB.m_invMass;
  this.m_invIA = bA.m_invI;
  this.m_invIB = bB.m_invI;
  this.m_axis.SetV(b2Math.MulMV(xf1.R, this.m_localXAxis1));
  this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
  this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
  this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2;
  if(this.m_motorMass > Number.MIN_VALUE) {
    this.m_motorMass = 1 / this.m_motorMass
  }
  this.m_perp.SetV(b2Math.MulMV(xf1.R, this.m_localYAxis1));
  this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
  this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
  var m1 = this.m_invMassA;
  var m2 = this.m_invMassB;
  var i1 = this.m_invIA;
  var i2 = this.m_invIB;
  this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
  this.m_K.col1.y = i1 * this.m_s1 + i2 * this.m_s2;
  this.m_K.col1.z = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
  this.m_K.col2.x = this.m_K.col1.y;
  this.m_K.col2.y = i1 + i2;
  this.m_K.col2.z = i1 * this.m_a1 + i2 * this.m_a2;
  this.m_K.col3.x = this.m_K.col1.z;
  this.m_K.col3.y = this.m_K.col2.z;
  this.m_K.col3.z = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
  if(this.m_enableLimit) {
    var jointTransition = this.m_axis.x * dX + this.m_axis.y * dY;
    if(b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * b2Settings.b2_linearSlop) {
      this.m_limitState = b2Joint.e_equalLimits
    }else {
      if(jointTransition <= this.m_lowerTranslation) {
        if(this.m_limitState != b2Joint.e_atLowerLimit) {
          this.m_limitState = b2Joint.e_atLowerLimit;
          this.m_impulse.z = 0
        }
      }else {
        if(jointTransition >= this.m_upperTranslation) {
          if(this.m_limitState != b2Joint.e_atUpperLimit) {
            this.m_limitState = b2Joint.e_atUpperLimit;
            this.m_impulse.z = 0
          }
        }else {
          this.m_limitState = b2Joint.e_inactiveLimit;
          this.m_impulse.z = 0
        }
      }
    }
  }else {
    this.m_limitState = b2Joint.e_inactiveLimit
  }
  if(this.m_enableMotor == false) {
    this.m_motorImpulse = 0
  }
  if(step.warmStarting) {
    this.m_impulse.x *= step.dtRatio;
    this.m_impulse.y *= step.dtRatio;
    this.m_motorImpulse *= step.dtRatio;
    var PX = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x;
    var PY = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y;
    var L1 = this.m_impulse.x * this.m_s1 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1;
    var L2 = this.m_impulse.x * this.m_s2 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;
    bA.m_linearVelocity.x -= this.m_invMassA * PX;
    bA.m_linearVelocity.y -= this.m_invMassA * PY;
    bA.m_angularVelocity -= this.m_invIA * L1;
    bB.m_linearVelocity.x += this.m_invMassB * PX;
    bB.m_linearVelocity.y += this.m_invMassB * PY;
    bB.m_angularVelocity += this.m_invIB * L2
  }else {
    this.m_impulse.SetZero();
    this.m_motorImpulse = 0
  }
};
b2PrismaticJoint.prototype.SolveVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var v1 = bA.m_linearVelocity;
  var w1 = bA.m_angularVelocity;
  var v2 = bB.m_linearVelocity;
  var w2 = bB.m_angularVelocity;
  var PX;
  var PY;
  var L1;
  var L2;
  if(this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
    var Cdot = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
    var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);
    var oldImpulse = this.m_motorImpulse;
    var maxImpulse = step.dt * this.m_maxMotorForce;
    this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);
    impulse = this.m_motorImpulse - oldImpulse;
    PX = impulse * this.m_axis.x;
    PY = impulse * this.m_axis.y;
    L1 = impulse * this.m_a1;
    L2 = impulse * this.m_a2;
    v1.x -= this.m_invMassA * PX;
    v1.y -= this.m_invMassA * PY;
    w1 -= this.m_invIA * L1;
    v2.x += this.m_invMassB * PX;
    v2.y += this.m_invMassB * PY;
    w2 += this.m_invIB * L2
  }
  var Cdot1X = this.m_perp.x * (v2.x - v1.x) + this.m_perp.y * (v2.y - v1.y) + this.m_s2 * w2 - this.m_s1 * w1;
  var Cdot1Y = w2 - w1;
  if(this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
    var Cdot2 = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
    var f1 = this.m_impulse.Copy();
    var df = this.m_K.Solve33(new b2Vec3, -Cdot1X, -Cdot1Y, -Cdot2);
    this.m_impulse.Add(df);
    if(this.m_limitState == b2Joint.e_atLowerLimit) {
      this.m_impulse.z = b2Math.Max(this.m_impulse.z, 0)
    }else {
      if(this.m_limitState == b2Joint.e_atUpperLimit) {
        this.m_impulse.z = b2Math.Min(this.m_impulse.z, 0)
      }
    }
    var bX = -Cdot1X - (this.m_impulse.z - f1.z) * this.m_K.col3.x;
    var bY = -Cdot1Y - (this.m_impulse.z - f1.z) * this.m_K.col3.y;
    var f2r = this.m_K.Solve22(new b2Vec2, bX, bY);
    f2r.x += f1.x;
    f2r.y += f1.y;
    this.m_impulse.x = f2r.x;
    this.m_impulse.y = f2r.y;
    df.x = this.m_impulse.x - f1.x;
    df.y = this.m_impulse.y - f1.y;
    df.z = this.m_impulse.z - f1.z;
    PX = df.x * this.m_perp.x + df.z * this.m_axis.x;
    PY = df.x * this.m_perp.y + df.z * this.m_axis.y;
    L1 = df.x * this.m_s1 + df.y + df.z * this.m_a1;
    L2 = df.x * this.m_s2 + df.y + df.z * this.m_a2;
    v1.x -= this.m_invMassA * PX;
    v1.y -= this.m_invMassA * PY;
    w1 -= this.m_invIA * L1;
    v2.x += this.m_invMassB * PX;
    v2.y += this.m_invMassB * PY;
    w2 += this.m_invIB * L2
  }else {
    var df2 = this.m_K.Solve22(new b2Vec2, -Cdot1X, -Cdot1Y);
    this.m_impulse.x += df2.x;
    this.m_impulse.y += df2.y;
    PX = df2.x * this.m_perp.x;
    PY = df2.x * this.m_perp.y;
    L1 = df2.x * this.m_s1 + df2.y;
    L2 = df2.x * this.m_s2 + df2.y;
    v1.x -= this.m_invMassA * PX;
    v1.y -= this.m_invMassA * PY;
    w1 -= this.m_invIA * L1;
    v2.x += this.m_invMassB * PX;
    v2.y += this.m_invMassB * PY;
    w2 += this.m_invIB * L2
  }
  bA.m_linearVelocity.SetV(v1);
  bA.m_angularVelocity = w1;
  bB.m_linearVelocity.SetV(v2);
  bB.m_angularVelocity = w2
};
b2PrismaticJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  var limitC;
  var oldLimitImpulse;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var c1 = bA.m_sweep.c;
  var a1 = bA.m_sweep.a;
  var c2 = bB.m_sweep.c;
  var a2 = bB.m_sweep.a;
  var tMat;
  var tX;
  var m1;
  var m2;
  var i1;
  var i2;
  var linearError = 0;
  var angularError = 0;
  var active = false;
  var C2 = 0;
  var R1 = b2Mat22.FromAngle(a1);
  var R2 = b2Mat22.FromAngle(a2);
  tMat = R1;
  var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
  var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
  tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = R2;
  var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
  var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var dX = c2.x + r2X - c1.x - r1X;
  var dY = c2.y + r2Y - c1.y - r1Y;
  if(this.m_enableLimit) {
    this.m_axis = b2Math.MulMV(R1, this.m_localXAxis1);
    this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
    this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
    var translation = this.m_axis.x * dX + this.m_axis.y * dY;
    if(b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * b2Settings.b2_linearSlop) {
      C2 = b2Math.Clamp(translation, -b2Settings.b2_maxLinearCorrection, b2Settings.b2_maxLinearCorrection);
      linearError = b2Math.Abs(translation);
      active = true
    }else {
      if(translation <= this.m_lowerTranslation) {
        C2 = b2Math.Clamp(translation - this.m_lowerTranslation + b2Settings.b2_linearSlop, -b2Settings.b2_maxLinearCorrection, 0);
        linearError = this.m_lowerTranslation - translation;
        active = true
      }else {
        if(translation >= this.m_upperTranslation) {
          C2 = b2Math.Clamp(translation - this.m_upperTranslation + b2Settings.b2_linearSlop, 0, b2Settings.b2_maxLinearCorrection);
          linearError = translation - this.m_upperTranslation;
          active = true
        }
      }
    }
  }
  this.m_perp = b2Math.MulMV(R1, this.m_localYAxis1);
  this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
  this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
  var impulse = new b2Vec3;
  var C1X = this.m_perp.x * dX + this.m_perp.y * dY;
  var C1Y = a2 - a1 - this.m_refAngle;
  linearError = b2Math.Max(linearError, b2Math.Abs(C1X));
  angularError = b2Math.Abs(C1Y);
  if(active) {
    m1 = this.m_invMassA;
    m2 = this.m_invMassB;
    i1 = this.m_invIA;
    i2 = this.m_invIB;
    this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
    this.m_K.col1.y = i1 * this.m_s1 + i2 * this.m_s2;
    this.m_K.col1.z = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
    this.m_K.col2.x = this.m_K.col1.y;
    this.m_K.col2.y = i1 + i2;
    this.m_K.col2.z = i1 * this.m_a1 + i2 * this.m_a2;
    this.m_K.col3.x = this.m_K.col1.z;
    this.m_K.col3.y = this.m_K.col2.z;
    this.m_K.col3.z = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
    this.m_K.Solve33(impulse, -C1X, -C1Y, -C2)
  }else {
    m1 = this.m_invMassA;
    m2 = this.m_invMassB;
    i1 = this.m_invIA;
    i2 = this.m_invIB;
    var k11 = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
    var k12 = i1 * this.m_s1 + i2 * this.m_s2;
    var k22 = i1 + i2;
    this.m_K.col1.Set(k11, k12, 0);
    this.m_K.col2.Set(k12, k22, 0);
    var impulse1 = this.m_K.Solve22(new b2Vec2, -C1X, -C1Y);
    impulse.x = impulse1.x;
    impulse.y = impulse1.y;
    impulse.z = 0
  }
  var PX = impulse.x * this.m_perp.x + impulse.z * this.m_axis.x;
  var PY = impulse.x * this.m_perp.y + impulse.z * this.m_axis.y;
  var L1 = impulse.x * this.m_s1 + impulse.y + impulse.z * this.m_a1;
  var L2 = impulse.x * this.m_s2 + impulse.y + impulse.z * this.m_a2;
  c1.x -= this.m_invMassA * PX;
  c1.y -= this.m_invMassA * PY;
  a1 -= this.m_invIA * L1;
  c2.x += this.m_invMassB * PX;
  c2.y += this.m_invMassB * PY;
  a2 += this.m_invIB * L2;
  bA.m_sweep.a = a1;
  bB.m_sweep.a = a2;
  bA.SynchronizeTransform();
  bB.SynchronizeTransform();
  return linearError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop
};
b2PrismaticJoint.prototype.GetAnchorA = function() {
  return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
};
b2PrismaticJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
};
b2PrismaticJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x), inv_dt * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y))
};
b2PrismaticJoint.prototype.GetReactionTorque = function(inv_dt) {
  return inv_dt * this.m_impulse.y
};
b2PrismaticJoint.prototype.GetJointTranslation = function() {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  var p1 = bA.GetWorldPoint(this.m_localAnchor1);
  var p2 = bB.GetWorldPoint(this.m_localAnchor2);
  var dX = p2.x - p1.x;
  var dY = p2.y - p1.y;
  var axis = bA.GetWorldVector(this.m_localXAxis1);
  var translation = axis.x * dX + axis.y * dY;
  return translation
};
b2PrismaticJoint.prototype.GetJointSpeed = function() {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var p1X = bA.m_sweep.c.x + r1X;
  var p1Y = bA.m_sweep.c.y + r1Y;
  var p2X = bB.m_sweep.c.x + r2X;
  var p2Y = bB.m_sweep.c.y + r2Y;
  var dX = p2X - p1X;
  var dY = p2Y - p1Y;
  var axis = bA.GetWorldVector(this.m_localXAxis1);
  var v1 = bA.m_linearVelocity;
  var v2 = bB.m_linearVelocity;
  var w1 = bA.m_angularVelocity;
  var w2 = bB.m_angularVelocity;
  var speed = dX * -w1 * axis.y + dY * w1 * axis.x + (axis.x * (v2.x + -w2 * r2Y - v1.x - -w1 * r1Y) + axis.y * (v2.y + w2 * r2X - v1.y - w1 * r1X));
  return speed
};
b2PrismaticJoint.prototype.IsLimitEnabled = function() {
  return this.m_enableLimit
};
b2PrismaticJoint.prototype.EnableLimit = function(flag) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_enableLimit = flag
};
b2PrismaticJoint.prototype.GetLowerLimit = function() {
  return this.m_lowerTranslation
};
b2PrismaticJoint.prototype.GetUpperLimit = function() {
  return this.m_upperTranslation
};
b2PrismaticJoint.prototype.SetLimits = function(lower, upper) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_lowerTranslation = lower;
  this.m_upperTranslation = upper
};
b2PrismaticJoint.prototype.IsMotorEnabled = function() {
  return this.m_enableMotor
};
b2PrismaticJoint.prototype.EnableMotor = function(flag) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_enableMotor = flag
};
b2PrismaticJoint.prototype.SetMotorSpeed = function(speed) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_motorSpeed = speed
};
b2PrismaticJoint.prototype.GetMotorSpeed = function() {
  return this.m_motorSpeed
};
b2PrismaticJoint.prototype.SetMaxMotorForce = function(force) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_maxMotorForce = force
};
b2PrismaticJoint.prototype.GetMotorForce = function() {
  return this.m_motorImpulse
};
b2PrismaticJoint.prototype.m_localAnchor1 = new b2Vec2;
b2PrismaticJoint.prototype.m_localAnchor2 = new b2Vec2;
b2PrismaticJoint.prototype.m_localXAxis1 = new b2Vec2;
b2PrismaticJoint.prototype.m_localYAxis1 = new b2Vec2;
b2PrismaticJoint.prototype.m_refAngle = null;
b2PrismaticJoint.prototype.m_axis = new b2Vec2;
b2PrismaticJoint.prototype.m_perp = new b2Vec2;
b2PrismaticJoint.prototype.m_s1 = null;
b2PrismaticJoint.prototype.m_s2 = null;
b2PrismaticJoint.prototype.m_a1 = null;
b2PrismaticJoint.prototype.m_a2 = null;
b2PrismaticJoint.prototype.m_K = new b2Mat33;
b2PrismaticJoint.prototype.m_impulse = new b2Vec3;
b2PrismaticJoint.prototype.m_motorMass = null;
b2PrismaticJoint.prototype.m_motorImpulse = null;
b2PrismaticJoint.prototype.m_lowerTranslation = null;
b2PrismaticJoint.prototype.m_upperTranslation = null;
b2PrismaticJoint.prototype.m_maxMotorForce = null;
b2PrismaticJoint.prototype.m_motorSpeed = null;
b2PrismaticJoint.prototype.m_enableLimit = null;
b2PrismaticJoint.prototype.m_enableMotor = null;
b2PrismaticJoint.prototype.m_limitState = 0;var b2RevoluteJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2RevoluteJoint.prototype, b2Joint.prototype);
b2RevoluteJoint.prototype._super = b2Joint.prototype;
b2RevoluteJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  this.m_localAnchor1.SetV(def.localAnchorA);
  this.m_localAnchor2.SetV(def.localAnchorB);
  this.m_referenceAngle = def.referenceAngle;
  this.m_impulse.SetZero();
  this.m_motorImpulse = 0;
  this.m_lowerAngle = def.lowerAngle;
  this.m_upperAngle = def.upperAngle;
  this.m_maxMotorTorque = def.maxMotorTorque;
  this.m_motorSpeed = def.motorSpeed;
  this.m_enableLimit = def.enableLimit;
  this.m_enableMotor = def.enableMotor;
  this.m_limitState = b2Joint.e_inactiveLimit
};
b2RevoluteJoint.prototype.__varz = function() {
  this.K = new b2Mat22;
  this.K1 = new b2Mat22;
  this.K2 = new b2Mat22;
  this.K3 = new b2Mat22;
  this.impulse3 = new b2Vec3;
  this.impulse2 = new b2Vec2;
  this.reduced = new b2Vec2;
  this.m_localAnchor1 = new b2Vec2;
  this.m_localAnchor2 = new b2Vec2;
  this.m_impulse = new b2Vec3;
  this.m_mass = new b2Mat33
};
b2RevoluteJoint.tImpulse = new b2Vec2;
b2RevoluteJoint.prototype.InitVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  var tX;
  if(this.m_enableMotor || this.m_enableLimit) {
  }
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var m1 = bA.m_invMass;
  var m2 = bB.m_invMass;
  var i1 = bA.m_invI;
  var i2 = bB.m_invI;
  this.m_mass.col1.x = m1 + m2 + r1Y * r1Y * i1 + r2Y * r2Y * i2;
  this.m_mass.col2.x = -r1Y * r1X * i1 - r2Y * r2X * i2;
  this.m_mass.col3.x = -r1Y * i1 - r2Y * i2;
  this.m_mass.col1.y = this.m_mass.col2.x;
  this.m_mass.col2.y = m1 + m2 + r1X * r1X * i1 + r2X * r2X * i2;
  this.m_mass.col3.y = r1X * i1 + r2X * i2;
  this.m_mass.col1.z = this.m_mass.col3.x;
  this.m_mass.col2.z = this.m_mass.col3.y;
  this.m_mass.col3.z = i1 + i2;
  this.m_motorMass = 1 / (i1 + i2);
  if(this.m_enableMotor == false) {
    this.m_motorImpulse = 0
  }
  if(this.m_enableLimit) {
    var jointAngle = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
    if(b2Math.Abs(this.m_upperAngle - this.m_lowerAngle) < 2 * b2Settings.b2_angularSlop) {
      this.m_limitState = b2Joint.e_equalLimits
    }else {
      if(jointAngle <= this.m_lowerAngle) {
        if(this.m_limitState != b2Joint.e_atLowerLimit) {
          this.m_impulse.z = 0
        }
        this.m_limitState = b2Joint.e_atLowerLimit
      }else {
        if(jointAngle >= this.m_upperAngle) {
          if(this.m_limitState != b2Joint.e_atUpperLimit) {
            this.m_impulse.z = 0
          }
          this.m_limitState = b2Joint.e_atUpperLimit
        }else {
          this.m_limitState = b2Joint.e_inactiveLimit;
          this.m_impulse.z = 0
        }
      }
    }
  }else {
    this.m_limitState = b2Joint.e_inactiveLimit
  }
  if(step.warmStarting) {
    this.m_impulse.x *= step.dtRatio;
    this.m_impulse.y *= step.dtRatio;
    this.m_motorImpulse *= step.dtRatio;
    var PX = this.m_impulse.x;
    var PY = this.m_impulse.y;
    bA.m_linearVelocity.x -= m1 * PX;
    bA.m_linearVelocity.y -= m1 * PY;
    bA.m_angularVelocity -= i1 * (r1X * PY - r1Y * PX + this.m_motorImpulse + this.m_impulse.z);
    bB.m_linearVelocity.x += m2 * PX;
    bB.m_linearVelocity.y += m2 * PY;
    bB.m_angularVelocity += i2 * (r2X * PY - r2Y * PX + this.m_motorImpulse + this.m_impulse.z)
  }else {
    this.m_impulse.SetZero();
    this.m_motorImpulse = 0
  }
};
b2RevoluteJoint.prototype.SolveVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  var tX;
  var newImpulse;
  var r1X;
  var r1Y;
  var r2X;
  var r2Y;
  var v1 = bA.m_linearVelocity;
  var w1 = bA.m_angularVelocity;
  var v2 = bB.m_linearVelocity;
  var w2 = bB.m_angularVelocity;
  var m1 = bA.m_invMass;
  var m2 = bB.m_invMass;
  var i1 = bA.m_invI;
  var i2 = bB.m_invI;
  if(this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
    var Cdot = w2 - w1 - this.m_motorSpeed;
    var impulse = this.m_motorMass * -Cdot;
    var oldImpulse = this.m_motorImpulse;
    var maxImpulse = step.dt * this.m_maxMotorTorque;
    this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);
    impulse = this.m_motorImpulse - oldImpulse;
    w1 -= i1 * impulse;
    w2 += i2 * impulse
  }
  if(this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
    tMat = bA.m_xf.R;
    r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
    r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
    tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
    r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
    r1X = tX;
    tMat = bB.m_xf.R;
    r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
    r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
    tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
    r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
    r2X = tX;
    var Cdot1X = v2.x + -w2 * r2Y - v1.x - -w1 * r1Y;
    var Cdot1Y = v2.y + w2 * r2X - v1.y - w1 * r1X;
    var Cdot2 = w2 - w1;
    this.m_mass.Solve33(this.impulse3, -Cdot1X, -Cdot1Y, -Cdot2);
    if(this.m_limitState == b2Joint.e_equalLimits) {
      this.m_impulse.Add(this.impulse3)
    }else {
      if(this.m_limitState == b2Joint.e_atLowerLimit) {
        newImpulse = this.m_impulse.z + this.impulse3.z;
        if(newImpulse < 0) {
          this.m_mass.Solve22(this.reduced, -Cdot1X, -Cdot1Y);
          this.impulse3.x = this.reduced.x;
          this.impulse3.y = this.reduced.y;
          this.impulse3.z = -this.m_impulse.z;
          this.m_impulse.x += this.reduced.x;
          this.m_impulse.y += this.reduced.y;
          this.m_impulse.z = 0
        }
      }else {
        if(this.m_limitState == b2Joint.e_atUpperLimit) {
          newImpulse = this.m_impulse.z + this.impulse3.z;
          if(newImpulse > 0) {
            this.m_mass.Solve22(this.reduced, -Cdot1X, -Cdot1Y);
            this.impulse3.x = this.reduced.x;
            this.impulse3.y = this.reduced.y;
            this.impulse3.z = -this.m_impulse.z;
            this.m_impulse.x += this.reduced.x;
            this.m_impulse.y += this.reduced.y;
            this.m_impulse.z = 0
          }
        }
      }
    }
    v1.x -= m1 * this.impulse3.x;
    v1.y -= m1 * this.impulse3.y;
    w1 -= i1 * (r1X * this.impulse3.y - r1Y * this.impulse3.x + this.impulse3.z);
    v2.x += m2 * this.impulse3.x;
    v2.y += m2 * this.impulse3.y;
    w2 += i2 * (r2X * this.impulse3.y - r2Y * this.impulse3.x + this.impulse3.z)
  }else {
    tMat = bA.m_xf.R;
    r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
    r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
    tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
    r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
    r1X = tX;
    tMat = bB.m_xf.R;
    r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
    r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
    tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
    r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
    r2X = tX;
    var CdotX = v2.x + -w2 * r2Y - v1.x - -w1 * r1Y;
    var CdotY = v2.y + w2 * r2X - v1.y - w1 * r1X;
    this.m_mass.Solve22(this.impulse2, -CdotX, -CdotY);
    this.m_impulse.x += this.impulse2.x;
    this.m_impulse.y += this.impulse2.y;
    v1.x -= m1 * this.impulse2.x;
    v1.y -= m1 * this.impulse2.y;
    w1 -= i1 * (r1X * this.impulse2.y - r1Y * this.impulse2.x);
    v2.x += m2 * this.impulse2.x;
    v2.y += m2 * this.impulse2.y;
    w2 += i2 * (r2X * this.impulse2.y - r2Y * this.impulse2.x)
  }
  bA.m_linearVelocity.SetV(v1);
  bA.m_angularVelocity = w1;
  bB.m_linearVelocity.SetV(v2);
  bB.m_angularVelocity = w2
};
b2RevoluteJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  var oldLimitImpulse;
  var C;
  var tMat;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var angularError = 0;
  var positionError = 0;
  var tX;
  var impulseX;
  var impulseY;
  if(this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
    var angle = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
    var limitImpulse = 0;
    if(this.m_limitState == b2Joint.e_equalLimits) {
      C = b2Math.Clamp(angle - this.m_lowerAngle, -b2Settings.b2_maxAngularCorrection, b2Settings.b2_maxAngularCorrection);
      limitImpulse = -this.m_motorMass * C;
      angularError = b2Math.Abs(C)
    }else {
      if(this.m_limitState == b2Joint.e_atLowerLimit) {
        C = angle - this.m_lowerAngle;
        angularError = -C;
        C = b2Math.Clamp(C + b2Settings.b2_angularSlop, -b2Settings.b2_maxAngularCorrection, 0);
        limitImpulse = -this.m_motorMass * C
      }else {
        if(this.m_limitState == b2Joint.e_atUpperLimit) {
          C = angle - this.m_upperAngle;
          angularError = C;
          C = b2Math.Clamp(C - b2Settings.b2_angularSlop, 0, b2Settings.b2_maxAngularCorrection);
          limitImpulse = -this.m_motorMass * C
        }
      }
    }
    bA.m_sweep.a -= bA.m_invI * limitImpulse;
    bB.m_sweep.a += bB.m_invI * limitImpulse;
    bA.SynchronizeTransform();
    bB.SynchronizeTransform()
  }
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var CX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
  var CY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
  var CLengthSquared = CX * CX + CY * CY;
  var CLength = Math.sqrt(CLengthSquared);
  positionError = CLength;
  var invMass1 = bA.m_invMass;
  var invMass2 = bB.m_invMass;
  var invI1 = bA.m_invI;
  var invI2 = bB.m_invI;
  var k_allowedStretch = 10 * b2Settings.b2_linearSlop;
  if(CLengthSquared > k_allowedStretch * k_allowedStretch) {
    var uX = CX / CLength;
    var uY = CY / CLength;
    var k = invMass1 + invMass2;
    var m = 1 / k;
    impulseX = m * -CX;
    impulseY = m * -CY;
    var k_beta = 0.5;
    bA.m_sweep.c.x -= k_beta * invMass1 * impulseX;
    bA.m_sweep.c.y -= k_beta * invMass1 * impulseY;
    bB.m_sweep.c.x += k_beta * invMass2 * impulseX;
    bB.m_sweep.c.y += k_beta * invMass2 * impulseY;
    CX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
    CY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y
  }
  this.K1.col1.x = invMass1 + invMass2;
  this.K1.col2.x = 0;
  this.K1.col1.y = 0;
  this.K1.col2.y = invMass1 + invMass2;
  this.K2.col1.x = invI1 * r1Y * r1Y;
  this.K2.col2.x = -invI1 * r1X * r1Y;
  this.K2.col1.y = -invI1 * r1X * r1Y;
  this.K2.col2.y = invI1 * r1X * r1X;
  this.K3.col1.x = invI2 * r2Y * r2Y;
  this.K3.col2.x = -invI2 * r2X * r2Y;
  this.K3.col1.y = -invI2 * r2X * r2Y;
  this.K3.col2.y = invI2 * r2X * r2X;
  this.K.SetM(this.K1);
  this.K.AddM(this.K2);
  this.K.AddM(this.K3);
  this.K.Solve(b2RevoluteJoint.tImpulse, -CX, -CY);
  impulseX = b2RevoluteJoint.tImpulse.x;
  impulseY = b2RevoluteJoint.tImpulse.y;
  bA.m_sweep.c.x -= bA.m_invMass * impulseX;
  bA.m_sweep.c.y -= bA.m_invMass * impulseY;
  bA.m_sweep.a -= bA.m_invI * (r1X * impulseY - r1Y * impulseX);
  bB.m_sweep.c.x += bB.m_invMass * impulseX;
  bB.m_sweep.c.y += bB.m_invMass * impulseY;
  bB.m_sweep.a += bB.m_invI * (r2X * impulseY - r2Y * impulseX);
  bA.SynchronizeTransform();
  bB.SynchronizeTransform();
  return positionError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop
};
b2RevoluteJoint.prototype.GetAnchorA = function() {
  return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
};
b2RevoluteJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
};
b2RevoluteJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y)
};
b2RevoluteJoint.prototype.GetReactionTorque = function(inv_dt) {
  return inv_dt * this.m_impulse.z
};
b2RevoluteJoint.prototype.GetJointAngle = function() {
  return this.m_bodyB.m_sweep.a - this.m_bodyA.m_sweep.a - this.m_referenceAngle
};
b2RevoluteJoint.prototype.GetJointSpeed = function() {
  return this.m_bodyB.m_angularVelocity - this.m_bodyA.m_angularVelocity
};
b2RevoluteJoint.prototype.IsLimitEnabled = function() {
  return this.m_enableLimit
};
b2RevoluteJoint.prototype.EnableLimit = function(flag) {
  this.m_enableLimit = flag
};
b2RevoluteJoint.prototype.GetLowerLimit = function() {
  return this.m_lowerAngle
};
b2RevoluteJoint.prototype.GetUpperLimit = function() {
  return this.m_upperAngle
};
b2RevoluteJoint.prototype.SetLimits = function(lower, upper) {
  this.m_lowerAngle = lower;
  this.m_upperAngle = upper
};
b2RevoluteJoint.prototype.IsMotorEnabled = function() {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  return this.m_enableMotor
};
b2RevoluteJoint.prototype.EnableMotor = function(flag) {
  this.m_enableMotor = flag
};
b2RevoluteJoint.prototype.SetMotorSpeed = function(speed) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_motorSpeed = speed
};
b2RevoluteJoint.prototype.GetMotorSpeed = function() {
  return this.m_motorSpeed
};
b2RevoluteJoint.prototype.SetMaxMotorTorque = function(torque) {
  this.m_maxMotorTorque = torque
};
b2RevoluteJoint.prototype.GetMotorTorque = function() {
  return this.m_maxMotorTorque
};
b2RevoluteJoint.prototype.K = new b2Mat22;
b2RevoluteJoint.prototype.K1 = new b2Mat22;
b2RevoluteJoint.prototype.K2 = new b2Mat22;
b2RevoluteJoint.prototype.K3 = new b2Mat22;
b2RevoluteJoint.prototype.impulse3 = new b2Vec3;
b2RevoluteJoint.prototype.impulse2 = new b2Vec2;
b2RevoluteJoint.prototype.reduced = new b2Vec2;
b2RevoluteJoint.prototype.m_localAnchor1 = new b2Vec2;
b2RevoluteJoint.prototype.m_localAnchor2 = new b2Vec2;
b2RevoluteJoint.prototype.m_impulse = new b2Vec3;
b2RevoluteJoint.prototype.m_motorImpulse = null;
b2RevoluteJoint.prototype.m_mass = new b2Mat33;
b2RevoluteJoint.prototype.m_motorMass = null;
b2RevoluteJoint.prototype.m_enableMotor = null;
b2RevoluteJoint.prototype.m_maxMotorTorque = null;
b2RevoluteJoint.prototype.m_motorSpeed = null;
b2RevoluteJoint.prototype.m_enableLimit = null;
b2RevoluteJoint.prototype.m_referenceAngle = null;
b2RevoluteJoint.prototype.m_lowerAngle = null;
b2RevoluteJoint.prototype.m_upperAngle = null;
b2RevoluteJoint.prototype.m_limitState = 0;var b2JointDef = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2JointDef.prototype.__constructor = function() {
  this.type = b2Joint.e_unknownJoint;
  this.userData = null;
  this.bodyA = null;
  this.bodyB = null;
  this.collideConnected = false
};
b2JointDef.prototype.__varz = function() {
};
b2JointDef.prototype.type = 0;
b2JointDef.prototype.userData = null;
b2JointDef.prototype.bodyA = null;
b2JointDef.prototype.bodyB = null;
b2JointDef.prototype.collideConnected = null;var b2LineJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2LineJointDef.prototype, b2JointDef.prototype);
b2LineJointDef.prototype._super = b2JointDef.prototype;
b2LineJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_lineJoint;
  this.localAxisA.Set(1, 0);
  this.enableLimit = false;
  this.lowerTranslation = 0;
  this.upperTranslation = 0;
  this.enableMotor = false;
  this.maxMotorForce = 0;
  this.motorSpeed = 0
};
b2LineJointDef.prototype.__varz = function() {
  this.localAnchorA = new b2Vec2;
  this.localAnchorB = new b2Vec2;
  this.localAxisA = new b2Vec2
};
b2LineJointDef.prototype.Initialize = function(bA, bB, anchor, axis) {
  this.bodyA = bA;
  this.bodyB = bB;
  this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
  this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
  this.localAxisA = this.bodyA.GetLocalVector(axis)
};
b2LineJointDef.prototype.localAnchorA = new b2Vec2;
b2LineJointDef.prototype.localAnchorB = new b2Vec2;
b2LineJointDef.prototype.localAxisA = new b2Vec2;
b2LineJointDef.prototype.enableLimit = null;
b2LineJointDef.prototype.lowerTranslation = null;
b2LineJointDef.prototype.upperTranslation = null;
b2LineJointDef.prototype.enableMotor = null;
b2LineJointDef.prototype.maxMotorForce = null;
b2LineJointDef.prototype.motorSpeed = null;var b2DistanceJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2DistanceJoint.prototype, b2Joint.prototype);
b2DistanceJoint.prototype._super = b2Joint.prototype;
b2DistanceJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  var tMat;
  var tX;
  var tY;
  this.m_localAnchor1.SetV(def.localAnchorA);
  this.m_localAnchor2.SetV(def.localAnchorB);
  this.m_length = def.length;
  this.m_frequencyHz = def.frequencyHz;
  this.m_dampingRatio = def.dampingRatio;
  this.m_impulse = 0;
  this.m_gamma = 0;
  this.m_bias = 0
};
b2DistanceJoint.prototype.__varz = function() {
  this.m_localAnchor1 = new b2Vec2;
  this.m_localAnchor2 = new b2Vec2;
  this.m_u = new b2Vec2
};
b2DistanceJoint.prototype.InitVelocityConstraints = function(step) {
  var tMat;
  var tX;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  this.m_u.x = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
  this.m_u.y = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
  var length = Math.sqrt(this.m_u.x * this.m_u.x + this.m_u.y * this.m_u.y);
  if(length > b2Settings.b2_linearSlop) {
    this.m_u.Multiply(1 / length)
  }else {
    this.m_u.SetZero()
  }
  var cr1u = r1X * this.m_u.y - r1Y * this.m_u.x;
  var cr2u = r2X * this.m_u.y - r2Y * this.m_u.x;
  var invMass = bA.m_invMass + bA.m_invI * cr1u * cr1u + bB.m_invMass + bB.m_invI * cr2u * cr2u;
  this.m_mass = invMass != 0 ? 1 / invMass : 0;
  if(this.m_frequencyHz > 0) {
    var C = length - this.m_length;
    var omega = 2 * Math.PI * this.m_frequencyHz;
    var d = 2 * this.m_mass * this.m_dampingRatio * omega;
    var k = this.m_mass * omega * omega;
    this.m_gamma = step.dt * (d + step.dt * k);
    this.m_gamma = this.m_gamma != 0 ? 1 / this.m_gamma : 0;
    this.m_bias = C * step.dt * k * this.m_gamma;
    this.m_mass = invMass + this.m_gamma;
    this.m_mass = this.m_mass != 0 ? 1 / this.m_mass : 0
  }
  if(step.warmStarting) {
    this.m_impulse *= step.dtRatio;
    var PX = this.m_impulse * this.m_u.x;
    var PY = this.m_impulse * this.m_u.y;
    bA.m_linearVelocity.x -= bA.m_invMass * PX;
    bA.m_linearVelocity.y -= bA.m_invMass * PY;
    bA.m_angularVelocity -= bA.m_invI * (r1X * PY - r1Y * PX);
    bB.m_linearVelocity.x += bB.m_invMass * PX;
    bB.m_linearVelocity.y += bB.m_invMass * PY;
    bB.m_angularVelocity += bB.m_invI * (r2X * PY - r2Y * PX)
  }else {
    this.m_impulse = 0
  }
};
b2DistanceJoint.prototype.SolveVelocityConstraints = function(step) {
  var tMat;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var v1X = bA.m_linearVelocity.x + -bA.m_angularVelocity * r1Y;
  var v1Y = bA.m_linearVelocity.y + bA.m_angularVelocity * r1X;
  var v2X = bB.m_linearVelocity.x + -bB.m_angularVelocity * r2Y;
  var v2Y = bB.m_linearVelocity.y + bB.m_angularVelocity * r2X;
  var Cdot = this.m_u.x * (v2X - v1X) + this.m_u.y * (v2Y - v1Y);
  var impulse = -this.m_mass * (Cdot + this.m_bias + this.m_gamma * this.m_impulse);
  this.m_impulse += impulse;
  var PX = impulse * this.m_u.x;
  var PY = impulse * this.m_u.y;
  bA.m_linearVelocity.x -= bA.m_invMass * PX;
  bA.m_linearVelocity.y -= bA.m_invMass * PY;
  bA.m_angularVelocity -= bA.m_invI * (r1X * PY - r1Y * PX);
  bB.m_linearVelocity.x += bB.m_invMass * PX;
  bB.m_linearVelocity.y += bB.m_invMass * PY;
  bB.m_angularVelocity += bB.m_invI * (r2X * PY - r2Y * PX)
};
b2DistanceJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  var tMat;
  if(this.m_frequencyHz > 0) {
    return true
  }
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
  var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
  var length = Math.sqrt(dX * dX + dY * dY);
  dX /= length;
  dY /= length;
  var C = length - this.m_length;
  C = b2Math.Clamp(C, -b2Settings.b2_maxLinearCorrection, b2Settings.b2_maxLinearCorrection);
  var impulse = -this.m_mass * C;
  this.m_u.Set(dX, dY);
  var PX = impulse * this.m_u.x;
  var PY = impulse * this.m_u.y;
  bA.m_sweep.c.x -= bA.m_invMass * PX;
  bA.m_sweep.c.y -= bA.m_invMass * PY;
  bA.m_sweep.a -= bA.m_invI * (r1X * PY - r1Y * PX);
  bB.m_sweep.c.x += bB.m_invMass * PX;
  bB.m_sweep.c.y += bB.m_invMass * PY;
  bB.m_sweep.a += bB.m_invI * (r2X * PY - r2Y * PX);
  bA.SynchronizeTransform();
  bB.SynchronizeTransform();
  return b2Math.Abs(C) < b2Settings.b2_linearSlop
};
b2DistanceJoint.prototype.GetAnchorA = function() {
  return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
};
b2DistanceJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
};
b2DistanceJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * this.m_impulse * this.m_u.x, inv_dt * this.m_impulse * this.m_u.y)
};
b2DistanceJoint.prototype.GetReactionTorque = function(inv_dt) {
  return 0
};
b2DistanceJoint.prototype.GetLength = function() {
  return this.m_length
};
b2DistanceJoint.prototype.SetLength = function(length) {
  this.m_length = length
};
b2DistanceJoint.prototype.GetFrequency = function() {
  return this.m_frequencyHz
};
b2DistanceJoint.prototype.SetFrequency = function(hz) {
  this.m_frequencyHz = hz
};
b2DistanceJoint.prototype.GetDampingRatio = function() {
  return this.m_dampingRatio
};
b2DistanceJoint.prototype.SetDampingRatio = function(ratio) {
  this.m_dampingRatio = ratio
};
b2DistanceJoint.prototype.m_localAnchor1 = new b2Vec2;
b2DistanceJoint.prototype.m_localAnchor2 = new b2Vec2;
b2DistanceJoint.prototype.m_u = new b2Vec2;
b2DistanceJoint.prototype.m_frequencyHz = null;
b2DistanceJoint.prototype.m_dampingRatio = null;
b2DistanceJoint.prototype.m_gamma = null;
b2DistanceJoint.prototype.m_bias = null;
b2DistanceJoint.prototype.m_impulse = null;
b2DistanceJoint.prototype.m_mass = null;
b2DistanceJoint.prototype.m_length = null;var b2PulleyJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2PulleyJointDef.prototype, b2JointDef.prototype);
b2PulleyJointDef.prototype._super = b2JointDef.prototype;
b2PulleyJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_pulleyJoint;
  this.groundAnchorA.Set(-1, 1);
  this.groundAnchorB.Set(1, 1);
  this.localAnchorA.Set(-1, 0);
  this.localAnchorB.Set(1, 0);
  this.lengthA = 0;
  this.maxLengthA = 0;
  this.lengthB = 0;
  this.maxLengthB = 0;
  this.ratio = 1;
  this.collideConnected = true
};
b2PulleyJointDef.prototype.__varz = function() {
  this.groundAnchorA = new b2Vec2;
  this.groundAnchorB = new b2Vec2;
  this.localAnchorA = new b2Vec2;
  this.localAnchorB = new b2Vec2
};
b2PulleyJointDef.prototype.Initialize = function(bA, bB, gaA, gaB, anchorA, anchorB, r) {
  this.bodyA = bA;
  this.bodyB = bB;
  this.groundAnchorA.SetV(gaA);
  this.groundAnchorB.SetV(gaB);
  this.localAnchorA = this.bodyA.GetLocalPoint(anchorA);
  this.localAnchorB = this.bodyB.GetLocalPoint(anchorB);
  var d1X = anchorA.x - gaA.x;
  var d1Y = anchorA.y - gaA.y;
  this.lengthA = Math.sqrt(d1X * d1X + d1Y * d1Y);
  var d2X = anchorB.x - gaB.x;
  var d2Y = anchorB.y - gaB.y;
  this.lengthB = Math.sqrt(d2X * d2X + d2Y * d2Y);
  this.ratio = r;
  var C = this.lengthA + this.ratio * this.lengthB;
  this.maxLengthA = C - this.ratio * b2PulleyJoint.b2_minPulleyLength;
  this.maxLengthB = (C - b2PulleyJoint.b2_minPulleyLength) / this.ratio
};
b2PulleyJointDef.prototype.groundAnchorA = new b2Vec2;
b2PulleyJointDef.prototype.groundAnchorB = new b2Vec2;
b2PulleyJointDef.prototype.localAnchorA = new b2Vec2;
b2PulleyJointDef.prototype.localAnchorB = new b2Vec2;
b2PulleyJointDef.prototype.lengthA = null;
b2PulleyJointDef.prototype.maxLengthA = null;
b2PulleyJointDef.prototype.lengthB = null;
b2PulleyJointDef.prototype.maxLengthB = null;
b2PulleyJointDef.prototype.ratio = null;var b2DistanceJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2DistanceJointDef.prototype, b2JointDef.prototype);
b2DistanceJointDef.prototype._super = b2JointDef.prototype;
b2DistanceJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_distanceJoint;
  this.length = 1;
  this.frequencyHz = 0;
  this.dampingRatio = 0
};
b2DistanceJointDef.prototype.__varz = function() {
  this.localAnchorA = new b2Vec2;
  this.localAnchorB = new b2Vec2
};
b2DistanceJointDef.prototype.Initialize = function(bA, bB, anchorA, anchorB) {
  this.bodyA = bA;
  this.bodyB = bB;
  this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchorA));
  this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchorB));
  var dX = anchorB.x - anchorA.x;
  var dY = anchorB.y - anchorA.y;
  this.length = Math.sqrt(dX * dX + dY * dY);
  this.frequencyHz = 0;
  this.dampingRatio = 0
};
b2DistanceJointDef.prototype.localAnchorA = new b2Vec2;
b2DistanceJointDef.prototype.localAnchorB = new b2Vec2;
b2DistanceJointDef.prototype.length = null;
b2DistanceJointDef.prototype.frequencyHz = null;
b2DistanceJointDef.prototype.dampingRatio = null;var b2FrictionJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2FrictionJointDef.prototype, b2JointDef.prototype);
b2FrictionJointDef.prototype._super = b2JointDef.prototype;
b2FrictionJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_frictionJoint;
  this.maxForce = 0;
  this.maxTorque = 0
};
b2FrictionJointDef.prototype.__varz = function() {
  this.localAnchorA = new b2Vec2;
  this.localAnchorB = new b2Vec2
};
b2FrictionJointDef.prototype.Initialize = function(bA, bB, anchor) {
  this.bodyA = bA;
  this.bodyB = bB;
  this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchor));
  this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchor))
};
b2FrictionJointDef.prototype.localAnchorA = new b2Vec2;
b2FrictionJointDef.prototype.localAnchorB = new b2Vec2;
b2FrictionJointDef.prototype.maxForce = null;
b2FrictionJointDef.prototype.maxTorque = null;var b2WeldJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2WeldJointDef.prototype, b2JointDef.prototype);
b2WeldJointDef.prototype._super = b2JointDef.prototype;
b2WeldJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_weldJoint;
  this.referenceAngle = 0
};
b2WeldJointDef.prototype.__varz = function() {
  this.localAnchorA = new b2Vec2;
  this.localAnchorB = new b2Vec2
};
b2WeldJointDef.prototype.Initialize = function(bA, bB, anchor) {
  this.bodyA = bA;
  this.bodyB = bB;
  this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchor));
  this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchor));
  this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle()
};
b2WeldJointDef.prototype.localAnchorA = new b2Vec2;
b2WeldJointDef.prototype.localAnchorB = new b2Vec2;
b2WeldJointDef.prototype.referenceAngle = null;var b2GearJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2GearJointDef.prototype, b2JointDef.prototype);
b2GearJointDef.prototype._super = b2JointDef.prototype;
b2GearJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_gearJoint;
  this.joint1 = null;
  this.joint2 = null;
  this.ratio = 1
};
b2GearJointDef.prototype.__varz = function() {
};
b2GearJointDef.prototype.joint1 = null;
b2GearJointDef.prototype.joint2 = null;
b2GearJointDef.prototype.ratio = null;var b2Color = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Color.prototype.__constructor = function(rr, gg, bb) {
  this._r = parseInt(255 * b2Math.Clamp(rr, 0, 1));
  this._g = parseInt(255 * b2Math.Clamp(gg, 0, 1));
  this._b = parseInt(255 * b2Math.Clamp(bb, 0, 1))
};
b2Color.prototype.__varz = function() {
};
b2Color.prototype.Set = function(rr, gg, bb) {
  this._r = parseInt(255 * b2Math.Clamp(rr, 0, 1));
  this._g = parseInt(255 * b2Math.Clamp(gg, 0, 1));
  this._b = parseInt(255 * b2Math.Clamp(bb, 0, 1))
};
b2Color.prototype.__defineGetter__("r", function() {
  return this._r
});
b2Color.prototype.__defineSetter__("r", function(rr) {
  this._r = parseInt(255 * b2Math.Clamp(rr, 0, 1))
});
b2Color.prototype.__defineGetter__("g", function() {
  return this._g
});
b2Color.prototype.__defineSetter__("g", function(gg) {
  this._g = parseInt(255 * b2Math.Clamp(gg, 0, 1))
});
b2Color.prototype.__defineGetter__("b", function() {
  return this._g
});
b2Color.prototype.__defineSetter__("b", function(bb) {
  this._b = parseInt(255 * b2Math.Clamp(bb, 0, 1))
});
b2Color.prototype.__defineGetter__("color", function() {
  return this._r << 16 | this._g << 8 | this._b
});
b2Color.prototype._r = 0;
b2Color.prototype._g = 0;
b2Color.prototype._b = 0;var b2FrictionJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2FrictionJoint.prototype, b2Joint.prototype);
b2FrictionJoint.prototype._super = b2Joint.prototype;
b2FrictionJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  this.m_localAnchorA.SetV(def.localAnchorA);
  this.m_localAnchorB.SetV(def.localAnchorB);
  this.m_linearMass.SetZero();
  this.m_angularMass = 0;
  this.m_linearImpulse.SetZero();
  this.m_angularImpulse = 0;
  this.m_maxForce = def.maxForce;
  this.m_maxTorque = def.maxTorque
};
b2FrictionJoint.prototype.__varz = function() {
  this.m_localAnchorA = new b2Vec2;
  this.m_localAnchorB = new b2Vec2;
  this.m_linearImpulse = new b2Vec2;
  this.m_linearMass = new b2Mat22
};
b2FrictionJoint.prototype.InitVelocityConstraints = function(step) {
  var tMat;
  var tX;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  tMat = bA.m_xf.R;
  var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
  var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
  tX = tMat.col1.x * rAX + tMat.col2.x * rAY;
  rAY = tMat.col1.y * rAX + tMat.col2.y * rAY;
  rAX = tX;
  tMat = bB.m_xf.R;
  var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
  var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * rBX + tMat.col2.x * rBY;
  rBY = tMat.col1.y * rBX + tMat.col2.y * rBY;
  rBX = tX;
  var mA = bA.m_invMass;
  var mB = bB.m_invMass;
  var iA = bA.m_invI;
  var iB = bB.m_invI;
  var K = new b2Mat22;
  K.col1.x = mA + mB;
  K.col2.x = 0;
  K.col1.y = 0;
  K.col2.y = mA + mB;
  K.col1.x += iA * rAY * rAY;
  K.col2.x += -iA * rAX * rAY;
  K.col1.y += -iA * rAX * rAY;
  K.col2.y += iA * rAX * rAX;
  K.col1.x += iB * rBY * rBY;
  K.col2.x += -iB * rBX * rBY;
  K.col1.y += -iB * rBX * rBY;
  K.col2.y += iB * rBX * rBX;
  K.GetInverse(this.m_linearMass);
  this.m_angularMass = iA + iB;
  if(this.m_angularMass > 0) {
    this.m_angularMass = 1 / this.m_angularMass
  }
  if(step.warmStarting) {
    this.m_linearImpulse.x *= step.dtRatio;
    this.m_linearImpulse.y *= step.dtRatio;
    this.m_angularImpulse *= step.dtRatio;
    var P = this.m_linearImpulse;
    bA.m_linearVelocity.x -= mA * P.x;
    bA.m_linearVelocity.y -= mA * P.y;
    bA.m_angularVelocity -= iA * (rAX * P.y - rAY * P.x + this.m_angularImpulse);
    bB.m_linearVelocity.x += mB * P.x;
    bB.m_linearVelocity.y += mB * P.y;
    bB.m_angularVelocity += iB * (rBX * P.y - rBY * P.x + this.m_angularImpulse)
  }else {
    this.m_linearImpulse.SetZero();
    this.m_angularImpulse = 0
  }
};
b2FrictionJoint.prototype.SolveVelocityConstraints = function(step) {
  var tMat;
  var tX;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var vA = bA.m_linearVelocity;
  var wA = bA.m_angularVelocity;
  var vB = bB.m_linearVelocity;
  var wB = bB.m_angularVelocity;
  var mA = bA.m_invMass;
  var mB = bB.m_invMass;
  var iA = bA.m_invI;
  var iB = bB.m_invI;
  tMat = bA.m_xf.R;
  var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
  var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
  tX = tMat.col1.x * rAX + tMat.col2.x * rAY;
  rAY = tMat.col1.y * rAX + tMat.col2.y * rAY;
  rAX = tX;
  tMat = bB.m_xf.R;
  var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
  var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * rBX + tMat.col2.x * rBY;
  rBY = tMat.col1.y * rBX + tMat.col2.y * rBY;
  rBX = tX;
  var maxImpulse;
  var Cdot = wB - wA;
  var impulse = -this.m_angularMass * Cdot;
  var oldImpulse = this.m_angularImpulse;
  maxImpulse = step.dt * this.m_maxTorque;
  this.m_angularImpulse = b2Math.Clamp(this.m_angularImpulse + impulse, -maxImpulse, maxImpulse);
  impulse = this.m_angularImpulse - oldImpulse;
  wA -= iA * impulse;
  wB += iB * impulse;
  var CdotX = vB.x - wB * rBY - vA.x + wA * rAY;
  var CdotY = vB.y + wB * rBX - vA.y - wA * rAX;
  var impulseV = b2Math.MulMV(this.m_linearMass, new b2Vec2(-CdotX, -CdotY));
  var oldImpulseV = this.m_linearImpulse.Copy();
  this.m_linearImpulse.Add(impulseV);
  maxImpulse = step.dt * this.m_maxForce;
  if(this.m_linearImpulse.LengthSquared() > maxImpulse * maxImpulse) {
    this.m_linearImpulse.Normalize();
    this.m_linearImpulse.Multiply(maxImpulse)
  }
  impulseV = b2Math.SubtractVV(this.m_linearImpulse, oldImpulseV);
  vA.x -= mA * impulseV.x;
  vA.y -= mA * impulseV.y;
  wA -= iA * (rAX * impulseV.y - rAY * impulseV.x);
  vB.x += mB * impulseV.x;
  vB.y += mB * impulseV.y;
  wB += iB * (rBX * impulseV.y - rBY * impulseV.x);
  bA.m_angularVelocity = wA;
  bB.m_angularVelocity = wB
};
b2FrictionJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  return true
};
b2FrictionJoint.prototype.GetAnchorA = function() {
  return this.m_bodyA.GetWorldPoint(this.m_localAnchorA)
};
b2FrictionJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchorB)
};
b2FrictionJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * this.m_linearImpulse.x, inv_dt * this.m_linearImpulse.y)
};
b2FrictionJoint.prototype.GetReactionTorque = function(inv_dt) {
  return inv_dt * this.m_angularImpulse
};
b2FrictionJoint.prototype.SetMaxForce = function(force) {
  this.m_maxForce = force
};
b2FrictionJoint.prototype.GetMaxForce = function() {
  return this.m_maxForce
};
b2FrictionJoint.prototype.SetMaxTorque = function(torque) {
  this.m_maxTorque = torque
};
b2FrictionJoint.prototype.GetMaxTorque = function() {
  return this.m_maxTorque
};
b2FrictionJoint.prototype.m_localAnchorA = new b2Vec2;
b2FrictionJoint.prototype.m_localAnchorB = new b2Vec2;
b2FrictionJoint.prototype.m_linearImpulse = new b2Vec2;
b2FrictionJoint.prototype.m_angularImpulse = null;
b2FrictionJoint.prototype.m_maxForce = null;
b2FrictionJoint.prototype.m_maxTorque = null;
b2FrictionJoint.prototype.m_linearMass = new b2Mat22;
b2FrictionJoint.prototype.m_angularMass = null;var b2Distance = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Distance.prototype.__constructor = function() {
};
b2Distance.prototype.__varz = function() {
};
b2Distance.Distance = function(output, cache, input) {
  ++b2Distance.b2_gjkCalls;
  var proxyA = input.proxyA;
  var proxyB = input.proxyB;
  var transformA = input.transformA;
  var transformB = input.transformB;
  var simplex = b2Distance.s_simplex;
  simplex.ReadCache(cache, proxyA, transformA, proxyB, transformB);
  var vertices = simplex.m_vertices;
  var k_maxIters = 20;
  var saveA = b2Distance.s_saveA;
  var saveB = b2Distance.s_saveB;
  var saveCount = 0;
  var closestPoint = simplex.GetClosestPoint();
  var distanceSqr1 = closestPoint.LengthSquared();
  var distanceSqr2 = distanceSqr1;
  var i = 0;
  var p;
  var iter = 0;
  while(iter < k_maxIters) {
    saveCount = simplex.m_count;
    for(i = 0;i < saveCount;i++) {
      saveA[i] = vertices[i].indexA;
      saveB[i] = vertices[i].indexB
    }
    switch(simplex.m_count) {
      case 1:
        break;
      case 2:
        simplex.Solve2();
        break;
      case 3:
        simplex.Solve3();
        break;
      default:
        b2Settings.b2Assert(false)
    }
    if(simplex.m_count == 3) {
      break
    }
    p = simplex.GetClosestPoint();
    distanceSqr2 = p.LengthSquared();
    if(distanceSqr2 > distanceSqr1) {
    }
    distanceSqr1 = distanceSqr2;
    var d = simplex.GetSearchDirection();
    if(d.LengthSquared() < Number.MIN_VALUE * Number.MIN_VALUE) {
      break
    }
    var vertex = vertices[simplex.m_count];
    vertex.indexA = proxyA.GetSupport(b2Math.MulTMV(transformA.R, d.GetNegative()));
    vertex.wA = b2Math.MulX(transformA, proxyA.GetVertex(vertex.indexA));
    vertex.indexB = proxyB.GetSupport(b2Math.MulTMV(transformB.R, d));
    vertex.wB = b2Math.MulX(transformB, proxyB.GetVertex(vertex.indexB));
    vertex.w = b2Math.SubtractVV(vertex.wB, vertex.wA);
    ++iter;
    ++b2Distance.b2_gjkIters;
    var duplicate = false;
    for(i = 0;i < saveCount;i++) {
      if(vertex.indexA == saveA[i] && vertex.indexB == saveB[i]) {
        duplicate = true;
        break
      }
    }
    if(duplicate) {
      break
    }
    ++simplex.m_count
  }
  b2Distance.b2_gjkMaxIters = b2Math.Max(b2Distance.b2_gjkMaxIters, iter);
  simplex.GetWitnessPoints(output.pointA, output.pointB);
  output.distance = b2Math.SubtractVV(output.pointA, output.pointB).Length();
  output.iterations = iter;
  simplex.WriteCache(cache);
  if(input.useRadii) {
    var rA = proxyA.m_radius;
    var rB = proxyB.m_radius;
    if(output.distance > rA + rB && output.distance > Number.MIN_VALUE) {
      output.distance -= rA + rB;
      var normal = b2Math.SubtractVV(output.pointB, output.pointA);
      normal.Normalize();
      output.pointA.x += rA * normal.x;
      output.pointA.y += rA * normal.y;
      output.pointB.x -= rB * normal.x;
      output.pointB.y -= rB * normal.y
    }else {
      p = new b2Vec2;
      p.x = 0.5 * (output.pointA.x + output.pointB.x);
      p.y = 0.5 * (output.pointA.y + output.pointB.y);
      output.pointA.x = output.pointB.x = p.x;
      output.pointA.y = output.pointB.y = p.y;
      output.distance = 0
    }
  }
};
b2Distance.b2_gjkCalls = 0;
b2Distance.b2_gjkIters = 0;
b2Distance.b2_gjkMaxIters = 0;
b2Distance.s_simplex = new b2Simplex;
b2Distance.s_saveA = new Array(3);
b2Distance.s_saveB = new Array(3);var b2MouseJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2MouseJoint.prototype, b2Joint.prototype);
b2MouseJoint.prototype._super = b2Joint.prototype;
b2MouseJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  this.m_target.SetV(def.target);
  var tX = this.m_target.x - this.m_bodyB.m_xf.position.x;
  var tY = this.m_target.y - this.m_bodyB.m_xf.position.y;
  var tMat = this.m_bodyB.m_xf.R;
  this.m_localAnchor.x = tX * tMat.col1.x + tY * tMat.col1.y;
  this.m_localAnchor.y = tX * tMat.col2.x + tY * tMat.col2.y;
  this.m_maxForce = def.maxForce;
  this.m_impulse.SetZero();
  this.m_frequencyHz = def.frequencyHz;
  this.m_dampingRatio = def.dampingRatio;
  this.m_beta = 0;
  this.m_gamma = 0
};
b2MouseJoint.prototype.__varz = function() {
  this.K = new b2Mat22;
  this.K1 = new b2Mat22;
  this.K2 = new b2Mat22;
  this.m_localAnchor = new b2Vec2;
  this.m_target = new b2Vec2;
  this.m_impulse = new b2Vec2;
  this.m_mass = new b2Mat22;
  this.m_C = new b2Vec2
};
b2MouseJoint.prototype.InitVelocityConstraints = function(step) {
  var b = this.m_bodyB;
  var mass = b.GetMass();
  var omega = 2 * Math.PI * this.m_frequencyHz;
  var d = 2 * mass * this.m_dampingRatio * omega;
  var k = mass * omega * omega;
  this.m_gamma = step.dt * (d + step.dt * k);
  this.m_gamma = this.m_gamma != 0 ? 1 / this.m_gamma : 0;
  this.m_beta = step.dt * k * this.m_gamma;
  var tMat;
  tMat = b.m_xf.R;
  var rX = this.m_localAnchor.x - b.m_sweep.localCenter.x;
  var rY = this.m_localAnchor.y - b.m_sweep.localCenter.y;
  var tX = tMat.col1.x * rX + tMat.col2.x * rY;
  rY = tMat.col1.y * rX + tMat.col2.y * rY;
  rX = tX;
  var invMass = b.m_invMass;
  var invI = b.m_invI;
  this.K1.col1.x = invMass;
  this.K1.col2.x = 0;
  this.K1.col1.y = 0;
  this.K1.col2.y = invMass;
  this.K2.col1.x = invI * rY * rY;
  this.K2.col2.x = -invI * rX * rY;
  this.K2.col1.y = -invI * rX * rY;
  this.K2.col2.y = invI * rX * rX;
  this.K.SetM(this.K1);
  this.K.AddM(this.K2);
  this.K.col1.x += this.m_gamma;
  this.K.col2.y += this.m_gamma;
  this.K.GetInverse(this.m_mass);
  this.m_C.x = b.m_sweep.c.x + rX - this.m_target.x;
  this.m_C.y = b.m_sweep.c.y + rY - this.m_target.y;
  b.m_angularVelocity *= 0.98;
  this.m_impulse.x *= step.dtRatio;
  this.m_impulse.y *= step.dtRatio;
  b.m_linearVelocity.x += invMass * this.m_impulse.x;
  b.m_linearVelocity.y += invMass * this.m_impulse.y;
  b.m_angularVelocity += invI * (rX * this.m_impulse.y - rY * this.m_impulse.x)
};
b2MouseJoint.prototype.SolveVelocityConstraints = function(step) {
  var b = this.m_bodyB;
  var tMat;
  var tX;
  var tY;
  tMat = b.m_xf.R;
  var rX = this.m_localAnchor.x - b.m_sweep.localCenter.x;
  var rY = this.m_localAnchor.y - b.m_sweep.localCenter.y;
  tX = tMat.col1.x * rX + tMat.col2.x * rY;
  rY = tMat.col1.y * rX + tMat.col2.y * rY;
  rX = tX;
  var CdotX = b.m_linearVelocity.x + -b.m_angularVelocity * rY;
  var CdotY = b.m_linearVelocity.y + b.m_angularVelocity * rX;
  tMat = this.m_mass;
  tX = CdotX + this.m_beta * this.m_C.x + this.m_gamma * this.m_impulse.x;
  tY = CdotY + this.m_beta * this.m_C.y + this.m_gamma * this.m_impulse.y;
  var impulseX = -(tMat.col1.x * tX + tMat.col2.x * tY);
  var impulseY = -(tMat.col1.y * tX + tMat.col2.y * tY);
  var oldImpulseX = this.m_impulse.x;
  var oldImpulseY = this.m_impulse.y;
  this.m_impulse.x += impulseX;
  this.m_impulse.y += impulseY;
  var maxImpulse = step.dt * this.m_maxForce;
  if(this.m_impulse.LengthSquared() > maxImpulse * maxImpulse) {
    this.m_impulse.Multiply(maxImpulse / this.m_impulse.Length())
  }
  impulseX = this.m_impulse.x - oldImpulseX;
  impulseY = this.m_impulse.y - oldImpulseY;
  b.m_linearVelocity.x += b.m_invMass * impulseX;
  b.m_linearVelocity.y += b.m_invMass * impulseY;
  b.m_angularVelocity += b.m_invI * (rX * impulseY - rY * impulseX)
};
b2MouseJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  return true
};
b2MouseJoint.prototype.GetAnchorA = function() {
  return this.m_target
};
b2MouseJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchor)
};
b2MouseJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y)
};
b2MouseJoint.prototype.GetReactionTorque = function(inv_dt) {
  return 0
};
b2MouseJoint.prototype.GetTarget = function() {
  return this.m_target
};
b2MouseJoint.prototype.SetTarget = function(target) {
  if(this.m_bodyB.IsAwake() == false) {
    this.m_bodyB.SetAwake(true)
  }
  this.m_target = target
};
b2MouseJoint.prototype.GetMaxForce = function() {
  return this.m_maxForce
};
b2MouseJoint.prototype.SetMaxForce = function(maxForce) {
  this.m_maxForce = maxForce
};
b2MouseJoint.prototype.GetFrequency = function() {
  return this.m_frequencyHz
};
b2MouseJoint.prototype.SetFrequency = function(hz) {
  this.m_frequencyHz = hz
};
b2MouseJoint.prototype.GetDampingRatio = function() {
  return this.m_dampingRatio
};
b2MouseJoint.prototype.SetDampingRatio = function(ratio) {
  this.m_dampingRatio = ratio
};
b2MouseJoint.prototype.K = new b2Mat22;
b2MouseJoint.prototype.K1 = new b2Mat22;
b2MouseJoint.prototype.K2 = new b2Mat22;
b2MouseJoint.prototype.m_localAnchor = new b2Vec2;
b2MouseJoint.prototype.m_target = new b2Vec2;
b2MouseJoint.prototype.m_impulse = new b2Vec2;
b2MouseJoint.prototype.m_mass = new b2Mat22;
b2MouseJoint.prototype.m_C = new b2Vec2;
b2MouseJoint.prototype.m_maxForce = null;
b2MouseJoint.prototype.m_frequencyHz = null;
b2MouseJoint.prototype.m_dampingRatio = null;
b2MouseJoint.prototype.m_beta = null;
b2MouseJoint.prototype.m_gamma = null;var b2PrismaticJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2PrismaticJointDef.prototype, b2JointDef.prototype);
b2PrismaticJointDef.prototype._super = b2JointDef.prototype;
b2PrismaticJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_prismaticJoint;
  this.localAxisA.Set(1, 0);
  this.referenceAngle = 0;
  this.enableLimit = false;
  this.lowerTranslation = 0;
  this.upperTranslation = 0;
  this.enableMotor = false;
  this.maxMotorForce = 0;
  this.motorSpeed = 0
};
b2PrismaticJointDef.prototype.__varz = function() {
  this.localAnchorA = new b2Vec2;
  this.localAnchorB = new b2Vec2;
  this.localAxisA = new b2Vec2
};
b2PrismaticJointDef.prototype.Initialize = function(bA, bB, anchor, axis) {
  this.bodyA = bA;
  this.bodyB = bB;
  this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
  this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
  this.localAxisA = this.bodyA.GetLocalVector(axis);
  this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle()
};
b2PrismaticJointDef.prototype.localAnchorA = new b2Vec2;
b2PrismaticJointDef.prototype.localAnchorB = new b2Vec2;
b2PrismaticJointDef.prototype.localAxisA = new b2Vec2;
b2PrismaticJointDef.prototype.referenceAngle = null;
b2PrismaticJointDef.prototype.enableLimit = null;
b2PrismaticJointDef.prototype.lowerTranslation = null;
b2PrismaticJointDef.prototype.upperTranslation = null;
b2PrismaticJointDef.prototype.enableMotor = null;
b2PrismaticJointDef.prototype.maxMotorForce = null;
b2PrismaticJointDef.prototype.motorSpeed = null;var b2TimeOfImpact = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2TimeOfImpact.prototype.__constructor = function() {
};
b2TimeOfImpact.prototype.__varz = function() {
};
b2TimeOfImpact.TimeOfImpact = function(input) {
  ++b2TimeOfImpact.b2_toiCalls;
  var proxyA = input.proxyA;
  var proxyB = input.proxyB;
  var sweepA = input.sweepA;
  var sweepB = input.sweepB;
  b2Settings.b2Assert(sweepA.t0 == sweepB.t0);
  b2Settings.b2Assert(1 - sweepA.t0 > Number.MIN_VALUE);
  var radius = proxyA.m_radius + proxyB.m_radius;
  var tolerance = input.tolerance;
  var alpha = 0;
  var k_maxIterations = 1E3;
  var iter = 0;
  var target = 0;
  b2TimeOfImpact.s_cache.count = 0;
  b2TimeOfImpact.s_distanceInput.useRadii = false;
  for(;;) {
    sweepA.GetTransform(b2TimeOfImpact.s_xfA, alpha);
    sweepB.GetTransform(b2TimeOfImpact.s_xfB, alpha);
    b2TimeOfImpact.s_distanceInput.proxyA = proxyA;
    b2TimeOfImpact.s_distanceInput.proxyB = proxyB;
    b2TimeOfImpact.s_distanceInput.transformA = b2TimeOfImpact.s_xfA;
    b2TimeOfImpact.s_distanceInput.transformB = b2TimeOfImpact.s_xfB;
    b2Distance.Distance(b2TimeOfImpact.s_distanceOutput, b2TimeOfImpact.s_cache, b2TimeOfImpact.s_distanceInput);
    if(b2TimeOfImpact.s_distanceOutput.distance <= 0) {
      alpha = 1;
      break
    }
    b2TimeOfImpact.s_fcn.Initialize(b2TimeOfImpact.s_cache, proxyA, b2TimeOfImpact.s_xfA, proxyB, b2TimeOfImpact.s_xfB);
    var separation = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
    if(separation <= 0) {
      alpha = 1;
      break
    }
    if(iter == 0) {
      if(separation > radius) {
        target = b2Math.Max(radius - tolerance, 0.75 * radius)
      }else {
        target = b2Math.Max(separation - tolerance, 0.02 * radius)
      }
    }
    if(separation - target < 0.5 * tolerance) {
      if(iter == 0) {
        alpha = 1;
        break
      }
      break
    }
    var newAlpha = alpha;
    var x1 = alpha;
    var x2 = 1;
    var f1 = separation;
    sweepA.GetTransform(b2TimeOfImpact.s_xfA, x2);
    sweepB.GetTransform(b2TimeOfImpact.s_xfB, x2);
    var f2 = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
    if(f2 >= target) {
      alpha = 1;
      break
    }
    var rootIterCount = 0;
    for(;;) {
      var x;
      if(rootIterCount & 1) {
        x = x1 + (target - f1) * (x2 - x1) / (f2 - f1)
      }else {
        x = 0.5 * (x1 + x2)
      }
      sweepA.GetTransform(b2TimeOfImpact.s_xfA, x);
      sweepB.GetTransform(b2TimeOfImpact.s_xfB, x);
      var f = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
      if(b2Math.Abs(f - target) < 0.025 * tolerance) {
        newAlpha = x;
        break
      }
      if(f > target) {
        x1 = x;
        f1 = f
      }else {
        x2 = x;
        f2 = f
      }
      ++rootIterCount;
      ++b2TimeOfImpact.b2_toiRootIters;
      if(rootIterCount == 50) {
        break
      }
    }
    b2TimeOfImpact.b2_toiMaxRootIters = b2Math.Max(b2TimeOfImpact.b2_toiMaxRootIters, rootIterCount);
    if(newAlpha < (1 + 100 * Number.MIN_VALUE) * alpha) {
      break
    }
    alpha = newAlpha;
    iter++;
    ++b2TimeOfImpact.b2_toiIters;
    if(iter == k_maxIterations) {
      break
    }
  }
  b2TimeOfImpact.b2_toiMaxIters = b2Math.Max(b2TimeOfImpact.b2_toiMaxIters, iter);
  return alpha
};
b2TimeOfImpact.b2_toiCalls = 0;
b2TimeOfImpact.b2_toiIters = 0;
b2TimeOfImpact.b2_toiMaxIters = 0;
b2TimeOfImpact.b2_toiRootIters = 0;
b2TimeOfImpact.b2_toiMaxRootIters = 0;
b2TimeOfImpact.s_cache = new b2SimplexCache;
b2TimeOfImpact.s_distanceInput = new b2DistanceInput;
b2TimeOfImpact.s_xfA = new b2Transform;
b2TimeOfImpact.s_xfB = new b2Transform;
b2TimeOfImpact.s_fcn = new b2SeparationFunction;
b2TimeOfImpact.s_distanceOutput = new b2DistanceOutput;var b2GearJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2GearJoint.prototype, b2Joint.prototype);
b2GearJoint.prototype._super = b2Joint.prototype;
b2GearJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  var type1 = def.joint1.m_type;
  var type2 = def.joint2.m_type;
  this.m_revolute1 = null;
  this.m_prismatic1 = null;
  this.m_revolute2 = null;
  this.m_prismatic2 = null;
  var coordinate1;
  var coordinate2;
  this.m_ground1 = def.joint1.GetBodyA();
  this.m_bodyA = def.joint1.GetBodyB();
  if(type1 == b2Joint.e_revoluteJoint) {
    this.m_revolute1 = def.joint1;
    this.m_groundAnchor1.SetV(this.m_revolute1.m_localAnchor1);
    this.m_localAnchor1.SetV(this.m_revolute1.m_localAnchor2);
    coordinate1 = this.m_revolute1.GetJointAngle()
  }else {
    this.m_prismatic1 = def.joint1;
    this.m_groundAnchor1.SetV(this.m_prismatic1.m_localAnchor1);
    this.m_localAnchor1.SetV(this.m_prismatic1.m_localAnchor2);
    coordinate1 = this.m_prismatic1.GetJointTranslation()
  }
  this.m_ground2 = def.joint2.GetBodyA();
  this.m_bodyB = def.joint2.GetBodyB();
  if(type2 == b2Joint.e_revoluteJoint) {
    this.m_revolute2 = def.joint2;
    this.m_groundAnchor2.SetV(this.m_revolute2.m_localAnchor1);
    this.m_localAnchor2.SetV(this.m_revolute2.m_localAnchor2);
    coordinate2 = this.m_revolute2.GetJointAngle()
  }else {
    this.m_prismatic2 = def.joint2;
    this.m_groundAnchor2.SetV(this.m_prismatic2.m_localAnchor1);
    this.m_localAnchor2.SetV(this.m_prismatic2.m_localAnchor2);
    coordinate2 = this.m_prismatic2.GetJointTranslation()
  }
  this.m_ratio = def.ratio;
  this.m_constant = coordinate1 + this.m_ratio * coordinate2;
  this.m_impulse = 0
};
b2GearJoint.prototype.__varz = function() {
  this.m_groundAnchor1 = new b2Vec2;
  this.m_groundAnchor2 = new b2Vec2;
  this.m_localAnchor1 = new b2Vec2;
  this.m_localAnchor2 = new b2Vec2;
  this.m_J = new b2Jacobian
};
b2GearJoint.prototype.InitVelocityConstraints = function(step) {
  var g1 = this.m_ground1;
  var g2 = this.m_ground2;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var ugX;
  var ugY;
  var rX;
  var rY;
  var tMat;
  var tVec;
  var crug;
  var tX;
  var K = 0;
  this.m_J.SetZero();
  if(this.m_revolute1) {
    this.m_J.angularA = -1;
    K += bA.m_invI
  }else {
    tMat = g1.m_xf.R;
    tVec = this.m_prismatic1.m_localXAxis1;
    ugX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
    ugY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
    tMat = bA.m_xf.R;
    rX = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
    rY = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
    tX = tMat.col1.x * rX + tMat.col2.x * rY;
    rY = tMat.col1.y * rX + tMat.col2.y * rY;
    rX = tX;
    crug = rX * ugY - rY * ugX;
    this.m_J.linearA.Set(-ugX, -ugY);
    this.m_J.angularA = -crug;
    K += bA.m_invMass + bA.m_invI * crug * crug
  }
  if(this.m_revolute2) {
    this.m_J.angularB = -this.m_ratio;
    K += this.m_ratio * this.m_ratio * bB.m_invI
  }else {
    tMat = g2.m_xf.R;
    tVec = this.m_prismatic2.m_localXAxis1;
    ugX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
    ugY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
    tMat = bB.m_xf.R;
    rX = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
    rY = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
    tX = tMat.col1.x * rX + tMat.col2.x * rY;
    rY = tMat.col1.y * rX + tMat.col2.y * rY;
    rX = tX;
    crug = rX * ugY - rY * ugX;
    this.m_J.linearB.Set(-this.m_ratio * ugX, -this.m_ratio * ugY);
    this.m_J.angularB = -this.m_ratio * crug;
    K += this.m_ratio * this.m_ratio * (bB.m_invMass + bB.m_invI * crug * crug)
  }
  this.m_mass = K > 0 ? 1 / K : 0;
  if(step.warmStarting) {
    bA.m_linearVelocity.x += bA.m_invMass * this.m_impulse * this.m_J.linearA.x;
    bA.m_linearVelocity.y += bA.m_invMass * this.m_impulse * this.m_J.linearA.y;
    bA.m_angularVelocity += bA.m_invI * this.m_impulse * this.m_J.angularA;
    bB.m_linearVelocity.x += bB.m_invMass * this.m_impulse * this.m_J.linearB.x;
    bB.m_linearVelocity.y += bB.m_invMass * this.m_impulse * this.m_J.linearB.y;
    bB.m_angularVelocity += bB.m_invI * this.m_impulse * this.m_J.angularB
  }else {
    this.m_impulse = 0
  }
};
b2GearJoint.prototype.SolveVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var Cdot = this.m_J.Compute(bA.m_linearVelocity, bA.m_angularVelocity, bB.m_linearVelocity, bB.m_angularVelocity);
  var impulse = -this.m_mass * Cdot;
  this.m_impulse += impulse;
  bA.m_linearVelocity.x += bA.m_invMass * impulse * this.m_J.linearA.x;
  bA.m_linearVelocity.y += bA.m_invMass * impulse * this.m_J.linearA.y;
  bA.m_angularVelocity += bA.m_invI * impulse * this.m_J.angularA;
  bB.m_linearVelocity.x += bB.m_invMass * impulse * this.m_J.linearB.x;
  bB.m_linearVelocity.y += bB.m_invMass * impulse * this.m_J.linearB.y;
  bB.m_angularVelocity += bB.m_invI * impulse * this.m_J.angularB
};
b2GearJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  var linearError = 0;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var coordinate1;
  var coordinate2;
  if(this.m_revolute1) {
    coordinate1 = this.m_revolute1.GetJointAngle()
  }else {
    coordinate1 = this.m_prismatic1.GetJointTranslation()
  }
  if(this.m_revolute2) {
    coordinate2 = this.m_revolute2.GetJointAngle()
  }else {
    coordinate2 = this.m_prismatic2.GetJointTranslation()
  }
  var C = this.m_constant - (coordinate1 + this.m_ratio * coordinate2);
  var impulse = -this.m_mass * C;
  bA.m_sweep.c.x += bA.m_invMass * impulse * this.m_J.linearA.x;
  bA.m_sweep.c.y += bA.m_invMass * impulse * this.m_J.linearA.y;
  bA.m_sweep.a += bA.m_invI * impulse * this.m_J.angularA;
  bB.m_sweep.c.x += bB.m_invMass * impulse * this.m_J.linearB.x;
  bB.m_sweep.c.y += bB.m_invMass * impulse * this.m_J.linearB.y;
  bB.m_sweep.a += bB.m_invI * impulse * this.m_J.angularB;
  bA.SynchronizeTransform();
  bB.SynchronizeTransform();
  return linearError < b2Settings.b2_linearSlop
};
b2GearJoint.prototype.GetAnchorA = function() {
  return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
};
b2GearJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
};
b2GearJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * this.m_impulse * this.m_J.linearB.x, inv_dt * this.m_impulse * this.m_J.linearB.y)
};
b2GearJoint.prototype.GetReactionTorque = function(inv_dt) {
  var tMat = this.m_bodyB.m_xf.R;
  var rX = this.m_localAnchor1.x - this.m_bodyB.m_sweep.localCenter.x;
  var rY = this.m_localAnchor1.y - this.m_bodyB.m_sweep.localCenter.y;
  var tX = tMat.col1.x * rX + tMat.col2.x * rY;
  rY = tMat.col1.y * rX + tMat.col2.y * rY;
  rX = tX;
  var PX = this.m_impulse * this.m_J.linearB.x;
  var PY = this.m_impulse * this.m_J.linearB.y;
  return inv_dt * (this.m_impulse * this.m_J.angularB - rX * PY + rY * PX)
};
b2GearJoint.prototype.GetRatio = function() {
  return this.m_ratio
};
b2GearJoint.prototype.SetRatio = function(ratio) {
  this.m_ratio = ratio
};
b2GearJoint.prototype.m_ground1 = null;
b2GearJoint.prototype.m_ground2 = null;
b2GearJoint.prototype.m_revolute1 = null;
b2GearJoint.prototype.m_prismatic1 = null;
b2GearJoint.prototype.m_revolute2 = null;
b2GearJoint.prototype.m_prismatic2 = null;
b2GearJoint.prototype.m_groundAnchor1 = new b2Vec2;
b2GearJoint.prototype.m_groundAnchor2 = new b2Vec2;
b2GearJoint.prototype.m_localAnchor1 = new b2Vec2;
b2GearJoint.prototype.m_localAnchor2 = new b2Vec2;
b2GearJoint.prototype.m_J = new b2Jacobian;
b2GearJoint.prototype.m_constant = null;
b2GearJoint.prototype.m_ratio = null;
b2GearJoint.prototype.m_mass = null;
b2GearJoint.prototype.m_impulse = null;var b2TOIInput = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2TOIInput.prototype.__constructor = function() {
};
b2TOIInput.prototype.__varz = function() {
  this.proxyA = new b2DistanceProxy;
  this.proxyB = new b2DistanceProxy;
  this.sweepA = new b2Sweep;
  this.sweepB = new b2Sweep
};
b2TOIInput.prototype.proxyA = new b2DistanceProxy;
b2TOIInput.prototype.proxyB = new b2DistanceProxy;
b2TOIInput.prototype.sweepA = new b2Sweep;
b2TOIInput.prototype.sweepB = new b2Sweep;
b2TOIInput.prototype.tolerance = null;var b2RevoluteJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2RevoluteJointDef.prototype, b2JointDef.prototype);
b2RevoluteJointDef.prototype._super = b2JointDef.prototype;
b2RevoluteJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_revoluteJoint;
  this.localAnchorA.Set(0, 0);
  this.localAnchorB.Set(0, 0);
  this.referenceAngle = 0;
  this.lowerAngle = 0;
  this.upperAngle = 0;
  this.maxMotorTorque = 0;
  this.motorSpeed = 0;
  this.enableLimit = false;
  this.enableMotor = false
};
b2RevoluteJointDef.prototype.__varz = function() {
  this.localAnchorA = new b2Vec2;
  this.localAnchorB = new b2Vec2
};
b2RevoluteJointDef.prototype.Initialize = function(bA, bB, anchor) {
  this.bodyA = bA;
  this.bodyB = bB;
  this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
  this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
  this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle()
};
b2RevoluteJointDef.prototype.localAnchorA = new b2Vec2;
b2RevoluteJointDef.prototype.localAnchorB = new b2Vec2;
b2RevoluteJointDef.prototype.referenceAngle = null;
b2RevoluteJointDef.prototype.enableLimit = null;
b2RevoluteJointDef.prototype.lowerAngle = null;
b2RevoluteJointDef.prototype.upperAngle = null;
b2RevoluteJointDef.prototype.enableMotor = null;
b2RevoluteJointDef.prototype.motorSpeed = null;
b2RevoluteJointDef.prototype.maxMotorTorque = null;var b2MouseJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2MouseJointDef.prototype, b2JointDef.prototype);
b2MouseJointDef.prototype._super = b2JointDef.prototype;
b2MouseJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_mouseJoint;
  this.maxForce = 0;
  this.frequencyHz = 5;
  this.dampingRatio = 0.7
};
b2MouseJointDef.prototype.__varz = function() {
  this.target = new b2Vec2
};
b2MouseJointDef.prototype.target = new b2Vec2;
b2MouseJointDef.prototype.maxForce = null;
b2MouseJointDef.prototype.frequencyHz = null;
b2MouseJointDef.prototype.dampingRatio = null;var b2Contact = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Contact.prototype.__constructor = function() {
};
b2Contact.prototype.__varz = function() {
  this.m_nodeA = new b2ContactEdge;
  this.m_nodeB = new b2ContactEdge;
  this.m_manifold = new b2Manifold;
  this.m_oldManifold = new b2Manifold
};
b2Contact.s_input = new b2TOIInput;
b2Contact.e_sensorFlag = 1;
b2Contact.e_continuousFlag = 2;
b2Contact.e_islandFlag = 4;
b2Contact.e_toiFlag = 8;
b2Contact.e_touchingFlag = 16;
b2Contact.e_enabledFlag = 32;
b2Contact.e_filterFlag = 64;
b2Contact.prototype.Reset = function(fixtureA, fixtureB) {
  this.m_flags = b2Contact.e_enabledFlag;
  if(!fixtureA || !fixtureB) {
    this.m_fixtureA = null;
    this.m_fixtureB = null;
    return
  }
  if(fixtureA.IsSensor() || fixtureB.IsSensor()) {
    this.m_flags |= b2Contact.e_sensorFlag
  }
  var bodyA = fixtureA.GetBody();
  var bodyB = fixtureB.GetBody();
  if(bodyA.GetType() != b2Body.b2_dynamicBody || bodyA.IsBullet() || bodyB.GetType() != b2Body.b2_dynamicBody || bodyB.IsBullet()) {
    this.m_flags |= b2Contact.e_continuousFlag
  }
  this.m_fixtureA = fixtureA;
  this.m_fixtureB = fixtureB;
  this.m_manifold.m_pointCount = 0;
  this.m_prev = null;
  this.m_next = null;
  this.m_nodeA.contact = null;
  this.m_nodeA.prev = null;
  this.m_nodeA.next = null;
  this.m_nodeA.other = null;
  this.m_nodeB.contact = null;
  this.m_nodeB.prev = null;
  this.m_nodeB.next = null;
  this.m_nodeB.other = null
};
b2Contact.prototype.Update = function(listener) {
  var tManifold = this.m_oldManifold;
  this.m_oldManifold = this.m_manifold;
  this.m_manifold = tManifold;
  this.m_flags |= b2Contact.e_enabledFlag;
  var touching = false;
  var wasTouching = (this.m_flags & b2Contact.e_touchingFlag) == b2Contact.e_touchingFlag;
  var bodyA = this.m_fixtureA.m_body;
  var bodyB = this.m_fixtureB.m_body;
  var aabbOverlap = this.m_fixtureA.m_aabb.TestOverlap(this.m_fixtureB.m_aabb);
  if(this.m_flags & b2Contact.e_sensorFlag) {
    if(aabbOverlap) {
      var shapeA = this.m_fixtureA.GetShape();
      var shapeB = this.m_fixtureB.GetShape();
      var xfA = bodyA.GetTransform();
      var xfB = bodyB.GetTransform();
      touching = b2Shape.TestOverlap(shapeA, xfA, shapeB, xfB)
    }
    this.m_manifold.m_pointCount = 0
  }else {
    if(bodyA.GetType() != b2Body.b2_dynamicBody || bodyA.IsBullet() || bodyB.GetType() != b2Body.b2_dynamicBody || bodyB.IsBullet()) {
      this.m_flags |= b2Contact.e_continuousFlag
    }else {
      this.m_flags &= ~b2Contact.e_continuousFlag
    }
    if(aabbOverlap) {
      this.Evaluate();
      touching = this.m_manifold.m_pointCount > 0;
      for(var i = 0;i < this.m_manifold.m_pointCount;++i) {
        var mp2 = this.m_manifold.m_points[i];
        mp2.m_normalImpulse = 0;
        mp2.m_tangentImpulse = 0;
        var id2 = mp2.m_id;
        for(var j = 0;j < this.m_oldManifold.m_pointCount;++j) {
          var mp1 = this.m_oldManifold.m_points[j];
          if(mp1.m_id.key == id2.key) {
            mp2.m_normalImpulse = mp1.m_normalImpulse;
            mp2.m_tangentImpulse = mp1.m_tangentImpulse;
            break
          }
        }
      }
    }else {
      this.m_manifold.m_pointCount = 0
    }
    if(touching != wasTouching) {
      bodyA.SetAwake(true);
      bodyB.SetAwake(true)
    }
  }
  if(touching) {
    this.m_flags |= b2Contact.e_touchingFlag
  }else {
    this.m_flags &= ~b2Contact.e_touchingFlag
  }
  if(wasTouching == false && touching == true) {
    listener.BeginContact(this)
  }
  if(wasTouching == true && touching == false) {
    listener.EndContact(this)
  }
  if((this.m_flags & b2Contact.e_sensorFlag) == 0) {
    listener.PreSolve(this, this.m_oldManifold)
  }
};
b2Contact.prototype.Evaluate = function() {
};
b2Contact.prototype.ComputeTOI = function(sweepA, sweepB) {
  b2Contact.s_input.proxyA.Set(this.m_fixtureA.GetShape());
  b2Contact.s_input.proxyB.Set(this.m_fixtureB.GetShape());
  b2Contact.s_input.sweepA = sweepA;
  b2Contact.s_input.sweepB = sweepB;
  b2Contact.s_input.tolerance = b2Settings.b2_linearSlop;
  return b2TimeOfImpact.TimeOfImpact(b2Contact.s_input)
};
b2Contact.prototype.GetManifold = function() {
  return this.m_manifold
};
b2Contact.prototype.GetWorldManifold = function(worldManifold) {
  var bodyA = this.m_fixtureA.GetBody();
  var bodyB = this.m_fixtureB.GetBody();
  var shapeA = this.m_fixtureA.GetShape();
  var shapeB = this.m_fixtureB.GetShape();
  worldManifold.Initialize(this.m_manifold, bodyA.GetTransform(), shapeA.m_radius, bodyB.GetTransform(), shapeB.m_radius)
};
b2Contact.prototype.IsTouching = function() {
  return(this.m_flags & b2Contact.e_touchingFlag) == b2Contact.e_touchingFlag
};
b2Contact.prototype.IsContinuous = function() {
  return(this.m_flags & b2Contact.e_continuousFlag) == b2Contact.e_continuousFlag
};
b2Contact.prototype.SetSensor = function(sensor) {
  if(sensor) {
    this.m_flags |= b2Contact.e_sensorFlag
  }else {
    this.m_flags &= ~b2Contact.e_sensorFlag
  }
};
b2Contact.prototype.IsSensor = function() {
  return(this.m_flags & b2Contact.e_sensorFlag) == b2Contact.e_sensorFlag
};
b2Contact.prototype.SetEnabled = function(flag) {
  if(flag) {
    this.m_flags |= b2Contact.e_enabledFlag
  }else {
    this.m_flags &= ~b2Contact.e_enabledFlag
  }
};
b2Contact.prototype.IsEnabled = function() {
  return(this.m_flags & b2Contact.e_enabledFlag) == b2Contact.e_enabledFlag
};
b2Contact.prototype.GetNext = function() {
  return this.m_next
};
b2Contact.prototype.GetFixtureA = function() {
  return this.m_fixtureA
};
b2Contact.prototype.GetFixtureB = function() {
  return this.m_fixtureB
};
b2Contact.prototype.FlagForFiltering = function() {
  this.m_flags |= b2Contact.e_filterFlag
};
b2Contact.prototype.m_flags = 0;
b2Contact.prototype.m_prev = null;
b2Contact.prototype.m_next = null;
b2Contact.prototype.m_nodeA = new b2ContactEdge;
b2Contact.prototype.m_nodeB = new b2ContactEdge;
b2Contact.prototype.m_fixtureA = null;
b2Contact.prototype.m_fixtureB = null;
b2Contact.prototype.m_manifold = new b2Manifold;
b2Contact.prototype.m_oldManifold = new b2Manifold;
b2Contact.prototype.m_toi = null;var b2ContactConstraint = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactConstraint.prototype.__constructor = function() {
  this.points = new Array(b2Settings.b2_maxManifoldPoints);
  for(var i = 0;i < b2Settings.b2_maxManifoldPoints;i++) {
    this.points[i] = new b2ContactConstraintPoint
  }
};
b2ContactConstraint.prototype.__varz = function() {
  this.localPlaneNormal = new b2Vec2;
  this.localPoint = new b2Vec2;
  this.normal = new b2Vec2;
  this.normalMass = new b2Mat22;
  this.K = new b2Mat22
};
b2ContactConstraint.prototype.points = null;
b2ContactConstraint.prototype.localPlaneNormal = new b2Vec2;
b2ContactConstraint.prototype.localPoint = new b2Vec2;
b2ContactConstraint.prototype.normal = new b2Vec2;
b2ContactConstraint.prototype.normalMass = new b2Mat22;
b2ContactConstraint.prototype.K = new b2Mat22;
b2ContactConstraint.prototype.bodyA = null;
b2ContactConstraint.prototype.bodyB = null;
b2ContactConstraint.prototype.type = 0;
b2ContactConstraint.prototype.radius = null;
b2ContactConstraint.prototype.friction = null;
b2ContactConstraint.prototype.restitution = null;
b2ContactConstraint.prototype.pointCount = 0;
b2ContactConstraint.prototype.manifold = null;var b2ContactResult = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactResult.prototype.__constructor = function() {
};
b2ContactResult.prototype.__varz = function() {
  this.position = new b2Vec2;
  this.normal = new b2Vec2;
  this.id = new b2ContactID
};
b2ContactResult.prototype.shape1 = null;
b2ContactResult.prototype.shape2 = null;
b2ContactResult.prototype.position = new b2Vec2;
b2ContactResult.prototype.normal = new b2Vec2;
b2ContactResult.prototype.normalImpulse = null;
b2ContactResult.prototype.tangentImpulse = null;
b2ContactResult.prototype.id = new b2ContactID;var b2PolygonContact = function() {
  b2Contact.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2PolygonContact.prototype, b2Contact.prototype);
b2PolygonContact.prototype._super = b2Contact.prototype;
b2PolygonContact.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2PolygonContact.prototype.__varz = function() {
};
b2PolygonContact.Create = function(allocator) {
  return new b2PolygonContact
};
b2PolygonContact.Destroy = function(contact, allocator) {
};
b2PolygonContact.prototype.Evaluate = function() {
  var bA = this.m_fixtureA.GetBody();
  var bB = this.m_fixtureB.GetBody();
  b2Collision.CollidePolygons(this.m_manifold, this.m_fixtureA.GetShape(), bA.m_xf, this.m_fixtureB.GetShape(), bB.m_xf)
};
b2PolygonContact.prototype.Reset = function(fixtureA, fixtureB) {
  this._super.Reset.apply(this, [fixtureA, fixtureB])
};var ClipVertex = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
ClipVertex.prototype.__constructor = function() {
};
ClipVertex.prototype.__varz = function() {
  this.v = new b2Vec2;
  this.id = new b2ContactID
};
ClipVertex.prototype.Set = function(other) {
  this.v.SetV(other.v);
  this.id.Set(other.id)
};
ClipVertex.prototype.v = new b2Vec2;
ClipVertex.prototype.id = new b2ContactID;var b2ContactFilter = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactFilter.prototype.__constructor = function() {
};
b2ContactFilter.prototype.__varz = function() {
};
b2ContactFilter.b2_defaultFilter = new b2ContactFilter;
b2ContactFilter.prototype.ShouldCollide = function(fixtureA, fixtureB) {
  var filter1 = fixtureA.GetFilterData();
  var filter2 = fixtureB.GetFilterData();
  if(filter1.groupIndex == filter2.groupIndex && filter1.groupIndex != 0) {
    return filter1.groupIndex > 0
  }
  var collide = (filter1.maskBits & filter2.categoryBits) != 0 && (filter1.categoryBits & filter2.maskBits) != 0;
  return collide
};
b2ContactFilter.prototype.RayCollide = function(userData, fixture) {
  if(!userData) {
    return true
  }
  return this.ShouldCollide(userData, fixture)
};var b2NullContact = function() {
  b2Contact.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2NullContact.prototype, b2Contact.prototype);
b2NullContact.prototype._super = b2Contact.prototype;
b2NullContact.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2NullContact.prototype.__varz = function() {
};
b2NullContact.prototype.Evaluate = function() {
};var b2ContactListener = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactListener.prototype.__constructor = function() {
};
b2ContactListener.prototype.__varz = function() {
};
b2ContactListener.b2_defaultListener = new b2ContactListener;
b2ContactListener.prototype.BeginContact = function(contact) {
};
b2ContactListener.prototype.EndContact = function(contact) {
};
b2ContactListener.prototype.PreSolve = function(contact, oldManifold) {
};
b2ContactListener.prototype.PostSolve = function(contact, impulse) {
};var b2Island = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Island.prototype.__constructor = function() {
  this.m_bodies = new Array;
  this.m_contacts = new Array;
  this.m_joints = new Array
};
b2Island.prototype.__varz = function() {
};
b2Island.s_impulse = new b2ContactImpulse;
b2Island.prototype.Initialize = function(bodyCapacity, contactCapacity, jointCapacity, allocator, listener, contactSolver) {
  var i = 0;
  this.m_bodyCapacity = bodyCapacity;
  this.m_contactCapacity = contactCapacity;
  this.m_jointCapacity = jointCapacity;
  this.m_bodyCount = 0;
  this.m_contactCount = 0;
  this.m_jointCount = 0;
  this.m_allocator = allocator;
  this.m_listener = listener;
  this.m_contactSolver = contactSolver;
  for(i = this.m_bodies.length;i < bodyCapacity;i++) {
    this.m_bodies[i] = null
  }
  for(i = this.m_contacts.length;i < contactCapacity;i++) {
    this.m_contacts[i] = null
  }
  for(i = this.m_joints.length;i < jointCapacity;i++) {
    this.m_joints[i] = null
  }
};
b2Island.prototype.Clear = function() {
  this.m_bodyCount = 0;
  this.m_contactCount = 0;
  this.m_jointCount = 0
};
b2Island.prototype.Solve = function(step, gravity, allowSleep) {
  var i = 0;
  var j = 0;
  var b;
  var joint;
  for(i = 0;i < this.m_bodyCount;++i) {
    b = this.m_bodies[i];
    if(b.GetType() != b2Body.b2_dynamicBody) {
      continue
    }
    b.m_linearVelocity.x += step.dt * (gravity.x + b.m_invMass * b.m_force.x);
    b.m_linearVelocity.y += step.dt * (gravity.y + b.m_invMass * b.m_force.y);
    b.m_angularVelocity += step.dt * b.m_invI * b.m_torque;
    b.m_linearVelocity.Multiply(b2Math.Clamp(1 - step.dt * b.m_linearDamping, 0, 1));
    b.m_angularVelocity *= b2Math.Clamp(1 - step.dt * b.m_angularDamping, 0, 1)
  }
  this.m_contactSolver.Initialize(step, this.m_contacts, this.m_contactCount, this.m_allocator);
  var contactSolver = this.m_contactSolver;
  contactSolver.InitVelocityConstraints(step);
  for(i = 0;i < this.m_jointCount;++i) {
    joint = this.m_joints[i];
    joint.InitVelocityConstraints(step)
  }
  for(i = 0;i < step.velocityIterations;++i) {
    for(j = 0;j < this.m_jointCount;++j) {
      joint = this.m_joints[j];
      joint.SolveVelocityConstraints(step)
    }
    contactSolver.SolveVelocityConstraints()
  }
  for(i = 0;i < this.m_jointCount;++i) {
    joint = this.m_joints[i];
    joint.FinalizeVelocityConstraints()
  }
  contactSolver.FinalizeVelocityConstraints();
  for(i = 0;i < this.m_bodyCount;++i) {
    b = this.m_bodies[i];
    if(b.GetType() == b2Body.b2_staticBody) {
      continue
    }
    var translationX = step.dt * b.m_linearVelocity.x;
    var translationY = step.dt * b.m_linearVelocity.y;
    if(translationX * translationX + translationY * translationY > b2Settings.b2_maxTranslationSquared) {
      b.m_linearVelocity.Normalize();
      b.m_linearVelocity.x *= b2Settings.b2_maxTranslation * step.inv_dt;
      b.m_linearVelocity.y *= b2Settings.b2_maxTranslation * step.inv_dt
    }
    var rotation = step.dt * b.m_angularVelocity;
    if(rotation * rotation > b2Settings.b2_maxRotationSquared) {
      if(b.m_angularVelocity < 0) {
        b.m_angularVelocity = -b2Settings.b2_maxRotation * step.inv_dt
      }else {
        b.m_angularVelocity = b2Settings.b2_maxRotation * step.inv_dt
      }
    }
    b.m_sweep.c0.SetV(b.m_sweep.c);
    b.m_sweep.a0 = b.m_sweep.a;
    b.m_sweep.c.x += step.dt * b.m_linearVelocity.x;
    b.m_sweep.c.y += step.dt * b.m_linearVelocity.y;
    b.m_sweep.a += step.dt * b.m_angularVelocity;
    b.SynchronizeTransform()
  }
  for(i = 0;i < step.positionIterations;++i) {
    var contactsOkay = contactSolver.SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
    var jointsOkay = true;
    for(j = 0;j < this.m_jointCount;++j) {
      joint = this.m_joints[j];
      var jointOkay = joint.SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
      jointsOkay = jointsOkay && jointOkay
    }
    if(contactsOkay && jointsOkay) {
      break
    }
  }
  this.Report(contactSolver.m_constraints);
  if(allowSleep) {
    var minSleepTime = Number.MAX_VALUE;
    var linTolSqr = b2Settings.b2_linearSleepTolerance * b2Settings.b2_linearSleepTolerance;
    var angTolSqr = b2Settings.b2_angularSleepTolerance * b2Settings.b2_angularSleepTolerance;
    for(i = 0;i < this.m_bodyCount;++i) {
      b = this.m_bodies[i];
      if(b.GetType() == b2Body.b2_staticBody) {
        continue
      }
      if((b.m_flags & b2Body.e_allowSleepFlag) == 0) {
        b.m_sleepTime = 0;
        minSleepTime = 0
      }
      if((b.m_flags & b2Body.e_allowSleepFlag) == 0 || b.m_angularVelocity * b.m_angularVelocity > angTolSqr || b2Math.Dot(b.m_linearVelocity, b.m_linearVelocity) > linTolSqr) {
        b.m_sleepTime = 0;
        minSleepTime = 0
      }else {
        b.m_sleepTime += step.dt;
        minSleepTime = b2Math.Min(minSleepTime, b.m_sleepTime)
      }
    }
    if(minSleepTime >= b2Settings.b2_timeToSleep) {
      for(i = 0;i < this.m_bodyCount;++i) {
        b = this.m_bodies[i];
        b.SetAwake(false)
      }
    }
  }
};
b2Island.prototype.SolveTOI = function(subStep) {
  var i = 0;
  var j = 0;
  this.m_contactSolver.Initialize(subStep, this.m_contacts, this.m_contactCount, this.m_allocator);
  var contactSolver = this.m_contactSolver;
  for(i = 0;i < this.m_jointCount;++i) {
    this.m_joints[i].InitVelocityConstraints(subStep)
  }
  for(i = 0;i < subStep.velocityIterations;++i) {
    contactSolver.SolveVelocityConstraints();
    for(j = 0;j < this.m_jointCount;++j) {
      this.m_joints[j].SolveVelocityConstraints(subStep)
    }
  }
  for(i = 0;i < this.m_bodyCount;++i) {
    var b = this.m_bodies[i];
    if(b.GetType() == b2Body.b2_staticBody) {
      continue
    }
    var translationX = subStep.dt * b.m_linearVelocity.x;
    var translationY = subStep.dt * b.m_linearVelocity.y;
    if(translationX * translationX + translationY * translationY > b2Settings.b2_maxTranslationSquared) {
      b.m_linearVelocity.Normalize();
      b.m_linearVelocity.x *= b2Settings.b2_maxTranslation * subStep.inv_dt;
      b.m_linearVelocity.y *= b2Settings.b2_maxTranslation * subStep.inv_dt
    }
    var rotation = subStep.dt * b.m_angularVelocity;
    if(rotation * rotation > b2Settings.b2_maxRotationSquared) {
      if(b.m_angularVelocity < 0) {
        b.m_angularVelocity = -b2Settings.b2_maxRotation * subStep.inv_dt
      }else {
        b.m_angularVelocity = b2Settings.b2_maxRotation * subStep.inv_dt
      }
    }
    b.m_sweep.c0.SetV(b.m_sweep.c);
    b.m_sweep.a0 = b.m_sweep.a;
    b.m_sweep.c.x += subStep.dt * b.m_linearVelocity.x;
    b.m_sweep.c.y += subStep.dt * b.m_linearVelocity.y;
    b.m_sweep.a += subStep.dt * b.m_angularVelocity;
    b.SynchronizeTransform()
  }
  var k_toiBaumgarte = 0.75;
  for(i = 0;i < subStep.positionIterations;++i) {
    var contactsOkay = contactSolver.SolvePositionConstraints(k_toiBaumgarte);
    var jointsOkay = true;
    for(j = 0;j < this.m_jointCount;++j) {
      var jointOkay = this.m_joints[j].SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
      jointsOkay = jointsOkay && jointOkay
    }
    if(contactsOkay && jointsOkay) {
      break
    }
  }
  this.Report(contactSolver.m_constraints)
};
b2Island.prototype.Report = function(constraints) {
  if(this.m_listener == null) {
    return
  }
  for(var i = 0;i < this.m_contactCount;++i) {
    var c = this.m_contacts[i];
    var cc = constraints[i];
    for(var j = 0;j < cc.pointCount;++j) {
      b2Island.s_impulse.normalImpulses[j] = cc.points[j].normalImpulse;
      b2Island.s_impulse.tangentImpulses[j] = cc.points[j].tangentImpulse
    }
    this.m_listener.PostSolve(c, b2Island.s_impulse)
  }
};
b2Island.prototype.AddBody = function(body) {
  body.m_islandIndex = this.m_bodyCount;
  this.m_bodies[this.m_bodyCount++] = body
};
b2Island.prototype.AddContact = function(contact) {
  this.m_contacts[this.m_contactCount++] = contact
};
b2Island.prototype.AddJoint = function(joint) {
  this.m_joints[this.m_jointCount++] = joint
};
b2Island.prototype.m_allocator = null;
b2Island.prototype.m_listener = null;
b2Island.prototype.m_contactSolver = null;
b2Island.prototype.m_bodies = null;
b2Island.prototype.m_contacts = null;
b2Island.prototype.m_joints = null;
b2Island.prototype.m_bodyCount = 0;
b2Island.prototype.m_jointCount = 0;
b2Island.prototype.m_contactCount = 0;
b2Island.prototype.m_bodyCapacity = 0;
b2Island.prototype.m_contactCapacity = 0;
b2Island.prototype.m_jointCapacity = 0;var b2PolyAndEdgeContact = function() {
  b2Contact.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2PolyAndEdgeContact.prototype, b2Contact.prototype);
b2PolyAndEdgeContact.prototype._super = b2Contact.prototype;
b2PolyAndEdgeContact.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2PolyAndEdgeContact.prototype.__varz = function() {
};
b2PolyAndEdgeContact.Create = function(allocator) {
  return new b2PolyAndEdgeContact
};
b2PolyAndEdgeContact.Destroy = function(contact, allocator) {
};
b2PolyAndEdgeContact.prototype.Evaluate = function() {
  var bA = this.m_fixtureA.GetBody();
  var bB = this.m_fixtureB.GetBody();
  this.b2CollidePolyAndEdge(this.m_manifold, this.m_fixtureA.GetShape(), bA.m_xf, this.m_fixtureB.GetShape(), bB.m_xf)
};
b2PolyAndEdgeContact.prototype.b2CollidePolyAndEdge = function(manifold, polygon, xf1, edge, xf2) {
};
b2PolyAndEdgeContact.prototype.Reset = function(fixtureA, fixtureB) {
  this._super.Reset.apply(this, [fixtureA, fixtureB]);
  b2Settings.b2Assert(fixtureA.GetType() == b2Shape.e_polygonShape);
  b2Settings.b2Assert(fixtureB.GetType() == b2Shape.e_edgeShape)
};var b2Collision = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Collision.prototype.__constructor = function() {
};
b2Collision.prototype.__varz = function() {
};
b2Collision.MakeClipPointVector = function() {
  var r = new Array(2);
  r[0] = new ClipVertex;
  r[1] = new ClipVertex;
  return r
};
b2Collision.ClipSegmentToLine = function(vOut, vIn, normal, offset) {
  var cv;
  var numOut = 0;
  cv = vIn[0];
  var vIn0 = cv.v;
  cv = vIn[1];
  var vIn1 = cv.v;
  var distance0 = normal.x * vIn0.x + normal.y * vIn0.y - offset;
  var distance1 = normal.x * vIn1.x + normal.y * vIn1.y - offset;
  if(distance0 <= 0) {
    vOut[numOut++].Set(vIn[0])
  }
  if(distance1 <= 0) {
    vOut[numOut++].Set(vIn[1])
  }
  if(distance0 * distance1 < 0) {
    var interp = distance0 / (distance0 - distance1);
    cv = vOut[numOut];
    var tVec = cv.v;
    tVec.x = vIn0.x + interp * (vIn1.x - vIn0.x);
    tVec.y = vIn0.y + interp * (vIn1.y - vIn0.y);
    cv = vOut[numOut];
    var cv2;
    if(distance0 > 0) {
      cv2 = vIn[0];
      cv.id = cv2.id
    }else {
      cv2 = vIn[1];
      cv.id = cv2.id
    }
    ++numOut
  }
  return numOut
};
b2Collision.EdgeSeparation = function(poly1, xf1, edge1, poly2, xf2) {
  var count1 = poly1.m_vertexCount;
  var vertices1 = poly1.m_vertices;
  var normals1 = poly1.m_normals;
  var count2 = poly2.m_vertexCount;
  var vertices2 = poly2.m_vertices;
  var tMat;
  var tVec;
  tMat = xf1.R;
  tVec = normals1[edge1];
  var normal1WorldX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
  var normal1WorldY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
  tMat = xf2.R;
  var normal1X = tMat.col1.x * normal1WorldX + tMat.col1.y * normal1WorldY;
  var normal1Y = tMat.col2.x * normal1WorldX + tMat.col2.y * normal1WorldY;
  var index = 0;
  var minDot = Number.MAX_VALUE;
  for(var i = 0;i < count2;++i) {
    tVec = vertices2[i];
    var dot = tVec.x * normal1X + tVec.y * normal1Y;
    if(dot < minDot) {
      minDot = dot;
      index = i
    }
  }
  tVec = vertices1[edge1];
  tMat = xf1.R;
  var v1X = xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  var v1Y = xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  tVec = vertices2[index];
  tMat = xf2.R;
  var v2X = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  var v2Y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  v2X -= v1X;
  v2Y -= v1Y;
  var separation = v2X * normal1WorldX + v2Y * normal1WorldY;
  return separation
};
b2Collision.FindMaxSeparation = function(edgeIndex, poly1, xf1, poly2, xf2) {
  var count1 = poly1.m_vertexCount;
  var normals1 = poly1.m_normals;
  var tVec;
  var tMat;
  tMat = xf2.R;
  tVec = poly2.m_centroid;
  var dX = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  var dY = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  tMat = xf1.R;
  tVec = poly1.m_centroid;
  dX -= xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  dY -= xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  var dLocal1X = dX * xf1.R.col1.x + dY * xf1.R.col1.y;
  var dLocal1Y = dX * xf1.R.col2.x + dY * xf1.R.col2.y;
  var edge = 0;
  var maxDot = -Number.MAX_VALUE;
  for(var i = 0;i < count1;++i) {
    tVec = normals1[i];
    var dot = tVec.x * dLocal1X + tVec.y * dLocal1Y;
    if(dot > maxDot) {
      maxDot = dot;
      edge = i
    }
  }
  var s = b2Collision.EdgeSeparation(poly1, xf1, edge, poly2, xf2);
  var prevEdge = edge - 1 >= 0 ? edge - 1 : count1 - 1;
  var sPrev = b2Collision.EdgeSeparation(poly1, xf1, prevEdge, poly2, xf2);
  var nextEdge = edge + 1 < count1 ? edge + 1 : 0;
  var sNext = b2Collision.EdgeSeparation(poly1, xf1, nextEdge, poly2, xf2);
  var bestEdge = 0;
  var bestSeparation;
  var increment = 0;
  if(sPrev > s && sPrev > sNext) {
    increment = -1;
    bestEdge = prevEdge;
    bestSeparation = sPrev
  }else {
    if(sNext > s) {
      increment = 1;
      bestEdge = nextEdge;
      bestSeparation = sNext
    }else {
      edgeIndex[0] = edge;
      return s
    }
  }
  while(true) {
    if(increment == -1) {
      edge = bestEdge - 1 >= 0 ? bestEdge - 1 : count1 - 1
    }else {
      edge = bestEdge + 1 < count1 ? bestEdge + 1 : 0
    }
    s = b2Collision.EdgeSeparation(poly1, xf1, edge, poly2, xf2);
    if(s > bestSeparation) {
      bestEdge = edge;
      bestSeparation = s
    }else {
      break
    }
  }
  edgeIndex[0] = bestEdge;
  return bestSeparation
};
b2Collision.FindIncidentEdge = function(c, poly1, xf1, edge1, poly2, xf2) {
  var count1 = poly1.m_vertexCount;
  var normals1 = poly1.m_normals;
  var count2 = poly2.m_vertexCount;
  var vertices2 = poly2.m_vertices;
  var normals2 = poly2.m_normals;
  var tMat;
  var tVec;
  tMat = xf1.R;
  tVec = normals1[edge1];
  var normal1X = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
  var normal1Y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
  tMat = xf2.R;
  var tX = tMat.col1.x * normal1X + tMat.col1.y * normal1Y;
  normal1Y = tMat.col2.x * normal1X + tMat.col2.y * normal1Y;
  normal1X = tX;
  var index = 0;
  var minDot = Number.MAX_VALUE;
  for(var i = 0;i < count2;++i) {
    tVec = normals2[i];
    var dot = normal1X * tVec.x + normal1Y * tVec.y;
    if(dot < minDot) {
      minDot = dot;
      index = i
    }
  }
  var tClip;
  var i1 = index;
  var i2 = i1 + 1 < count2 ? i1 + 1 : 0;
  tClip = c[0];
  tVec = vertices2[i1];
  tMat = xf2.R;
  tClip.v.x = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  tClip.v.y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  tClip.id.features.referenceEdge = edge1;
  tClip.id.features.incidentEdge = i1;
  tClip.id.features.incidentVertex = 0;
  tClip = c[1];
  tVec = vertices2[i2];
  tMat = xf2.R;
  tClip.v.x = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  tClip.v.y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  tClip.id.features.referenceEdge = edge1;
  tClip.id.features.incidentEdge = i2;
  tClip.id.features.incidentVertex = 1
};
b2Collision.CollidePolygons = function(manifold, polyA, xfA, polyB, xfB) {
  var cv;
  manifold.m_pointCount = 0;
  var totalRadius = polyA.m_radius + polyB.m_radius;
  var edgeA = 0;
  b2Collision.s_edgeAO[0] = edgeA;
  var separationA = b2Collision.FindMaxSeparation(b2Collision.s_edgeAO, polyA, xfA, polyB, xfB);
  edgeA = b2Collision.s_edgeAO[0];
  if(separationA > totalRadius) {
    return
  }
  var edgeB = 0;
  b2Collision.s_edgeBO[0] = edgeB;
  var separationB = b2Collision.FindMaxSeparation(b2Collision.s_edgeBO, polyB, xfB, polyA, xfA);
  edgeB = b2Collision.s_edgeBO[0];
  if(separationB > totalRadius) {
    return
  }
  var poly1;
  var poly2;
  var xf1;
  var xf2;
  var edge1 = 0;
  var flip = 0;
  var k_relativeTol = 0.98;
  var k_absoluteTol = 0.0010;
  var tMat;
  if(separationB > k_relativeTol * separationA + k_absoluteTol) {
    poly1 = polyB;
    poly2 = polyA;
    xf1 = xfB;
    xf2 = xfA;
    edge1 = edgeB;
    manifold.m_type = b2Manifold.e_faceB;
    flip = 1
  }else {
    poly1 = polyA;
    poly2 = polyB;
    xf1 = xfA;
    xf2 = xfB;
    edge1 = edgeA;
    manifold.m_type = b2Manifold.e_faceA;
    flip = 0
  }
  var incidentEdge = b2Collision.s_incidentEdge;
  b2Collision.FindIncidentEdge(incidentEdge, poly1, xf1, edge1, poly2, xf2);
  var count1 = poly1.m_vertexCount;
  var vertices1 = poly1.m_vertices;
  var local_v11 = vertices1[edge1];
  var local_v12;
  if(edge1 + 1 < count1) {
    local_v12 = vertices1[parseInt(edge1 + 1)]
  }else {
    local_v12 = vertices1[0]
  }
  var localTangent = b2Collision.s_localTangent;
  localTangent.Set(local_v12.x - local_v11.x, local_v12.y - local_v11.y);
  localTangent.Normalize();
  var localNormal = b2Collision.s_localNormal;
  localNormal.x = localTangent.y;
  localNormal.y = -localTangent.x;
  var planePoint = b2Collision.s_planePoint;
  planePoint.Set(0.5 * (local_v11.x + local_v12.x), 0.5 * (local_v11.y + local_v12.y));
  var tangent = b2Collision.s_tangent;
  tMat = xf1.R;
  tangent.x = tMat.col1.x * localTangent.x + tMat.col2.x * localTangent.y;
  tangent.y = tMat.col1.y * localTangent.x + tMat.col2.y * localTangent.y;
  var tangent2 = b2Collision.s_tangent2;
  tangent2.x = -tangent.x;
  tangent2.y = -tangent.y;
  var normal = b2Collision.s_normal;
  normal.x = tangent.y;
  normal.y = -tangent.x;
  var v11 = b2Collision.s_v11;
  var v12 = b2Collision.s_v12;
  v11.x = xf1.position.x + (tMat.col1.x * local_v11.x + tMat.col2.x * local_v11.y);
  v11.y = xf1.position.y + (tMat.col1.y * local_v11.x + tMat.col2.y * local_v11.y);
  v12.x = xf1.position.x + (tMat.col1.x * local_v12.x + tMat.col2.x * local_v12.y);
  v12.y = xf1.position.y + (tMat.col1.y * local_v12.x + tMat.col2.y * local_v12.y);
  var frontOffset = normal.x * v11.x + normal.y * v11.y;
  var sideOffset1 = -tangent.x * v11.x - tangent.y * v11.y + totalRadius;
  var sideOffset2 = tangent.x * v12.x + tangent.y * v12.y + totalRadius;
  var clipPoints1 = b2Collision.s_clipPoints1;
  var clipPoints2 = b2Collision.s_clipPoints2;
  var np = 0;
  np = b2Collision.ClipSegmentToLine(clipPoints1, incidentEdge, tangent2, sideOffset1);
  if(np < 2) {
    return
  }
  np = b2Collision.ClipSegmentToLine(clipPoints2, clipPoints1, tangent, sideOffset2);
  if(np < 2) {
    return
  }
  manifold.m_localPlaneNormal.SetV(localNormal);
  manifold.m_localPoint.SetV(planePoint);
  var pointCount = 0;
  for(var i = 0;i < b2Settings.b2_maxManifoldPoints;++i) {
    cv = clipPoints2[i];
    var separation = normal.x * cv.v.x + normal.y * cv.v.y - frontOffset;
    if(separation <= totalRadius) {
      var cp = manifold.m_points[pointCount];
      tMat = xf2.R;
      var tX = cv.v.x - xf2.position.x;
      var tY = cv.v.y - xf2.position.y;
      cp.m_localPoint.x = tX * tMat.col1.x + tY * tMat.col1.y;
      cp.m_localPoint.y = tX * tMat.col2.x + tY * tMat.col2.y;
      cp.m_id.Set(cv.id);
      cp.m_id.features.flip = flip;
      ++pointCount
    }
  }
  manifold.m_pointCount = pointCount
};
b2Collision.CollideCircles = function(manifold, circle1, xf1, circle2, xf2) {
  manifold.m_pointCount = 0;
  var tMat;
  var tVec;
  tMat = xf1.R;
  tVec = circle1.m_p;
  var p1X = xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  var p1Y = xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  tMat = xf2.R;
  tVec = circle2.m_p;
  var p2X = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  var p2Y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  var dX = p2X - p1X;
  var dY = p2Y - p1Y;
  var distSqr = dX * dX + dY * dY;
  var radius = circle1.m_radius + circle2.m_radius;
  if(distSqr > radius * radius) {
    return
  }
  manifold.m_type = b2Manifold.e_circles;
  manifold.m_localPoint.SetV(circle1.m_p);
  manifold.m_localPlaneNormal.SetZero();
  manifold.m_pointCount = 1;
  manifold.m_points[0].m_localPoint.SetV(circle2.m_p);
  manifold.m_points[0].m_id.key = 0
};
b2Collision.CollidePolygonAndCircle = function(manifold, polygon, xf1, circle, xf2) {
  manifold.m_pointCount = 0;
  var tPoint;
  var dX;
  var dY;
  var positionX;
  var positionY;
  var tVec;
  var tMat;
  tMat = xf2.R;
  tVec = circle.m_p;
  var cX = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  var cY = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  dX = cX - xf1.position.x;
  dY = cY - xf1.position.y;
  tMat = xf1.R;
  var cLocalX = dX * tMat.col1.x + dY * tMat.col1.y;
  var cLocalY = dX * tMat.col2.x + dY * tMat.col2.y;
  var dist;
  var normalIndex = 0;
  var separation = -Number.MAX_VALUE;
  var radius = polygon.m_radius + circle.m_radius;
  var vertexCount = polygon.m_vertexCount;
  var vertices = polygon.m_vertices;
  var normals = polygon.m_normals;
  for(var i = 0;i < vertexCount;++i) {
    tVec = vertices[i];
    dX = cLocalX - tVec.x;
    dY = cLocalY - tVec.y;
    tVec = normals[i];
    var s = tVec.x * dX + tVec.y * dY;
    if(s > radius) {
      return
    }
    if(s > separation) {
      separation = s;
      normalIndex = i
    }
  }
  var vertIndex1 = normalIndex;
  var vertIndex2 = vertIndex1 + 1 < vertexCount ? vertIndex1 + 1 : 0;
  var v1 = vertices[vertIndex1];
  var v2 = vertices[vertIndex2];
  if(separation < Number.MIN_VALUE) {
    manifold.m_pointCount = 1;
    manifold.m_type = b2Manifold.e_faceA;
    manifold.m_localPlaneNormal.SetV(normals[normalIndex]);
    manifold.m_localPoint.x = 0.5 * (v1.x + v2.x);
    manifold.m_localPoint.y = 0.5 * (v1.y + v2.y);
    manifold.m_points[0].m_localPoint.SetV(circle.m_p);
    manifold.m_points[0].m_id.key = 0;
    return
  }
  var u1 = (cLocalX - v1.x) * (v2.x - v1.x) + (cLocalY - v1.y) * (v2.y - v1.y);
  var u2 = (cLocalX - v2.x) * (v1.x - v2.x) + (cLocalY - v2.y) * (v1.y - v2.y);
  if(u1 <= 0) {
    if((cLocalX - v1.x) * (cLocalX - v1.x) + (cLocalY - v1.y) * (cLocalY - v1.y) > radius * radius) {
      return
    }
    manifold.m_pointCount = 1;
    manifold.m_type = b2Manifold.e_faceA;
    manifold.m_localPlaneNormal.x = cLocalX - v1.x;
    manifold.m_localPlaneNormal.y = cLocalY - v1.y;
    manifold.m_localPlaneNormal.Normalize();
    manifold.m_localPoint.SetV(v1);
    manifold.m_points[0].m_localPoint.SetV(circle.m_p);
    manifold.m_points[0].m_id.key = 0
  }else {
    if(u2 <= 0) {
      if((cLocalX - v2.x) * (cLocalX - v2.x) + (cLocalY - v2.y) * (cLocalY - v2.y) > radius * radius) {
        return
      }
      manifold.m_pointCount = 1;
      manifold.m_type = b2Manifold.e_faceA;
      manifold.m_localPlaneNormal.x = cLocalX - v2.x;
      manifold.m_localPlaneNormal.y = cLocalY - v2.y;
      manifold.m_localPlaneNormal.Normalize();
      manifold.m_localPoint.SetV(v2);
      manifold.m_points[0].m_localPoint.SetV(circle.m_p);
      manifold.m_points[0].m_id.key = 0
    }else {
      var faceCenterX = 0.5 * (v1.x + v2.x);
      var faceCenterY = 0.5 * (v1.y + v2.y);
      separation = (cLocalX - faceCenterX) * normals[vertIndex1].x + (cLocalY - faceCenterY) * normals[vertIndex1].y;
      if(separation > radius) {
        return
      }
      manifold.m_pointCount = 1;
      manifold.m_type = b2Manifold.e_faceA;
      manifold.m_localPlaneNormal.x = normals[vertIndex1].x;
      manifold.m_localPlaneNormal.y = normals[vertIndex1].y;
      manifold.m_localPlaneNormal.Normalize();
      manifold.m_localPoint.Set(faceCenterX, faceCenterY);
      manifold.m_points[0].m_localPoint.SetV(circle.m_p);
      manifold.m_points[0].m_id.key = 0
    }
  }
};
b2Collision.TestOverlap = function(a, b) {
  var t1 = b.lowerBound;
  var t2 = a.upperBound;
  var d1X = t1.x - t2.x;
  var d1Y = t1.y - t2.y;
  t1 = a.lowerBound;
  t2 = b.upperBound;
  var d2X = t1.x - t2.x;
  var d2Y = t1.y - t2.y;
  if(d1X > 0 || d1Y > 0) {
    return false
  }
  if(d2X > 0 || d2Y > 0) {
    return false
  }
  return true
};
b2Collision.b2_nullFeature = 255;
b2Collision.s_incidentEdge = b2Collision.MakeClipPointVector();
b2Collision.s_clipPoints1 = b2Collision.MakeClipPointVector();
b2Collision.s_clipPoints2 = b2Collision.MakeClipPointVector();
b2Collision.s_edgeAO = new Array(1);
b2Collision.s_edgeBO = new Array(1);
b2Collision.s_localTangent = new b2Vec2;
b2Collision.s_localNormal = new b2Vec2;
b2Collision.s_planePoint = new b2Vec2;
b2Collision.s_normal = new b2Vec2;
b2Collision.s_tangent = new b2Vec2;
b2Collision.s_tangent2 = new b2Vec2;
b2Collision.s_v11 = new b2Vec2;
b2Collision.s_v12 = new b2Vec2;
b2Collision.b2CollidePolyTempVec = new b2Vec2;var b2PolyAndCircleContact = function() {
  b2Contact.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2PolyAndCircleContact.prototype, b2Contact.prototype);
b2PolyAndCircleContact.prototype._super = b2Contact.prototype;
b2PolyAndCircleContact.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2PolyAndCircleContact.prototype.__varz = function() {
};
b2PolyAndCircleContact.Create = function(allocator) {
  return new b2PolyAndCircleContact
};
b2PolyAndCircleContact.Destroy = function(contact, allocator) {
};
b2PolyAndCircleContact.prototype.Evaluate = function() {
  var bA = this.m_fixtureA.m_body;
  var bB = this.m_fixtureB.m_body;
  b2Collision.CollidePolygonAndCircle(this.m_manifold, this.m_fixtureA.GetShape(), bA.m_xf, this.m_fixtureB.GetShape(), bB.m_xf)
};
b2PolyAndCircleContact.prototype.Reset = function(fixtureA, fixtureB) {
  this._super.Reset.apply(this, [fixtureA, fixtureB]);
  b2Settings.b2Assert(fixtureA.GetType() == b2Shape.e_polygonShape);
  b2Settings.b2Assert(fixtureB.GetType() == b2Shape.e_circleShape)
};var b2ContactPoint = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactPoint.prototype.__constructor = function() {
};
b2ContactPoint.prototype.__varz = function() {
  this.position = new b2Vec2;
  this.velocity = new b2Vec2;
  this.normal = new b2Vec2;
  this.id = new b2ContactID
};
b2ContactPoint.prototype.shape1 = null;
b2ContactPoint.prototype.shape2 = null;
b2ContactPoint.prototype.position = new b2Vec2;
b2ContactPoint.prototype.velocity = new b2Vec2;
b2ContactPoint.prototype.normal = new b2Vec2;
b2ContactPoint.prototype.separation = null;
b2ContactPoint.prototype.friction = null;
b2ContactPoint.prototype.restitution = null;
b2ContactPoint.prototype.id = new b2ContactID;var b2CircleContact = function() {
  b2Contact.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2CircleContact.prototype, b2Contact.prototype);
b2CircleContact.prototype._super = b2Contact.prototype;
b2CircleContact.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2CircleContact.prototype.__varz = function() {
};
b2CircleContact.Create = function(allocator) {
  return new b2CircleContact
};
b2CircleContact.Destroy = function(contact, allocator) {
};
b2CircleContact.prototype.Evaluate = function() {
  var bA = this.m_fixtureA.GetBody();
  var bB = this.m_fixtureB.GetBody();
  b2Collision.CollideCircles(this.m_manifold, this.m_fixtureA.GetShape(), bA.m_xf, this.m_fixtureB.GetShape(), bB.m_xf)
};
b2CircleContact.prototype.Reset = function(fixtureA, fixtureB) {
  this._super.Reset.apply(this, [fixtureA, fixtureB])
};var b2EdgeAndCircleContact = function() {
  b2Contact.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2EdgeAndCircleContact.prototype, b2Contact.prototype);
b2EdgeAndCircleContact.prototype._super = b2Contact.prototype;
b2EdgeAndCircleContact.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2EdgeAndCircleContact.prototype.__varz = function() {
};
b2EdgeAndCircleContact.Create = function(allocator) {
  return new b2EdgeAndCircleContact
};
b2EdgeAndCircleContact.Destroy = function(contact, allocator) {
};
b2EdgeAndCircleContact.prototype.Evaluate = function() {
  var bA = this.m_fixtureA.GetBody();
  var bB = this.m_fixtureB.GetBody();
  this.b2CollideEdgeAndCircle(this.m_manifold, this.m_fixtureA.GetShape(), bA.m_xf, this.m_fixtureB.GetShape(), bB.m_xf)
};
b2EdgeAndCircleContact.prototype.b2CollideEdgeAndCircle = function(manifold, edge, xf1, circle, xf2) {
};
b2EdgeAndCircleContact.prototype.Reset = function(fixtureA, fixtureB) {
  this._super.Reset.apply(this, [fixtureA, fixtureB])
};var b2ContactManager = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactManager.prototype.__constructor = function() {
  this.m_world = null;
  this.m_contactCount = 0;
  this.m_contactFilter = b2ContactFilter.b2_defaultFilter;
  this.m_contactListener = b2ContactListener.b2_defaultListener;
  this.m_contactFactory = new b2ContactFactory(this.m_allocator);
  this.m_broadPhase = new b2DynamicTreeBroadPhase
};
b2ContactManager.prototype.__varz = function() {
};
b2ContactManager.s_evalCP = new b2ContactPoint;
b2ContactManager.prototype.AddPair = function(proxyUserDataA, proxyUserDataB) {
  var fixtureA = proxyUserDataA;
  var fixtureB = proxyUserDataB;
  var bodyA = fixtureA.GetBody();
  var bodyB = fixtureB.GetBody();
  if(bodyA == bodyB) {
    return
  }
  var edge = bodyB.GetContactList();
  while(edge) {
    if(edge.other == bodyA) {
      var fA = edge.contact.GetFixtureA();
      var fB = edge.contact.GetFixtureB();
      if(fA == fixtureA && fB == fixtureB) {
        return
      }
      if(fA == fixtureB && fB == fixtureA) {
        return
      }
    }
    edge = edge.next
  }
  if(bodyB.ShouldCollide(bodyA) == false) {
    return
  }
  if(this.m_contactFilter.ShouldCollide(fixtureA, fixtureB) == false) {
    return
  }
  var c = this.m_contactFactory.Create(fixtureA, fixtureB);
  fixtureA = c.GetFixtureA();
  fixtureB = c.GetFixtureB();
  bodyA = fixtureA.m_body;
  bodyB = fixtureB.m_body;
  c.m_prev = null;
  c.m_next = this.m_world.m_contactList;
  if(this.m_world.m_contactList != null) {
    this.m_world.m_contactList.m_prev = c
  }
  this.m_world.m_contactList = c;
  c.m_nodeA.contact = c;
  c.m_nodeA.other = bodyB;
  c.m_nodeA.prev = null;
  c.m_nodeA.next = bodyA.m_contactList;
  if(bodyA.m_contactList != null) {
    bodyA.m_contactList.prev = c.m_nodeA
  }
  bodyA.m_contactList = c.m_nodeA;
  c.m_nodeB.contact = c;
  c.m_nodeB.other = bodyA;
  c.m_nodeB.prev = null;
  c.m_nodeB.next = bodyB.m_contactList;
  if(bodyB.m_contactList != null) {
    bodyB.m_contactList.prev = c.m_nodeB
  }
  bodyB.m_contactList = c.m_nodeB;
  ++this.m_world.m_contactCount;
  return
};
b2ContactManager.prototype.FindNewContacts = function() {
  var that = this;
  this.m_broadPhase.UpdatePairs(function(a, b) {
    return that.AddPair(a, b)
  })
};
b2ContactManager.prototype.Destroy = function(c) {
  var fixtureA = c.GetFixtureA();
  var fixtureB = c.GetFixtureB();
  var bodyA = fixtureA.GetBody();
  var bodyB = fixtureB.GetBody();
  if(c.IsTouching()) {
    this.m_contactListener.EndContact(c)
  }
  if(c.m_prev) {
    c.m_prev.m_next = c.m_next
  }
  if(c.m_next) {
    c.m_next.m_prev = c.m_prev
  }
  if(c == this.m_world.m_contactList) {
    this.m_world.m_contactList = c.m_next
  }
  if(c.m_nodeA.prev) {
    c.m_nodeA.prev.next = c.m_nodeA.next
  }
  if(c.m_nodeA.next) {
    c.m_nodeA.next.prev = c.m_nodeA.prev
  }
  if(c.m_nodeA == bodyA.m_contactList) {
    bodyA.m_contactList = c.m_nodeA.next
  }
  if(c.m_nodeB.prev) {
    c.m_nodeB.prev.next = c.m_nodeB.next
  }
  if(c.m_nodeB.next) {
    c.m_nodeB.next.prev = c.m_nodeB.prev
  }
  if(c.m_nodeB == bodyB.m_contactList) {
    bodyB.m_contactList = c.m_nodeB.next
  }
  this.m_contactFactory.Destroy(c);
  --this.m_contactCount
};
b2ContactManager.prototype.Collide = function() {
  var c = this.m_world.m_contactList;
  while(c) {
    var fixtureA = c.GetFixtureA();
    var fixtureB = c.GetFixtureB();
    var bodyA = fixtureA.GetBody();
    var bodyB = fixtureB.GetBody();
    if(bodyA.IsAwake() == false && bodyB.IsAwake() == false) {
      c = c.GetNext();
      continue
    }
    if(c.m_flags & b2Contact.e_filterFlag) {
      if(bodyB.ShouldCollide(bodyA) == false) {
        var cNuke = c;
        c = cNuke.GetNext();
        this.Destroy(cNuke);
        continue
      }
      if(this.m_contactFilter.ShouldCollide(fixtureA, fixtureB) == false) {
        cNuke = c;
        c = cNuke.GetNext();
        this.Destroy(cNuke);
        continue
      }
      c.m_flags &= ~b2Contact.e_filterFlag
    }
    var proxyA = fixtureA.m_proxy;
    var proxyB = fixtureB.m_proxy;
    var overlap = this.m_broadPhase.TestOverlap(proxyA, proxyB);
    if(overlap == false) {
      cNuke = c;
      c = cNuke.GetNext();
      this.Destroy(cNuke);
      continue
    }
    c.Update(this.m_contactListener);
    c = c.GetNext()
  }
};
b2ContactManager.prototype.m_world = null;
b2ContactManager.prototype.m_broadPhase = null;
b2ContactManager.prototype.m_contactList = null;
b2ContactManager.prototype.m_contactCount = 0;
b2ContactManager.prototype.m_contactFilter = null;
b2ContactManager.prototype.m_contactListener = null;
b2ContactManager.prototype.m_contactFactory = null;
b2ContactManager.prototype.m_allocator = null;var b2World = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2World.prototype.__constructor = function(gravity, doSleep) {
  this.m_destructionListener = null;
  this.m_debugDraw = null;
  this.m_bodyList = null;
  this.m_contactList = null;
  this.m_jointList = null;
  this.m_controllerList = null;
  this.m_bodyCount = 0;
  this.m_contactCount = 0;
  this.m_jointCount = 0;
  this.m_controllerCount = 0;
  b2World.m_warmStarting = true;
  b2World.m_continuousPhysics = true;
  this.m_allowSleep = doSleep;
  this.m_gravity = gravity;
  this.m_inv_dt0 = 0;
  this.m_contactManager.m_world = this;
  var bd = new b2BodyDef;
  this.m_groundBody = this.CreateBody(bd)
};
b2World.prototype.__varz = function() {
  this.s_stack = new Array;
  this.m_contactManager = new b2ContactManager;
  this.m_contactSolver = new b2ContactSolver;
  this.m_island = new b2Island
};
b2World.s_timestep2 = new b2TimeStep;
b2World.s_backupA = new b2Sweep;
b2World.s_backupB = new b2Sweep;
b2World.s_timestep = new b2TimeStep;
b2World.s_queue = new Array;
b2World.e_newFixture = 1;
b2World.e_locked = 2;
b2World.s_xf = new b2Transform;
b2World.s_jointColor = new b2Color(0.5, 0.8, 0.8);
b2World.m_warmStarting = null;
b2World.m_continuousPhysics = null;
b2World.prototype.Solve = function(step) {
  var b;
  for(var controller = this.m_controllerList;controller;controller = controller.m_next) {
    controller.Step(step)
  }
  var island = this.m_island;
  island.Initialize(this.m_bodyCount, this.m_contactCount, this.m_jointCount, null, this.m_contactManager.m_contactListener, this.m_contactSolver);
  for(b = this.m_bodyList;b;b = b.m_next) {
    b.m_flags &= ~b2Body.e_islandFlag
  }
  for(var c = this.m_contactList;c;c = c.m_next) {
    c.m_flags &= ~b2Contact.e_islandFlag
  }
  for(var j = this.m_jointList;j;j = j.m_next) {
    j.m_islandFlag = false
  }
  var stackSize = this.m_bodyCount;
  var stack = this.s_stack;
  for(var seed = this.m_bodyList;seed;seed = seed.m_next) {
    if(seed.m_flags & b2Body.e_islandFlag) {
      continue
    }
    if(seed.IsAwake() == false || seed.IsActive() == false) {
      continue
    }
    if(seed.GetType() == b2Body.b2_staticBody) {
      continue
    }
    island.Clear();
    var stackCount = 0;
    stack[stackCount++] = seed;
    seed.m_flags |= b2Body.e_islandFlag;
    while(stackCount > 0) {
      b = stack[--stackCount];
      island.AddBody(b);
      if(b.IsAwake() == false) {
        b.SetAwake(true)
      }
      if(b.GetType() == b2Body.b2_staticBody) {
        continue
      }
      var other;
      for(var ce = b.m_contactList;ce;ce = ce.next) {
        if(ce.contact.m_flags & b2Contact.e_islandFlag) {
          continue
        }
        if(ce.contact.IsSensor() == true || ce.contact.IsEnabled() == false || ce.contact.IsTouching() == false) {
          continue
        }
        island.AddContact(ce.contact);
        ce.contact.m_flags |= b2Contact.e_islandFlag;
        other = ce.other;
        if(other.m_flags & b2Body.e_islandFlag) {
          continue
        }
        stack[stackCount++] = other;
        other.m_flags |= b2Body.e_islandFlag
      }
      for(var jn = b.m_jointList;jn;jn = jn.next) {
        if(jn.joint.m_islandFlag == true) {
          continue
        }
        other = jn.other;
        if(other.IsActive() == false) {
          continue
        }
        island.AddJoint(jn.joint);
        jn.joint.m_islandFlag = true;
        if(other.m_flags & b2Body.e_islandFlag) {
          continue
        }
        stack[stackCount++] = other;
        other.m_flags |= b2Body.e_islandFlag
      }
    }
    island.Solve(step, this.m_gravity, this.m_allowSleep);
    for(var i = 0;i < island.m_bodyCount;++i) {
      b = island.m_bodies[i];
      if(b.GetType() == b2Body.b2_staticBody) {
        b.m_flags &= ~b2Body.e_islandFlag
      }
    }
  }
  for(i = 0;i < stack.length;++i) {
    if(!stack[i]) {
      break
    }
    stack[i] = null
  }
  for(b = this.m_bodyList;b;b = b.m_next) {
    if(b.IsAwake() == false || b.IsActive() == false) {
      continue
    }
    if(b.GetType() == b2Body.b2_staticBody) {
      continue
    }
    b.SynchronizeFixtures()
  }
  this.m_contactManager.FindNewContacts()
};
b2World.prototype.SolveTOI = function(step) {
  var b;
  var fA;
  var fB;
  var bA;
  var bB;
  var cEdge;
  var j;
  var island = this.m_island;
  island.Initialize(this.m_bodyCount, b2Settings.b2_maxTOIContactsPerIsland, b2Settings.b2_maxTOIJointsPerIsland, null, this.m_contactManager.m_contactListener, this.m_contactSolver);
  var queue = b2World.s_queue;
  for(b = this.m_bodyList;b;b = b.m_next) {
    b.m_flags &= ~b2Body.e_islandFlag;
    b.m_sweep.t0 = 0
  }
  var c;
  for(c = this.m_contactList;c;c = c.m_next) {
    c.m_flags &= ~(b2Contact.e_toiFlag | b2Contact.e_islandFlag)
  }
  for(j = this.m_jointList;j;j = j.m_next) {
    j.m_islandFlag = false
  }
  for(;;) {
    var minContact = null;
    var minTOI = 1;
    for(c = this.m_contactList;c;c = c.m_next) {
      if(c.IsSensor() == true || c.IsEnabled() == false || c.IsContinuous() == false) {
        continue
      }
      var toi = 1;
      if(c.m_flags & b2Contact.e_toiFlag) {
        toi = c.m_toi
      }else {
        fA = c.m_fixtureA;
        fB = c.m_fixtureB;
        bA = fA.m_body;
        bB = fB.m_body;
        if((bA.GetType() != b2Body.b2_dynamicBody || bA.IsAwake() == false) && (bB.GetType() != b2Body.b2_dynamicBody || bB.IsAwake() == false)) {
          continue
        }
        var t0 = bA.m_sweep.t0;
        if(bA.m_sweep.t0 < bB.m_sweep.t0) {
          t0 = bB.m_sweep.t0;
          bA.m_sweep.Advance(t0)
        }else {
          if(bB.m_sweep.t0 < bA.m_sweep.t0) {
            t0 = bA.m_sweep.t0;
            bB.m_sweep.Advance(t0)
          }
        }
        toi = c.ComputeTOI(bA.m_sweep, bB.m_sweep);
        b2Settings.b2Assert(0 <= toi && toi <= 1);
        if(toi > 0 && toi < 1) {
          toi = (1 - toi) * t0 + toi;
          if(toi > 1) {
            toi = 1
          }
        }
        c.m_toi = toi;
        c.m_flags |= b2Contact.e_toiFlag
      }
      if(Number.MIN_VALUE < toi && toi < minTOI) {
        minContact = c;
        minTOI = toi
      }
    }
    if(minContact == null || 1 - 100 * Number.MIN_VALUE < minTOI) {
      break
    }
    fA = minContact.m_fixtureA;
    fB = minContact.m_fixtureB;
    bA = fA.m_body;
    bB = fB.m_body;
    b2World.s_backupA.Set(bA.m_sweep);
    b2World.s_backupB.Set(bB.m_sweep);
    bA.Advance(minTOI);
    bB.Advance(minTOI);
    minContact.Update(this.m_contactManager.m_contactListener);
    minContact.m_flags &= ~b2Contact.e_toiFlag;
    if(minContact.IsSensor() == true || minContact.IsEnabled() == false) {
      bA.m_sweep.Set(b2World.s_backupA);
      bB.m_sweep.Set(b2World.s_backupB);
      bA.SynchronizeTransform();
      bB.SynchronizeTransform();
      continue
    }
    if(minContact.IsTouching() == false) {
      continue
    }
    var seed = bA;
    if(seed.GetType() != b2Body.b2_dynamicBody) {
      seed = bB
    }
    island.Clear();
    var queueStart = 0;
    var queueSize = 0;
    queue[queueStart + queueSize++] = seed;
    seed.m_flags |= b2Body.e_islandFlag;
    while(queueSize > 0) {
      b = queue[queueStart++];
      --queueSize;
      island.AddBody(b);
      if(b.IsAwake() == false) {
        b.SetAwake(true)
      }
      if(b.GetType() != b2Body.b2_dynamicBody) {
        continue
      }
      for(cEdge = b.m_contactList;cEdge;cEdge = cEdge.next) {
        if(island.m_contactCount == island.m_contactCapacity) {
          break
        }
        if(cEdge.contact.m_flags & b2Contact.e_islandFlag) {
          continue
        }
        if(cEdge.contact.IsSensor() == true || cEdge.contact.IsEnabled() == false || cEdge.contact.IsTouching() == false) {
          continue
        }
        island.AddContact(cEdge.contact);
        cEdge.contact.m_flags |= b2Contact.e_islandFlag;
        var other = cEdge.other;
        if(other.m_flags & b2Body.e_islandFlag) {
          continue
        }
        if(other.GetType() != b2Body.b2_staticBody) {
          other.Advance(minTOI);
          other.SetAwake(true)
        }
        queue[queueStart + queueSize] = other;
        ++queueSize;
        other.m_flags |= b2Body.e_islandFlag
      }
      for(var jEdge = b.m_jointList;jEdge;jEdge = jEdge.next) {
        if(island.m_jointCount == island.m_jointCapacity) {
          continue
        }
        if(jEdge.joint.m_islandFlag == true) {
          continue
        }
        other = jEdge.other;
        if(other.IsActive() == false) {
          continue
        }
        island.AddJoint(jEdge.joint);
        jEdge.joint.m_islandFlag = true;
        if(other.m_flags & b2Body.e_islandFlag) {
          continue
        }
        if(other.GetType() != b2Body.b2_staticBody) {
          other.Advance(minTOI);
          other.SetAwake(true)
        }
        queue[queueStart + queueSize] = other;
        ++queueSize;
        other.m_flags |= b2Body.e_islandFlag
      }
    }
    var subStep = b2World.s_timestep;
    subStep.warmStarting = false;
    subStep.dt = (1 - minTOI) * step.dt;
    subStep.inv_dt = 1 / subStep.dt;
    subStep.dtRatio = 0;
    subStep.velocityIterations = step.velocityIterations;
    subStep.positionIterations = step.positionIterations;
    island.SolveTOI(subStep);
    var i = 0;
    for(i = 0;i < island.m_bodyCount;++i) {
      b = island.m_bodies[i];
      b.m_flags &= ~b2Body.e_islandFlag;
      if(b.IsAwake() == false) {
        continue
      }
      if(b.GetType() != b2Body.b2_dynamicBody) {
        continue
      }
      b.SynchronizeFixtures();
      for(cEdge = b.m_contactList;cEdge;cEdge = cEdge.next) {
        cEdge.contact.m_flags &= ~b2Contact.e_toiFlag
      }
    }
    for(i = 0;i < island.m_contactCount;++i) {
      c = island.m_contacts[i];
      c.m_flags &= ~(b2Contact.e_toiFlag | b2Contact.e_islandFlag)
    }
    for(i = 0;i < island.m_jointCount;++i) {
      j = island.m_joints[i];
      j.m_islandFlag = false
    }
    this.m_contactManager.FindNewContacts()
  }
};
b2World.prototype.DrawJoint = function(joint) {
  var b1 = joint.GetBodyA();
  var b2 = joint.GetBodyB();
  var xf1 = b1.m_xf;
  var xf2 = b2.m_xf;
  var x1 = xf1.position;
  var x2 = xf2.position;
  var p1 = joint.GetAnchorA();
  var p2 = joint.GetAnchorB();
  var color = b2World.s_jointColor;
  switch(joint.m_type) {
    case b2Joint.e_distanceJoint:
      this.m_debugDraw.DrawSegment(p1, p2, color);
      break;
    case b2Joint.e_pulleyJoint:
      var pulley = joint;
      var s1 = pulley.GetGroundAnchorA();
      var s2 = pulley.GetGroundAnchorB();
      this.m_debugDraw.DrawSegment(s1, p1, color);
      this.m_debugDraw.DrawSegment(s2, p2, color);
      this.m_debugDraw.DrawSegment(s1, s2, color);
      break;
    case b2Joint.e_mouseJoint:
      this.m_debugDraw.DrawSegment(p1, p2, color);
      break;
    default:
      if(b1 != this.m_groundBody) {
        this.m_debugDraw.DrawSegment(x1, p1, color)
      }
      this.m_debugDraw.DrawSegment(p1, p2, color);
      if(b2 != this.m_groundBody) {
        this.m_debugDraw.DrawSegment(x2, p2, color)
      }
  }
};
b2World.prototype.DrawShape = function(shape, xf, color) {
  switch(shape.m_type) {
    case b2Shape.e_circleShape:
      var circle = shape;
      var center = b2Math.MulX(xf, circle.m_p);
      var radius = circle.m_radius;
      var axis = xf.R.col1;
      this.m_debugDraw.DrawSolidCircle(center, radius, axis, color);
      break;
    case b2Shape.e_polygonShape:
      var i = 0;
      var poly = shape;
      var vertexCount = poly.GetVertexCount();
      var localVertices = poly.GetVertices();
      var vertices = new Array(vertexCount);
      for(i = 0;i < vertexCount;++i) {
        vertices[i] = b2Math.MulX(xf, localVertices[i])
      }
      this.m_debugDraw.DrawSolidPolygon(vertices, vertexCount, color);
      break;
    case b2Shape.e_edgeShape:
      var edge = shape;
      this.m_debugDraw.DrawSegment(b2Math.MulX(xf, edge.GetVertex1()), b2Math.MulX(xf, edge.GetVertex2()), color);
      break
  }
};
b2World.prototype.SetDestructionListener = function(listener) {
  this.m_destructionListener = listener
};
b2World.prototype.SetContactFilter = function(filter) {
  this.m_contactManager.m_contactFilter = filter
};
b2World.prototype.SetContactListener = function(listener) {
  this.m_contactManager.m_contactListener = listener
};
b2World.prototype.SetDebugDraw = function(debugDraw) {
  this.m_debugDraw = debugDraw
};
b2World.prototype.SetBroadPhase = function(broadPhase) {
  var oldBroadPhase = this.m_contactManager.m_broadPhase;
  this.m_contactManager.m_broadPhase = broadPhase;
  for(var b = this.m_bodyList;b;b = b.m_next) {
    for(var f = b.m_fixtureList;f;f = f.m_next) {
      f.m_proxy = broadPhase.CreateProxy(oldBroadPhase.GetFatAABB(f.m_proxy), f)
    }
  }
};
b2World.prototype.Validate = function() {
  this.m_contactManager.m_broadPhase.Validate()
};
b2World.prototype.GetProxyCount = function() {
  return this.m_contactManager.m_broadPhase.GetProxyCount()
};
b2World.prototype.CreateBody = function(def) {
  if(this.IsLocked() == true) {
    return null
  }
  var b = new b2Body(def, this);
  b.m_prev = null;
  b.m_next = this.m_bodyList;
  if(this.m_bodyList) {
    this.m_bodyList.m_prev = b
  }
  this.m_bodyList = b;
  ++this.m_bodyCount;
  return b
};
b2World.prototype.DestroyBody = function(b) {
  if(this.IsLocked() == true) {
    return
  }
  var jn = b.m_jointList;
  while(jn) {
    var jn0 = jn;
    jn = jn.next;
    if(this.m_destructionListener) {
      this.m_destructionListener.SayGoodbyeJoint(jn0.joint)
    }
    this.DestroyJoint(jn0.joint)
  }
  var coe = b.m_controllerList;
  while(coe) {
    var coe0 = coe;
    coe = coe.nextController;
    coe0.controller.RemoveBody(b)
  }
  var ce = b.m_contactList;
  while(ce) {
    var ce0 = ce;
    ce = ce.next;
    this.m_contactManager.Destroy(ce0.contact)
  }
  b.m_contactList = null;
  var f = b.m_fixtureList;
  while(f) {
    var f0 = f;
    f = f.m_next;
    if(this.m_destructionListener) {
      this.m_destructionListener.SayGoodbyeFixture(f0)
    }
    f0.DestroyProxy(this.m_contactManager.m_broadPhase);
    f0.Destroy()
  }
  b.m_fixtureList = null;
  b.m_fixtureCount = 0;
  if(b.m_prev) {
    b.m_prev.m_next = b.m_next
  }
  if(b.m_next) {
    b.m_next.m_prev = b.m_prev
  }
  if(b == this.m_bodyList) {
    this.m_bodyList = b.m_next
  }
  --this.m_bodyCount
};
b2World.prototype.CreateJoint = function(def) {
  var j = b2Joint.Create(def, null);
  j.m_prev = null;
  j.m_next = this.m_jointList;
  if(this.m_jointList) {
    this.m_jointList.m_prev = j
  }
  this.m_jointList = j;
  ++this.m_jointCount;
  j.m_edgeA.joint = j;
  j.m_edgeA.other = j.m_bodyB;
  j.m_edgeA.prev = null;
  j.m_edgeA.next = j.m_bodyA.m_jointList;
  if(j.m_bodyA.m_jointList) {
    j.m_bodyA.m_jointList.prev = j.m_edgeA
  }
  j.m_bodyA.m_jointList = j.m_edgeA;
  j.m_edgeB.joint = j;
  j.m_edgeB.other = j.m_bodyA;
  j.m_edgeB.prev = null;
  j.m_edgeB.next = j.m_bodyB.m_jointList;
  if(j.m_bodyB.m_jointList) {
    j.m_bodyB.m_jointList.prev = j.m_edgeB
  }
  j.m_bodyB.m_jointList = j.m_edgeB;
  var bodyA = def.bodyA;
  var bodyB = def.bodyB;
  if(def.collideConnected == false) {
    var edge = bodyB.GetContactList();
    while(edge) {
      if(edge.other == bodyA) {
        edge.contact.FlagForFiltering()
      }
      edge = edge.next
    }
  }
  return j
};
b2World.prototype.DestroyJoint = function(j) {
  var collideConnected = j.m_collideConnected;
  if(j.m_prev) {
    j.m_prev.m_next = j.m_next
  }
  if(j.m_next) {
    j.m_next.m_prev = j.m_prev
  }
  if(j == this.m_jointList) {
    this.m_jointList = j.m_next
  }
  var bodyA = j.m_bodyA;
  var bodyB = j.m_bodyB;
  bodyA.SetAwake(true);
  bodyB.SetAwake(true);
  if(j.m_edgeA.prev) {
    j.m_edgeA.prev.next = j.m_edgeA.next
  }
  if(j.m_edgeA.next) {
    j.m_edgeA.next.prev = j.m_edgeA.prev
  }
  if(j.m_edgeA == bodyA.m_jointList) {
    bodyA.m_jointList = j.m_edgeA.next
  }
  j.m_edgeA.prev = null;
  j.m_edgeA.next = null;
  if(j.m_edgeB.prev) {
    j.m_edgeB.prev.next = j.m_edgeB.next
  }
  if(j.m_edgeB.next) {
    j.m_edgeB.next.prev = j.m_edgeB.prev
  }
  if(j.m_edgeB == bodyB.m_jointList) {
    bodyB.m_jointList = j.m_edgeB.next
  }
  j.m_edgeB.prev = null;
  j.m_edgeB.next = null;
  b2Joint.Destroy(j, null);
  --this.m_jointCount;
  if(collideConnected == false) {
    var edge = bodyB.GetContactList();
    while(edge) {
      if(edge.other == bodyA) {
        edge.contact.FlagForFiltering()
      }
      edge = edge.next
    }
  }
};
b2World.prototype.AddController = function(c) {
  c.m_next = this.m_controllerList;
  c.m_prev = null;
  this.m_controllerList = c;
  c.m_world = this;
  this.m_controllerCount++;
  return c
};
b2World.prototype.RemoveController = function(c) {
  if(c.m_prev) {
    c.m_prev.m_next = c.m_next
  }
  if(c.m_next) {
    c.m_next.m_prev = c.m_prev
  }
  if(this.m_controllerList == c) {
    this.m_controllerList = c.m_next
  }
  this.m_controllerCount--
};
b2World.prototype.CreateController = function(controller) {
  if(controller.m_world != this) {
    throw new Error("Controller can only be a member of one world");
  }
  controller.m_next = this.m_controllerList;
  controller.m_prev = null;
  if(this.m_controllerList) {
    this.m_controllerList.m_prev = controller
  }
  this.m_controllerList = controller;
  ++this.m_controllerCount;
  controller.m_world = this;
  return controller
};
b2World.prototype.DestroyController = function(controller) {
  controller.Clear();
  if(controller.m_next) {
    controller.m_next.m_prev = controller.m_prev
  }
  if(controller.m_prev) {
    controller.m_prev.m_next = controller.m_next
  }
  if(controller == this.m_controllerList) {
    this.m_controllerList = controller.m_next
  }
  --this.m_controllerCount
};
b2World.prototype.SetWarmStarting = function(flag) {
  b2World.m_warmStarting = flag
};
b2World.prototype.SetContinuousPhysics = function(flag) {
  b2World.m_continuousPhysics = flag
};
b2World.prototype.GetBodyCount = function() {
  return this.m_bodyCount
};
b2World.prototype.GetJointCount = function() {
  return this.m_jointCount
};
b2World.prototype.GetContactCount = function() {
  return this.m_contactCount
};
b2World.prototype.SetGravity = function(gravity) {
  this.m_gravity = gravity
};
b2World.prototype.GetGravity = function() {
  return this.m_gravity
};
b2World.prototype.GetGroundBody = function() {
  return this.m_groundBody
};
b2World.prototype.Step = function(dt, velocityIterations, positionIterations) {
  if(this.m_flags & b2World.e_newFixture) {
    this.m_contactManager.FindNewContacts();
    this.m_flags &= ~b2World.e_newFixture
  }
  this.m_flags |= b2World.e_locked;
  var step = b2World.s_timestep2;
  step.dt = dt;
  step.velocityIterations = velocityIterations;
  step.positionIterations = positionIterations;
  if(dt > 0) {
    step.inv_dt = 1 / dt
  }else {
    step.inv_dt = 0
  }
  step.dtRatio = this.m_inv_dt0 * dt;
  step.warmStarting = b2World.m_warmStarting;
  this.m_contactManager.Collide();
  if(step.dt > 0) {
    this.Solve(step)
  }
  if(b2World.m_continuousPhysics && step.dt > 0) {
    this.SolveTOI(step)
  }
  if(step.dt > 0) {
    this.m_inv_dt0 = step.inv_dt
  }
  this.m_flags &= ~b2World.e_locked
};
b2World.prototype.ClearForces = function() {
  for(var body = this.m_bodyList;body;body = body.m_next) {
    body.m_force.SetZero();
    body.m_torque = 0
  }
};
b2World.prototype.DrawDebugData = function() {
  if(this.m_debugDraw == null) {
    return
  }
  this.m_debugDraw.Clear();
  var flags = this.m_debugDraw.GetFlags();
  var i = 0;
  var b;
  var f;
  var s;
  var j;
  var bp;
  var invQ = new b2Vec2;
  var x1 = new b2Vec2;
  var x2 = new b2Vec2;
  var xf;
  var b1 = new b2AABB;
  var b2 = new b2AABB;
  var vs = [new b2Vec2, new b2Vec2, new b2Vec2, new b2Vec2];
  var color = new b2Color(0, 0, 0);
  if(flags & b2DebugDraw.e_shapeBit) {
    for(b = this.m_bodyList;b;b = b.m_next) {
      xf = b.m_xf;
      for(f = b.GetFixtureList();f;f = f.m_next) {
        s = f.GetShape();
        if(b.IsActive() == false) {
          color.Set(0.5, 0.5, 0.3);
          this.DrawShape(s, xf, color)
        }else {
          if(b.GetType() == b2Body.b2_staticBody) {
            color.Set(0.5, 0.9, 0.5);
            this.DrawShape(s, xf, color)
          }else {
            if(b.GetType() == b2Body.b2_kinematicBody) {
              color.Set(0.5, 0.5, 0.9);
              this.DrawShape(s, xf, color)
            }else {
              if(b.IsAwake() == false) {
                color.Set(0.6, 0.6, 0.6);
                this.DrawShape(s, xf, color)
              }else {
                color.Set(0.9, 0.7, 0.7);
                this.DrawShape(s, xf, color)
              }
            }
          }
        }
      }
    }
  }
  if(flags & b2DebugDraw.e_jointBit) {
    for(j = this.m_jointList;j;j = j.m_next) {
      this.DrawJoint(j)
    }
  }
  if(flags & b2DebugDraw.e_controllerBit) {
    for(var c = this.m_controllerList;c;c = c.m_next) {
      c.Draw(this.m_debugDraw)
    }
  }
  if(flags & b2DebugDraw.e_pairBit) {
    color.Set(0.3, 0.9, 0.9);
    for(var contact = this.m_contactManager.m_contactList;contact;contact = contact.GetNext()) {
      var fixtureA = contact.GetFixtureA();
      var fixtureB = contact.GetFixtureB();
      var cA = fixtureA.GetAABB().GetCenter();
      var cB = fixtureB.GetAABB().GetCenter();
      this.m_debugDraw.DrawSegment(cA, cB, color)
    }
  }
  if(flags & b2DebugDraw.e_aabbBit) {
    bp = this.m_contactManager.m_broadPhase;
    vs = [new b2Vec2, new b2Vec2, new b2Vec2, new b2Vec2];
    for(b = this.m_bodyList;b;b = b.GetNext()) {
      if(b.IsActive() == false) {
        continue
      }
      for(f = b.GetFixtureList();f;f = f.GetNext()) {
        var aabb = bp.GetFatAABB(f.m_proxy);
        vs[0].Set(aabb.lowerBound.x, aabb.lowerBound.y);
        vs[1].Set(aabb.upperBound.x, aabb.lowerBound.y);
        vs[2].Set(aabb.upperBound.x, aabb.upperBound.y);
        vs[3].Set(aabb.lowerBound.x, aabb.upperBound.y);
        this.m_debugDraw.DrawPolygon(vs, 4, color)
      }
    }
  }
  if(flags & b2DebugDraw.e_centerOfMassBit) {
    for(b = this.m_bodyList;b;b = b.m_next) {
      xf = b2World.s_xf;
      xf.R = b.m_xf.R;
      xf.position = b.GetWorldCenter();
      this.m_debugDraw.DrawTransform(xf)
    }
  }
};
b2World.prototype.QueryAABB = function(callback, aabb) {
  var broadPhase = this.m_contactManager.m_broadPhase;
  function WorldQueryWrapper(proxy) {
    return callback(broadPhase.GetUserData(proxy))
  }
  broadPhase.Query(WorldQueryWrapper, aabb)
};
b2World.prototype.QueryShape = function(callback, shape, transform) {
  if(transform == null) {
    transform = new b2Transform;
    transform.SetIdentity()
  }
  var broadPhase = this.m_contactManager.m_broadPhase;
  function WorldQueryWrapper(proxy) {
    var fixture = broadPhase.GetUserData(proxy);
    if(b2Shape.TestOverlap(shape, transform, fixture.GetShape(), fixture.GetBody().GetTransform())) {
      return callback(fixture)
    }
    return true
  }
  var aabb = new b2AABB;
  shape.ComputeAABB(aabb, transform);
  broadPhase.Query(WorldQueryWrapper, aabb)
};
b2World.prototype.QueryPoint = function(callback, p) {
  var broadPhase = this.m_contactManager.m_broadPhase;
  function WorldQueryWrapper(proxy) {
    var fixture = broadPhase.GetUserData(proxy);
    if(fixture.TestPoint(p)) {
      return callback(fixture)
    }
    return true
  }
  var aabb = new b2AABB;
  aabb.lowerBound.Set(p.x - b2Settings.b2_linearSlop, p.y - b2Settings.b2_linearSlop);
  aabb.upperBound.Set(p.x + b2Settings.b2_linearSlop, p.y + b2Settings.b2_linearSlop);
  broadPhase.Query(WorldQueryWrapper, aabb)
};
b2World.prototype.RayCast = function(callback, point1, point2) {
  var broadPhase = this.m_contactManager.m_broadPhase;
  var output = new b2RayCastOutput;
  function RayCastWrapper(input, proxy) {
    var userData = broadPhase.GetUserData(proxy);
    var fixture = userData;
    var hit = fixture.RayCast(output, input);
    if(hit) {
      var fraction = output.fraction;
      var point = new b2Vec2((1 - fraction) * point1.x + fraction * point2.x, (1 - fraction) * point1.y + fraction * point2.y);
      return callback(fixture, point, output.normal, fraction)
    }
    return input.maxFraction
  }
  var input = new b2RayCastInput(point1, point2);
  broadPhase.RayCast(RayCastWrapper, input)
};
b2World.prototype.RayCastOne = function(point1, point2) {
  var result;
  function RayCastOneWrapper(fixture, point, normal, fraction) {
    result = fixture;
    return fraction
  }
  this.RayCast(RayCastOneWrapper, point1, point2);
  return result
};
b2World.prototype.RayCastAll = function(point1, point2) {
  var result = new Array;
  function RayCastAllWrapper(fixture, point, normal, fraction) {
    result[result.length] = fixture;
    return 1
  }
  this.RayCast(RayCastAllWrapper, point1, point2);
  return result
};
b2World.prototype.GetBodyList = function() {
  return this.m_bodyList
};
b2World.prototype.GetJointList = function() {
  return this.m_jointList
};
b2World.prototype.GetContactList = function() {
  return this.m_contactList
};
b2World.prototype.IsLocked = function() {
  return(this.m_flags & b2World.e_locked) > 0
};
b2World.prototype.s_stack = new Array;
b2World.prototype.m_flags = 0;
b2World.prototype.m_contactManager = new b2ContactManager;
b2World.prototype.m_contactSolver = new b2ContactSolver;
b2World.prototype.m_island = new b2Island;
b2World.prototype.m_bodyList = null;
b2World.prototype.m_jointList = null;
b2World.prototype.m_contactList = null;
b2World.prototype.m_bodyCount = 0;
b2World.prototype.m_contactCount = 0;
b2World.prototype.m_jointCount = 0;
b2World.prototype.m_controllerList = null;
b2World.prototype.m_controllerCount = 0;
b2World.prototype.m_gravity = null;
b2World.prototype.m_allowSleep = null;
b2World.prototype.m_groundBody = null;
b2World.prototype.m_destructionListener = null;
b2World.prototype.m_debugDraw = null;
b2World.prototype.m_inv_dt0 = null;if(typeof exports !== "undefined") {
  exports.b2BoundValues = b2BoundValues;
  exports.b2Math = b2Math;
  exports.b2DistanceOutput = b2DistanceOutput;
  exports.b2Mat33 = b2Mat33;
  exports.b2ContactPoint = b2ContactPoint;
  exports.b2PairManager = b2PairManager;
  exports.b2PositionSolverManifold = b2PositionSolverManifold;
  exports.b2OBB = b2OBB;
  exports.b2CircleContact = b2CircleContact;
  exports.b2PulleyJoint = b2PulleyJoint;
  exports.b2Pair = b2Pair;
  exports.b2TimeStep = b2TimeStep;
  exports.b2FixtureDef = b2FixtureDef;
  exports.b2World = b2World;
  exports.b2PrismaticJoint = b2PrismaticJoint;
  exports.b2Controller = b2Controller;
  exports.b2ContactID = b2ContactID;
  exports.b2RevoluteJoint = b2RevoluteJoint;
  exports.b2JointDef = b2JointDef;
  exports.b2Transform = b2Transform;
  exports.b2GravityController = b2GravityController;
  exports.b2EdgeAndCircleContact = b2EdgeAndCircleContact;
  exports.b2EdgeShape = b2EdgeShape;
  exports.b2BuoyancyController = b2BuoyancyController;
  exports.b2LineJointDef = b2LineJointDef;
  exports.b2Contact = b2Contact;
  exports.b2DistanceJoint = b2DistanceJoint;
  exports.b2Body = b2Body;
  exports.b2DestructionListener = b2DestructionListener;
  exports.b2PulleyJointDef = b2PulleyJointDef;
  exports.b2ContactEdge = b2ContactEdge;
  exports.b2ContactConstraint = b2ContactConstraint;
  exports.b2ContactImpulse = b2ContactImpulse;
  exports.b2DistanceJointDef = b2DistanceJointDef;
  exports.b2ContactResult = b2ContactResult;
  exports.b2EdgeChainDef = b2EdgeChainDef;
  exports.b2Vec2 = b2Vec2;
  exports.b2Vec3 = b2Vec3;
  exports.b2DistanceProxy = b2DistanceProxy;
  exports.b2FrictionJointDef = b2FrictionJointDef;
  exports.b2PolygonContact = b2PolygonContact;
  exports.b2TensorDampingController = b2TensorDampingController;
  exports.b2ContactFactory = b2ContactFactory;
  exports.b2WeldJointDef = b2WeldJointDef;
  exports.b2ConstantAccelController = b2ConstantAccelController;
  exports.b2GearJointDef = b2GearJointDef;
  exports.ClipVertex = ClipVertex;
  exports.b2SeparationFunction = b2SeparationFunction;
  exports.b2ManifoldPoint = b2ManifoldPoint;
  exports.b2Color = b2Color;
  exports.b2PolygonShape = b2PolygonShape;
  exports.b2DynamicTreePair = b2DynamicTreePair;
  exports.b2ContactConstraintPoint = b2ContactConstraintPoint;
  exports.b2FrictionJoint = b2FrictionJoint;
  exports.b2ContactFilter = b2ContactFilter;
  exports.b2ControllerEdge = b2ControllerEdge;
  exports.b2Distance = b2Distance;
  exports.b2Fixture = b2Fixture;
  exports.b2DynamicTreeNode = b2DynamicTreeNode;
  exports.b2MouseJoint = b2MouseJoint;
  exports.b2DistanceInput = b2DistanceInput;
  exports.b2BodyDef = b2BodyDef;
  exports.b2DynamicTreeBroadPhase = b2DynamicTreeBroadPhase;
  exports.b2Settings = b2Settings;
  exports.b2Proxy = b2Proxy;
  exports.b2Point = b2Point;
  exports.b2BroadPhase = b2BroadPhase;
  exports.b2Manifold = b2Manifold;
  exports.b2WorldManifold = b2WorldManifold;
  exports.b2PrismaticJointDef = b2PrismaticJointDef;
  exports.b2RayCastOutput = b2RayCastOutput;
  exports.b2ConstantForceController = b2ConstantForceController;
  exports.b2TimeOfImpact = b2TimeOfImpact;
  exports.b2CircleShape = b2CircleShape;
  exports.b2MassData = b2MassData;
  exports.b2Joint = b2Joint;
  exports.b2GearJoint = b2GearJoint;
  exports.b2DynamicTree = b2DynamicTree;
  exports.b2JointEdge = b2JointEdge;
  exports.b2LineJoint = b2LineJoint;
  exports.b2NullContact = b2NullContact;
  exports.b2ContactListener = b2ContactListener;
  exports.b2RayCastInput = b2RayCastInput;
  exports.b2TOIInput = b2TOIInput;
  exports.Features = Features;
  exports.b2FilterData = b2FilterData;
  exports.b2Island = b2Island;
  exports.b2ContactManager = b2ContactManager;
  exports.b2ContactSolver = b2ContactSolver;
  exports.b2Simplex = b2Simplex;
  exports.b2AABB = b2AABB;
  exports.b2Jacobian = b2Jacobian;
  exports.b2Bound = b2Bound;
  exports.b2RevoluteJointDef = b2RevoluteJointDef;
  exports.b2PolyAndEdgeContact = b2PolyAndEdgeContact;
  exports.b2SimplexVertex = b2SimplexVertex;
  exports.b2WeldJoint = b2WeldJoint;
  exports.b2Collision = b2Collision;
  exports.b2Mat22 = b2Mat22;
  exports.b2SimplexCache = b2SimplexCache;
  exports.b2PolyAndCircleContact = b2PolyAndCircleContact;
  exports.b2MouseJointDef = b2MouseJointDef;
  exports.b2Shape = b2Shape;
  exports.b2Segment = b2Segment;
  exports.b2ContactRegister = b2ContactRegister;
  exports.b2DebugDraw = b2DebugDraw;
  exports.b2Sweep = b2Sweep
}
;

}};
__resources__["/__builtin__/libs/cocos2d/ActionManager.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    console = require('system').console,
    Timer = require('./Scheduler').Timer,
    Scheduler = require('./Scheduler').Scheduler;

var ActionManager = BObject.extend(/** @lends cocos.ActionManager# */{
    targets: null,
    currentTarget: null,
    currentTargetSalvaged: null,

    /**
     * <p>A singleton that manages all the actions. Normally you
     * won't need to use this singleton directly. 99% of the cases you will use the
     * cocos.nodes.Node interface, which uses this singleton. But there are some cases where
     * you might need to use this singleton. Examples:</p>
     *
     * <ul>
     * <li>When you want to run an action where the target is different from a cocos.nodes.Node</li>
     * <li>When you want to pause / resume the actions</li>
     * </ul>
     *
     * @memberOf cocos
     * @constructs
     * @extends BObject
     * @singleton
     */
    init: function () {
        ActionManager.superclass.init.call(this);

        Scheduler.get('sharedScheduler').scheduleUpdate({target: this, priority: 0, paused: false});
        this.targets = [];
    },

    /**
     * Adds an action with a target. If the target is already present, then the
     * action will be added to the existing target. If the target is not
     * present, a new instance of this target will be created either paused or
     * paused, and the action will be added to the newly created target. When
     * the target is paused, the queued actions won't be 'ticked'.
     *
     * @opt {cocos.nodes.Node} target Node to run the action on
     */
    addAction: function (opts) {

        var targetID = opts.target.get('id');
        var element = this.targets[targetID];

        if (!element) {
            element = this.targets[targetID] = {
                paused: false,
                target: opts.target,
                actions: []
            };
        }

        element.actions.push(opts.action);

        opts.action.startWithTarget(opts.target);
    },

    /**
     * Remove an action
     *
     * @param {cocos.actions.Action} action Action to remove
     */
    removeAction: function (action) {
        var targetID = action.originalTarget.get('id'),
            element = this.targets[targetID];

        if (!element) {
            return;
        }

        var actionIndex = element.actions.indexOf(action);

        if (actionIndex == -1) {
            return;
        }

        if (this.currentTarget == element) {
            element.currentActionSalvaged = true;
        } 
        
        element.actions[actionIndex] = null;
        element.actions.splice(actionIndex, 1); // Delete array item

        if (element.actions.length === 0) {
            if (this.currentTarget == element) {
                this.set('currentTargetSalvaged', true);
            }
        }
            
    },

    /**
     * Fetch an action belonging to a cocos.nodes.Node
     *
     * @returns {cocos.actions.Action}
     *
     * @opts {cocos.nodes.Node} target Target of the action
     * @opts {String} tag Tag of the action
     */
    getActionFromTarget: function(opts) {
        var tag = opts.tag,
            targetID = opts.target.get('id');

        var element = this.targets[targetID];
        if (!element) {
            return null;
        }
        for (var i = 0; i < element.actions.length; i++ ) {
            if (element.actions[i] && 
                (element.actions[i].get('tag') === tag)) {
                return element.actions[i];
            }
        }
        // Not found
        return null;
    },
     
    /**
     * Remove all actions for a cocos.nodes.Node
     *
     * @param {cocos.nodes.Node} target Node to remove all actions for
     */
    removeAllActionsFromTarget: function (target) {
        var targetID = target.get('id');

        var element = this.targets[targetID];
        if (!element) {
            return;
        }
        // Delete everything in array but don't replace it incase something else has a reference
        element.actions.splice(0, element.actions.length);
    },

    /**
     * @private
     */
    update: function (dt) {
        var self = this;
        util.each(this.targets, function (currentTarget, i) {

            if (!currentTarget) {
                return;
            }
            self.currentTarget = currentTarget;

            if (!currentTarget.paused) {
                util.each(currentTarget.actions, function (currentAction, j) {
                    if (!currentAction) {
                        return;
                    }

                    currentTarget.currentAction = currentAction;
                    currentTarget.currentActionSalvaged = false;

                    currentTarget.currentAction.step(dt);

                    if (currentTarget.currentAction.get('isDone')) {
                        currentTarget.currentAction.stop();

                        var a = currentTarget.currentAction;
                        currentTarget.currentAction = null;
                        self.removeAction(a);
                    }

                    currentTarget.currentAction = null;

                });
            }

            if (self.currentTargetSalvaged && currentTarget.actions.length === 0) {
                self.targets[i] = null;
                delete self.targets[i];
            }
        });
    },

    pauseTarget: function (target) {
    },

    resumeTarget: function (target) {
        // TODO
    }
});

util.extend(ActionManager, /** @lends cocos.ActionManager */{
    /**
     * Singleton instance of cocos.ActionManager
     * @getter sharedManager
     * @type cocos.ActionManager
     */
    get_sharedManager: function (key) {
        if (!this._instance) {
            this._instance = this.create();
        }

        return this._instance;
    }
});

exports.ActionManager = ActionManager;

}};
__resources__["/__builtin__/libs/cocos2d/actions/Action.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    console = require('system').console,
    geo = require('geometry'),
    ccp = geo.ccp;

/** 
 * @memberOf cocos.actions
 * @class Base class for Actions
 * @extends BObject
 * @constructor
 */
var Action = BObject.extend(/** @lends cocos.actions.Action# */{
    /**
     * The Node the action is being performed on
     * @type cocos.nodes.Node
     */
    target: null,
    originalTarget: null,
    
    /**
     * Unique tag to identify the action
     * @type *
     */
    tag: null,
    
    /**
     * Called every frame with it's delta time.
     *
     * @param {Float} dt The delta time
     */
    step: function (dt) {
        window.console.warn("Action.step() Override me");
    },

    /**
     * Called once per frame.
     *
     * @param {Float} time How much of the animation has played. 0.0 = just started, 1.0 just finished.
     */
    update: function (time) {
        window.console.warn("Action.update() Override me");
    },

    /**
     * Called before the action start. It will also set the target.
     *
     * @param {cocos.nodes.Node} target The Node to run the action on
     */
    startWithTarget: function (target) {
        this.target = this.originalTarget = target;
    },

    /**
     * Called after the action has finished. It will set the 'target' to nil.
     * <strong>Important</strong>: You should never call cocos.actions.Action#stop manually.
     * Instead, use cocos.nodes.Node#stopAction(action)
     */
    stop: function () {
        this.target = null;
    },

    /**
     * @getter isDone
     * @type {Boolean} 
     */
    get_isDone: function (key) {
        return true;
    },


    /**
     * Returns a copy of this Action but in reverse
     *
     * @returns {cocos.actions.Action} A new Action in reverse
     */
    reverse: function () {
    }
});

var RepeatForever = Action.extend(/** @lends cocos.actions.RepeatForever# */{
    other: null,

    /**
     * @memberOf cocos.actions
     * @class Repeats an action forever. To repeat the an action for a limited
     * number of times use the cocos.Repeat action.
     * @extends cocos.actions.Action
     * @param {cocos.actions.Action} action An action to repeat forever
     * @constructs
     */
    init: function (action) {
        RepeatForever.superclass.init(this, action);

        this.other = action;
    },

    startWithTarget: function (target) {
        RepeatForever.superclass.startWithTarget.call(this, target);

        this.other.startWithTarget(this.target);
    },

    step: function (dt) {
        this.other.step(dt);
        if (this.other.get('isDone')) {
            var diff = dt - this.other.get('duration') - this.other.get('elapsed');
            this.other.startWithTarget(this.target);

            this.other.step(diff);
        }
    },

    get_isDone: function () {
        return false;
    },

    reverse: function () {
        return RepeatForever.create(this.other.reverse());
    },

    copy: function () {
        return RepeatForever.create(this.other.copy());
    }
});

var FiniteTimeAction = Action.extend(/** @lends cocos.actions.FiniteTimeAction# */{
    /**
     * Number of seconds to run the Action for
     * @type Float
     */
    duration: 2,

    /** 
     * Repeats an action a number of times. To repeat an action forever use the
     * cocos.RepeatForever action.
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.Action
     */
    init: function () {
        FiniteTimeAction.superclass.init.call(this);
    },

    /** @ignore */
    reverse: function () {
        console.log('FiniteTimeAction.reverse() Override me');
    }
});

var Speed = Action.extend(/** @lends cocos.actions.Speed# */{
    other: null,
    
    /** 
     * speed of the inner function
     * @type Float
     */
    speed: 1.0,
    
    /** 
     * Changes the speed of an action, making it take longer (speed>1)
     * or less (speed<1) time.
     * Useful to simulate 'slow motion' or 'fast forward' effect.
     * @warning This action can't be Sequenceable because it is not an IntervalAction
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.Action
     */
    init: function(opts) {
        Speed.superclass.init.call(this, opts);
        
        this.other = opts.action;
        this.speed = opts.speed;
    },
    
    startWithTarget: function(target) {
        Speed.superclass.startWithTarget.call(this, target);
        this.other.startWithTarget(this.target);
    },
    
    setSpeed: function(speed) {
        this.speed = speed;
    },
    
    stop: function() {
        this.other.stop();
        Speed.superclass.stop.call(this);
    },
    
    step: function(dt) {
        this.other.step(dt * this.speed);
    },
    
    get_isDone: function() {
        return this.other.get_isDone();
    },
    
    copy: function() {
        return Speed.create({action: this.other.copy(), speed: this.speed});
    },
    
    reverse: function() {
        return Speed.create({action: this.other.reverse(), speed: this.speed});
    }
});

var Follow = Action.extend(/** @lends cocos.actions.Follow# */{
    /**
     * node to follow
     */
    followedNode: null,
    
    /**
     * whether camera should be limited to certain area
     * @type {Boolean}
     */
    boundarySet: false,
    
    /**
     * if screensize is bigger than the boundary - update not needed 
     * @type {Boolean}
     */
    boundaryFullyCovered: false,
    
    /**
     * fast access to the screen dimensions 
     * @type {geometry.Point}
     */
    halfScreenSize: null,
    fullScreenSize: null,
    
    /**
     * world boundaries
     * @type {Float}
     */
    leftBoundary: 0,
    rightBoundary: 0,
    topBoundary: 0,
    bottomBoundary: 0,
    
    /** 
     * @class Follow an action that "follows" a node.
     *
     * Eg:
     * layer.runAction(cocos.actions.Follow.create({target: hero}))
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.Action
     *
     * @opt {cocos.nodes.Node} target
     * @opt {geometry.Rect} worldBoundary
     */
    init: function(opts) {
        Follow.superclass.init.call(this, opts);
        
        this.followedNode = opts.target;
        
        var s = require('../Director').Director.get('sharedDirector').get('winSize');
        this.fullScreenSize = geo.ccp(s.width, s.height);
        this.halfScreenSize = geo.ccpMult(this.fullScreenSize, geo.ccp(0.5, 0.5));
        
        if (opts.worldBoundary !== undefined) {
            this.boundarySet = true;
            this.leftBoundary = -((opts.worldBoundary.origin.x + opts.worldBoundary.size.width) - this.fullScreenSize.x);
            this.rightBoundary = -opts.worldBoundary.origin.x;
            this.topBoundary = -opts.worldBoundary.origin.y;
            this.bottomBoundary = -((opts.worldBoundary.origin.y+opts.worldBoundary.size.height) - this.fullScreenSize.y);
            
            if (this.rightBoundary < this.leftBoundary) {
                // screen width is larger than world's boundary width
                //set both in the middle of the world
                this.rightBoundary = this.leftBoundary = (this.leftBoundary + this.rightBoundary) / 2;
            }
            if (this.topBoundary < this.bottomBoundary)
            {
                // screen width is larger than world's boundary width
                //set both in the middle of the world
                this.topBoundary = this.bottomBoundary = (this.topBoundary + this.bottomBoundary) / 2;
            }
            if ((this.topBoundary == this.bottomBoundary) && (this.leftBoundary == this.rightBoundary)) {
                this.boundaryFullyCovered = true;
            }
        }
    },
    
    step: function(dt) {
        if (this.boundarySet) {
            // whole map fits inside a single screen, no need to modify the position - unless map boundaries are increased
            if (this.boundaryFullyCovered) {
                return;
            }
            var tempPos = geo.ccpSub(this.halfScreenSize, this.followedNode.get('position'));
            this.target.set('position', ccp(
                Math.min(Math.max(tempPos.x, this.leftBoundary), this.rightBoundary),
                Math.min(Math.max(tempPos.y, this.bottomBoundary), this.topBoundary))
            );
        } else {
            this.target.set('position', geo.ccpSub(this.halfScreenSize, this.followedNode.get('position')));
        }
    },
    
    get_isDone: function() {
        return !this.followedNode.get('isRunning');
    }
});


exports.Action = Action;
exports.RepeatForever = RepeatForever;
exports.FiniteTimeAction = FiniteTimeAction;
exports.Speed = Speed;
exports.Follow = Follow;

}};
__resources__["/__builtin__/libs/cocos2d/actions/ActionEase.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    ActionInterval = require('./ActionInterval').ActionInterval,
    geo = require('geometry'),
    ccp = geo.ccp;

var ActionEase = ActionInterval.extend(/** @lends cocos.actions.ActionEase# */{
    other: null,
    
    /**
     * @class Base class for Easing actions
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.ActionInterval
     *
     * @opt {cocos.actions.ActionInterval} action
     */
    init: function(opts) {
        if (!opts.action) {
            throw "Ease: action argument must be non-nil";
        }
        ActionEase.superclass.init.call(this, {duration: opts.action.duration});
        
        this.other = opts.action;
    },
    
    startWithTarget: function(target) {
        ActionEase.superclass.startWithTarget.call(this, target);
        this.other.startWithTarget(this.target);
    },
    
    stop: function() {
        this.other.stop();
        ActionEase.superclass.stop.call(this);
    },
    /*
    update: function(t) {
        this.other.update(t);
    },
    */
    copy: function() {
        return ActionEase.create({action: this.other.copy()});
    },
    
    reverse: function() {
        return ActionEase.create({action: this.other.reverse()});
    }
});

var EaseRate = ActionEase.extend(/** @lends cocos.actions.EaseRate# */{
    /**
     * rate value for the actions 
     * @type {Float} 
     */
    rate: 0,
    
    /**
    * @class Base class for Easing actions with rate parameter
    *
    * @memberOf cocos.actions
    * @constructs
    * @extends cocos.actions.ActionEase
    *
    * @opt {cocos.actions.ActionInterval} action
    * @opt {Float} rate
    */
    init: function(opts) {
        EaseRate.superclass.init.call(this, opts);

        this.rate = opts.rate;
    },
    
    copy: function() {
        return EaseRate.create({action: this.other.copy(), rate: this.rate});
    },
    
    reverse: function() {
        return EaseRate.create({action: this.other.reverse(), rate: 1 / this.rate});
    }
});

/**
 * @class EaseIn action with a rate
 */
var EaseIn = EaseRate.extend(/** @lends cocos.actions.EaseIn# */{
    update: function(t) {
        this.other.update(Math.pow(t, this.rate));
    },
    
    copy: function() {
        return EaseIn.create({action: this.other.copy(), rate: this.rate});
    },
    
    reverse: function() {
        return EaseIn.create({action: this.other.reverse(), rate: 1 / this.rate});
    }
});

/**
 * @class EaseOut action with a rate
 */
var EaseOut = EaseRate.extend(/** @lends cocos.actions.EaseOut# */{
    update: function(t) {
        this.other.update(Math.pow(t, 1/this.rate));
    },
    
    copy: function() {
        return EaseOut.create({action: this.other.copy(), rate: this.rate});
    },
    
    reverse: function() {
        return EaseOut.create({action: this.other.reverse(), rate: 1 / this.rate});
    }
});

/**
 * @class EaseInOut action with a rate
 */
var EaseInOut = EaseRate.extend(/** @lends cocos.actions.EaseInOut# */{
    update: function(t) {
        var sign = 1;
        var r = Math.floor(this.rate);
        if (r % 2 == 0) {
            sign = -1;
        }
        t *= 2;
        if (t < 1) {
            this.other.update(0.5 * Math.pow(t, this.rate));
        } else {
            this.other.update(sign * 0.5 * (Math.pow(t-2, this.rate) + sign * 2));
        }
    },
    
    copy: function() {
        return EaseInOut.create({action: this.other.copy(), rate: this.rate});
    },
    
    reverse: function() {
        return EaseInOut.create({action: this.other.reverse(), rate: this.rate});
    }
});

/**
 * @class EaseExponentialIn action
 */
var EaseExponentialIn = ActionEase.extend(/** @lends cocos.actions.EaseExponentialIn# */{
    update: function(t) {
        this.other.update((t == 0) ? 0 : (Math.pow(2, 10 * (t/1 - 1)) - 1 * 0.001));
    },
    
    copy: function() {
        return EaseExponentialIn.create({action: this.other.copy()});
    },
    
    reverse: function() {
        return exports.EaseExponentialOut.create({action: this.other.reverse()});
    }
});

/**
 * @class EaseExponentialOut action
 */
var EaseExponentialOut = ActionEase.extend(/** @lends cocos.actions.EaseExponentialOut# */{
    update: function(t) {
        this.other.update((t == 1) ? 1 : (-Math.pow(2, -10 * t/1) + 1));
    },
    
    copy: function() {
        return EaseExponentialOut.create({action: this.other.copy()});
    },
    
    reverse: function() {
        return exports.EaseExponentialIn.create({action: this.other.reverse()});
    }
});

/**
 * @class EaseExponentialInOut action
 */
var EaseExponentialInOut = ActionEase.extend(/** @lends cocos.actions.EaseExponentialInOut# */{
    update: function(t) {
        t /= 0.5;
        if (t < 1) {
            t = 0.5 * Math.pow(2, 10 * (t - 1));
        } else {
            t = 0.5 * (-Math.pow(2, -10 * (t - 1)) + 2);
        }
        this.other.update(t);
    },
    
    copy: function() {
        return EaseExponentialInOut.create({action: this.other.copy()});
    },
    
    reverse: function() {
        return EaseExponentialInOut.create({action: this.other.reverse()});
    }
});

/**
 * @class EaseSineIn action
 */
var EaseSineIn = ActionEase.extend(/** @lends cocos.actions.EaseSineIn# */{
    update: function(t) {
        this.other.update(-1 * Math.cos(t * Math.PI_2) + 1);
    },
    
    copy: function() {
        return EaseSineIn.create({action: this.other.copy()});
    },
    
    reverse: function() {
        return exports.EaseSineOut.create({action: this.other.reverse()});
    }
});

/**
 * @class EaseSineOut action
 */
var EaseSineOut = ActionEase.extend(/** @lends cocos.actions.EaseSineOut# */{
    update: function(t) {
        this.other.update(Math.sin(t * Math.PI_2));
    },
    
    copy: function() {
        return EaseSineOut.create({action: this.other.copy()});
    },
    
    reverse: function() {
        return exports.EaseSineIn.create({action: this.other.reverse()});
    }
});

/**
 * @class EaseSineInOut action
 */
var EaseSineInOut = ActionEase.extend(/** @lends cocos.actions.EaseSineInOut# */{
    update: function(t) {
        this.other.update(-0.5 * (Math.cos(t * Math.PI) - 1));
    },
    
    copy: function() {
        return EaseSineInOut.create({action: this.other.copy()});
    },
    
    reverse: function() {
        return EaseSineInOut.create({action: this.other.reverse()});
    }
});

var EaseElastic = ActionEase.extend(/** @lends cocos.actions.EaseElastic# */{
    /**
    * period of the wave in radians. default is 0.3
    * @type {Float}
    */
    period: 0.3,

    /**
    * @class EaseElastic Ease Elastic abstract class
    *
    * @memberOf cocos.actions
    * @constructs
    * @extends cocos.actions.ActionEase
    *
    * @opt {cocos.actions.ActionInterval} action
    * @opt {Float} period
    */
    init: function(opts) {
        EaseElastic.superclass.init.call(this, {action: opts.action});

        if (opts.period !== undefined) {
            this.period = opts.period;
        }
    },

    copy: function() {
        return EaseElastic.create({action: this.other.copy(), period: this.period});
    },

    reverse: function() {
        window.console.warn("EaseElastic reverse(): Override me");
        return null;
    }
});

var EaseElasticIn = EaseElastic.extend(/** @lends cocos.actions.EaseElasticIn# */{
    /** 
     * @class EaseElasticIn Ease Elastic In action
     */
    update: function(t) {
        var newT = 0;
        if (t == 0 || t == 1) {
            newT = t;
        } else {
            var s = this.period / 4;
            t -= 1;
            newT = -Math.pow(2, 10 * t) * Math.sin((t - s) * Math.PI*2 / this.period);
        }
        this.other.update(newT);
    },
    
    // Wish we could use base class's copy
    copy: function() {
        return EaseElasticIn.create({action: this.other.copy(), period: this.period});
    },
    
    reverse: function() {
        return exports.EaseElasticOut.create({action: this.other.reverse(), period: this.period});
    }
});

var EaseElasticOut = EaseElastic.extend(/** @lends cocos.actions.EaseElasticOut# */{
    /** 
     * @class EaseElasticOut Ease Elastic Out action
     */
    update: function(t) {
        var newT = 0;
        if (t == 0 || t == 1) {
            newT = t;
        } else {
            var s = this.period / 4;
            newT = Math.pow(2, -10 * t) * Math.sin((t - s) * Math.PI*2 / this.period) + 1;
        }
        this.other.update(newT);
    },
    
    copy: function() {
        return EaseElasticOut.create({action: this.other.copy(), period: this.period});
    },
    
    reverse: function() {
        return exports.EaseElasticIn.create({action: this.other.reverse(), period: this.period});
    }
});

var EaseElasticInOut = EaseElastic.extend(/** @lends cocos.actions.EaseElasticInOut# */{
    /** 
     * @class EaseElasticInOut Ease Elastic InOut action
     */
    update: function(t) {
        var newT = 0;
        if (t == 0 || t == 1) {
            newT = t;
        } else {
            t *= 2;
            if (this.period == 0) {
                this.period = 0.3 * 1.5;
            }
            var s = this.period / 4;
            
            t -= 1;
            if (t < 0) {
                newT = -0.5 * Math.pow(2, 10 * t) * Math.sin((t - s) * Math.PI*2 / this.period);
            } else {
                newT = Math.pow(2, -10 * t) * Math.sin((t - s) * Math.PI*2 / this.period) * 0.5 + 1;
            }
        }
        this.other.update(newT);
    },
    
    copy: function() {
        return EaseElasticInOut.create({action: this.other.copy(), period: this.period});
    },
    
    reverse: function() {
        return EaseElasticInOut.create({action: this.other.reverse(), period: this.period});
    }
});

var EaseBounce = ActionEase.extend(/** @lends cocos.actions.EaseBounce# */{
    /** 
     * @class EaseBounce abstract class
     */
    bounceTime: function(t) {
        // Direct cut & paste from CCActionEase.m, obviously.
        // Glad someone else figured out all this math...
        if (t < 1 / 2.75) {
            return 7.5625 * t * t;
        }
        else if (t < 2 / 2.75) {
            t -= 1.5 / 2.75;
            return 7.5625 * t * t + 0.75;
        }
        else if (t < 2.5 / 2.75) {
            t -= 2.25 / 2.75;
            return 7.5625 * t * t + 0.9375;
        }

        t -= 2.625 / 2.75;
        return 7.5625 * t * t + 0.984375;
    }
});

var EaseBounceIn = EaseBounce.extend(/** @lends cocos.actions.EaseBounceIn# */{
    /** 
     * @class EaseBounceIn EaseBounceIn action
     */
    update: function(t) {
        var newT = 1 - this.bounceTime(1-t);
        this.other.update(newT);
    },
    
    copy: function() {
        return EaseBounceIn.create({action: this.other.copy()});
    },
    
    reverse: function() {
        return exports.EaseBounceOut.create({action: this.other.reverse()});
    }
});

var EaseBounceOut = EaseBounce.extend(/** @lends cocos.actions.EaseBounceOut# */{
    /** 
     * @class EaseBounceOut EaseBounceOut action
     */
    update: function(t) {
        var newT = this.bounceTime(t);
        this.other.update(newT);
    },
    
    copy: function() {
        return EaseBounceOut.create({action: this.other.copy()});
    },
    
    reverse: function() {
        return exports.EaseBounceIn.create({action: this.other.reverse()});
    }
});

var EaseBounceInOut = EaseBounce.extend(/** @lends cocos.actions.EaseBounceInOut# */{
    /** 
     * @class EaseBounceInOut EaseBounceInOut action
     */
    update: function(t) {
        var newT = 0;
        if (t < 0.5) {
            t *= 2;
            newT = (1 - this.bounceTime(1 - t)) * 0.5;
        } else {
            newT = this.bounceTime(t * 2 - 1) * 0.5 + 0.5;
        }
        this.other.update(newT);
    },
    
    copy: function() {
        return EaseBounceInOut.create({action: this.other.copy()});
    },
    
    reverse: function() {
        return EaseBounceInOut.create({action: this.other.reverse()});
    }
});

var EaseBackIn = ActionEase.extend(/** @lends cocos.actions.EaseBackIn# */{
    /** 
     * @class EaseBackIn EaseBackIn action
     */
    update: function(t) {
        var overshoot = 1.70158;
        this.other.update(t * t * ((overshoot + 1) * t - overshoot));
    },
    
    copy: function() {
        return EaseBackIn.create({action: this.other.copy()});
    },
    
    reverse: function() {
        return exports.EaseBackOut.create({action: this.other.reverse()});
    }
});

var EaseBackOut = ActionEase.extend(/** @lends cocos.actions.EaseBackOut# */{
    /** 
     * @class EaseBackOut EaseBackOut action
     */
    update: function(t) {
        var overshoot = 1.70158;
        t -= 1;
        this.other.update(t * t * ((overshoot + 1) * t + overshoot) + 1);
    },
    
    copy: function() {
        return EaseBackOut.create({action: this.other.copy()});
    },
    
    reverse: function() {
        return exports.EaseBackIn.create({action: this.other.reverse()});
    }
});

var EaseBackInOut = ActionEase.extend(/** @lends cocos.actions.EaseBackInOut# */{
    /** 
     * @class EaseBackInOut EaseBackInOut action
     */
    update: function(t) {
        // Where do these constants come from?
        var overshoot = 1.70158 * 1.525;
        t *= 2;
        if (t < 1) {
            this.other.update((t * t * ((overshoot + 1) * t - overshoot)) / 2);
        } else {
            t -= 2;
            this.other.update((t * t * ((overshoot + 1) * t + overshoot)) / 2 + 1);
        }
    },
    
    copy: function() {
        return EaseBackInOut.create({action: this.other.copy()});
    },
    
    reverse: function() {
        return EaseBackInOut.create({action: this.other.reverse()});
    }
});

exports.ActionEase = ActionEase;
exports.EaseRate = EaseRate;
exports.EaseIn = EaseIn;
exports.EaseOut = EaseOut;
exports.EaseInOut = EaseInOut;
exports.EaseExponentialIn = EaseExponentialIn;
exports.EaseExponentialOut = EaseExponentialOut;
exports.EaseExponentialInOut = EaseExponentialInOut;
exports.EaseSineIn = EaseSineIn;
exports.EaseSineOut = EaseSineOut;
exports.EaseSineInOut = EaseSineInOut;
exports.EaseElastic = EaseElastic;
exports.EaseElasticIn = EaseElasticIn;
exports.EaseElasticOut = EaseElasticOut;
exports.EaseElasticInOut = EaseElasticInOut;
exports.EaseBounce = EaseBounce;
exports.EaseBounceIn = EaseBounceIn;
exports.EaseBounceOut = EaseBounceOut;
exports.EaseBounceInOut = EaseBounceInOut;
exports.EaseBackIn = EaseBackIn;
exports.EaseBackOut = EaseBackOut;
exports.EaseBackInOut = EaseBackInOut;


}};
__resources__["/__builtin__/libs/cocos2d/actions/ActionInstant.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    act = require('./Action'),
    ccp = require('geometry').ccp;

var ActionInstant = act.FiniteTimeAction.extend(/** @lends cocos.actions.ActionInstant */{
    /**
     * @class Base class for actions that triggers instantly. They have no duration.
     *
     * @memberOf cocos.actions
     * @extends cocos.actions.FiniteTimeAction
     * @constructs
     */
    init: function (opts) {
        ActionInstant.superclass.init.call(this, opts);

        this.duration = 0;
    },
    
    get_isDone: function () {
        return true;
    },
    
    step: function (dt) {
        this.update(1);
    },
    
    update: function (t) {
        // ignore
    },
    
    copy: function() {
        return this;
    },
    
    reverse: function () {
        return this.copy();
    }
});

var Show = ActionInstant.extend(/** @lends cocos.actions.Show# */{
    /** 
    * @class Show Show the node
    **/
    startWithTarget: function(target) {
        Show.superclass.startWithTarget.call(this, target);
        this.target.set('visible', true);
    },

    copy: function() {
        return Show.create();
    },
    
    reverse: function() {
        return exports.Hide.create();
    }
});

var Hide = ActionInstant.extend(/** @lends cocos.actions.Hide# */{
    /** 
    * @class Hide Hide the node
    **/
    startWithTarget: function(target) {
        Show.superclass.startWithTarget.call(this, target);
        this.target.set('visible', false);
    },

    copy: function() {
        return Hide.create();
    },
    
    reverse: function() {
        return exports.Show.create();
    }
});

var ToggleVisibility = ActionInstant.extend(/** @lends cocos.actions.ToggleVisibility# */{
    /** 
    * @class ToggleVisibility Toggles the visibility of a node
    **/
    startWithTarget: function(target) {
        ToggleVisibility.superclass.startWithTarget.call(this, target);
        var vis = this.target.get('visible');
        this.target.set('visible', !vis);
    },
    
    copy: function() {
        return ToggleVisibility.create();
    }
});

var FlipX = ActionInstant.extend(/** @lends cocos.actions.FlipX# */{
    flipX: false,

    /**
     * @class FlipX Flips a sprite horizontally
     *
     * @memberOf cocos.actions
     * @extends cocos.actions.ActionInstant
     * @constructs
     *
     * @opt {Boolean} flipX Should the sprite be flipped
     */
    init: function (opts) {
        FlipX.superclass.init.call(this, opts);

        this.flipX = opts.flipX;
    },
    
    startWithTarget: function (target) {
        FlipX.superclass.startWithTarget.call(this, target);

        target.set('flipX', this.flipX);
    },
    
    reverse: function () {
        return FlipX.create({flipX: !this.flipX});
    },
    
    copy: function () {
        return FlipX.create({flipX: this.flipX});
    }
});

var FlipY = ActionInstant.extend(/** @lends cocos.actions.FlipY# */{
    flipY: false,

    /**
     * @class FlipY Flips a sprite vertically
     *
     * @memberOf cocos.actions
     * @extends cocos.actions.ActionInstant
     * @constructs
     *
     * @opt {Boolean} flipY Should the sprite be flipped
     */
    init: function (opts) {
        FlipY.superclass.init.call(this, opts);

        this.flipY = opts.flipY;
    },
    
    startWithTarget: function (target) {
        FlipY.superclass.startWithTarget.call(this, target);

        target.set('flipY', this.flipY);
    },
    
    reverse: function () {
        return FlipY.create({flipY: !this.flipY});
    },
    
    copy: function () {
        return FlipY.create({flipY: this.flipY});
    }
});

var Place = ActionInstant.extend(/** @lends cocos.actions.Place# */{
    position: null,
    
    /**
	 * @class Place Places the node in a certain position
	 *
     * @memberOf cocos.actions
     * @extends cocos.actions.ActionInstant
     * @constructs
     *
     * @opt {geometry.Point} position
     */
    init: function(opts) {
        Place.superclass.init.call(this, opts);
        this.set('position', util.copy(opts.position));
    },
    
    startWithTarget: function(target) {
        Place.superclass.startWithTarget.call(this, target);
        this.target.set('position', this.position);
    },
    
    copy: function() {
        return Place.create({position: this.position});
    }
});

var CallFunc = ActionInstant.extend(/** @lends cocos.actions.CallFunc# */{
	callback: null,
    target: null,
    method: null,
    
	/**
	 * @class CallFunc Calls a 'callback'
	 *
     * @memberOf cocos.actions
     * @extends cocos.actions.ActionInstant
     * @constructs
     *
     * @opt {BObject} target
     * @opt {String|Function} method
     */
	init: function(opts) {
		CallFunc.superclass.init.call(this, opts);
		
		// Save target & method so that copy() can recreate callback
		this.target = opts.target;
		this.method = opts.method;
		this.callback = util.callback(this.target, this.method);
	},
	
	startWithTarget: function(target) {
		CallFunc.superclass.startWithTarget.call(this, target);
		this.execute(target);
	},
	
	execute: function(target) {
	    // Pass target to callback
		this.callback.call(this, target);
	},
	
	copy: function() {
	    return CallFunc.create({target: this.target, method: this.method});
	}
});

exports.ActionInstant = ActionInstant;
exports.Show = Show;
exports.Hide = Hide;
exports.ToggleVisibility = ToggleVisibility;
exports.FlipX = FlipX;
exports.FlipY = FlipY;
exports.Place = Place;
exports.CallFunc = CallFunc;


}};
__resources__["/__builtin__/libs/cocos2d/actions/ActionInterval.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    act = require('./Action'),
    geo = require('geometry'),
    ccp = geo.ccp;


var ActionInterval = act.FiniteTimeAction.extend(/** @lends cocos.actions.ActionInterval# */{
    /**
     * Number of seconds that have elapsed
     * @type Float
     */
    elapsed: 0.0,

    _firstTick: true,

    /**
     * Base class actions that do have a finite time duration.
     *
     * Possible actions:
     *
     * - An action with a duration of 0 seconds
     * - An action with a duration of 35.5 seconds Infinite time actions are valid
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.FiniteTimeAction
     *
     * @opt {Float} duration Number of seconds to run action for
     */
    init: function (opts) {
        ActionInterval.superclass.init.call(this, opts);

        var dur = opts.duration || 0;
        if (dur === 0) {
            dur = 0.0000001;
        }

        this.set('duration', dur);
        this.set('elapsed', 0);
        this._firstTick = true;
    },

    get_isDone: function () {
        return (this.elapsed >= this.duration);
    },

    step: function (dt) {
        if (this._firstTick) {
            this._firstTick = false;
            this.elapsed = 0;
        } else {
            this.elapsed += dt;
        }

        this.update(Math.min(1, this.elapsed / this.duration));
    },

    startWithTarget: function (target) {
        ActionInterval.superclass.startWithTarget.call(this, target);

        this.elapsed = 0.0;
        this._firstTick = true;
    },

    copy: function() {
        throw "copy() not implemented";
    },
    
    reverse: function () {
        throw "Reverse Action not implemented";
    }
});

var DelayTime = ActionInterval.extend(/** @lends cocos.actions.DelayTime# */{
    /**
     * @class DelayTime Delays the action a certain amount of seconds
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.ActionInterval
     */
    update: function (t) {
        if (t === 1.0) {
            this.stop();
        }
    },

    copy: function () {
        return DelayTime.create({duration: this.get('duration')});
    },

    reverse: function () {
        return DelayTime.create({duration: this.get('duration')});
    }
});


var ScaleTo = ActionInterval.extend(/** @lends cocos.actions.ScaleTo# */{
    /**
     * Current X Scale
     * @type Float
     */
    scaleX: 1,

    /**
     * Current Y Scale
     * @type Float
     */
    scaleY: 1,

    /**
     * Initial X Scale
     * @type Float
     */
    startScaleX: 1,

    /**
     * Initial Y Scale
     * @type Float
     */
    startScaleY: 1,

    /**
     * Final X Scale
     * @type Float
     */
    endScaleX: 1,

    /**
     * Final Y Scale
     * @type Float
     */
    endScaleY: 1,

    /**
     * Delta X Scale
     * @type Float
     * @private
     */
    deltaX: 0.0,

    /**
     * Delta Y Scale
     * @type Float
     * @private
     */
    deltaY: 0.0,

    /**
     * @class ScaleTo Scales a cocos.Node object to a zoom factor by modifying it's scale attribute.
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.ActionInterval
     *
     * @opt {Float} duration Number of seconds to run action for
     * @opt {Float} [scale] Size to scale Node to
     * @opt {Float} [scaleX] Size to scale width of Node to
     * @opt {Float} [scaleY] Size to scale height of Node to
     */
    init: function (opts) {
        ScaleTo.superclass.init.call(this, opts);

        if (opts.scale !== undefined) {
            this.endScaleX = this.endScaleY = opts.scale;
        } else {
            this.endScaleX = opts.scaleX;
            this.endScaleY = opts.scaleY;
        }


    },

    startWithTarget: function (target) {
        ScaleTo.superclass.startWithTarget.call(this, target);

        this.startScaleX = this.target.get('scaleX');
        this.startScaleY = this.target.get('scaleY');
        this.deltaX = this.endScaleX - this.startScaleX;
        this.deltaY = this.endScaleY - this.startScaleY;
    },

    update: function (t) {
        if (!this.target) {
            return;
        }

        this.target.set('scaleX', this.startScaleX + this.deltaX * t);
        this.target.set('scaleY', this.startScaleY + this.deltaY * t);
    },

    copy: function () {
        return ScaleTo.create({duration: this.get('duration'),
                                 scaleX: this.get('endScaleX'),
                                 scaleY: this.get('endScaleY')});
    }
});

var ScaleBy = ScaleTo.extend(/** @lends cocos.actions.ScaleBy# */{
    /**
     * @class ScaleBy Scales a cocos.Node object to a zoom factor by modifying it's scale attribute.
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.ScaleTo
     *
     * @opt {Float} duration Number of seconds to run action for
     * @opt {Float} [scale] Size to scale Node by
     * @opt {Float} [scaleX] Size to scale width of Node by
     * @opt {Float} [scaleY] Size to scale height of Node by
     */
    init: function (opts) {
        ScaleBy.superclass.init.call(this, opts);
    },

    startWithTarget: function (target) {
        ScaleBy.superclass.startWithTarget.call(this, target);

        this.deltaX = this.startScaleX * this.endScaleX - this.startScaleX;
        this.deltaY = this.startScaleY * this.endScaleY - this.startScaleY;
    },

    reverse: function () {
        return ScaleBy.create({duration: this.get('duration'), scaleX: 1 / this.endScaleX, scaleY: 1 / this.endScaleY});
    }
});


var RotateTo = ActionInterval.extend(/** @lends cocos.actions.RotateTo# */{
    /**
     * Final angle
     * @type Float
     */
    dstAngle: 0,

    /**
     * Initial angle
     * @type Float
     */
    startAngle: 0,

    /**
     * Angle delta
     * @type Float
     */
    diffAngle: 0,

    /**
     * @class RotateTo Rotates a cocos.Node object to a certain angle by modifying its rotation
     * attribute. The direction will be decided by the shortest angle.
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.ActionInterval
     *
     * @opt {Float} duration Number of seconds to run action for
     * @opt {Float} angle Angle in degrees to rotate to
     */
    init: function (opts) {
        RotateTo.superclass.init.call(this, opts);

        this.dstAngle = opts.angle;
    },

    startWithTarget: function (target) {
        RotateTo.superclass.startWithTarget.call(this, target);

        this.startAngle = target.get('rotation');

        if (this.startAngle > 0) {
            this.startAngle = (this.startAngle % 360);
        } else {
            this.startAngle = (this.startAngle % -360);
        }

        this.diffAngle = this.dstAngle - this.startAngle;
        if (this.diffAngle > 180) {
            this.diffAngle -= 360;
        } else if (this.diffAngle < -180) {
            this.diffAngle += 360;
        }
    },

    update: function (t) {
        this.target.set('rotation', this.startAngle + this.diffAngle * t);
    },

    copy: function () {
        return RotateTo.create({duration: this.get('duration'), angle: this.get('dstAngle')});
    }
});

var RotateBy = RotateTo.extend(/** @lends cocos.actions.RotateBy# */{
    /**
     * Number of degrees to rotate by
     * @type Float
     */
    angle: 0,

    /**
     * @class RotateBy Rotates a cocos.Node object to a certain angle by modifying its rotation
     * attribute. The direction will be decided by the shortest angle.
     *
     * @memberOf cocos.action
     * @constructs
     * @extends cocos.actions.RotateTo
     *
     * @opt {Float} duration Number of seconds to run action for
     * @opt {Float} angle Angle in degrees to rotate by
     */
    init: function (opts) {
        RotateBy.superclass.init.call(this, opts);

        this.angle = opts.angle;
    },

    startWithTarget: function (target) {
        RotateBy.superclass.startWithTarget.call(this, target);

        this.startAngle = this.target.get('rotation');
    },

    update: function (t) {
        this.target.set('rotation', this.startAngle + this.angle * t);
    },

    copy: function () {
        return RotateBy.create({duration: this.get('duration'), angle: this.angle});
    },
    
    reverse: function () {
        return RotateBy.create({duration: this.get('duration'), angle: -this.angle});
    }
});

var MoveTo = ActionInterval.extend(/** @lends cocos.actions.MoveTo# */{
    delta: null,
    startPosition: null,
    endPosition: null,

    /**
     * @class MoveTo Animates moving a cocos.nodes.Node object to a another point.
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.ActionInterval
     *
     * @opt {Float} duration Number of seconds to run action for
     * @opt {geometry.Point} position Destination position
     */
    init: function (opts) {
        MoveTo.superclass.init.call(this, opts);

        this.set('endPosition', util.copy(opts.position));
    },

    startWithTarget: function (target) {
        MoveTo.superclass.startWithTarget.call(this, target);

        this.set('startPosition', util.copy(target.get('position')));
        this.set('delta', geo.ccpSub(this.get('endPosition'), this.get('startPosition')));
    },

    update: function (t) {
        var startPosition = this.get('startPosition'),
            delta = this.get('delta');
        this.target.set('position', ccp(startPosition.x + delta.x * t, startPosition.y + delta.y * t));
    },
    
    copy: function() {
        return MoveTo.create({duration: this.get('duration'), position: this.get('endPosition')});
    }
});

var MoveBy = MoveTo.extend(/** @lends cocos.actions.MoveBy# */{
    /**
     * @class MoveBy Animates moving a cocos.node.Node object by a given number of pixels
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.MoveTo
     *
     * @opt {Float} duration Number of seconds to run action for
     * @opt {geometry.Point} position Number of pixels to move by
     */
    init: function (opts) {
        MoveBy.superclass.init.call(this, opts);

        this.set('delta', util.copy(opts.position));
    },

    startWithTarget: function (target) {
        var dTmp = this.get('delta');
        MoveBy.superclass.startWithTarget.call(this, target);
        this.set('delta', dTmp);
    },
    
    copy: function() {
         return MoveBy.create({duration: this.get('duration'), position: this.get('delta')});
    },
    
    reverse: function() {
        var delta = this.get('delta');
        return MoveBy.create({duration: this.get('duration'), position: geo.ccp(-delta.x, -delta.y)});
    }
});

var JumpBy = ActionInterval.extend(/** @lends cocos.actions.JumpBy# */{
    /**
     * Number of pixels to jump by
     * @type geometry.Point
     */
    delta: null,
    
    /**
     * Height of jump
     * @type Float
     */
    height: 0,
    
    /**
     * Number of times to jump
     * @type Integer
     */
    jumps: 0,
    
    /**
     * Starting point
     * @type geometry.Point
     */
    startPosition: null,
    
    /**
     * @class JumpBy Moves a CCNode object simulating a parabolic jump movement by modifying it's position attribute.
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.ActionInterval
     *
     * @opt {Float} duration Number of seconds to run action for
     * @opt {geometry.Point} startPosition Point at which jump starts
     * @opt {geometry.Point} delta Number of pixels to jump by
     * @opt {Float} height Height of jump
     * @opt {Int} jumps Number of times to repeat
     */
    init: function(opts) {
        JumpBy.superclass.init.call(this, opts);
        
        this.delta  = util.copy(opts.delta);
        this.height = opts.height;
        this.jumps  = opts.jumps;
    },
    
    copy: function() {
        return JumpBy.create({duration: this.duration, 
                                 delta: this.delta,
                                height: this.height,
                                 jumps: this.jumps});
    },
    
    startWithTarget: function(target) {
        JumpBy.superclass.startWithTarget.call(this, target);
        this.set('startPosition', target.get('position'));
    },
    
    update: function(t) {
        // parabolic jump
        var frac = (t * this.jumps) % 1.0;
        var y = this.height * 4 * frac * (1 - frac);
        y += this.delta.y * t;
        var x = this.delta.x * t;
        this.target.set('position', geo.ccp(this.startPosition.x + x, this.startPosition.y + y));
    },
    
    reverse: function() {
        return JumpBy.create({duration: this.duration,
                                 delta: geo.ccp(-this.delta.x, -this.delta.y),
                                height: this.height,
                                 jumps: this.jumps});
    }
});

var JumpTo = JumpBy.extend(/** @lends cocos.actions.JumpTo# */{
    /**
     * @class JumpTo Moves a Node object to a parabolic position simulating a jump 
     * movement by modifying it's position attribute.
     *
     * @memberOf cocos.actions
     * @extends cocos.actions.JumpBy
     */
    startWithTarget: function(target) {
        JumpTo.superclass.startWithTarget.call(this, target);
        this.delta = geo.ccp(this.delta.x - this.startPosition.x, this.delta.y - this.startPosition.y);
    }
});

var BezierBy = ActionInterval.extend(/** @lends cocos.actions.BezierBy# */{
    /**
     * @type {geometry.BezierConfig}
     */
    config: null,
    
    startPosition: null,
    
    /**
     * @class BezierBy An action that moves the target with a cubic Bezier curve by a certain distance.
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.ActionInterval
     *
     * @opts {geometry.BezierConfig} bezier Bezier control points object
     * @opts {Float} duration
     */
    init: function(opts) {
        BezierBy.superclass.init.call(this, opts);
        
        this.config = util.copy(opts.bezier);
    },
    
    startWithTarget: function(target) {
        BezierBy.superclass.startWithTarget.call(this, target);
        this.set('startPosition', this.target.get('position'));
    },
    
    update: function(t) {
        var c = this.get('config');
        var xa = 0,
            xb = c.controlPoint1.x,
            xc = c.controlPoint2.x,
            xd = c.endPosition.x,
            ya = 0,
            yb = c.controlPoint1.y,
            yc = c.controlPoint2.y,
            yd = c.endPosition.y;
        
        var x = BezierBy.bezierat(xa, xb, xc, xd, t);
        var y = BezierBy.bezierat(ya, yb, yc, yd, t);
        
        this.target.set('position', geo.ccpAdd(this.get('startPosition'), geo.ccp(x, y)));
    },
    
    copy: function() {
        return BezierBy.create({bezier: this.get('config'), duration: this.get('duration')});
    },
    
    reverse: function() {
        var c = this.get('config'),
            bc = new geo.BezierConfig();
            
        bc.endPosition = geo.ccpNeg(c.endPosition);
        bc.controlPoint1 = geo.ccpAdd(c.controlPoint2, geo.ccpNeg(c.endPosition));
        bc.controlPoint2 = geo.ccpAdd(c.controlPoint1, geo.ccpNeg(c.endPosition));
        
        return BezierBy.create({bezier: bc, duration: this.get('duration')});
    }
});

util.extend(BezierBy, {
    /**
     * Bezier cubic formula
     * ((1 - t) + t)3 = 1 
     */
    bezierat: function(a, b, c, d, t) {
       return Math.pow(1-t, 3) * a + 
            3 * t * Math.pow(1-t, 2) * b +
            3 * Math.pow(t, 2) * (1 - t) * c +
            Math.pow(t, 3) * d;
    }
});

var BezierTo = BezierBy.extend(/** @lends cocos.actions.BezierTo# */{
    /**
     * @class BezierTo An action that moves the target with a cubic Bezier curve to a destination point.
     *
     * @memberOf cocos.actions
     * @extends cocos.actions.BezierBy
     */
    startWithTarget: function(target) {
        BezierTo.superclass.startWithTarget.call(this, target);
        
        var c = this.get('config');
        c.controlPoint1 = geo.ccpSub(c.controlPoint1, this.get('startPosition'));
        c.controlPoint2 = geo.ccpSub(c.controlPoint2, this.get('startPosition'));
        c.endPosition = geo.ccpSub(c.endPosition, this.get('startPosition'));
    }
});

var Blink = ActionInterval.extend(/** @lends cocos.actions.Blink# */{
    /**
     * @type {Integer}
     */
    times: 1,
    
    /**
     * @class Blink Blinks a Node object by modifying it's visible attribute
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.ActionInterval
     *
     * @opts {Integer} blinks Number of times to blink
     * @opts {Float} duration
     */
    init: function(opts) {
        Blink.superclass.init.call(this, opts);
        this.times = opts.blinks;
    },
    
    update: function(t) {
        if (! this.get_isDone()) {
            var slice = 1 / this.times;
            var m = t % slice;
            this.target.set('visible', (m > slice/2));
        }
    },
    
    copy: function() {
        return Blink.create({duration: this.get('duration'), blinks: this.get('times')});
    },
    
    reverse: function() {
        return this.copy();
    }
});

var FadeOut = ActionInterval.extend(/** @lends cocos.actions.FadeOut# */{
   /**
    * @class FadeOut Fades out a cocos.nodes.Node to zero opacity
    *
    * @memberOf cocos.actions
    * @extends cocos.actions.ActionInterval
    */     
    update: function (t) {
        var target = this.get('target');
        if (!target) return;
        target.set('opacity', 255 - (255 * t));
    },

    copy: function () {
        return FadeOut.create({duration: this.get('duration')});
    },
    
    reverse: function () {
        return exports.FadeIn.create({duration: this.get('duration')});
    }
});


var FadeIn = ActionInterval.extend(/** @lends cocos.actions.FadeIn# */{
    /**
     * @class FadeIn Fades in a cocos.nodes.Node to 100% opacity
     *
     * @memberOf cocos.actions
     * @extends cocos.actions.ActionInterval
     */
    update: function (t) {
        var target = this.get('target');
        if (!target) return;
        target.set('opacity', t * 255);
    },

    copy: function () {
        return FadeIn.create({duration: this.get('duration')});
    },
    
    reverse: function () {
        return exports.FadeOut.create({duration: this.get('duration')});
    }
});

var FadeTo = ActionInterval.extend(/** @lends cocos.actions.FadeTo# */{
    /**
     * The final opacity
     * @type Float
     */
    toOpacity: null,

    /**
     * The initial opacity
     * @type Float
     */
    fromOpacity: null,

    /**
     * @class FadeTo Fades a cocos.nodes.Node to a given opacity
     *
     * @memberOf cocos.actions
     * @constructor
     * @extends cocos.actions.ActionInterval
     */
    init: function (opts) {
        FadeTo.superclass.init.call(this, opts);
        this.set('toOpacity', opts.toOpacity);
    },

    startWithTarget: function (target) {
        FadeTo.superclass.startWithTarget.call(this, target);
        this.set('fromOpacity', this.target.get('opacity'));
    },

    update: function (t) {
        var target = this.get('target');
        if (!target) return;

        target.set('opacity', this.fromOpacity + ( this.toOpacity - this.fromOpacity ) * t);
    },
    
    copy: function() {
        return FadeTo.create({duration: this.get('duration'), toOpacity: this.get('toOpacity')});
    }
});

var Sequence = ActionInterval.extend(/** @lends cocos.actions.Sequence# */{
    /**
     * Array of actions to run
     * @type cocos.nodes.Node[]
     */
    actions: null,

    split: 0,
    last: 0,
    
    /**
     * Runs a pair of actions sequentially, one after another
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.ActionInterval
     *
     * @opt {cocos.actions.FiniteTimeAction} one 1st action to run
     * @opt {cocos.actions.FiniteTimeAction} two 2nd action to run
     */
    init: function (opts) {
        if (!opts.one) {
            throw "Sequence argument one must be non-nil";
        }
        if (!opts.two) {
            throw "Sequence argument two must be non-nil";
        }
        this.actions = [];
        
        var d = opts.one.get('duration') + opts.two.get('duration');
        
        Sequence.superclass.init.call(this, {duration: d});
        
        this.actions[0] = opts.one;
        this.actions[1] = opts.two;
    },
    
    startWithTarget: function (target) {
        Sequence.superclass.startWithTarget.call(this, target);
        this.split = this.actions[0].get('duration') / this.get('duration');
        this.last = -1;
    },

    stop: function () {
        this.actions[0].stop();
        this.actions[1].stop();
        Sequence.superclass.stop.call(this);
    },

    update: function (t) {
        // This is confusing but will hopefully work better in conjunction
        // with modifer actions like Repeat & Spawn...
        var found = 0;
        var new_t = 0;
        
        if (t >= this.split) {
            found = 1;
            if (this.split == 1) {
                new_t = 1;
            } else {
                new_t = (t - this.split) / (1 - this.split);
            }
        } else {
            found = 0;
            if (this.split != 0) {
                new_t = t / this.split;
            } else {
                new_t = 1;
            }
        }
        if (this.last == -1 && found == 1) {
            this.actions[0].startWithTarget(this.target);
            this.actions[0].update(1);
            this.actions[0].stop();
        }
        if (this.last != found) {
            if (this.last != -1) {
                this.actions[this.last].update(1);
                this.actions[this.last].stop();
            }
            this.actions[found].startWithTarget(this.target);
        }
        this.actions[found].update(new_t);
        this.last = found;
    },

    copy: function () {
        // Constructor will copy actions 
        return Sequence.create({actions: this.get('actions')});
    },

    reverse: function() {
        return Sequence.create({actions: [this.actions[1].reverse(), this.actions[0].reverse()]});
    }
});

util.extend(Sequence, {
    /** 
     * Override BObject.create in order to implement recursive construction
     * of actions array
     */
    create: function() {
        // Don't copy actions array, copy the actions
        var actions = arguments[0].actions;
        var prev = actions[0].copy();
        
        // Recursively create Sequence with pair of actions
        for (var i=1; i<actions.length; i++) {
            var now = actions[i].copy();
            if (now) {
                prev = this.initFromPair(prev, now);
            } else {
                break;
            }
        }
        return prev;
    },
    
    /** 
     * Create sequence object from a pair of actions
     */
    initFromPair: function(a1, a2) {
        var ret = new this();
        ret.init.apply(ret, [{one: a1, two: a2}]);
        return ret;
    }
});

var Repeat = ActionInterval.extend(/** @lends cocos.actions.Repeat# */{
    times: 1,
    total: 0,
    other: null,
    
    /**
     * @class Repeat Repeats an action a number of times.
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.ActionInterval
     *
     * @opt {cocos.actions.FiniteTimeAction} action Action to repeat
     * @opt {Number} times Number of times to repeat
     */
     init: function(opts) {
         var d = opts.action.get('duration') * opts.times;

         Repeat.superclass.init.call(this, {duration: d});
         
         this.times = opts.times;
         this.other = opts.action.copy();
         this.total = 0;
     },
     
     startWithTarget: function(target) {
         this.total = 0;
         Repeat.superclass.startWithTarget.call(this, target);
         this.other.startWithTarget(target);
     },
     
     stop: function() {
         this.other.stop();
         Repeat.superclass.stop.call(this);
     },
     
     update: function(dt) {
         var t = dt * this.times;
         
         if (t > (this.total+1)) {
             this.other.update(1);
             this.total += 1;
             this.other.stop();
             this.other.startWithTarget(this.target);
             
             // If repeat is over
             if (this.total == this.times) {
                 // set it in the original position
                 this.other.update(0);
             } else {
                 // otherwise start next repeat
                 this.other.update(t - this.total);
             }
         } else {
             var r = t % 1.0;
             
             // fix last repeat position otherwise it could be 0
             if (dt == 1) {
                 r = 1;
                 this.total += 1;
             }
             this.other.update(Math.min(r, 1));
         }
     },
     
     get_isDone: function() {
         return this.total == this.times;
     },
     
     copy: function() {
         // Constructor copies action
         return Repeat.create({action: this.other, times: this.times});
     },
     
     reverse: function() {
         return Repeat.create({action: this.other.reverse(), times: this.times});
     }
});

var Spawn = ActionInterval.extend(/** @lends cocos.actions.Spawn# */{
    one: null,
    two: null,

    /**
     * @class Spawn Executes multiple actions simultaneously
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.ActionInterval
     *
     * @opt {cocos.actions.FiniteTimeAction} one: first action to spawn
     * @opt {cocos.actions.FiniteTimeAction} two: second action to spawn
     */
    init: function (opts) {
        var action1 = opts.one, 
            action2 = opts.two;
            
        if (!action1 || !action2) {
            throw "cocos.actions.Spawn: required actions missing";
        }
        var d1 = action1.get('duration'), 
            d2 = action2.get('duration');
        
        Spawn.superclass.init.call(this, {duration: Math.max(d1, d2)});
        
        this.set('one', action1);
        this.set('two', action2);
        
        if (d1 > d2) {
            this.set('two', Sequence.create({actions: [
                action2, 
                DelayTime.create({duration: d1-d2})
            ]}));
        } else if (d1 < d2) {
            this.set('one', Sequence.create({actions: [
                action1,
                DelayTime.create({duration: d2-d1})
            ]}));
        }
    },
    
    startWithTarget: function (target) {
        Spawn.superclass.startWithTarget.call(this, target);
        this.get('one').startWithTarget(this.target);
        this.get('two').startWithTarget(this.target);
    },
    
    stop: function () {
        this.get('one').stop();
        this.get('two').stop();
        Spawn.superclass.stop.call(this);
    },
    
    step: function (dt) {
        if (this._firstTick) {
            this._firstTick = false;
            this.elapsed = 0;
        } else {
            this.elapsed += dt;
        }
        this.get('one').step(dt);
        this.get('two').step(dt);
    },
    
    update: function (t) {
        this.get('one').update(t);
        this.get('two').update(t);
    },
    
    copy: function () {
        return Spawn.create({one: this.get('one').copy(), two: this.get('two').copy()});
    },
    
    reverse: function () {
        return Spawn.create({one: this.get('one').reverse(), two: this.get('two').reverse()});
    }
});

util.extend(Spawn, {
    /**
     * Helper class function to create Spawn object from array of actions
     *
     * @opt {Array} actions: list of actions to run simultaneously
     */
    initWithActions: function (opts) {
        var now, prev = opts.actions.shift();
        while (opts.actions.length > 0) {
            now = opts.actions.shift();
            if (now) {
                prev = this.create({one: prev, two: now});
            } else {
                break;
            }
        }
        return prev;
    }
});

var Animate = ActionInterval.extend(/** @lends cocos.actions.Animate# */{
    animation: null,
    restoreOriginalFrame: true,
    origFrame: null,


    /**
     * Animates a sprite given the name of an Animation
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.ActionInterval
     *
     * @opt {Float} duration Number of seconds to run action for
     * @opt {cocos.Animation} animation Animation to run
     * @opt {Boolean} [restoreOriginalFrame=true] Return to first frame when finished
     */
    init: function (opts) {
        this.animation = opts.animation;
        this.restoreOriginalFrame = opts.restoreOriginalFrame !== false;
        opts.duration = this.animation.frames.length * this.animation.delay;

        Animate.superclass.init.call(this, opts);
    },

    startWithTarget: function (target) {
        Animate.superclass.startWithTarget.call(this, target);

        if (this.restoreOriginalFrame) {
            this.set('origFrame', this.target.get('displayedFrame'));
        }
    },

    stop: function () {
        if (this.target && this.restoreOriginalFrame) {
            var sprite = this.target;
            sprite.set('displayFrame', this.origFrame);
        }

        Animate.superclass.stop.call(this);
    },

    update: function (t) {
        var frames = this.animation.get('frames'),
            numberOfFrames = frames.length,
            idx = Math.floor(t * numberOfFrames);

        if (idx >= numberOfFrames) {
            idx = numberOfFrames - 1;
        }

        var sprite = this.target;
        if (!sprite.isFrameDisplayed(frames[idx])) {
            sprite.set('displayFrame', frames[idx]);
        }
    },

    copy: function () {
        return Animate.create({animation: this.animation, restoreOriginalFrame: this.restoreOriginalFrame});
    }

});

exports.ActionInterval = ActionInterval;
exports.DelayTime = DelayTime;
exports.ScaleTo = ScaleTo;
exports.ScaleBy = ScaleBy;
exports.RotateTo = RotateTo;
exports.RotateBy = RotateBy;
exports.MoveTo = MoveTo;
exports.MoveBy = MoveBy;
exports.JumpBy = JumpBy;
exports.JumpTo = JumpTo;
exports.BezierBy = BezierBy;
exports.BezierTo = BezierTo;
exports.Blink = Blink;
exports.FadeIn = FadeIn;
exports.FadeOut = FadeOut;
exports.FadeTo = FadeTo;
exports.Spawn = Spawn;
exports.Sequence = Sequence;
exports.Repeat = Repeat;
exports.Animate = Animate;

}};
__resources__["/__builtin__/libs/cocos2d/actions/index.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    path = require('path');

var modules = 'Action ActionInterval ActionInstant ActionEase'.w();

/**
 * @memberOf cocos
 * @namespace Actions used to animate or change a Node
 */
var actions = {};

util.each(modules, function (mod, i) {
    util.extend(actions, require('./' + mod));
});

module.exports = actions;

}};
__resources__["/__builtin__/libs/cocos2d/Animation.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util');

var Animation = BObject.extend(/** @lends cocos.Animation# */{
    name: null,
    delay: 0.0,
    frames: null,

    /** 
     * A cocos.Animation object is used to perform animations on the Sprite objects.
     * 
     * The Animation object contains cocos.SpriteFrame objects, and a possible delay between the frames.
     * You can animate a cocos.Animation object by using the cocos.actions.Animate action.
     * 
     * @memberOf cocos
     * @constructs
     * @extends BObject
     *
     * @opt {cocos.SpriteFrame[]} frames Frames to animate
     * @opt {Float} [delay=0.0] Delay between each frame
     * 
     * @example
     * var animation = cocos.Animation.create({frames: [f1, f2, f3], delay: 0.1});
     * sprite.runAction(cocos.actions.Animate.create({animation: animation}));
     */
    init: function (opts) {
        Animation.superclass.init.call(this, opts);

        this.frames = opts.frames || [];
        this.delay  = opts.delay  || 0.0;
    }
});

exports.Animation = Animation;

}};
__resources__["/__builtin__/libs/cocos2d/AnimationCache.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    Plist = require('Plist').Plist;

var AnimationCache = BObject.extend(/** @lends cocos.AnimationCache# */{
    /**
     * Cached animations
     * @type Object
     */
    animations: null,

    /**
     * @memberOf cocos
     * @constructs
     * @extends BObject
     * @singleton
     */
    init: function () {
        AnimationCache.superclass.init.call(this);

        this.set('animations', {});
    },

    /**
     * Add an animation to the cache
     *
     * @opt {String} name Unique name of the animation
     * @opt {cocos.Animcation} animation Animation to cache
     */
    addAnimation: function (opts) {
        var name = opts.name,
            animation = opts.animation;

        this.get('animations')[name] = animation;
    },

    /**
     * Remove an animation from the cache
     *
     * @opt {String} name Unique name of the animation
     */
    removeAnimation: function (opts) {
        var name = opts.name;

        delete this.get('animations')[name];
    },

    /**
     * Get an animation from the cache
     *
     * @opt {String} name Unique name of the animation
     * @returns {cocos.Animation} Cached animation
     */
    getAnimation: function (opts) {
        var name = opts.name;

        return this.get('animations')[name];
    }
});

/**
 * Class methods
 */
util.extend(AnimationCache, /** @lends cocos.AnimationCache */{
    /**
     * @getter sharedAnimationCache
     * @type cocos.AnimationCache
     */
    get_sharedAnimationCache: function (key) {
        if (!this._instance) {
            this._instance = this.create();
        }

        return this._instance;
    }
});

exports.AnimationCache = AnimationCache;

}};
__resources__["/__builtin__/libs/cocos2d/Director.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray FLIP_Y_AXIS SHOW_REDRAW_REGIONS*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    geo = require('geometry'),
    ccp = geo.ccp,
    events    = require('events'),
    Scheduler = require('./Scheduler').Scheduler,
    EventDispatcher = require('./EventDispatcher').EventDispatcher,
    Scene = require('./nodes/Scene').Scene;


/**
 * requestAnimationFrame for smart animating
 * @see http://paulirish.com/2011/requestanimationframe-for-smart-animating/
 */
window.requestAnimFrame = (function (){
    return  window.requestAnimationFrame       || 
            window.webkitRequestAnimationFrame || 
            window.mozRequestAnimationFrame    || 
            window.oRequestAnimationFrame      || 
            window.msRequestAnimationFrame     || 
            function (callback) {
                window.setTimeout(callback, 1000 / 30);
            };
})();

var Director = BObject.extend(/** @lends cocos.Director# */{
    backgroundColor: 'rgb(0, 0, 0)',
    canvas: null,
    context: null,
    sceneStack: null,
    winSize: null,
    isPaused: false,
    maxFrameRate: 30,
    displayFPS: false,
    preloadScene: null,
    isReady: false,

    // Time delta
    dt: 0,
    nextDeltaTimeZero: false,
    lastUpdate: 0,

    _nextScene: null,

    /**
     * <p>Creates and handles the main view and manages how and when to execute the
     * Scenes.</p>
     *
     * <p>This class is a singleton so don't instantiate it yourself, instead use
     * cocos.Director.get('sharedDirector') to return the instance.</p>
     *
     * @memberOf cocos
     * @constructs
     * @extends BObject
     * @singleton
     */
    init: function () {
        Director.superclass.init.call(this);

        this.set('sceneStack', []);
    },

    /**
     * Append to a HTML element. It will create a canvas tag
     *
     * @param {HTMLElement} view Any HTML element to add the application to
     */
    attachInView: function (view) {
        if (!view.tagName) {
            throw "Director.attachInView must be given a HTML DOM Node";
        }

        while (view.firstChild) {
            view.removeChild(view.firstChild);
        }


        var canvas = document.createElement('canvas');
        this.set('canvas', canvas);
        canvas.setAttribute('width', view.clientWidth);
        canvas.setAttribute('height', view.clientHeight);

        var context = canvas.getContext('2d');
        this.set('context', context);

        if (FLIP_Y_AXIS) {
            context.translate(0, view.clientHeight);
            context.scale(1, -1);
        }

        view.appendChild(canvas);

        this.set('winSize', {width: view.clientWidth, height: view.clientHeight});


        // Setup event handling

        // Mouse events
        var eventDispatcher = EventDispatcher.get('sharedDispatcher');
        var self = this;
        function mouseDown(evt) {
            evt.locationInWindow = ccp(evt.clientX, evt.clientY);
            evt.locationInCanvas = self.convertEventToCanvas(evt);

            function mouseDragged(evt) {
                evt.locationInWindow = ccp(evt.clientX, evt.clientY);
                evt.locationInCanvas = self.convertEventToCanvas(evt);

                eventDispatcher.mouseDragged(evt);
            }
            function mouseUp(evt) {
                evt.locationInWindow = ccp(evt.clientX, evt.clientY);
                evt.locationInCanvas = self.convertEventToCanvas(evt);

                document.body.removeEventListener('mousemove', mouseDragged, false);
                document.body.removeEventListener('mouseup',   mouseUp,   false);


                eventDispatcher.mouseUp(evt);
            }

            document.body.addEventListener('mousemove', mouseDragged, false);
            document.body.addEventListener('mouseup',   mouseUp,   false);

            eventDispatcher.mouseDown(evt);
        }
        function mouseMoved(evt) {
            evt.locationInWindow = ccp(evt.clientX, evt.clientY);
            evt.locationInCanvas = self.convertEventToCanvas(evt);

            eventDispatcher.mouseMoved(evt);
        }
        canvas.addEventListener('mousedown', mouseDown, false);
        canvas.addEventListener('mousemove', mouseMoved, false);

        // Keyboard events
        function keyDown(evt) {
            this._keysDown = this._keysDown || {};
            eventDispatcher.keyDown(evt);
        }
        function keyUp(evt) {
            eventDispatcher.keyUp(evt);
        }

        document.documentElement.addEventListener('keydown', keyDown, false);
        document.documentElement.addEventListener('keyup', keyUp, false);
    },

    runPreloadScene: function () {
        var preloader = this.get('preloadScene');
        if (!preloader) {
            var PreloadScene = require('./nodes/PreloadScene').PreloadScene;
            preloader = PreloadScene.create();
            this.set('preloadScene', preloader);
        }

        events.addListener(preloader, 'complete', util.callback(this, function (preloader) {
            this.isReady = true;
            events.trigger(this, 'ready', this);
        }));

        this.pushScene(preloader);
        this.startAnimation();
    },

    /**
     * Enters the Director's main loop with the given Scene. Call it to run
     * only your FIRST scene. Don't call it if there is already a running
     * scene.
     *
     * @param {cocos.Scene} scene The scene to start
     */
    runWithScene: function (scene) {
        if (!(scene instanceof Scene)) {
            throw "Director.runWithScene must be given an instance of Scene";
        }

        if (this._runningScene) {
            throw "You can't run a Scene if another Scene is already running. Use replaceScene or pushScene instead";
        }

        this.pushScene(scene);
        this.startAnimation();
    },

    /**
     * Replaces the running scene with a new one. The running scene is
     * terminated. ONLY call it if there is a running scene.
     *
     * @param {cocos.Scene} scene The scene to replace with
     */
    replaceScene: function (scene) {
        var index = this.sceneStack.length;

        this._sendCleanupToScene = true;
        this.sceneStack.pop();
        this.sceneStack.push(scene);
        this._nextScene = scene;
    },

    /**
     * Pops out a scene from the queue. This scene will replace the running
     * one. The running scene will be deleted. If there are no more scenes in
     * the stack the execution is terminated. ONLY call it if there is a
     * running scene.
     */
    popScene: function () {
    },

    /**
     * Suspends the execution of the running scene, pushing it on the stack of
     * suspended scenes. The new scene will be executed. Try to avoid big
     * stacks of pushed scenes to reduce memory allocation. ONLY call it if
     * there is a running scene.
     *
     * @param {cocos.Scene} scene The scene to add to the stack
     */
    pushScene: function (scene) {
        this._nextScene = scene;
    },

    /**
     * The main loop is triggered again. Call this function only if
     * cocos.Directory#stopAnimation was called earlier.
     */
    startAnimation: function () {
        this.animate();
    },

    animate: function() {
        this.drawScene();
        window.requestAnimFrame(util.callback(this, 'animate'), this.canvas);
    },

    /**
     * Stops the animation. Nothing will be drawn. The main loop won't be
     * triggered anymore. If you want to pause your animation call
     * cocos.Directory#pause instead.
     */
    stopAnimation: function () {
        if (this._animationTimer) {
            clearInterval(this._animationTimer);
            this._animationTimer = null;
        }
    },

    /**
     * Calculate time since last call
     * @private
     */
    calculateDeltaTime: function () {
        var now = (new Date()).getTime() / 1000;

        if (this.nextDeltaTimeZero) {
            this.dt = 0;
            this.nextDeltaTimeZero = false;
        }

        this.dt = Math.max(0, now - this.lastUpdate);

        this.lastUpdate = now;
    },

    /**
     * The main run loop
     * @private
     */
    drawScene: function () {
        this.calculateDeltaTime();
        
        if (!this.isPaused) {
            Scheduler.get('sharedScheduler').tick(this.dt);
        }


        var context = this.get('context');
        context.fillStyle = this.get('backgroundColor');
        context.fillRect(0, 0, this.winSize.width, this.winSize.height);
        //this.canvas.width = this.canvas.width


        if (this._nextScene) {
            this.setNextScene();
        }

        var rect = new geo.Rect(0, 0, this.winSize.width, this.winSize.height);

        if (rect) {
            context.beginPath();
            context.rect(rect.origin.x, rect.origin.y, rect.size.width, rect.size.height);
            context.clip();
            context.closePath();
        }

        this._runningScene.visit(context, rect);

        if (SHOW_REDRAW_REGIONS) {
            if (rect) {
                context.beginPath();
                context.rect(rect.origin.x, rect.origin.y, rect.size.width, rect.size.height);
                context.fillStyle = "rgba(255, 0, 0, 0.5)";
                //context.fill();
                context.closePath();
            }
        }

        if (this.get('displayFPS')) {
            this.showFPS();
        }
    },

    /**
     * Initialises the next scene
     * @private
     */
    setNextScene: function () {
        // TODO transitions

        if (this._runningScene) {
            this._runningScene.onExit();
            if (this._sendCleanupToScene) {
                this._runningScene.cleanup();
            }
        }

        this._runningScene = this._nextScene;

        this._nextScene = null;

        this._runningScene.onEnter();
    },

    convertEventToCanvas: function (evt) {
        var x = this.canvas.offsetLeft - document.documentElement.scrollLeft,
            y = this.canvas.offsetTop - document.documentElement.scrollTop;

        var o = this.canvas;
        while ((o = o.offsetParent)) {
            x += o.offsetLeft - o.scrollLeft;
            y += o.offsetTop - o.scrollTop;
        }

        var p = geo.ccpSub(evt.locationInWindow, ccp(x, y));
        if (FLIP_Y_AXIS) {
            p.y = this.canvas.height - p.y;
        }

        return p;
    },

    showFPS: function () {
        if (!this._fpsLabel) {
            var Label = require('./nodes/Label').Label;
            this._fpsLabel = Label.create({string: '', fontSize: 16});
            this._fpsLabel.set('anchorPoint', ccp(0, 1));
            this._frames = 0;
            this._accumDt = 0;
        }


        this._frames++;
        this._accumDt += this.get('dt');
        
        if (this._accumDt > 1.0 / 3.0)  {
            var frameRate = this._frames / this._accumDt;
            this._frames = 0;
            this._accumDt = 0;

            this._fpsLabel.set('string', 'FPS: ' + (Math.round(frameRate * 100) / 100).toString());
        }


        var s = this.get('winSize');
        this._fpsLabel.set('position', ccp(10, s.height - 10));

        this._fpsLabel.visit(this.get('context'));
    }

});

/**
 * Class methods
 */
util.extend(Director, /** @lends cocos.Director */{
    /**
     * A shared singleton instance of cocos.Director
     *
     * @getter sharedDirector
     * @type cocos.Director
     */
    get_sharedDirector: function (key) {
        if (!Director._instance) {
            Director._instance = this.create();
        }

        return Director._instance;
    }
});

/**
 * @memberOf cocos
 * @class Pretends to run at a constant frame rate even if it slows down
 * @extends cocos.Director
 */
var DirectorFixedSpeed = Director.extend(/** @lends cocos.DirectorFixedSpeed */{
    /**
     * Frames per second to draw.
     * @type Integer
     */
    frameRate: 60,

    /**
     * Calculate time since last call
     * @private
     */
    calculateDeltaTime: function () {
        if (this.nextDeltaTimeZero) {
            this.dt = 0;
            this.nextDeltaTimeZero = false;
        }

        this.dt = 1.0 / this.get('frameRate');
    },

    /**
     * The main loop is triggered again. Call this function only if
     * cocos.Directory#stopAnimation was called earlier.
     */
    startAnimation: function () {
        this._animationTimer = setInterval(util.callback(this, 'drawScene'), 1000 / this.get('frameRate'));
        this.drawScene();
    }

});

exports.Director = Director;
exports.DirectorFixedSpeed = DirectorFixedSpeed;

}};
__resources__["/__builtin__/libs/cocos2d/EventDispatcher.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray FLIP_Y_AXIS*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    geo = require('geometry');

var EventDispatcher = BObject.extend(/** @lends cocos.EventDispatcher# */{
    dispatchEvents: true,
    keyboardDelegates: null,
    mouseDelegates: null,
    _keysDown: null,
    
    /**
     * This singleton is responsible for dispatching Mouse and Keyboard events.
     *
     * @memberOf cocos
     * @constructs
     * @extends BObject
     * @singleton
     */
    init: function () {
        EventDispatcher.superclass.init.call(this);

        this.keyboardDelegates = [];
        this.mouseDelegates = [];

        this._keysDown = {};
    },

    addDelegate: function (opts) {
        var delegate = opts.delegate,
            priority = opts.priority,
            flags    = opts.flags,
            list     = opts.list;

        var listElement = {
            delegate: delegate,
            priority: priority,
            flags: flags
        };

        var added = false;
        for (var i = 0; i < list.length; i++) {
            var elem = list[i];
            if (priority < elem.priority) {
                // Priority is lower, so insert before elem
                list.splice(i, 0, listElement);
                added = true;
                break;
            }
        }

        // High priority; append to array
        if (!added) {
            list.push(listElement);
        }
    },

    removeDelegate: function (opts) {
        var delegate = opts.delegate,
            list = opts.list;

        var idx = -1,
            i;
        for (i = 0; i < list.length; i++) {
            var l = list[i];
            if (l.delegate == delegate) {
                idx = i;
                break;
            }
        }
        if (idx == -1) {
            return;
        }
        list.splice(idx, 1);
    },
    removeAllDelegates: function (opts) {
        var list = opts.list;

        list.splice(0, list.length - 1);
    },

    addMouseDelegate: function (opts) {
        var delegate = opts.delegate,
            priority = opts.priority;

        var flags = 0;

        // TODO flags

        this.addDelegate({delegate: delegate, priority: priority, flags: flags, list: this.mouseDelegates});
    },

    removeMouseDelegate: function (opts) {
        var delegate = opts.delegate;

        this.removeDelegate({delegate: delegate, list: this.mouseDelegates});
    },

    removeAllMouseDelegate: function () {
        this.removeAllDelegates({list: this.mouseDelegates});
    },

    addKeyboardDelegate: function (opts) {
        var delegate = opts.delegate,
            priority = opts.priority;

        var flags = 0;

        // TODO flags

        this.addDelegate({delegate: delegate, priority: priority, flags: flags, list: this.keyboardDelegates});
    },

    removeKeyboardDelegate: function (opts) {
        var delegate = opts.delegate;

        this.removeDelegate({delegate: delegate, list: this.keyboardDelegates});
    },

    removeAllKeyboardDelegate: function () {
        this.removeAllDelegates({list: this.keyboardDelegates});
    },



    // Mouse Events

    mouseDown: function (evt) {
        if (!this.dispatchEvents) {
            return;
        }

        this._previousMouseMovePosition = geo.ccp(evt.clientX, evt.clientY);
        this._previousMouseDragPosition = geo.ccp(evt.clientX, evt.clientY);

        for (var i = 0; i < this.mouseDelegates.length; i++) {
            var entry = this.mouseDelegates[i];
            if (entry.delegate.mouseDown) {
                var swallows = entry.delegate.mouseDown(evt);
                if (swallows) {
                    break;
                }
            }
        }
    },
    mouseMoved: function (evt) {
        if (!this.dispatchEvents) {
            return;
        }

        if (this._previousMouseMovePosition) {
            evt.deltaX = evt.clientX - this._previousMouseMovePosition.x;
            evt.deltaY = evt.clientY - this._previousMouseMovePosition.y;
            if (FLIP_Y_AXIS) {
                evt.deltaY *= -1;
            }
        } else {
            evt.deltaX = 0;
            evt.deltaY = 0;
        }
        this._previousMouseMovePosition = geo.ccp(evt.clientX, evt.clientY);

        for (var i = 0; i < this.mouseDelegates.length; i++) {
            var entry = this.mouseDelegates[i];
            if (entry.delegate.mouseMoved) {
                var swallows = entry.delegate.mouseMoved(evt);
                if (swallows) {
                    break;
                }
            }
        }
    },
    mouseDragged: function (evt) {
        if (!this.dispatchEvents) {
            return;
        }

        if (this._previousMouseDragPosition) {
            evt.deltaX = evt.clientX - this._previousMouseDragPosition.x;
            evt.deltaY = evt.clientY - this._previousMouseDragPosition.y;
            if (FLIP_Y_AXIS) {
                evt.deltaY *= -1;
            }
        } else {
            evt.deltaX = 0;
            evt.deltaY = 0;
        }
        this._previousMouseDragPosition = geo.ccp(evt.clientX, evt.clientY);

        for (var i = 0; i < this.mouseDelegates.length; i++) {
            var entry = this.mouseDelegates[i];
            if (entry.delegate.mouseDragged) {
                var swallows = entry.delegate.mouseDragged(evt);
                if (swallows) {
                    break;
                }
            }
        }
    },
    mouseUp: function (evt) {
        if (!this.dispatchEvents) {
            return;
        }

        for (var i = 0; i < this.mouseDelegates.length; i++) {
            var entry = this.mouseDelegates[i];
            if (entry.delegate.mouseUp) {
                var swallows = entry.delegate.mouseUp(evt);
                if (swallows) {
                    break;
                }
            }
        }
    },

    // Keyboard events
    keyDown: function (evt) {
        var kc = evt.keyCode;
        if (!this.dispatchEvents || this._keysDown[kc]) {
            return;
        }

        this._keysDown[kc] = true;

        for (var i = 0; i < this.keyboardDelegates.length; i++) {
            var entry = this.keyboardDelegates[i];
            if (entry.delegate.keyDown) {
                var swallows = entry.delegate.keyDown(evt);
                if (swallows) {
                    break;
                }
            }
        }
    },

    keyUp: function (evt) {
        if (!this.dispatchEvents) {
            return;
        }

        var kc = evt.keyCode;
        if (this._keysDown[kc]) {
            delete this._keysDown[kc];
        }

        for (var i = 0; i < this.keyboardDelegates.length; i++) {
            var entry = this.keyboardDelegates[i];
            if (entry.delegate.keyUp) {
                var swallows = entry.delegate.keyUp(evt);
                if (swallows) {
                    break;
                }
            }
        }
    }

});

/**
 * Class methods
 */
util.extend(EventDispatcher, /** @lends cocos.EventDispatcher */{
    /**
     * A shared singleton instance of cocos.EventDispatcher
     *
     * @getter sharedDispatcher
     * @type cocos.EventDispatcher
     */
    get_sharedDispatcher: function (key) {
        if (!this._instance) {
            this._instance = this.create();
        }

        return this._instance;
    }
});
exports.EventDispatcher = EventDispatcher;

}};
__resources__["/__builtin__/libs/cocos2d/index.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    path = require('path');

var modules = 'TextureAtlas Texture2D Preloader RemoteImage RemoteResource SpriteFrame SpriteFrameCache Director Animation AnimationCache Scheduler ActionManager TMXXMLParser'.w();

/**
 * @namespace All cocos2d objects live in this namespace
 */
var cocos = {
    nodes: require('./nodes'),
    actions: require('./actions')
};

util.each(modules, function (mod, i) {
    util.extend(cocos, require('./' + mod));
});

module.exports = cocos;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/AtlasNode.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var SpriteBatchNode = require('./BatchNode').SpriteBatchNode,
    TextureAtlas = require('../TextureAtlas').TextureAtlas,
    geo   = require('geometry');

var AtlasNode = SpriteBatchNode.extend(/** @lends cocos.AtlasNode# */{
    /**
     * Characters per row
     * @type Integer
     */
    itemsPerRow: 0,

    /**
     * Characters per column
     * @type Integer
     */
    itemsPerColumn: 0,

    /**
     * Width of a character
     * @type Integer
     */
    itemWidth: 0,

    /**
     * Height of a character
     * @type Integer
     */
    itemHeight: 0,


    /**
     * @type cocos.TextureAtlas
     */
     textureAtlas: null,

    /**
     * @class
     * It knows how to render a TextureAtlas object. If you are going to
     * render a TextureAtlas consider subclassing cocos.nodes.AtlasNode (or a
     * subclass of cocos.nodes.AtlasNode)
     * @memberOf cocos
     * @extends cocos.nodes.SpriteBatchNode
     * @constructs
     *
     * @opt {String} file Path to Atals image
     * @opt {Integer} itemWidth Character width
     * @opt {Integer} itemHeight Character height
     * @opt {Integer} itemsToRender Quantity of items to render
     */
    init: function (opts) {
        AtlasNode.superclass.init.call(this, opts);

        this.itemWidth = opts.itemWidth;
        this.itemHeight = opts.itemHeight;
        
        this.textureAtlas = TextureAtlas.create({file: opts.file, capacity: opts.itemsToRender});


        this._calculateMaxItems();
    },

    updateAtlasValues: function () {
        throw "cocos.nodes.AtlasNode:Abstract - updateAtlasValue not overriden";
    },

    _calculateMaxItems: function () {
        var s = this.textureAtlas.get('texture.contentSize');
        this.itemsPerColumn = s.height / this.itemHeight;
        this.itemsPerRow = s.width / this.itemWidth;
    }
});

exports.AtlasNode = AtlasNode;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/BatchNode.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray SHOW_REDRAW_REGIONS*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    evt = require('events'),
    geo = require('geometry'),
    ccp = geo.ccp,
    TextureAtlas = require('../TextureAtlas').TextureAtlas,
    RenderTexture = require('./RenderTexture').RenderTexture,
    Node = require('./Node').Node;

var BatchNode = Node.extend(/** @lends cocos.nodes.BatchNode# */{
    partialDraw: false,
    contentRect: null,
    renderTexture: null,
    dirty: true,

    /**
     * Region to redraw
     * @type geometry.Rect
     */
    dirtyRegion: null,
    dynamicResize: false,

    /** @private
     * Areas that need redrawing
     *
     * Not implemented
     */
    _dirtyRects: null,


    /**
     * Draws all children to an in-memory canvas and only redraws when something changes
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.Node
     *
     * @opt {geometry.Size} size The size of the in-memory canvas used for drawing to
     * @opt {Boolean} [partialDraw=false] Draw only the area visible on screen. Small maps may be slower in some browsers if this is true.
     */
    init: function (opts) {
        BatchNode.superclass.init.call(this, opts);

        var size = opts.size || geo.sizeMake(1, 1);
        this.set('partialDraw', opts.partialDraw);

        evt.addListener(this, 'contentsize_changed', util.callback(this, this._resizeCanvas));
        
        this._dirtyRects = [];
        this.set('contentRect', geo.rectMake(0, 0, size.width, size.height));
        this.renderTexture = RenderTexture.create(size);
        this.renderTexture.sprite.set('isRelativeAnchorPoint', false);
        this.addChild({child: this.renderTexture});
    },

    addChild: function (opts) {
        BatchNode.superclass.addChild.call(this, opts);

        var child = opts.child,
            z     = opts.z;

        if (child == this.renderTexture) {
            return;
        }

        // TODO handle texture resize

        // Watch for changes in child
        var watchEvents = ['position_before_changed',
                           'scalex_before_changed',
                           'scaley_before_changed',
                           'rotation_before_changed',
                           'anchorpoint_before_changed',
                           'opacity_before_changed',
                           'visible_before_changed'];
        evt.addListener(child, watchEvents, util.callback(this, function () {
            this.addDirtyRegion(child.get('boundingBox'));
        }));

        this.addDirtyRegion(child.get('boundingBox'));
    },

    removeChild: function (opts) {
        BatchNode.superclass.removeChild.call(this, opts);

        // TODO remove istransformdirty_changed and visible_changed listeners

        this.set('dirty', true);
    },

    addDirtyRegion: function (rect) {
        // Increase rect slightly to compensate for subpixel artifacts
        rect = util.copy(rect);
        rect.origin.x -= 2;
        rect.origin.y -= 2;
        rect.size.width += 4;
        rect.size.height += 4;

        var region = this.get('dirtyRegion');
        if (!region) {
            region = rect;
        } else {
            region = geo.rectUnion(region, rect);
        }

        this.set('dirtyRegion', region);
        this.set('dirty', true);
    },

    _resizeCanvas: function (oldSize) {
        var size = this.get('contentSize');

        if (geo.sizeEqualToSize(size, oldSize)) {
            return; // No change
        }


        this.renderTexture.set('contentSize', size);
        this.set('dirty', true);
    },

    update: function () {

    },

    visit: function (context) {
        if (!this.visible) {
            return;
        }

        context.save();

        this.transform(context);

        var rect = this.get('dirtyRegion');
        // Only redraw if something changed
        if (this.dirty) {

            if (rect) {
                if (this.get('partialDraw')) {
                    // Clip region to visible area
                    var s = require('../Director').Director.get('sharedDirector').get('winSize'),
                        p = this.get('position');
                    var r = new geo.Rect(
                        0, 0,
                        s.width, s.height
                    );
                    r = geo.rectApplyAffineTransform(r, this.worldToNodeTransform());
                    rect = geo.rectIntersection(r, rect);
                }

                this.renderTexture.clear(rect);

                this.renderTexture.context.save();
                this.renderTexture.context.beginPath();
                this.renderTexture.context.rect(rect.origin.x, rect.origin.y, rect.size.width, rect.size.height);
                this.renderTexture.context.clip();
                this.renderTexture.context.closePath();
            } else {
                this.renderTexture.clear();
            }

            for (var i = 0, childLen = this.children.length; i < childLen; i++) {
                var c = this.children[i];
                if (c == this.renderTexture) {
                    continue;
                }

                // Draw children inside rect
                if (!rect || geo.rectOverlapsRect(c.get('boundingBox'), rect)) {
                    c.visit(this.renderTexture.context, rect);
                }
            }

            if (SHOW_REDRAW_REGIONS) {
                if (rect) {
                    this.renderTexture.context.beginPath();
                    this.renderTexture.context.rect(rect.origin.x, rect.origin.y, rect.size.width, rect.size.height);
                    this.renderTexture.context.fillStyle = "rgba(0, 0, 255, 0.5)";
                    this.renderTexture.context.fill();
                    this.renderTexture.context.closePath();
                }
            }

            if (rect) {
                this.renderTexture.context.restore();
            }

            this.set('dirty', false);
            this.set('dirtyRegion', null);
        }

        this.renderTexture.visit(context);

        context.restore();
    },

    draw: function (ctx) {
    },

    onEnter: function () {
        if (this.get('partialDraw')) {
            evt.addListener(this.get('parent'), 'istransformdirty_changed', util.callback(this, function () {
                var box = this.get('visibleRect');
                this.addDirtyRegion(box);
            }));
        }
    }
});

var SpriteBatchNode = BatchNode.extend(/** @lends cocos.nodes.SpriteBatchNode# */{
    textureAtlas: null,

    /**
     * @memberOf cocos.nodes
     * @class A BatchNode that accepts only Sprite using the same texture
     * @extends cocos.nodes.BatchNode
     * @constructs
     *
     * @opt {String} file (Optional) Path to image to use as sprite atlas
     * @opt {Texture2D} texture (Optional) Texture to use as sprite atlas
     * @opt {cocos.TextureAtlas} textureAtlas (Optional) TextureAtlas to use as sprite atlas
     */
    init: function (opts) {
        SpriteBatchNode.superclass.init.call(this, opts);

        var file         = opts.file,
            textureAtlas = opts.textureAtlas,
            texture      = opts.texture;

        if (file || texture) {
            textureAtlas = TextureAtlas.create({file: file, texture: texture});
        }

        this.set('textureAtlas', textureAtlas);
    },

    /**
     * @getter texture
     * @type cocos.Texture2D
     */
    get_texture: function () {
        return this.textureAtlas ? this.textureAtlas.texture : null;
    },

    set_opacity: function (newOpacity) {
        this.opacity = newOpacity;
        for (var i = 0, len = this.children.length; i < len; i++) {
            var child = this.children[i];
            child.set('opacity', newOpacity);
        }
    }

});

exports.BatchNode = BatchNode;
exports.SpriteBatchNode = SpriteBatchNode;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/index.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    path = require('path');

var modules = 'AtlasNode LabelAtlas ProgressBar PreloadScene Node Layer Scene Label Sprite TMXTiledMap BatchNode RenderTexture Menu MenuItem Transition'.w();

/** 
 * @memberOf cocos
 * @namespace All cocos2d nodes. i.e. anything that can be added to a Scene
 */
var nodes = {};

util.each(modules, function (mod, i) {
    util.extend(nodes, require('./' + mod));
});

module.exports = nodes;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/Label.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray FLIP_Y_AXIS*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    console = require('system').console,
    Director = require('../Director').Director,
    Node = require('./Node').Node,
    ccp = require('geometry').ccp;

var Label = Node.extend(/** @lends cocos.nodes.Label# */{
    string:   '',
    fontName: 'Helvetica',
    fontSize: 16,
    fontColor: 'white',

    /**
     * Renders a simple text label
     *
     * @constructs
     * @extends cocos.nodes.Node
     *
     * @opt {String} [string=""] The text string to draw
     * @opt {Float} [fontSize=16] The size of the font
     * @opt {String} [fontName="Helvetica"] The name of the font to use
     * @opt {String} [fontColor="white"] The color of the text
     */
    init: function (opts) {
        Label.superclass.init.call(this, opts);

        util.each('fontSize fontName fontColor string'.w(), util.callback(this, function (name) {
            // Set property on init
            if (opts[name]) {
                this.set(name, opts[name]);
            }

            // Update content size
            this._updateLabelContentSize();
        }));
    },

    /** 
     * String of the font name and size to use in a format &lt;canvas&gt; understands
     *
     * @getter font
     * @type String
     */
    get_font: function (key) {
        return this.get('fontSize') + 'px ' + this.get('fontName');
    },

    draw: function (context) {
        if (FLIP_Y_AXIS) {
            context.save();

            // Flip Y axis
            context.scale(1, -1);
            context.translate(0, -this.get('fontSize'));
        }


        context.fillStyle = this.get('fontColor');
        context.font = this.get('font');
        context.textBaseline = 'top';
        if (context.fillText) {
            context.fillText(this.get('string'), 0, 0);
        } else if (context.mozDrawText) {
            context.mozDrawText(this.get('string'));
        }

        if (FLIP_Y_AXIS) {
            context.restore();
        }
    },

    /**
     * @private
     */
    _updateLabelContentSize: function () {
        var ctx = Director.get('sharedDirector').get('context');
        var size = {width: 0, height: this.get('fontSize')};

        var prevFont = ctx.font;
        ctx.font = this.get('font');

        if (ctx.measureText) {
            var txtSize = ctx.measureText(this.get('string'));
            size.width = txtSize.width;
        } else if (ctx.mozMeasureText) {
            size.width = ctx.mozMeasureText(this.get('string'));
        }

        ctx.font = prevFont;

        this.set('contentSize', size);
    }
});

module.exports.Label = Label;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/LabelAtlas.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var AtlasNode = require('./AtlasNode').AtlasNode,
    Sprite = require('./Sprite').Sprite,
    geo   = require('geometry');

var LabelAtlas = AtlasNode.extend(/** @lends cocos.nodes.LabelAtlas# */{
    string: '',

    mapStartChar: '',

    /**
     * @memberOf cocos.nodes
     * @extends cocos.nodes.BatchNode
     * @constructs
     *
     * @opt {String} [string=] Initial text to draw
     * @opt {String} charMapFile
     * @opt {Integer} itemWidth
     * @opt {Integer} itemHeight
     * @opt {String} startCharMap Single character
     */
    init: function (opts) {
        LabelAtlas.superclass.init.call(this, {
            file: opts.charMapFile,
            itemWidth: opts.itemWidth,
            itemHeight: opts.itemHeight,
            itemsToRender: opts.string.length,
            size: new geo.Size(opts.itemWidth * opts.string.length, opts.itemHeight)
        });


        this.mapStartChar = opts.startCharMap.charCodeAt(0);
        this.set('string', opts.string);
    },

    updateAtlasValue: function () {
        var n = this.string.length,
            s = this.get('string');
    
        // FIXME this should reuse children to improve performance
        while (this.children.length > 0) {
            this.removeChild(this.children[0]);
        }
        for (var i = 0; i < n; i++) {
            var a = s.charCodeAt(i) - this.mapStartChar,
                row = (a % this.itemsPerRow),
                col = Math.floor(a / this.itemsPerRow);
    
            var left = row * this.itemWidth,
                top  = col * this.itemHeight;

            var tile = Sprite.create({rect: new geo.Rect(left, top, this.itemWidth, this.itemHeight),
                              textureAtlas: this.textureAtlas});

            tile.set('position', new geo.Point(i * this.itemWidth, 0));
            tile.set('anchorPoint', new geo.Point(0, 0));
            tile.set('opacity', this.get('opacity'));
            
            this.addChild({child: tile});
        }
    },

    set_string: function (newString) {
        this.string = newString;

        this.updateAtlasValue();
    }
});


exports.LabelAtlas = LabelAtlas;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/Layer.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var Node = require('./Node').Node,
    util = require('util'),
    evt = require('events'),
    Director = require('../Director').Director,
    ccp    = require('geometry').ccp,
    EventDispatcher = require('../EventDispatcher').EventDispatcher;

var Layer = Node.extend(/** @lends cocos.nodes.Layer# */{
    isMouseEnabled: false,
    isKeyboardEnabled: false,
    mouseDelegatePriority: 0,
    keyboardDelegatePriority: 0,

    /** 
     * A fullscreen Node. You need at least 1 layer in your app to add other nodes to.
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.Node
     */
    init: function () {
        Layer.superclass.init.call(this);

        var s = Director.get('sharedDirector').get('winSize');

        this.set('isRelativeAnchorPoint', false);
        this.anchorPoint = ccp(0.5, 0.5);
        this.set('contentSize', s);

        evt.addListener(this, 'ismouseenabled_changed', util.callback(this, function () {
            if (this.isRunning) {
                if (this.isMouseEnabled) {
                    EventDispatcher.get('sharedDispatcher').addMouseDelegate({delegate: this, priority: this.get('mouseDelegatePriority')});
                } else {
                    EventDispatcher.get('sharedDispatcher').removeMouseDelegate({delegate: this});
                }
            }
        }));


        evt.addListener(this, 'iskeyboardenabled_changed', util.callback(this, function () {
            if (this.isRunning) {
                if (this.isKeyboardEnabled) {
                    EventDispatcher.get('sharedDispatcher').addKeyboardDelegate({delegate: this, priority: this.get('keyboardDelegatePriority')});
                } else {
                    EventDispatcher.get('sharedDispatcher').removeKeyboardDelegate({delegate: this});
                }
            }
        }));
    },

    onEnter: function () {
        if (this.isMouseEnabled) {
            EventDispatcher.get('sharedDispatcher').addMouseDelegate({delegate: this, priority: this.get('mouseDelegatePriority')});
        }
        if (this.isKeyboardEnabled) {
            EventDispatcher.get('sharedDispatcher').addKeyboardDelegate({delegate: this, priority: this.get('keyboardDelegatePriority')});
        }
				
        Layer.superclass.onEnter.call(this);
    },

    onExit: function () {
        if (this.isMouseEnabled) {
            EventDispatcher.get('sharedDispatcher').removeMouseDelegate({delegate: this});
        }
        if (this.isKeyboardEnabled) {
            EventDispatcher.get('sharedDispatcher').removeKeyboardDelegate({delegate: this});
        }

        Layer.superclass.onExit.call(this);
    }
});

module.exports.Layer = Layer;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/Menu.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    Layer = require('./Layer').Layer,
    Director = require('../Director').Director,
    MenuItem = require('./MenuItem').MenuItem,
    geom = require('geometry'), ccp = geom.ccp;

/**
 * @private
 * @constant
 */
var kMenuStateWaiting = 0;

/**
 * @private
 * @constant
 */
var kMenuStateTrackingTouch = 1;
    

var Menu = Layer.extend(/** @lends cocos.nodes.Menu# */{
    mouseDelegatePriority: (-Number.MAX_VALUE + 1),
    state: kMenuStateWaiting,
    selectedItem: null,
    color: null,

    /**
     * A fullscreen node used to render a selection of menu options
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.Layer
     *
     * @opt {cocos.nodes.MenuItem[]} items An array of MenuItems to draw on the menu
     */
    init: function (opts) {
        Menu.superclass.init.call(this, opts);

        var items = opts.items;

        this.set('isMouseEnabled', true);
        
        var s = Director.get('sharedDirector').get('winSize');

        this.set('isRelativeAnchorPoint', false);
        this.anchorPoint = ccp(0.5, 0.5);
        this.set('contentSize', s);

        this.set('position', ccp(s.width / 2, s.height / 2));


        if (items) {
            var z = 0;
            util.each(items, util.callback(this, function (item) {
                this.addChild({child: item, z: z++});
            }));
        }

        
    },

    addChild: function (opts) {
        if (!opts.child instanceof MenuItem) {
            throw "Menu only supports MenuItem objects as children";
        }

        Menu.superclass.addChild.call(this, opts);
    },

    itemForMouseEvent: function (event) {
        var location = event.locationInCanvas;

        var children = this.get('children');
        for (var i = 0, len = children.length; i < len; i++) {
            var item = children[i];

            if (item.get('visible') && item.get('isEnabled')) {
                var local = item.convertToNodeSpace(location);
                
                var r = item.get('rect');
                r.origin = ccp(0, 0);

                if (geom.rectContainsPoint(r, local)) {
                    return item;
                }

            }
        }

        return null;
    },

    mouseUp: function (event) {
        var selItem = this.get('selectedItem');

        if (selItem) {
            selItem.unselected();
            selItem.activate();
        }

        if (this.state != kMenuStateWaiting) {
            this.set('state', kMenuStateWaiting);
        }
        if (selItem) {
            return true;
        }
        return false;

    },
    mouseDown: function (event) {
        if (this.state != kMenuStateWaiting || !this.visible) {
            return false;
        }

        var selectedItem = this.itemForMouseEvent(event);
        this.set('selectedItem', selectedItem);
        if (selectedItem) {
            selectedItem.selected()
            this.set('state', kMenuStateTrackingTouch);

            return true;
        }

        return false;
    },

    mouseDragged: function (event) {
        var currentItem = this.itemForMouseEvent(event);

        if (currentItem != this.selectedItem) {
            if (this.selectedItem) {
                this.selectedItem.unselected();
            }
            this.set('selectedItem', currentItem);
            if (this.selectedItem) {
                this.selectedItem.selected();
            }
        }

        if (currentItem && this.state == kMenuStateTrackingTouch) {
            return true;
        }

        return false;
        
    }

});

exports.Menu = Menu;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/MenuItem.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    Node = require('./Node').Node,
    Sprite = require('./Sprite').Sprite,
    rectMake = require('geometry').rectMake,
    ccp = require('geometry').ccp;

var MenuItem = Node.extend(/** @lends cocos.nodes.MenuItem# */{
    isEnabled: true,
    isSelected: false,
    callback: null,

    /**
     * Base class for any buttons or options in a menu
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.Node
     *
     * @opt {Function} callback Function to call when menu item is activated
     */
    init: function (opts) {
        MenuItem.superclass.init.call(this, opts);

        var callback = opts.callback;

        this.set('anchorPoint', ccp(0.5, 0.5));
        this.set('callback', callback);
    },

    activate: function () {
        if (this.isEnabled && this.callback) {
            this.callback(this);
        }
    },

    /**
     * @getter rect
     * @type geometry.Rect
     */
    get_rect: function () {
        return rectMake(
            this.position.x - this.contentSize.width  * this.anchorPoint.x,
            this.position.y - this.contentSize.height * this.anchorPoint.y,
            this.contentSize.width,
            this.contentSize.height
        );
    },

    selected: function () {
        this.isSelected = true;
    },

    unselected: function () {
        this.isSelected = false;
    }
});

var MenuItemSprite = MenuItem.extend(/** @lends cocos.nodes.MenuItemSprite# */{
    normalImage: null,
    selectedImage: null,
    disabledImage: null,

    /**
     * A menu item that accepts any cocos.nodes.Node
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.MenuItem
     *
     * @opt {cocos.nodes.Node} normalImage Main Node to draw
     * @opt {cocos.nodes.Node} selectedImage Node to draw when menu item is selected
     * @opt {cocos.nodes.Node} disabledImage Node to draw when menu item is disabled
     */
    init: function (opts) {
        MenuItemSprite.superclass.init.call(this, opts);

        var normalImage   = opts.normalImage,
            selectedImage = opts.selectedImage,
            disabledImage = opts.disabledImage;

        this.set('normalImage', normalImage);
        this.set('selectedImage', selectedImage);
        this.set('disabledImage', disabledImage);

        this.set('contentSize', normalImage.get('contentSize'));
    },

    set_normalImage: function (image) {
        if (image != this.normalImage) {
            image.set('anchorPoint', ccp(0, 0));
            image.set('visible', true);
            this.removeChild({child: this.normalImage, cleanup: true});
            this.addChild(image);

            this.normalImage = image;
        }
    },

    set_selectedImage: function (image) {
        if (image != this.selectedImage) {
            image.set('anchorPoint', ccp(0, 0));
            image.set('visible', false);
            this.removeChild({child: this.selectedImage, cleanup: true});
            this.addChild(image);

            this.selectedImage = image;
        }
    },

    set_disabledImage: function (image) {
        if (image != this.disabledImage) {
            image.set('anchorPoint', ccp(0, 0));
            image.set('visible', false);
            this.removeChild({child: this.disabledImage, cleanup: true});
            this.addChild(image);

            this.disabledImage = image;
        }
    },

    selected: function () {
        MenuItemSprite.superclass.selected.call(this);

        if (this.selectedImage) {
            this.normalImage.set('visible',   false);
            this.selectedImage.set('visible', true);
            if (this.disabledImage) this.disabledImage.set('visible', false);
        } else {
            this.normalImage.set('visible',   true);
            if (this.disabledImage) this.disabledImage.set('visible', false);
        }
    },

    unselected: function () {
        MenuItemSprite.superclass.unselected.call(this);

        this.normalImage.set('visible',   true);
        if (this.selectedImage) this.selectedImage.set('visible', false);
        if (this.disabledImage) this.disabledImage.set('visible', false);
    },

    set_isEnabled: function (enabled) {
        this.isEnabled = enabled;

        if (enabled) {
            this.normalImage.set('visible',   true);
            if (this.selectedImage) this.selectedImage.set('visible', false);
            if (this.disabledImage) this.disabledImage.set('visible', false);
        } else {
            if (this.disabledImage) {
                this.normalImage.set('visible',   false);
                if (this.selectedImage) this.selectedImage.set('visible', false);
                this.disabledImage.set('visible', true);
            } else {
                this.normalImage.set('visible',   true);
                if (this.selectedImage) this.selectedImage.set('visible', false);
            }
        }
    }

});

var MenuItemImage = MenuItemSprite.extend(/** @lends cocos.nodes.MenuItemImage# */{

    /**
     * MenuItem that accepts image files
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.MenuItemSprite
     *
     * @opt {String} normalImage Main image file to draw
     * @opt {String} selectedImage Image file to draw when menu item is selected
     * @opt {String} disabledImage Image file to draw when menu item is disabled
     */
    init: function (opts) {
        var normalI   = opts.normalImage,
            selectedI = opts.selectedImage,
            disabledI = opts.disabledImage,
            callback  = opts.callback;

        var normalImage = Sprite.create({file: normalI}),
            selectedImage = Sprite.create({file: selectedI}),
            disabledImage = null;

        if (disabledI) {
            disabledImage = Sprite.create({file: disabledI});
        }

        return MenuItemImage.superclass.init.call(this, {normalImage: normalImage, selectedImage: selectedImage, disabledImage: disabledImage, callback: callback});
    }
});

exports.MenuItem = MenuItem;
exports.MenuItemImage = MenuItemImage;
exports.MenuItemSprite = MenuItemSprite;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/Node.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    evt = require('events'),
    Scheduler = require('../Scheduler').Scheduler,
    ActionManager = require('../ActionManager').ActionManager,
    geo = require('geometry'), ccp = geo.ccp;

var Node = BObject.extend(/** @lends cocos.nodes.Node# */{
    isCocosNode: true,

    /**
     * Is the node visible
     * @type boolean
     */
    visible: true,

    /**
     * Position relative to parent node
     * @type geometry.Point
     */
    position: null,

    /**
     * Parent node
     * @type cocos.nodes.Node
     */
    parent: null,

    /**
     * Unique tag to identify the node
     * @type *
     */
    tag: null,

    /**
     * Size of the node
     * @type geometry.Size
     */
    contentSize: null,

    /**
     * Nodes Z index. i.e. draw order
     * @type Integer
     */
    zOrder: 0,

    /**
     * Anchor point for scaling and rotation. 0x0 is top left and 1x1 is bottom right
     * @type geometry.Point
     */
    anchorPoint: null,

    /**
     * Anchor point for scaling and rotation in pixels from top left
     * @type geometry.Point
     */
    anchorPointInPixels: null,

    /**
     * Rotation angle in degrees
     * @type Float
     */
    rotation: 0,

    /**
     * X scale factor
     * @type Float
     */
    scaleX: 1,

    /**
     * Y scale factor
     * @type Float
     */
    scaleY: 1,

    /**
     * Opacity of the Node. 0 is totally transparent, 255 is totally opaque
     * @type Float
     */
    opacity: 255,

    isRunning: false,
    isRelativeAnchorPoint: true,

    isTransformDirty: true,
    isInverseDirty: true,
    inverse: null,
    transformMatrix: null,

    /**
     * The child Nodes
     * @type cocos.nodes.Node[]
     */
    children: null,

    /**
     * @memberOf cocos.nodes
     * @class The base class all visual elements extend from
     * @extends BObject
     * @constructs
     */
    init: function () {
        Node.superclass.init.call(this);
        this.set('contentSize', {width: 0, height: 0});
        this.anchorPoint = ccp(0.5, 0.5);
        this.anchorPointInPixels = ccp(0, 0);
        this.position = ccp(0, 0);
        this.children = [];

        util.each(['scaleX', 'scaleY', 'rotation', 'position', 'anchorPoint', 'contentSize', 'isRelativeAnchorPoint'], util.callback(this, function (key) {
            evt.addListener(this, key.toLowerCase() + '_changed', util.callback(this, this._dirtyTransform));
        }));
        evt.addListener(this, 'anchorpoint_changed', util.callback(this, this._updateAnchorPointInPixels));
        evt.addListener(this, 'contentsize_changed', util.callback(this, this._updateAnchorPointInPixels));
    },

    /**
     * Calculates the anchor point in pixels and updates the
     * anchorPointInPixels property
     * @private
     */
    _updateAnchorPointInPixels: function () {
        var ap = this.get('anchorPoint'),
            cs = this.get('contentSize');
        this.set('anchorPointInPixels', ccp(cs.width * ap.x, cs.height * ap.y));
    },

    /**
     * Add a child Node
     *
     * @opt {cocos.nodes.Node} child The child node to add
     * @opt {Integer} [z] Z Index for the child
     * @opt {Integer|String} [tag] A tag to reference the child with
     * @returns {cocos.nodes.Node} The node the child was added to. i.e. 'this'
     */
    addChild: function (opts) {
        if (opts.isCocosNode) {
            return this.addChild({child: opts});
        }

        var child = opts.child,
            z = opts.z,
            tag = opts.tag;

        if (z === undefined || z === null) {
            z = child.get('zOrder');
        }

        //this.insertChild({child: child, z:z});
        var added = false;


        for (var i = 0, childLen = this.children.length; i < childLen; i++) {
            var c = this.children[i];
            if (c.zOrder > z) {
                added = true;
                this.children.splice(i, 0, child);
                break;
            }
        }

        if (!added) {
            this.children.push(child);
        }

        child.set('tag', tag);
        child.set('zOrder', z);
        child.set('parent', this);

        if (this.isRunning) {
            child.onEnter();
        }

        return this;
    },
    getChild: function (opts) {
        var tag = opts.tag;

        for (var i = 0; i < this.children.length; i++) {
            if (this.children[i].tag == tag) {
                return this.children[i];
            }
        }

        return null;
    },

    removeChild: function (opts) {
        if (opts.isCocosNode) {
            return this.removeChild({child: opts});
        }

        var child = opts.child,
            cleanup = opts.cleanup;

        if (!child) {
            return;
        }

        var children = this.get('children'),
            idx = children.indexOf(child);

        if (idx > -1) {
            this.detatchChild({child: child, cleanup: cleanup});
        }
    },

    removeChildren: function(opts) {
        var children = this.get('children'),
            isRunning = this.get('isRunning');
        
        // Perform cleanup on each child but can't call removeChild() 
        // due to Array.splice's destructive nature during iteration.
        for (var i = 0; i < children.length; i++) {
            if (opts.cleanup) {
                children[i].cleanup();
            }
            if (isRunning) {
                children[i].onExit();
            }
            children[i].set('parent', null);
        }
        // Now safe to empty children list
        this.children = [];
    },
    
    detatchChild: function (opts) {
        var child = opts.child,
            cleanup = opts.cleanup;

        var children = this.get('children'),
            isRunning = this.get('isRunning'),
            idx = children.indexOf(child);

        if (isRunning) {
            child.onExit();
        }

        if (cleanup) {
            child.cleanup();
        }

        child.set('parent', null);
        children.splice(idx, 1);
    },

    reorderChild: function (opts) {
        var child = opts.child,
            z     = opts.z;

        var pos = this.children.indexOf(child);
        if (pos == -1) {
            throw "Node isn't a child of this node";
        }

        child.set('zOrder', z);

        // Remove child
        this.children.splice(pos, 1);

        // Add child back at correct location
        var added = false;
        for (var i = 0, childLen = this.children.length; i < childLen; i++) {
            var c = this.children[i];
            if (c.zOrder > z) {
                added = true;
                this.children.splice(i, 0, child);
                break;
            }
        }

        if (!added) {
            this.children.push(child);
        }
    },

    /**
     * Draws the node. Override to do custom drawing. If it's less efficient to
     * draw only the area inside the rect then don't bother. The result will be
     * clipped to that area anyway.
     *
     * @param {CanvasRenderingContext2D|WebGLRenderingContext} context Canvas rendering context
     * @param {geometry.Rect} rect Rectangular region that needs redrawing. Limit drawing to this area only if it's more efficient to do so.
     */
    draw: function (context, rect) {
        // All draw code goes here
    },

    /**
     * @getter scale
     * @type Float
     */
    get_scale: function () {
        if (this.scaleX != this.scaleY) {
            throw "scaleX and scaleY aren't identical";
        }

        return this.scaleX;
    },

    /**
     * @setter scale
     * @type Float
     */
    set_scale: function (val) {
        this.set('scaleX', val);
        this.set('scaleY', val);
    },
		
    scheduleUpdate: function (opts) {
        opts = opts || {};
        var priority = opts.priority || 0;

        Scheduler.get('sharedScheduler').scheduleUpdate({target: this, priority: priority, paused: !this.get('isRunning')});
    },

    /**
     * Triggered when the node is added to a scene
     *
     * @event
     */
    onEnter: function () {
        util.each(this.children, function (child) {
            child.onEnter();
        });

        this.resumeSchedulerAndActions();
        this.set('isRunning', true);
    },

    /**
     * Triggered when the node is removed from a scene
     *
     * @event
     */
    onExit: function () {
        this.pauseSchedulerAndActions();
        this.set('isRunning', false);

        util.each(this.children, function (child) {
            child.onExit();
        });
    },

    cleanup: function () {
        this.stopAllActions();
        this.unscheduleAllSelectors();
        util.each(this.children, function (child) {
            child.cleanup();
        });
    },

    resumeSchedulerAndActions: function () {
        Scheduler.get('sharedScheduler').resumeTarget(this);
        ActionManager.get('sharedManager').resumeTarget(this);
    },
    pauseSchedulerAndActions: function () {
        Scheduler.get('sharedScheduler').pauseTarget(this);
        ActionManager.get('sharedManager').pauseTarget(this);
    },
    unscheduleSelector: function (selector) {
        Scheduler.get('sharedScheduler').unschedule({target: this, method: selector});
    },
    unscheduleAllSelectors: function () {
        Scheduler.get('sharedScheduler').unscheduleAllSelectorsForTarget(this);
    },
    stopAllActions: function () {
        ActionManager.get('sharedManager').removeAllActionsFromTarget(this);
    },

    visit: function (context, rect) {
        if (!this.visible) {
            return;
        }

        context.save();

        this.transform(context);

        // Set alpha value (global only for now)
        context.globalAlpha = this.get('opacity') / 255.0;
        
        // Adjust redraw region by nodes position
        if (rect) {
            var pos = this.get('position');
            rect = new geo.Rect(rect.origin.x - pos.x, rect.origin.y - pos.y, rect.size.width, rect.size.height);
        }

        // Draw background nodes
        util.each(this.children, function (child, i) {
            if (child.zOrder < 0) {
                child.visit(context, rect);
            }
        });
        
        this.draw(context, rect);

        // Draw foreground nodes
        util.each(this.children, function (child, i) {
            if (child.zOrder >= 0) {
                child.visit(context, rect);
            }
        });

        context.restore();
    },
    transform: function (context) {
        // Translate
        if (this.isRelativeAnchorPoint && (this.anchorPointInPixels.x !== 0 || this.anchorPointInPixels.y !== 0)) {
            context.translate(Math.round(-this.anchorPointInPixels.x), Math.round(-this.anchorPointInPixels.y));
        }

        if (this.anchorPointInPixels.x !== 0 || this.anchorPointInPixels.y !== 0) {
            context.translate(Math.round(this.position.x + this.anchorPointInPixels.x), Math.round(this.position.y + this.anchorPointInPixels.y));
        } else {
            context.translate(Math.round(this.position.x), Math.round(this.position.y));
        }

        // Rotate
        context.rotate(geo.degreesToRadians(this.get('rotation')));

        // Scale
        context.scale(this.scaleX, this.scaleY);

        if (this.anchorPointInPixels.x !== 0 || this.anchorPointInPixels.y !== 0) {
            context.translate(Math.round(-this.anchorPointInPixels.x), Math.round(-this.anchorPointInPixels.y));
        }
    },

    runAction: function (action) {
        ActionManager.get('sharedManager').addAction({action: action, target: this, paused: this.get('isRunning')});
    },
    
    /**
     * @opts {String} tag Tag of the action to return
     */
    getAction: function(opts) {
        return ActionManager.get('sharedManager').getActionFromTarget({target: this, tag: opts.tag});
    },
    
    nodeToParentTransform: function () {
        if (this.isTransformDirty) {
            this.transformMatrix = geo.affineTransformIdentity();

            if (!this.isRelativeAnchorPoint && !geo.pointEqualToPoint(this.anchorPointInPixels, ccp(0, 0))) {
                this.transformMatrix = geo.affineTransformTranslate(this.transformMatrix, this.anchorPointInPixels.x, this.anchorPointInPixels.y);
            }

            if (!geo.pointEqualToPoint(this.position, ccp(0, 0))) {
                this.transformMatrix = geo.affineTransformTranslate(this.transformMatrix, this.position.x, this.position.y);
            }

            if (this.rotation !== 0) {
                this.transformMatrix = geo.affineTransformRotate(this.transformMatrix, -geo.degreesToRadians(this.rotation));
            }
            if (!(this.scaleX == 1 && this.scaleY == 1)) {
                this.transformMatrix = geo.affineTransformScale(this.transformMatrix, this.scaleX, this.scaleY);
            }

            if (!geo.pointEqualToPoint(this.anchorPointInPixels, ccp(0, 0))) {
                this.transformMatrix = geo.affineTransformTranslate(this.transformMatrix, -this.anchorPointInPixels.x, -this.anchorPointInPixels.y);
            }

            this.set('isTransformDirty', false);

        }

        return this.transformMatrix;
    },

    parentToNodeTransform: function () {
        // TODO
    },

    nodeToWorldTransform: function () {
        var t = this.nodeToParentTransform();

        var p;
        for (p = this.get('parent'); p; p = p.get('parent')) {
            t = geo.affineTransformConcat(t, p.nodeToParentTransform());
        }

        return t;
    },

    worldToNodeTransform: function () {
        return geo.affineTransformInvert(this.nodeToWorldTransform());
    },

    convertToNodeSpace: function (worldPoint) {
        return geo.pointApplyAffineTransform(worldPoint, this.worldToNodeTransform());
    },

    /**
     * @getter boundingBox
     * @type geometry.Rect
     */
    get_boundingBox: function () {
        var cs = this.get('contentSize');
        var rect = geo.rectMake(0, 0, cs.width, cs.height);
        rect = geo.rectApplyAffineTransform(rect, this.nodeToParentTransform());
        return rect;
    },

    /**
     * @getter worldBoundingBox
     * @type geometry.Rect
     */
    get_worldBoundingBox: function () {
        var cs = this.get('contentSize');

        var rect = geo.rectMake(0, 0, cs.width, cs.height);
        rect = geo.rectApplyAffineTransform(rect, this.nodeToWorldTransform());
        return rect;
    },

    /**
     * The area of the node currently visible on screen. Returns an rect even
     * if visible is false.
     *
     * @getter visibleRect
     * @type geometry.Rect
     */
    get_visibleRect: function () {
        var s = require('../Director').Director.get('sharedDirector').get('winSize');
        var rect = new geo.Rect(
            0, 0,
            s.width, s.height
        );

        return geo.rectApplyAffineTransform(rect, this.worldToNodeTransform());
    },

    /**
     * @private
     */
    _dirtyTransform: function () {
        this.set('isTransformDirty', true);
    },

    /**
     * Schedules a custom method with an interval time in seconds.
     * If time is 0 it will be ticked every frame.
     * If time is 0, it is recommended to use 'scheduleUpdate' instead.
     * 
     * If the method is already scheduled, then the interval parameter will
     * be updated without scheduling it again.
     *
     * @opt {String|Function} method Function of method name to schedule
     * @opt {Float} [interval=0] Interval in seconds
     */
    schedule: function (opts) {
        if (typeof opts == 'string') {
            return this.schedule({method: opts, interval: 0});
        }

        opts.interval = opts.interval || 0;

        Scheduler.get('sharedScheduler').schedule({target: this, method: opts.method, interval: opts.interval, paused: this.isRunning});
    },

    /**
     * Unschedules a custom method
     *
     * @param {String|Function} method
     */
    unschedule: function (method) {
        if (!method) {
            return;
        }

        if (typeof method == 'string') {
            method = this[method];
        }
        
        Scheduler.get('sharedScheduler').unschedule({target: this, method: method});
    }

});

module.exports.Node = Node;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/PreloadScene.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var Scene       = require('./Scene').Scene,
    Director    = require('../Director').Director,
    Label       = require('./Label').Label,
    ProgressBar = require('./ProgressBar').ProgressBar,
    Preloader   = require('../Preloader').Preloader,
    RemoteResource = require('../RemoteResource').RemoteResource,
    geo         = require('geometry'),
    util        = require('util'),
    events      = require('events');

var PreloadScene = Scene.extend(/** @lends cocos.nodes.PreloadScene# */{
    progressBar: null,
    label: null,
    preloader: null,
    isReady: false, // True when both progress bar images have loaded
    emptyImage: "/__builtin__/libs/cocos2d/resources/progress-bar-empty.png",
    fullImage:  "/__builtin__/libs/cocos2d/resources/progress-bar-full.png",

    /**
     * @memberOf cocos.nodes
     * @extends cocos.nodes.Scene
     * @constructs
     */
    init: function (opts) {
        PreloadScene.superclass.init.call(this, opts);
        var size = Director.get('sharedDirector').get('winSize');

        // Setup 'please wait' label
        var label = Label.create({
            fontSize: 14,
            fontName: 'Helvetica',
            fontColor: '#ffffff',
            string: 'Please wait...'
        });
        label.set('position', new geo.Point(size.width / 2, (size.height / 2) + 32));
        this.set('label', label);
        this.addChild({child: label});

        // Setup preloader
        var preloader = Preloader.create();
        this.set('preloader', preloader);
        var self = this;

        // Listen for preload events
        events.addListener(preloader, 'load', function (uri, preloader) {
            var loaded = preloader.get('loaded'),
                count = preloader.get('count');
            //console.log("Loaded: %d%% -- %d of %d -- %s", (loaded / count) * 100, loaded, count, uri);
            events.trigger(self, 'load', uri, preloader);
        });

        events.addListener(preloader, 'complete', function (preloader) {
            events.trigger(self, 'complete', preloader);
        });


        // Load the images used by the progress bar
        var emptyImage = resource(this.get('emptyImage')),
            fullImage  = resource(this.get('fullImage'));


        var loaded = 0;
        function imageLoaded() {
            if (loaded == 2) {
                this.isReady = true;
                this.createProgressBar();
                if (this.get('isRunning')) {
                    preloader.load();
                }
            }
        }

        if (emptyImage instanceof RemoteResource) {
            events.addListener(emptyImage, 'load', util.callback(this, function() {
                loaded++;
                imageLoaded.call(this);
            }));
            emptyImage.load();
        } else {
            loaded++;
            imageLoaded.call(this);
        }
        if (fullImage instanceof RemoteResource) {
            events.addListener(fullImage, 'load', util.callback(this, function() {
                loaded++;
                imageLoaded.call(this);
            }));
            fullImage.load();
        } else {
            loaded++;
            imageLoaded.call(this);
        }

    },

    createProgressBar: function () {
        var preloader = this.get('preloader'),
            size = Director.get('sharedDirector').get('winSize');

        var progressBar = ProgressBar.create({
            emptyImage: "/__builtin__/libs/cocos2d/resources/progress-bar-empty.png",
            fullImage:  "/__builtin__/libs/cocos2d/resources/progress-bar-full.png"
        });

        progressBar.set('position', new geo.Point(size.width / 2, size.height / 2));

        this.set('progressBar', progressBar);
        this.addChild({child: progressBar});

        progressBar.bindTo('maxValue', preloader, 'count');
        progressBar.bindTo('value',    preloader, 'loaded');
    },

    onEnter: function () {
        PreloadScene.superclass.onEnter.call(this);
        var preloader = this.get('preloader');

        // Preload everything
        if (this.isReady) {
            preloader.load();
        }
    }
});

exports.PreloadScene = PreloadScene;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/ProgressBar.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var Node   = require('./Node').Node,
    util   = require('util'),
    geo    = require('geometry'),
    events = require('events'),
    Sprite = require('./Sprite').Sprite;

var ProgressBar = Node.extend(/** @lends cocos.nodes.ProgressBar# */{
    emptySprite: null,
    fullSprite: null,
    maxValue: 100,
    value: 0,

    /**
     * @memberOf cocos.nodes
     * @extends cocos.nodes.Node
     * @constructs
     */
    init: function (opts) {
        ProgressBar.superclass.init.call(this, opts);
        var size = new geo.Size(272, 32);
        this.set('contentSize', size);

        var s;
        if (opts.emptyImage) {
            s = Sprite.create({file: opts.emptyImage, rect: new geo.Rect(0, 0, size.width, size.height)});
            s.set('anchorPoint', new geo.Point(0, 0));
            this.set('emptySprite', s);
            this.addChild({child: s});
        }
        if (opts.fullImage) {
            s = Sprite.create({file: opts.fullImage, rect: new geo.Rect(0, 0, 0, size.height)});
            s.set('anchorPoint', new geo.Point(0, 0));
            this.set('fullSprite', s);
            this.addChild({child: s});
        }

        events.addListener(this, 'maxvalue_changed', util.callback(this, 'updateImages'));
        events.addListener(this, 'value_changed', util.callback(this, 'updateImages'));

        this.updateImages();
    },

    updateImages: function () {
        var empty = this.get('emptySprite'),
            full  = this.get('fullSprite'),
            value = this.get('value'),
            size  = this.get('contentSize'),
            maxValue = this.get('maxValue'),
            ratio = (value / maxValue);

        var diff = Math.round(size.width * ratio);
        if (diff === 0) {
            full.set('visible', false);
        } else {
            full.set('visible', true);
            full.set('rect', new geo.Rect(0, 0, diff, size.height));
            full.set('contentSize', new geo.Size(diff, size.height));
        }

        if ((size.width - diff) === 0) {
            empty.set('visible', false);
        } else {
            empty.set('visible', true);
            empty.set('rect', new geo.Rect(diff, 0, size.width - diff, size.height));
            empty.set('position', new geo.Point(diff, 0));
            empty.set('contentSize', new geo.Size(size.width - diff, size.height));
        }
    }
});

exports.ProgressBar = ProgressBar;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/RenderTexture.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray FLIP_Y_AXIS*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    evt = require('events'),
    Node = require('./Node').Node,
    geo = require('geometry'),
    Sprite = require('./Sprite').Sprite,
    TextureAtlas = require('../TextureAtlas').TextureAtlas,
    ccp = geo.ccp;

var RenderTexture = Node.extend(/** @lends cocos.nodes.RenderTexture# */{
    canvas: null,
    context: null,
    sprite: null,

    /** 
     * An in-memory canvas which can be drawn to in the background before drawing on screen
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.Node
     *
     * @opt {Integer} width The width of the canvas
     * @opt {Integer} height The height of the canvas
     */
    init: function (opts) {
        RenderTexture.superclass.init.call(this, opts);

        var width = opts.width,
            height = opts.height;

        evt.addListener(this, 'contentsize_changed', util.callback(this, this._resizeCanvas));

        this.canvas = document.createElement('canvas');
        this.context = this.canvas.getContext('2d');

        var atlas = TextureAtlas.create({canvas: this.canvas});
        this.sprite = Sprite.create({textureAtlas: atlas, rect: {origin: ccp(0, 0), size: {width: width, height: height}}});

        this.set('contentSize', geo.sizeMake(width, height));
        this.addChild(this.sprite);
        this.set('anchorPoint', ccp(0, 0));
        this.sprite.set('anchorPoint', ccp(0, 0));

    },

    /**
     * @private
     */
    _resizeCanvas: function () {
        var size = this.get('contentSize'),
            canvas = this.get('canvas');

        canvas.width  = size.width;
        canvas.height = size.height;
        if (FLIP_Y_AXIS) {
            this.context.scale(1, -1);
            this.context.translate(0, -canvas.height);
        }

        var s = this.get('sprite');
        if (s) {
            s.set('textureRect', {rect: geo.rectMake(0, 0, size.width, size.height)});
        }
    },

    /**
     * Clear the canvas
     */
    clear: function (rect) {
        if (rect) {
            this.context.clearRect(rect.origin.x, rect.origin.y, rect.size.width, rect.size.height);
        } else {
            this.canvas.width = this.canvas.width;
            if (FLIP_Y_AXIS) {
                this.context.scale(1, -1);
                this.context.translate(0, -this.canvas.height);
            }
        }
    }
});

module.exports.RenderTexture = RenderTexture;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/Scene.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var Node = require('./Node').Node,
    geo = require('geometry');

var Scene = Node.extend(/** @lends cocos.nodes.Scene */{
    /**
     * Everything in your view will be a child of this object. You need at least 1 scene per app.
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.Node
     */
    init: function () {
        Scene.superclass.init.call(this);


        var Director = require('../Director').Director;
        var s = Director.get('sharedDirector').get('winSize');
        this.set('isRelativeAnchorPoint', false);
        this.anchorPoint = new geo.Point(0.5, 0.5);
        this.set('contentSize', s);
    }

});

module.exports.Scene = Scene;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/Sprite.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    evt = require('events'),
    Director = require('../Director').Director,
    TextureAtlas = require('../TextureAtlas').TextureAtlas,
    Node = require('./Node').Node,
    geo = require('geometry'),
    ccp = geo.ccp;

var Sprite = Node.extend(/** @lends cocos.nodes.Sprite# */{
    textureAtlas: null,
    rect: null,
    dirty: true,
    recursiveDirty: true,
    quad: null,
    flipX: false,
    flipY: false,
    offsetPosition: null,
    unflippedOffsetPositionFromCenter: null,
    untrimmedSize: null,

    /**
     * A small 2D graphics than can be animated
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.Node
     *
     * @opt {String} file Path to image to use as sprite atlas
     * @opt {Rect} [rect] The rect in the sprite atlas image file to use as the sprite
     */
    init: function (opts) {
        Sprite.superclass.init.call(this, opts);

        opts = opts || {};

        var file         = opts.file,
            textureAtlas = opts.textureAtlas,
            texture      = opts.texture,
            frame        = opts.frame,
            spritesheet  = opts.spritesheet,
            rect         = opts.rect;

        this.set('offsetPosition', ccp(0, 0));
        this.set('unflippedOffsetPositionFromCenter', ccp(0, 0));


        if (frame) {
            texture = frame.get('texture');
            rect    = frame.get('rect');
        }

        util.each(['scale', 'scaleX', 'scaleY', 'rect', 'flipX', 'flipY', 'contentSize'], util.callback(this, function (key) {
            evt.addListener(this, key.toLowerCase() + '_changed', util.callback(this, this._updateQuad));
        }));
        evt.addListener(this, 'textureatlas_changed', util.callback(this, this._updateTextureQuad));

        if (file || texture) {
            textureAtlas = TextureAtlas.create({file: file, texture: texture});
        } else if (spritesheet) {
            textureAtlas = spritesheet.get('textureAtlas');
            this.set('useSpriteSheet', true);
        } else if (!textureAtlas) {
            //throw "Sprite has no texture";
        }

        if (!rect && textureAtlas) {
            rect = {origin: ccp(0, 0), size: {width: textureAtlas.texture.size.width, height: textureAtlas.texture.size.height}};
        }

        if (rect) {
            this.set('rect', rect);
            this.set('contentSize', rect.size);

            this.quad = {
                drawRect: {origin: ccp(0, 0), size: rect.size},
                textureRect: rect
            };
        }

        this.set('textureAtlas', textureAtlas);

        if (frame) {
            this.set('displayFrame', frame);
        }
    },

    /**
     * @private
     */
    _updateTextureQuad: function (obj, key, texture, oldTexture) {
        if (oldTexture) {
            oldTexture.removeQuad({quad: this.get('quad')});
        }

        if (texture) {
            texture.insertQuad({quad: this.get('quad')});
        }
    },

    /**
     * @setter textureCoords
     * @type geometry.Rect
     */
    set_textureCoords: function (rect) {
        var quad = this.get('quad');
        if (!quad) {
            quad = {
                drawRect: geo.rectMake(0, 0, 0, 0), 
                textureRect: geo.rectMake(0, 0, 0, 0)
            };
        }

        quad.textureRect = util.copy(rect);

        this.set('quad', quad);
    },

    /**
     * @setter textureRect
     * @type geometry.Rect
     */
    set_textureRect: function (opts) {
        var rect = opts.rect,
            rotated = !!opts.rotated,
            untrimmedSize = opts.untrimmedSize || rect.size;

        this.set('contentSize', untrimmedSize);
        this.set('rect', util.copy(rect));
        this.set('textureCoords', rect);

        var quad = this.get('quad');

        var relativeOffset = util.copy(this.get('unflippedOffsetPositionFromCenter'));

        if (this.get('flipX')) {
            relativeOffset.x = -relativeOffset.x;
        }
        if (this.get('flipY')) {
            relativeOffset.y = -relativeOffset.y;
        }

        var offsetPosition = util.copy(this.get('offsetPosition'));
        offsetPosition.x =  relativeOffset.x + (this.get('contentSize').width  - rect.size.width) / 2;
        offsetPosition.y = -relativeOffset.y + (this.get('contentSize').height - rect.size.height) / 2;

        quad.drawRect.origin = util.copy(offsetPosition);
        quad.drawRect.size = util.copy(rect.size);
        if (this.flipX) {
            quad.drawRect.size.width *= -1;
            quad.drawRect.origin.x = -rect.size.width;
        }
        if (this.flipY) {
            quad.drawRect.size.height *= -1;
            quad.drawRect.origin.y = -rect.size.height;
        }

        this.set('quad', quad);
    },

    /**
     * @private
     */
    _updateQuad: function () {
        if (!this.get('rect')) {
            return;
        }
        if (!this.quad) {
            this.quad = {
                drawRect: geo.rectMake(0, 0, 0, 0), 
                textureRect: geo.rectMake(0, 0, 0, 0)
            };
        }

        var relativeOffset = util.copy(this.get('unflippedOffsetPositionFromCenter'));

        if (this.get('flipX')) {
            relativeOffset.x = -relativeOffset.x;
        }
        if (this.get('flipY')) {
            relativeOffset.y = -relativeOffset.y;
        }

        var offsetPosition = util.copy(this.get('offsetPosition'));
        offsetPosition.x = relativeOffset.x + (this.get('contentSize').width  - this.get('rect').size.width) / 2;
        offsetPosition.y = relativeOffset.y + (this.get('contentSize').height - this.get('rect').size.height) / 2;

        this.quad.textureRect = util.copy(this.rect);
        this.quad.drawRect.origin = util.copy(offsetPosition);
        this.quad.drawRect.size = util.copy(this.rect.size);

        if (this.flipX) {
            this.quad.drawRect.size.width *= -1;
            this.quad.drawRect.origin.x = -this.rect.size.width;
        }
        if (this.flipY) {
            this.quad.drawRect.size.height *= -1;
            this.quad.drawRect.origin.y = -this.rect.size.height;
        }
    },

    updateTransform: function (ctx) {
        if (!this.useSpriteSheet) {
            throw "updateTransform is only valid when Sprite is being rendered using a SpriteSheet";
        }

        if (!this.visible) {
            this.set('dirty', false);
            this.set('recursiveDirty', false);
            return;
        }

        // TextureAtlas has hard reference to this quad so we can just update it directly
        this.quad.drawRect.origin = {
            x: this.position.x - this.anchorPointInPixels.x * this.scaleX,
            y: this.position.y - this.anchorPointInPixels.y * this.scaleY
        };
        this.quad.drawRect.size = {
            width: this.rect.size.width * this.scaleX,
            height: this.rect.size.height * this.scaleY
        };

        this.set('dirty', false);
        this.set('recursiveDirty', false);
    },

    draw: function (ctx) {
        if (!this.quad) {
            return;
        }
        this.get('textureAtlas').drawQuad(ctx, this.quad);
    },

    isFrameDisplayed: function (frame) {
        if (!this.rect || !this.textureAtlas) {
            return false;
        }
        return (frame.texture === this.textureAtlas.texture && geo.rectEqualToRect(frame.rect, this.rect));
    },


    /**
     * @setter displayFrame
     * @type cocos.SpriteFrame
     */
    set_displayFrame: function (frame) {
        if (!frame) {
            delete this.quad;
            return;
        }
        this.set('unflippedOffsetPositionFromCenter', util.copy(frame.offset));


        // change texture
        if (!this.textureAtlas || frame.texture !== this.textureAtlas.texture) {
            this.set('textureAtlas', TextureAtlas.create({texture: frame.texture}));
        }

        this.set('textureRect', {rect: frame.rect, rotated: frame.rotated, untrimmedSize: frame.originalSize});
    }
});

module.exports.Sprite = Sprite;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/TMXLayer.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray FLIP_Y_AXIS*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    SpriteBatchNode = require('./BatchNode').SpriteBatchNode,
    Sprite = require('./Sprite').Sprite,
    TMXOrientationOrtho = require('../TMXOrientation').TMXOrientationOrtho,
    TMXOrientationHex   = require('../TMXOrientation').TMXOrientationHex,
    TMXOrientationIso   = require('../TMXOrientation').TMXOrientationIso,
    geo    = require('geometry'),
    ccp    = geo.ccp,
    Node = require('./Node').Node;

var TMXLayer = SpriteBatchNode.extend(/** @lends cocos.nodes.TMXLayer# */{
    layerSize: null,
    layerName: '',
    tiles: null,
    tilset: null,
    layerOrientation: 0,
    mapTileSize: null,
    properties: null,

    /** 
     * A tile map layer loaded from a TMX file. This will probably automatically be made by cocos.TMXTiledMap
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.SpriteBatchNode
     *
     * @opt {cocos.TMXTilesetInfo} tilesetInfo
     * @opt {cocos.TMXLayerInfo} layerInfo
     * @opt {cocos.TMXMapInfo} mapInfo
     */
    init: function (opts) {
        var tilesetInfo = opts.tilesetInfo,
            layerInfo = opts.layerInfo,
            mapInfo = opts.mapInfo;

        var size = layerInfo.get('layerSize'),
            totalNumberOfTiles = size.width * size.height;

        var tex = null;
        if (tilesetInfo) {
            tex = tilesetInfo.sourceImage;
        }

        TMXLayer.superclass.init.call(this, {file: tex});

        this.set('anchorPoint', ccp(0, 0));

        this.layerName = layerInfo.get('name');
        this.layerSize = layerInfo.get('layerSize');
        this.tiles = layerInfo.get('tiles');
        this.minGID = layerInfo.get('minGID');
        this.maxGID = layerInfo.get('maxGID');
        this.opacity = layerInfo.get('opacity');
        this.properties = util.copy(layerInfo.properties);

        this.tileset = tilesetInfo;
        this.mapTileSize = mapInfo.get('tileSize');
        this.layerOrientation = mapInfo.get('orientation');

        var offset = this.calculateLayerOffset(layerInfo.get('offset'));
        this.set('position', offset);

        this.set('contentSize', geo.sizeMake(this.layerSize.width * this.mapTileSize.width, (this.layerSize.height * (this.mapTileSize.height - 1)) + this.tileset.tileSize.height));
    },

    calculateLayerOffset: function (pos) {
        var ret = ccp(0, 0);

        switch (this.layerOrientation) {
        case TMXOrientationOrtho:
            ret = ccp(pos.x * this.mapTileSize.width, pos.y * this.mapTileSize.height);
            break;
        case TMXOrientationIso:
            // TODO
            break;
        case TMXOrientationHex:
            // TODO
            break;
        }

        return ret;
    },

    setupTiles: function () {
        this.tileset.bindTo('imageSize', this.get('texture'), 'contentSize');


        for (var y = 0; y < this.layerSize.height; y++) {
            for (var x = 0; x < this.layerSize.width; x++) {
                
                var pos = x + this.layerSize.width * y,
                    gid = this.tiles[pos];
                
                if (gid !== 0) {
                    this.appendTile({gid: gid, position: ccp(x, y)});
                    
                    // Optimization: update min and max GID rendered by the layer
                    this.minGID = Math.min(gid, this.minGID);
                    this.maxGID = Math.max(gid, this.maxGID);
                }
            }
        }
    },
    appendTile: function (opts) {
        var gid = opts.gid,
            pos = opts.position;

        var z = pos.x + pos.y * this.layerSize.width;
            
        var rect = this.tileset.rectForGID(gid);
        var tile = Sprite.create({rect: rect, textureAtlas: this.textureAtlas});
        tile.set('position', this.positionAt(pos));
        tile.set('anchorPoint', ccp(0, 0));
        tile.set('opacity', this.get('opacity'));
        
        this.addChild({child: tile, z: 0, tag: z});
    },
    positionAt: function (pos) {
        switch (this.layerOrientation) {
        case TMXOrientationOrtho:
            return this.positionForOrthoAt(pos);
        case TMXOrientationIso:
            return this.positionForIsoAt(pos);
        /*
        case TMXOrientationHex:
            // TODO
        */
        default:
            return ccp(0, 0);
        }
    },
    positionForOrthoAt: function (pos) {
        var overlap = this.mapTileSize.height - this.tileset.tileSize.height;
        var x = Math.floor(pos.x * this.mapTileSize.width + 0.49);
        var y;
        if (FLIP_Y_AXIS) {
            y = Math.floor((this.get('layerSize').height - pos.y - 1) * this.mapTileSize.height + 0.49);
        } else {
            y = Math.floor(pos.y * this.mapTileSize.height + 0.49) + overlap;
        }
        return ccp(x, y);
    },

    positionForIsoAt: function (pos) {
        var mapTileSize = this.get('mapTileSize'),
            layerSize = this.get('layerSize');

        if (FLIP_Y_AXIS) {
            return ccp(
                mapTileSize.width  / 2 * (layerSize.width + pos.x - pos.y - 1),
                mapTileSize.height / 2 * ((layerSize.height * 2 - pos.x - pos.y) - 2)
            );
        } else {
            throw "Isometric tiles without FLIP_Y_AXIS is currently unsupported";
        }
    },

    /**
     * Get the tile at a specifix tile coordinate
     *
     * @param {geometry.Point} pos Position of tile to get in tile coordinates (not pixels)
     * @returns {cocos.nodes.Sprite} The tile
     */
    tileAt: function (pos) {
        var layerSize = this.get('layerSize'),
            tiles = this.get('tiles');

        if (pos.x < 0 || pos.y < 0 || pos.x >= layerSize.width || pos.y >= layerSize.height) {
            throw "TMX Layer: Invalid position";
        }

        var tile,
            gid = this.tileGIDAt(pos);

        // if GID is 0 then no tile exists at that point
        if (gid) {
            var z = pos.x + pos.y * layerSize.width;
            tile = this.getChild({tag: z});
        }

        return tile;
    },


    tileGID: function (pos) {
        var tilesPerRow = this.get('layerSize').width,
            tilePos = pos.x + (pos.y * tilesPerRow);

        return this.tiles[tilePos];
    },
    tileGIDAt: function (pos) {
        return this.tileGID(pos);
    },

    removeTile: function (pos) {
        var gid = this.tileGID(pos);
        if (gid === 0) {
            // Tile is already blank
            return;
        }

        var tiles = this.get('tiles'),
            tilesPerRow = this.get('layerSize').width,
            tilePos = pos.x + (pos.y * tilesPerRow);


        tiles[tilePos] = 0;

        var sprite = this.getChild({tag: tilePos});
        if (sprite) {
            this.removeChild({child: sprite});
        }
    }
});

exports.TMXLayer = TMXLayer;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/TMXTiledMap.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray console*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    geo = require('geometry'),
    ccp = geo.ccp,
    Node = require('./Node').Node,
    TMXOrientationOrtho = require('../TMXOrientation').TMXOrientationOrtho,
    TMXOrientationHex   = require('../TMXOrientation').TMXOrientationHex,
    TMXOrientationIso   = require('../TMXOrientation').TMXOrientationIso,
    TMXLayer   = require('./TMXLayer').TMXLayer,
    TMXMapInfo = require('../TMXXMLParser').TMXMapInfo;

var TMXTiledMap = Node.extend(/** @lends cocos.nodes.TMXTiledMap# */{
    mapSize: null,
    tileSize: null,
    mapOrientation: 0,
    objectGroups: null,
    properties: null,
    tileProperties: null,

    /**
     * A TMX Map loaded from a .tmx file
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.Node
     *
     * @opt {String} file The file path of the TMX map to load
     */
    init: function (opts) {
        TMXTiledMap.superclass.init.call(this, opts);

        this.set('anchorPoint', ccp(0, 0));

        var mapInfo = TMXMapInfo.create(opts.file);

        this.mapSize        = mapInfo.get('mapSize');
        this.tileSize       = mapInfo.get('tileSize');
        this.mapOrientation = mapInfo.get('orientation');
        this.objectGroups   = mapInfo.get('objectGroups');
        this.properties     = mapInfo.get('properties');
        this.tileProperties = mapInfo.get('tileProperties');

        // Add layers to map
        var idx = 0;
        util.each(mapInfo.layers, util.callback(this, function (layerInfo) {
            if (layerInfo.get('visible')) {
                var child = this.parseLayer({layerInfo: layerInfo, mapInfo: mapInfo});
                this.addChild({child: child, z: idx, tag: idx});

                var childSize   = child.get('contentSize');
                var currentSize = this.get('contentSize');
                currentSize.width  = Math.max(currentSize.width,  childSize.width);
                currentSize.height = Math.max(currentSize.height, childSize.height);
                this.set('contentSize', currentSize);

                idx++;
            }
        }));
    },
    
    parseLayer: function (opts) {
        var tileset = this.tilesetForLayer(opts);
        var layer = TMXLayer.create({tilesetInfo: tileset, layerInfo: opts.layerInfo, mapInfo: opts.mapInfo});

        layer.setupTiles();

        return layer;
    },

    tilesetForLayer: function (opts) {
        var layerInfo = opts.layerInfo,
            mapInfo = opts.mapInfo,
            size = layerInfo.get('layerSize');

        // Reverse loop
        var tileset;
        for (var i = mapInfo.tilesets.length - 1; i >= 0; i--) {
            tileset = mapInfo.tilesets[i];

            for (var y = 0; y < size.height; y++) {
                for (var x = 0; x < size.width; x++) {
                    var pos = x + size.width * y, 
                        gid = layerInfo.tiles[pos];

                    if (gid !== 0 && gid >= tileset.firstGID) {
                        return tileset;
                    }
                } // for (var x
            } // for (var y
        } // for (var i

        //console.log("cocos2d: Warning: TMX Layer '%s' has no tiles", layerInfo.name);
        return tileset;
    },

    /**
     * Get a layer
     *
     * @opt {String} name The name of the layer to get
     * @returns {cocos.nodes.TMXLayer} The layer requested
     */
    getLayer: function (opts) {
        var layerName = opts.name,
            layer = null;

        this.get('children').forEach(function (item) {
            if (item instanceof TMXLayer && item.layerName == layerName) {
                layer = item;
            }
        });
        if (layer !== null) {
            return layer;
        }
    },
    
    /**
     * Return the ObjectGroup for the secific group
     *
     * @opt {String} name The object group name
     * @returns {cocos.TMXObjectGroup} The object group
     */
    getObjectGroup: function (opts) {
        var objectGroupName = opts.name,
            objectGroup = null;

        this.objectGroups.forEach(function (item) {
            if (item.name == objectGroupName) {
                objectGroup = item;
            }
        });
        if (objectGroup !== null) {
            return objectGroup;
        }
    },

    /**
     * @deprected Since v0.2. You should now use cocos.TMXTiledMap#getObjectGroup.
     */
    objectGroupNamed: function (opts) {
        console.warn('TMXTiledMap#objectGroupNamed is deprected. Use TMXTiledMap#getObjectGroup instread');
        return this.getObjectGroup(opts);
    }
});

exports.TMXTiledMap = TMXTiledMap;


}};
__resources__["/__builtin__/libs/cocos2d/nodes/Transition.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var geo             = require('geometry'),
    util            = require('util'),
    actions         = require('../actions'),
    Scene           = require('./Scene').Scene,
    Director        = require('../Director').Director,
    EventDispatcher = require('../EventDispatcher').EventDispatcher,
    Scheduler       = require('../Scheduler').Scheduler;

/** Orientation Type used by some transitions
 */
var tOrientation = {
    kOrientationLeftOver: 0,
    kOrientationRightOver: 1,
    kOrientationUpOver: 0,
    kOrientationDownOver: 1
};

/**
 */
var TransitionScene = Scene.extend(/** @lends cocos.nodes.TransitionScene */{
    /**
     * Incoming scene
     * @type {cocos.nodes.Scene}
     */
    inScene: null,

    /**
     * Outgoing (current) scene
     * @type {cocos.nodes.Scene}
     */
    outScene: null,

    /**
     * transition duration
     * @type Float
     */
    duration: null,

    inSceneOnTop: null,
    sendCleanupToScene: null,

    /**
     * @class Base class for Transition scenes
     * @memberOf cocos.nodes
     * @extends cocos.nodes.Scene
     * @constructs
     *
     * @opt {Float} duration How long the transition should last
     * @opt {cocos.nodes.Scene} scene Income scene
     */
    init: function (opts) {
        TransitionScene.superclass.init.call(this, opts);

        this.set('duration', opts.duration);
        if (!opts.scene) {
            throw "TransitionScene requires scene property";
        }
        this.set('inScene', opts.scene);
        this.set('outScene', Director.get('sharedDirector')._runningScene);

        if (this.inScene == this.outScene) {
            throw "Incoming scene must be different from the outgoing scene";
        }
        EventDispatcher.get('sharedDispatcher').set('dispatchEvents', false);
        this.sceneOrder();
    },

    /**
     * Called after the transition finishes
     */
    finish: function () {
        var is = this.get('inScene'),
            os = this.get('outScene');

        /* clean up */
        is.set('visible', true);
        is.set('position', geo.PointZero());
        is.set('scale', 1.0);
        is.set('rotation', 0);

        os.set('visible', false);
        os.set('position', geo.PointZero());
        os.set('scale', 1.0);
        os.set('rotation', 0);

        Scheduler.get('sharedScheduler').schedule({
            target: this,
            method: this.setNewScene,
            interval: 0
        });
    },

    /**
     * Used by some transitions to hide the outer scene
     */
    hideOutShowIn: function () {
        this.get('inScene').set('visible', true);
        this.get('outScene').set('visible', false);
    },
    
    setNewScene: function (dt) {
        var dir = Director.get('sharedDirector');
        
        this.unscheduleSelector(this.setNewScene);
        // Save 'send cleanup to scene'
        // Not sure if it's cool to be accessing all these Director privates like this...
        this.set('sendCleanupToScene', dir._sendCleanupToScene);
        
        dir.replaceScene(this.get('inScene'));
        
        // enable events while transitions
        EventDispatcher.get('sharedDispatcher').set('dispatchEvents', true);

        // issue #267 
        this.get('outScene').set('visible', true);
    },

    sceneOrder: function () {
        this.set('inSceneOnTop', true);
    },

    draw: function (context, rect) {
        if (this.get('inSceneOnTop')) {
            this.get('outScene').visit(context, rect);
            this.get('inScene').visit(context, rect);
        } else {
            this.get('inScene').visit(context, rect);
            this.get('outScene').visit(context, rect);
        }
    },
    
    onEnter: function () {
        TransitionScene.superclass.onEnter.call(this);
        this.get('inScene').onEnter();
        // outScene_ should not receive the onEnter callback
    },

    onExit: function () {
        TransitionScene.superclass.onExit.call(this);
        this.get('outScene').onExit();
        // inScene_ should not receive the onExit callback
        // only the onEnterTransitionDidFinish
        if (this.get('inScene').hasOwnProperty('onEnterTransitionDidFinish')) {
            this.get('inScene').onEnterTransitionDidFinish();
        }
    },

    cleanup: function () {
        TransitionScene.superclass.cleanup.call(this);

        if (this.get('sendCleanupToScene')) {
            this.get('outScene').cleanup();
        }
    }
});

/**
 * @class Rotate and zoom out the outgoing scene, and then rotate and zoom in the incoming 
 * @memberOf cocos.nodes
 * @extends cocos.nodes.TransitionScene
 */
var TransitionRotoZoom = TransitionScene.extend(/** @lends cocos.nodes.TransitionRotoZoom */{
    onEnter: function() {
        TransitionRotoZoom.superclass.onEnter.call(this);
        
        var dur = this.get('duration');
        this.get('inScene').set('scale', 0.001);
        this.get('outScene').set('scale', 1.0);
        
        this.get('inScene').set('anchorPoint', geo.ccp(0.5, 0.5));
        this.get('outScene').set('anchorPoint', geo.ccp(0.5, 0.5));
        
        var outzoom = [
            actions.Spawn.initWithActions({actions: [
                actions.ScaleBy.create({scale: 0.001, duration: dur/2}),
                actions.RotateBy.create({angle: 360*2, duration: dur/2})
                ]}),
            actions.DelayTime.create({duration: dur/2})];
        
        // Can't nest sequences or reverse them very easily, so incoming scene actions must be put 
        // together manually for now...
        var inzoom = [
            actions.DelayTime.create({duration: dur/2}),
            
            actions.Spawn.initWithActions({actions: [
                actions.ScaleTo.create({scale: 1.0, duration: dur/2}),
                actions.RotateBy.create({angle: -360*2, duration: dur/2})
                ]}),
            actions.CallFunc.create({
                target: this,
                method: this.finish
            })
        ];
        
        // Sequence init() copies actions
        this.get('outScene').runAction(actions.Sequence.create({actions: outzoom}));
        this.get('inScene').runAction(actions.Sequence.create({actions: inzoom}));
    }
});

/**
 * @class Move in from to the left the incoming scene.
 * @memberOf cocos.nodes
 * @extends cocos.nodes.TransitionScene
 */
var TransitionMoveInL = TransitionScene.extend(/** @lends cocos.nodes.TransitionMoveInL */{
    onEnter: function () {
        TransitionMoveInL.superclass.onEnter.call(this);

        this.initScenes();

        this.get('inScene').runAction(actions.Sequence.create({actions: [
            this.action(),
            actions.CallFunc.create({
                target: this,
                method: this.finish
            })]
        }));
    },
    
    action: function () {
        return actions.MoveTo.create({
            position: geo.ccp(0, 0),
            duration: this.get('duration')
        });
    },
    
    initScenes: function () {
        var s = Director.get('sharedDirector').get('winSize');
        this.get('inScene').set('position', geo.ccp(-s.width, 0));
    }
});
    
/**
 * @class Move in from to the right the incoming scene.
 * @memberOf cocos.nodes
 * @extends cocos.nodes.TransitionMoveInL
 */
var TransitionMoveInR = TransitionMoveInL.extend(/** @lends cocos.nodes.TransitionMoveInR */{
    initScenes: function () {
        var s = Director.get('sharedDirector').get('winSize');
        this.get('inScene').set('position', geo.ccp(s.width, 0));
    }
});

/**
 * @class Move the incoming scene in from the top.
 * @memberOf cocos.nodes
 * @extends cocos.nodes.TransitionMoveInL
 */
var TransitionMoveInT = TransitionMoveInL.extend(/** @lends cocos.nodes.TransitionMoveInT */{
    initScenes: function () {
        var s = Director.get('sharedDirector').get('winSize');
        this.get('inScene').set('position', geo.ccp(0, s.height));
    }
});

/**
 * @class Move the incoming scene in from the bottom.
 * @memberOf cocos.nodes
 * @extends cocos.nodes.TransitionMoveInL
 */
var TransitionMoveInB = TransitionMoveInL.extend(/** @lends cocos.nodes.TransitionMoveInB */{
    initScenes: function () {
        var s = Director.get('sharedDirector').get('winSize');
        this.get('inScene').set('position', geo.ccp(0, -s.height));
    }
});

/**
 * @class Slide in the incoming scene from the left.
 * @memberOf cocos.nodes
 * @extends cocos.nodes.TransitionScene
 */
var TransitionSlideInL = TransitionScene.extend(/** @lends cocos.nodes.TransitionSlideInL */{
    onEnter: function () {
        TransitionSlideInL.superclass.onEnter.call(this);

        this.initScenes();

        var movein = this.action();
        var moveout = this.action();
        var outAction = actions.Sequence.create({
            actions: [
            moveout, 
            actions.CallFunc.create({
                target: this,
                method: this.finish
            })]
        });
        this.get('inScene').runAction(movein);
        this.get('outScene').runAction(outAction);
    },

    sceneOrder: function () {
        this.set('inSceneOnTop', false);
    },

    initScenes: function () {
        var s = Director.get('sharedDirector').get('winSize');
        this.get('inScene').set('position', geo.ccp(-s.width, 0));
    },
    
    action: function () {
        var s = Director.get('sharedDirector').get('winSize');
        return actions.MoveBy.create({
            position: geo.ccp(s.width, 0),
            duration: this.get('duration')
        });
    }
});

/** 
 * @class Slide in the incoming scene from the right.
 * @memberOf cocos.nodes
 * @extends cocos.nodes.TransitionSlideInL
 */
var TransitionSlideInR = TransitionSlideInL.extend(/** @lends cocos.nodes.TransitionSlideInR */{
    sceneOrder: function () {
        this.set('inSceneOnTop', true);
    },

    initScenes: function () {
        var s = Director.get('sharedDirector').get('winSize');
        this.get('inScene').set('position', geo.ccp(s.width, 0));
    },
    
    action: function () {
        var s = Director.get('sharedDirector').get('winSize');
        return actions.MoveBy.create({
            position: geo.ccp(-s.width, 0),
            duration: this.get('duration')
        });
    }
});

/**
 * @class Slide in the incoming scene from the top.
 * @memberOf cocos.nodes
 * @extends cocos.nodes.TransitionSlideInL
 */
var TransitionSlideInT = TransitionSlideInL.extend(/** @lends cocos.nodes.TransitionSlideInT */{
    sceneOrder: function () {
        this.set('inSceneOnTop', false);
    },

    initScenes: function () {
        var s = Director.get('sharedDirector').get('winSize');
        this.get('inScene').set('position', geo.ccp(0, s.height));
    },
    
    action: function () {
        var s = Director.get('sharedDirector').get('winSize');
        return actions.MoveBy.create({
            position: geo.ccp(0, -s.height),
            duration: this.get('duration')
        });
    }
});

/**
 * @class Slide in the incoming scene from the bottom.
 * @memberOf cocos.nodes
 * @extends cocos.nodes.TransitionSlideInL
 */
var TransitionSlideInB = TransitionSlideInL.extend(/** @lends cocos.nodes.TransitionSlideInB */{
    sceneOrder: function () {
        this.set('inSceneOnTop', true);
    },

    initScenes: function () {
        var s = Director.get('sharedDirector').get('winSize');
        this.get('inScene').set('position', geo.ccp(0, -s.height));
    },
    
    action: function () {
        var s = Director.get('sharedDirector').get('winSize');
        return actions.MoveBy.create({
            position: geo.ccp(0, s.height),
            duration: this.get('duration')
        });
    }
});

exports.TransitionScene = TransitionScene;
exports.TransitionRotoZoom = TransitionRotoZoom;
exports.TransitionMoveInL = TransitionMoveInL;
exports.TransitionMoveInR = TransitionMoveInR;
exports.TransitionMoveInT = TransitionMoveInT;
exports.TransitionMoveInB = TransitionMoveInB;
exports.TransitionSlideInL = TransitionSlideInL;
exports.TransitionSlideInR = TransitionSlideInR;
exports.TransitionSlideInT = TransitionSlideInT;
exports.TransitionSlideInB = TransitionSlideInB;

}};
__resources__["/__builtin__/libs/cocos2d/Preloader.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    events = require('events');

var Preloader = BObject.extend(/** @lends cocos.Preloader# */{
    /**
     * Total number of resources.
     * @type Integer
     */
    count: -1,

    /**
     * Number of resources that have finished loading
     * @type Integer
     */
    loaded: 0,

    _listeners: null,

    /**
     * @class Preloads all remote resources
     * @memberOf cocos
     * @extends BObject
     * @constructs
     */
    init: function (opts) {
        Preloader.superclass.init.call(this, opts);

        this._listeners = {};
        this.set('count', Object.keys(__remote_resources__).length);
    },

    load: function() {
        this.set('loaded', 0);
        this.set('count', Object.keys(__remote_resources__).length);

        for (var uri in __remote_resources__) {
            if (__remote_resources__.hasOwnProperty(uri)) {
                if (__resources__[uri]) {
                    // Already loaded
                    this.didLoadResource(uri);
                    continue;
                }
                var file = resource(uri);

                // Notify when a resource has loaded
                this._listeners[uri] = events.addListener(file, 'load', util.callback(this, (function(uri) {
                    return function () { this.didLoadResource(uri); };
                })(uri)));

                file.load()
            }
        }
    },
    
    didLoadResource: function(uri) {
        this.set('loaded', this.get('loaded') +1);
        if (this._listeners[uri]) {
            events.removeListener(this._listeners[uri]);
        }
        events.trigger(this, 'load', uri, this);

        if (this.get('loaded') >= this.get('count')) {
            events.trigger(this, 'complete', this);
        }
    }
});

exports.Preloader = Preloader;

}};
__resources__["/__builtin__/libs/cocos2d/RemoteImage.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    events = require('events'),
    RemoteResource = require('./RemoteResource').RemoteResource;

var RemoteImage = RemoteResource.extend(/** @lends cocos.RemoteImage# */{
    /**
     * @memberOf cocos
     * @extends cocos.RemoteResource
     * @constructs
     */
    init: function (opts) {
        RemoteImage.superclass.init.call(this, opts);
    },

    /**
     * Load a remote image
     * @returns Image
     */
    load: function () {
        var img = new Image();
        var self = this;
        img.onload = function () {
            var path = self.get('path');

            var r = __remote_resources__[path];
            __resources__[path] = util.copy(r);
            __resources__[path].data = img;
            __resources__[path].meta.remote = true;

            events.trigger(self, 'load', self);
        };
        
        img.src = this.get('url');

        return img;
    }
});

exports.RemoteImage = RemoteImage;

}};
__resources__["/__builtin__/libs/cocos2d/RemoteResource.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    events = require('events');

var RemoteResource = BObject.extend(/** @lends cocos.RemoteResource# */{
    /**
     * The URL to the remote resource
     * @type String
     */
    url: null,

    /**
     * The path used to reference the resource in the app
     * @type String
     */
    path: null,

    /**
     * @memberOf cocos
     * @extends BObject
     * @constructs
     */
    init: function (opts) {
        RemoteResource.superclass.init.call(this, opts);

        this.set('url', opts.url);
        this.set('path', opts.path);
        
    },

    /**
     * Load the remote resource via ajax
     */
    load: function () {
        var xhr = new XMLHttpRequest();
        var self = this;
        xhr.onreadystatechange = function() {
            if (xhr.readyState == 4) {
                var path = self.get('path');

                var r = __remote_resources__[path];
                __resources__[path] = util.copy(r);
                __resources__[path].data = xhr.responseText;
                __resources__[path].meta.remote = true;

                events.trigger(self, 'load', self);
            }
        };

        xhr.open('GET', this.get('url'), true);  
        xhr.send(null);
    }
});


exports.RemoteResource = RemoteResource;

}};
__resources__["/__builtin__/libs/cocos2d/resources/progress-bar-empty.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARAAAAAgCAYAAADaBycMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAwRJREFUeNrsnbFLW1EUxm9cpP0HLDgUC4JDhoJuOggdBYcg7Sw4BSl0K0inItSpUMSp4NxSHAqOBQfdInTIIAQMDoX4D7TNlJ6PnGtOg76mwUXf7wcf5N28LAfy8d6593630uv10ojMmhZNC6aqacY0ZZpMAHBX6ZouTW1T09QwnZhao/y4MoKBLJtqplXTY+oNcO+5MH01HZiOxjWQJ6YN07rpETUFKB0d077po+n8fwzkmemVaSWM6cZvpmPTqenM9MO/+0WtAe4kD0zTpjnTvGnJ//+VcM+h6b3///9pIHpVeZP6vY7MZ9Mnf6QBgPuNWhYvTM/DmHojb/3V5kYDkfO8C+ahx5Zd017qN1sAoBxocqRu2kz9dkY2kdfxSSQaiG76EF5bvpu2TV+oJUBpWTNtmZ6G15mX/nCRJsKNG8E8zjEPAHAP2E6DJuqKe0WKBrKc+rMtmV3MAwCCieyG63X3jCsDUdMkT9WqYbpHzQAgsOfekNwratlAtMJ01b9QQ0SzLTRMASDSdW/ITVN5xqwMRMvT8wpTdVeZqgWA6zhIgxkYecaiDCSu9zimRgBQQPSIBRlINQycUh8AKCB6RFUGMhMGzqgPABQQPWJGC8l+p8GW/IeJfS0AcDPaO/PTP3cnqAcAjIsM5DJcT1MSACggesSlDKQdBuaoDwAUED2iLQNphoF56gMABUSPaMpAGmFgifoAQAHRIxoyEAWoXviA8kBq1AgArqHmHpHcM05kIEpfzilDijFTEhFJ6wAQmXRvyFGH8oxWnsbVGveOf1aMWZ16AUCgngYRhx33jKvt/Eepn76cUYzZGjUDAPeCzXC9757xVyKZotsP/bPiDbcwEQDMw70g56IeulekYQNRZJmi2/OsjDIQd1L/eAd6IgDlYtL/+ztpkIfacI+4OiOGYx0AYJixj3XIcLAUQDm49YOlMhxtCVBuxj7aMrKcOFwboEzcyuHawyh8Wfmp6o0oxUxBRFOJBivAXUZhydqRr0212henXodWp7dG+fEfAQYAt2e24R/QqdsAAAAASUVORK5CYII=")};
__resources__["/__builtin__/libs/cocos2d/resources/progress-bar-full.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARAAAAAgCAYAAADaBycMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA5lJREFUeNrsnT9IlVEYxo8uUdTSYmAQBoKDQ6KTf0BocAgcLpKrgjSIBC1mRVNU6hKEOISgaxENQUNDIKh3UmxwEARFKNClpaicbs/D9x6/t4vR9eJy73l+8MDx3O9zeOE8nO8957ynoVQqhQpphXqgLqgdaoGaoHNBCFGrHEGH0B60Ba1Da9BOJS83VGAg/VABGoSuKd5C1D370HvoHbRcrYFch8agUeiKYipEchxAi9ACtHsaA7kJ3YNuuT4++AlahTagbeir/fZLsRaiJjkPNUNtUCfUa+O/wT3zAXph4/+/BsJPlcchy3VE3kCvbUojhKhvmLIYhm67PuZGntinzT8NhM4z7cyD05Y5aD5kyRYhRBpwcWQcmghZOiOayJSfiXgD4UMv3WfLZ+gp9Nb906vQANQHddg7FxVrIWqWHzZR2IRWoI/QF/f7EPQIuuE+Z+7aO38ZyDPogZt53Hfmwe8hJlRHoG7FXIi6pQgthSxxWnImMuNmIs+hh2w0Wkd/yFZbInPOPC7bZ80rmYcQdU+3jfVpG/vBvGDOPTNqnnFsIEyaxKVaJkzn3cyDM5FJxVWIpJi0sR9XY+bNG4J5RSEaCHeYDtoPnLJwtSUmTMdkHkIkbSJj1j4yb4ifNfSMVhoIt6fHHabMrsalWiZMRxRDIZJmxLwgmDfEFRh6Rg8NxO/3WHXtgaCchxCp021ecJJHdNFA2l3Hhmv3KXZCiDIv8B7RTgNpcR3brt2huAkhyrzAe0QL94H8DvmR/AshP9fyPWiTmBAi22x2ydo8O/PT2keNio0QolpoIIfu72bX3lV4hBBlXuA94pAGsuc62lx7U3ETQpR5gfeIPRrIluvodO0VxU0IUeYF3iO2aCDrrqPXtXkqr6jYCZE0RfOCkzxinQbCAqr71sF6IAVr80jvkuInRNIshfx4f8E8IphnrNFAWH05VhniwRlWIorLujzSO6sYCpEks+YBwTxhOOSH6+gZO3EZl3vcD6zNMmbj1ubBmRmZiBBJmsdMyA/PjYe8xOGBecbxcf7lkFVfjrCM2ZC1v4WsjNmdoJyIEPVO0cb6lI39YF4w4Z5ZNM9QSUMhEufMShoSFVUWQpBTF1WO6FoHIdKm6msd/ExEF0sJUf+c+cVSEV1tKUTaVH21pac/6HJtIVLiTC7XLofFl1k/lbkRVjFjIaKmkG86E0LUHlwc4Yl8HqrluTjmOrg7faeSl/8IMABgRvK9Q/ireQAAAABJRU5ErkJggg==")};
__resources__["/__builtin__/libs/cocos2d/Scheduler.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util');

/** @ignore */
function HashUpdateEntry() {
    this.timers = [];
    this.timerIndex = 0;
    this.currentTimer = null;
    this.currentTimerSalvaged = false;
    this.paused = false;
}

/** @ignore */
function HashMethodEntry() {
    this.timers = [];
    this.timerIndex = 0;
    this.currentTimer = null;
    this.currentTimerSalvaged = false;
    this.paused = false;
}

var Timer = BObject.extend(/** @lends cocos.Timer# */{
    callback: null,
    interval: 0,
    elapsed: -1,

    /**
     * Runs a function repeatedly at a fixed interval
     *
     * @memberOf cocos
     * @constructs
     * @extends BObject
     *
     * @opt {Function} callback The function to run at each interval
     * @opt {Float} interval Number of milliseconds to wait between each exectuion of callback
     */
    init: function (opts) {
        Timer.superclass.init(this, opts);

        this.set('callback', opts.callback);
        this.set('interval', opts.interval || 0);
        this.set('elapsed', -1);
    },

    /**
     * @private
     */
    update: function (dt) {
        if (this.elapsed == -1) {
            this.elapsed = 0;
        } else {
            this.elapsed += dt;
        }

        if (this.elapsed >= this.interval) {
            this.callback(this.elapsed);
            this.elapsed = 0;
        }
    }
});


var Scheduler = BObject.extend(/** @lends cocos.Scheduler# */{
    updates0: null,
    updatesNeg: null,
    updatesPos: null,
    hashForUpdates: null,
    hashForMethods: null,
    timeScale: 1.0,

    /**
     * Runs the timers
     *
     * @memberOf cocos
     * @constructs
     * @extends BObject
     * @singleton
     * @private
     */
    init: function () {
        this.updates0 = [];
        this.updatesNeg = [];
        this.updatesPos = [];
        this.hashForUpdates = {};
        this.hashForMethods = {};
    },

    /**
     * The scheduled method will be called every 'interval' seconds.
     * If paused is YES, then it won't be called until it is resumed.
     * If 'interval' is 0, it will be called every frame, but if so, it recommened to use 'scheduleUpdateForTarget:' instead.
     * If the selector is already scheduled, then only the interval parameter will be updated without re-scheduling it again.
     */
    schedule: function (opts) {
        var target   = opts.target,
            method   = opts.method,
            interval = opts.interval,
            paused   = opts.paused || false;

        var element = this.hashForMethods[target.get('id')];

        if (!element) {
            element = new HashMethodEntry();
            this.hashForMethods[target.get('id')] = element;
            element.target = target;
            element.paused = paused;
        } else if (element.paused != paused) {
            throw "cocos.Scheduler. Trying to schedule a method with a pause value different than the target";
        }

        var timer = Timer.create({callback: util.callback(target, method), interval: interval});
        element.timers.push(timer);
    },

    /**
     * Schedules the 'update' selector for a given target with a given priority.
     * The 'update' selector will be called every frame.
     * The lower the priority, the earlier it is called.
     */
    scheduleUpdate: function (opts) {
        var target   = opts.target,
            priority = opts.priority,
            paused   = opts.paused;

        var i, len;
        var entry = {target: target, priority: priority, paused: paused};
        var added = false;

        if (priority === 0) {
            this.updates0.push(entry);
        } else if (priority < 0) {
            for (i = 0, len = this.updatesNeg.length; i < len; i++) {
                if (priority < this.updatesNeg[i].priority) {
                    this.updatesNeg.splice(i, 0, entry);
                    added = true;
                    break;
                }
            }

            if (!added) {
                this.updatesNeg.push(entry);
            }
        } else /* priority > 0 */{
            for (i = 0, len = this.updatesPos.length; i < len; i++) {
                if (priority < this.updatesPos[i].priority) {
                    this.updatesPos.splice(i, 0, entry);
                    added = true;
                    break;
                }
            }

            if (!added) {
                this.updatesPos.push(entry);
            }
        }

        this.hashForUpdates[target.get('id')] = entry;
    },

    /**
     * 'tick' the scheduler.
     * You should NEVER call this method, unless you know what you are doing.
     */
    tick: function (dt) {
        var i, len, x;
        if (this.timeScale != 1.0) {
            dt *= this.timeScale;
        }

        var entry;
        for (i = 0, len = this.updatesNeg.length; i < len; i++) {
            entry = this.updatesNeg[i];
            if (entry && !entry.paused) {
                entry.target.update(dt);
            }
        }

        for (i = 0, len = this.updates0.length; i < len; i++) {
            entry = this.updates0[i];
            if (entry && !entry.paused) {
                entry.target.update(dt);
            }
        }

        for (i = 0, len = this.updatesPos.length; i < len; i++) {
            entry = this.updatesPos[i];
            if (entry && !entry.paused) {
                entry.target.update(dt);
            }
        }

        for (x in this.hashForMethods) {
            if (this.hashForMethods.hasOwnProperty(x)) {
                entry = this.hashForMethods[x];

                if (entry) {
                    for (i = 0, len = entry.timers.length; i < len; i++) {
                        var timer = entry.timers[i];
                        if (timer) {
                            timer.update(dt);
                        }
                    }
                }
            }
        }

    },

    /**
     * Unshedules a selector for a given target.
     * If you want to unschedule the "update", use unscheduleUpdateForTarget.
     */
    unschedule: function (opts) {
        if (!opts.target || !opts.method) {
            return;
        }
        var element = this.hashForMethods[opts.target.get('id')];
        if (element) {
            for (var i=0; i<element.timers.length; i++) {
                // Compare callback function
                if (element.timers[i].callback == util.callback(opts.target, opts.method)) {
                    var timer = element.timers.splice(i, 1);
                    timer = null;
                }
            }
        }
    },

    /**
     * Unschedules the update selector for a given target
     */
    unscheduleUpdateForTarget: function (target) {
        if (!target) {
            return;
        }
        var id = target.get('id'),
            elementUpdate = this.hashForUpdates[id];
        if (elementUpdate) {
            // Remove from updates list
            if (elementUpdate.priority === 0) {
                this.updates0.splice(this.updates0.indexOf(elementUpdate), 1);
            } else if (elementUpdate.priority < 0) {
                this.updatesNeg.splice(this.updatesNeg.indexOf(elementUpdate), 1);
            } else /* priority > 0 */{
                this.updatesPos.splice(this.updatesPos.indexOf(elementUpdate), 1);
            }
        }
        // Release HashMethodEntry object
        this.hashForUpdates[id] = null;
    },

    /**
     * Unschedules all selectors from all targets.
     * You should NEVER call this method, unless you know what you are doing.
     */
    unscheduleAllSelectors: function () {
        var i, x, entry;

        // Custom selectors
        for (x in this.hashForMethods) {
            if (this.hashForMethods.hasOwnProperty(x)) {
                entry = this.hashForMethods[x];
                this.unscheduleAllSelectorsForTarget(entry.target);
            }
        }
        // Updates selectors
        for (i = 0, len = this.updatesNeg.length; i < len; i++) {
            entry = this.updatesNeg[i];
            if (entry) {
                this.unscheduleUpdateForTarget(entry.target);
            }
        }

        for (i = 0, len = this.updates0.length; i < len; i++) {
            entry = this.updates0[i];
            if (entry) {
                this.unscheduleUpdateForTarget(entry.target);
            }
        }

        for (i = 0, len = this.updatesPos.length; i < len; i++) {
            entry = this.updatesPos[i];
            if (entry) {
                this.unscheduleUpdateForTarget(entry.target);
            }
        }
    },

    /**
     * Unschedules all selectors for a given target.
     * This also includes the "update" selector.
     */
    unscheduleAllSelectorsForTarget: function (target) {
        if (!target) {
            return;
        }
        // Custom selector
        var element = this.hashForMethods[target.get('id')];
        if (element) {
            element.paused = true;
            element.timers = []; // Clear all timers
        }
        // Release HashMethodEntry object
        this.hashForMethods[target.get('id')] = null;

        // Update selector
        this.unscheduleUpdateForTarget(target);
    },

    /**
     * Pauses the target.
     * All scheduled selectors/update for a given target won't be 'ticked' until the target is resumed.
     * If the target is not present, nothing happens.
     */

    pauseTarget: function (target) {
        var element = this.hashForMethods[target.get('id')];
        if (element) {
            element.paused = true;
        }

        var elementUpdate = this.hashForUpdates[target.get('id')];
        if (elementUpdate) {
            elementUpdate.paused = true;
        }
    },

    /**
     * Resumes the target.
     * The 'target' will be unpaused, so all schedule selectors/update will be 'ticked' again.
     * If the target is not present, nothing happens.
     */

    resumeTarget: function (target) {
        var element = this.hashForMethods[target.get('id')];
        if (element) {
            element.paused = false;
        }

        var elementUpdate = this.hashForUpdates[target.get('id')];
        //console.log('foo', target.get('id'), elementUpdate);
        if (elementUpdate) {
            elementUpdate.paused = false;
        }
    }
});

util.extend(Scheduler, /** @lends cocos.Scheduler */{
    /**
     * A shared singleton instance of cocos.Scheduler
     * @getter sharedScheduler 
     * @type cocos.Scheduler
     */
    get_sharedScheduler: function (key) {
        if (!this._instance) {
            this._instance = this.create();
        }

        return this._instance;
    }
});

exports.Timer = Timer;
exports.Scheduler = Scheduler;

}};
__resources__["/__builtin__/libs/cocos2d/SpriteFrame.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    geo = require('geometry'),
    ccp = geo.ccp;

var SpriteFrame = BObject.extend(/** @lends cocos.SpriteFrame# */{
    rect: null,
    rotated: false,
    offset: null,
    originalSize: null,
    texture: null,

    /**
     * Represents a single frame of animation for a cocos.Sprite
     *
     * <p>A SpriteFrame has:<br>
     * - texture: A Texture2D that will be used by the Sprite<br>
     * - rectangle: A rectangle of the texture</p>
     *
     * <p>You can modify the frame of a Sprite by doing:</p>
     * 
     * <code>var frame = SpriteFrame.create({texture: texture, rect: rect});
     * sprite.set('displayFrame', frame);</code>
     *
     * @memberOf cocos
     * @constructs
     * @extends BObject
     *
     * @opt {cocos.Texture2D} texture The texture to draw this frame using
     * @opt {geometry.Rect} rect The rectangle inside the texture to draw
     */
    init: function (opts) {
        SpriteFrame.superclass.init(this, opts);

        this.texture      = opts.texture;
        this.rect         = opts.rect;
        this.rotated      = !!opts.rotate;
        this.offset       = opts.offset || ccp(0, 0);
        this.originalSize = opts.originalSize || util.copy(this.rect.size);
    },

    /**
     * @ignore
     */
    toString: function () {
        return "[object SpriteFrame | TextureName=" + this.texture.get('name') + ", Rect = (" + this.rect.origin.x + ", " + this.rect.origin.y + ", " + this.rect.size.width + ", " + this.rect.size.height + ")]";
    },

    /**
     * Make a copy of this frame
     *
     * @returns {cocos.SpriteFrame} Exact copy of this object
     */
    copy: function () {
        return SpriteFrame.create({rect: this.rect, rotated: this.rotated, offset: this.offset, originalSize: this.originalSize, texture: this.texture});
    }

});

exports.SpriteFrame = SpriteFrame;

}};
__resources__["/__builtin__/libs/cocos2d/SpriteFrameCache.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray FLIP_Y_AXIS*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    geo = require('geometry'),
    Plist = require('Plist').Plist,
    SpriteFrame = require('./SpriteFrame').SpriteFrame,
    Texture2D = require('./Texture2D').Texture2D;

var SpriteFrameCache = BObject.extend(/** @lends cocos.SpriteFrameCache# */{
    /**
     * List of sprite frames
     * @type Object
     */
    spriteFrames: null,

    /**
     * List of sprite frame aliases
     * @type Object
     */
    spriteFrameAliases: null,


    /**
     * @memberOf cocos
     * @extends BObject
     * @constructs
     * @singleton
     */
    init: function () {
        SpriteFrameCache.superclass.init.call(this);

        this.set('spriteFrames', {});
        this.set('spriteFrameAliases', {});
    },

    /**
     * Add SpriteFrame(s) to the cache
     *
     * @param {String} opts.file The filename of a Zwoptex .plist containing the frame definiitons.
     */
    addSpriteFrames: function (opts) {
        var plistPath = opts.file,
            plist = Plist.create({file: plistPath}),
            plistData = plist.get('data');


        var metaDataDict = plistData.metadata,
            framesDict = plistData.frames;

        var format = 0,
            texturePath = null;

        if (metaDataDict) {
            format = metaDataDict.format;
            // Get texture path from meta data
            texturePath = metaDataDict.textureFileName;
        }

        if (!texturePath) {
            // No texture path so assuming it's the same name as the .plist but ending in .png
            texturePath = plistPath.replace(/\.plist$/i, '.png');
        }


        var texture = Texture2D.create({file: texturePath});

        // Add frames
        for (var frameDictKey in framesDict) {
            if (framesDict.hasOwnProperty(frameDictKey)) {
                var frameDict = framesDict[frameDictKey],
                    spriteFrame = null;

                switch (format) {
                case 0:
                    var x = frameDict.x,
                        y =  frameDict.y,
                        w =  frameDict.width,
                        h =  frameDict.height,
                        ox = frameDict.offsetX,
                        oy = frameDict.offsetY,
                        ow = frameDict.originalWidth,
                        oh = frameDict.originalHeight;

                    // check ow/oh
                    if (!ow || !oh) {
                        //console.log("cocos2d: WARNING: originalWidth/Height not found on the CCSpriteFrame. AnchorPoint won't work as expected. Regenerate the .plist");
                    }

                    if (FLIP_Y_AXIS) {
                        oy *= -1;
                    }

                    // abs ow/oh
                    ow = Math.abs(ow);
                    oh = Math.abs(oh);

                    // create frame
                    spriteFrame = SpriteFrame.create({texture: texture,
                                                         rect: geo.rectMake(x, y, w, h),
                                                       rotate: false,
                                                       offset: geo.ccp(ox, oy),
                                                 originalSize: geo.sizeMake(ow, oh)});
                    break;

                case 1:
                case 2:
                    var frame      = geo.rectFromString(frameDict.frame),
                        rotated    = !!frameDict.rotated,
                        offset     = geo.pointFromString(frameDict.offset),
                        sourceSize = geo.sizeFromString(frameDict.sourceSize);

                    if (FLIP_Y_AXIS) {
                        offset.y *= -1;
                    }


                    // create frame
                    spriteFrame = SpriteFrame.create({texture: texture,
                                                         rect: frame,
                                                       rotate: rotated,
                                                       offset: offset,
                                                 originalSize: sourceSize});
                    break;

                case 3:
                    var spriteSize       = geo.sizeFromString(frameDict.spriteSize),
                        spriteOffset     = geo.pointFromString(frameDict.spriteOffset),
                        spriteSourceSize = geo.sizeFromString(frameDict.spriteSourceSize),
                        textureRect      = geo.rectFromString(frameDict.textureRect),
                        textureRotated   = frameDict.textureRotated;
                    

                    if (FLIP_Y_AXIS) {
                        spriteOffset.y *= -1;
                    }

                    // get aliases
                    var aliases = frameDict.aliases;
                    for (var i = 0, len = aliases.length; i < len; i++) {
                        var alias = aliases[i];
                        this.get('spriteFrameAliases')[frameDictKey] = alias;
                    }
                    
                    // create frame
                    spriteFrame = SpriteFrame.create({texture: texture,
                                                         rect: geo.rectMake(textureRect.origin.x, textureRect.origin.y, spriteSize.width, spriteSize.height),
                                                       rotate: textureRotated,
                                                       offset: spriteOffset,
                                                 originalSize: spriteSourceSize});
                    break;

                default:
                    throw "Unsupported Zwoptex format: " + format;
                }

                // Add sprite frame
                this.get('spriteFrames')[frameDictKey] = spriteFrame;
            }
        }
    },

    /**
     * Get a single SpriteFrame
     *
     * @param {String} opts.name The name of the sprite frame
     * @returns {cocos.SpriteFrame} The sprite frame
     */
    getSpriteFrame: function (opts) {
        var name = opts.name;

        var frame = this.get('spriteFrames')[name];

        if (!frame) {
            // No frame, look for an alias
            var key = this.get('spriteFrameAliases')[name];

            if (key) {
                frame = this.get('spriteFrames')[key];
            }

            if (!frame) {
                throw "Unable to find frame: " + name;
            }
        }

        return frame;
    }
});

/**
 * Class methods
 */
util.extend(SpriteFrameCache, /** @lends cocos.SpriteFrameCache */{
    /**
     * @field
     * @name cocos.SpriteFrameCache.sharedSpriteFrameCache
     * @type cocos.SpriteFrameCache
     */
    get_sharedSpriteFrameCache: function (key) {
        if (!this._instance) {
            this._instance = this.create();
        }

        return this._instance;
    }
});

exports.SpriteFrameCache = SpriteFrameCache;

}};
__resources__["/__builtin__/libs/cocos2d/Texture2D.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    events = require('events'),
    RemoteResource = require('./RemoteResource').RemoteResource;

var Texture2D = BObject.extend(/** @lends cocos.Texture2D# */{
    imgElement: null,
    size: null,
    name: null,
    isLoaded: false,

    /**
     * @memberOf cocos
     * @constructs
     * @extends BObject
     *
     * @opt {String} [file] The file path of the image to use as a texture
     * @opt {Texture2D|HTMLImageElement} [data] Image data to read from
     */
    init: function (opts) {
        var file = opts.file,
            data = opts.data,
            texture = opts.texture;

        if (file) {
            this.name = file;
            data = resource(file);
        } else if (texture) {
            this.name = texture.get('name');
            data = texture.get('imgElement');
        }

        this.size = {width: 0, height: 0};

        if (data instanceof RemoteResource) {
            events.addListener(data, 'load', util.callback(this, this.dataDidLoad));
            this.set('imgElement', data.load());
        } else {
            this.set('imgElement', data);
            this.dataDidLoad(data);
        }
    },

    dataDidLoad: function (data) {
        this.isLoaded = true;
        this.set('size', {width: this.imgElement.width, height: this.imgElement.height});
        events.trigger(self, 'load', self);
    },

    drawAtPoint: function (ctx, point) {
        if (!this.isLoaded) {
            return;
        }
        ctx.drawImage(this.imgElement, point.x, point.y);
    },
    drawInRect: function (ctx, rect) {
        if (!this.isLoaded) {
            return;
        }
        ctx.drawImage(this.imgElement,
            rect.origin.x, rect.origin.y,
            rect.size.width, rect.size.height
        );
    },

    /**
     * @getter data
     * @type {String} Base64 encoded image data
     */
    get_data: function () {
        return this.imgElement ? this.imgElement.src : null;
    },

    /**
     * @getter contentSize
     * @type {geometry.Size} Size of the texture
     */
    get_contentSize: function () {
        return this.size;
    },

    get_pixelsWide: function () {
        return this.size.width;
    },

    get_pixelsHigh: function () {
        return this.size.height;
    }
});

exports.Texture2D = Texture2D;

}};
__resources__["/__builtin__/libs/cocos2d/TextureAtlas.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray FLIP_Y_AXIS*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    Texture2D = require('./Texture2D').Texture2D;


/* QUAD STRUCTURE
 quad = {
     drawRect: <rect>, // Where the quad is drawn to
     textureRect: <rect>  // The slice of the texture to draw in drawRect
 }
*/

var TextureAtlas = BObject.extend(/** @lends cocos.TextureAtlas# */{
    quads: null,
    imgElement: null,
    texture: null,

    /**
     * A single texture that can represent lots of smaller images
     *
     * @memberOf cocos
     * @constructs
     * @extends BObject
     *
     * @opt {String} file The file path of the image to use as a texture
     * @opt {Texture2D|HTMLImageElement} [data] Image data to read from
     * @opt {CanvasElement} [canvas] A canvas to use as a texture
     */
    init: function (opts) {
        var file = opts.file,
            data = opts.data,
            texture = opts.texture,
            canvas = opts.canvas;

        if (canvas) {
            // If we've been given a canvas element then we'll use that for our image
            this.imgElement = canvas;
        } else {
            texture = Texture2D.create({texture: texture, file: file, data: data});
            this.set('texture', texture);
            this.imgElement = texture.get('imgElement');
        }

        this.quads = [];
    },

    insertQuad: function (opts) {
        var quad = opts.quad,
            index = opts.index || 0;

        this.quads.splice(index, 0, quad);
    },
    removeQuad: function (opts) {
        var index = opts.index;

        this.quads.splice(index, 1);
    },


    drawQuads: function (ctx) {
        util.each(this.quads, util.callback(this, function (quad) {
            if (!quad) {
                return;
            }

            this.drawQuad(ctx, quad);
        }));
    },

    drawQuad: function (ctx, quad) {
        var sx = quad.textureRect.origin.x,
            sy = quad.textureRect.origin.y,
            sw = quad.textureRect.size.width, 
            sh = quad.textureRect.size.height;

        var dx = quad.drawRect.origin.x,
            dy = quad.drawRect.origin.y,
            dw = quad.drawRect.size.width, 
            dh = quad.drawRect.size.height;


        var scaleX = 1;
        var scaleY = 1;

        if (FLIP_Y_AXIS) {
            dy -= dh;
            dh *= -1;
        }

            
        if (dw < 0) {
            dw *= -1;
            scaleX = -1;
        }
            
        if (dh < 0) {
            dh *= -1;
            scaleY = -1;
        }

        ctx.scale(scaleX, scaleY);

        var img = this.get('imgElement');
        ctx.drawImage(img, 
            sx, sy, // Draw slice from x,y
            sw, sh, // Draw slice size
            dx, dy, // Draw at 0, 0
            dw, dh  // Draw size
        );
        ctx.scale(1, 1);
    }
});

exports.TextureAtlas = TextureAtlas;

}};
__resources__["/__builtin__/libs/cocos2d/TMXOrientation.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

/**
 * @memberOf cocos
 * @namespace
 */
var TMXOrientation = /** @lends cocos.TMXOrientation */{
    /**
     * Orthogonal orientation
     * @constant
     */
    TMXOrientationOrtho: 1,

    /**
     * Hexagonal orientation
     * @constant
     */
    TMXOrientationHex: 2,

    /**
     * Isometric orientation
     * @constant
     */
    TMXOrientationIso: 3
};

module.exports = TMXOrientation;

}};
__resources__["/__builtin__/libs/cocos2d/TMXXMLParser.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray DOMParser console*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    path = require('path'),
    ccp = require('geometry').ccp,
    base64 = require('base64'),
    gzip   = require('gzip'),
    TMXOrientationOrtho = require('./TMXOrientation').TMXOrientationOrtho,
    TMXOrientationHex = require('./TMXOrientation').TMXOrientationHex,
    TMXOrientationIso = require('./TMXOrientation').TMXOrientationIso;

var TMXTilesetInfo = BObject.extend(/** @lends cocos.TMXTilesetInfo# */{
    name: '',
    firstGID: 0,
    tileSize: null,
    spacing: 0,
    margin: 0,
    sourceImage: null,

    /**
     * @memberOf cocos
     * @constructs
     * @extends BObject
     */
    init: function () {
        TMXTilesetInfo.superclass.init.call(this);
    },

    rectForGID: function (gid) {
        var rect = {size: {}, origin: ccp(0, 0)};
        rect.size = util.copy(this.tileSize);
        
        gid = gid - this.firstGID;

        var imgSize = this.get('imageSize');
        
        var maxX = Math.floor((imgSize.width - this.margin * 2 + this.spacing) / (this.tileSize.width + this.spacing));
        
        rect.origin.x = (gid % maxX) * (this.tileSize.width + this.spacing) + this.margin;
        rect.origin.y = Math.floor(gid / maxX) * (this.tileSize.height + this.spacing) + this.margin;
        
        return rect;
    }
});

var TMXLayerInfo = BObject.extend(/** @lends cocos.TMXLayerInfo# */{
    name: '',
    layerSize: null,
    tiles: null,
    visible: true,
    opacity: 255,
    minGID: 100000,
    maxGID: 0,
    properties: null,
    offset: null,

    /**
     * @memberOf cocos
     * @constructs
     * @extends BObject
     */
    init: function () {
        TMXLayerInfo.superclass.init.call(this);

        this.properties = {};
        this.offset = ccp(0, 0);
    }
});

var TMXObjectGroup = BObject.extend(/** @lends cocos.TMXObjectGroup# */{
    name: '',
    properties: null,
    offset: null,
    objects: null,

    /**
     * @memberOf cocos
     * @constructs
     * @extends BObject
     */
    init: function () {
        TMXObjectGroup.superclass.init.call(this);

        this.properties = {};
        this.objects = {};
        this.offset = ccp(0, 0);
    },

    /**
     * Get the value for the specific property name
     *
     * @opt {String} name Property name
     * @returns {String} Property value
     */
    getProperty: function (opts) {
        var propertyName = opts.name;
        return this.properties[propertyName];
    },

    /**
     * @deprected Since v0.2. You should now use cocos.TMXObjectGroup#getProperty
     */
    propertyNamed: function (opts) {
        console.warn('TMXObjectGroup#propertyNamed is deprected. Use TMXTiledMap#getProperty instread');
        return this.getProperty(opts);
    },

    /**
     * Get the object for the specific object name. It will return the 1st
     * object found on the array for the given name.
     *
     * @opt {String} name Object name
     * @returns {Object} Object
     */
    getObject: function (opts) {
        var objectName = opts.name;
        var object = null;
        
        this.objects.forEach(function (item) {
            if (item.name == objectName) {
                object = item;
            }
        });
        if (object !== null) {
            return object;
        }
    },

    /**
     * @deprected Since v0.2. You should now use cocos.TMXObjectGroup#getProperty
     */
    objectNamed: function (opts) {
        console.warn('TMXObjectGroup#objectNamed is deprected. Use TMXObjectGroup#getObject instread');
        return this.getObject(opts);
    }
});

var TMXMapInfo = BObject.extend(/** @lends cocos.TMXMapInfo# */{
    filename: '',
    orientation: 0,
    mapSize: null,
    tileSize: null,
    layer: null,
    tilesets: null,
    objectGroups: null,
    properties: null,
    tileProperties: null,

    /**
     * @memberOf cocos
     * @constructs
     * @extends BObject
     *
     * @param {String} tmxFile The file path of the TMX file to load
     */
    init: function (tmxFile) {
        TMXMapInfo.superclass.init.call(this, tmxFile);

        this.tilesets = [];
        this.layers = [];
        this.objectGroups = [];
        this.properties = {};
        this.tileProperties = {};
        this.filename = tmxFile;

        this.parseXMLFile(tmxFile);
    },

    parseXMLFile: function (xmlFile) {
        var parser = new DOMParser(),
            doc = parser.parseFromString(resource(xmlFile), 'text/xml');

        // PARSE <map>
        var map = doc.documentElement;

        // Set Orientation
        switch (map.getAttribute('orientation')) {
        case 'orthogonal':
            this.orientation = TMXOrientationOrtho;
            break;
        case 'isometric':
            this.orientation = TMXOrientationIso;
            break;
        case 'hexagonal':
            this.orientation = TMXOrientationHex;
            break;
        default:
            throw "cocos2d: TMXFomat: Unsupported orientation: " + map.getAttribute('orientation');
        }
        this.mapSize = {width: parseInt(map.getAttribute('width'), 10), height: parseInt(map.getAttribute('height'), 10)};
        this.tileSize = {width: parseInt(map.getAttribute('tilewidth'), 10), height: parseInt(map.getAttribute('tileheight'), 10)};


        // PARSE <tilesets>
        var tilesets = map.getElementsByTagName('tileset');
        var i, j, len, jen, s;
        for (i = 0, len = tilesets.length; i < len; i++) {
            var t = tilesets[i];

            var tileset = TMXTilesetInfo.create();
            tileset.set('name', t.getAttribute('name'));
            tileset.set('firstGID', parseInt(t.getAttribute('firstgid'), 10));
            if (t.getAttribute('spacing')) {
                tileset.set('spacing', parseInt(t.getAttribute('spacing'), 10));
            }
            if (t.getAttribute('margin')) {
                tileset.set('margin', parseInt(t.getAttribute('margin'), 10));
            }

            s = {};
            s.width = parseInt(t.getAttribute('tilewidth'), 10);
            s.height = parseInt(t.getAttribute('tileheight'), 10);
            tileset.set('tileSize', s);

            // PARSE <image> We assume there's only 1
            var image = t.getElementsByTagName('image')[0];
            tileset.set('sourceImage', path.join(path.dirname(this.filename), image.getAttribute('source')));

            this.tilesets.push(tileset);
        }

        // PARSE <layers>
        var layers = map.getElementsByTagName('layer');
        for (i = 0, len = layers.length; i < len; i++) {
            var l = layers[i];
            var data = l.getElementsByTagName('data')[0];
            var layer = TMXLayerInfo.create();

            layer.set('name', l.getAttribute('name'));
            if (l.getAttribute('visible') !== false) {
                layer.set('visible', true);
            } else {
                layer.set('visible', !!parseInt(l.getAttribute('visible'), 10));
            }

            s = {};
            s.width = parseInt(l.getAttribute('width'), 10);
            s.height = parseInt(l.getAttribute('height'), 10);
            layer.set('layerSize', s);

            var opacity = l.getAttribute('opacity');
            if (!opacity && opacity !== 0) {
                layer.set('opacity', 255);
            } else {
                layer.set('opacity', 255 * parseFloat(opacity));
            }

            var x = parseInt(l.getAttribute('x'), 10),
                y = parseInt(l.getAttribute('y'), 10);
            if (isNaN(x)) {
                x = 0;
            }
            if (isNaN(y)) {
                y = 0;
            }
            layer.set('offset', ccp(x, y));


            // Firefox has a 4KB limit on node values. It will split larger
            // nodes up into multiple nodes. So, we'll stitch them back
            // together.
            var nodeValue = '';
            for (j = 0, jen = data.childNodes.length; j < jen; j++) {
                nodeValue += data.childNodes[j].nodeValue;
            }

            // Unpack the tilemap data
            var compression = data.getAttribute('compression');
            switch (compression) {
            case 'gzip':
                layer.set('tiles', gzip.unzipBase64AsArray(nodeValue, 4));
                break;
                
            // Uncompressed
            case null:
            case '': 
                layer.set('tiles', base64.decodeAsArray(nodeValue, 4));
                break;

            default: 
                throw "Unsupported TMX Tile Map compression: " + compression;
            }

            this.layers.push(layer);
        }

        // TODO PARSE <tile>

        // PARSE <objectgroup>
        var objectgroups = map.getElementsByTagName('objectgroup');
        for (i = 0, len = objectgroups.length; i < len; i++) {
            var g = objectgroups[i],
                objectGroup = TMXObjectGroup.create();

            objectGroup.set('name', g.getAttribute('name'));
            
            var properties = g.querySelectorAll('objectgroup > properties property'),
                propertiesValue = {},
                property;
            
            for (j = 0; j < properties.length; j++) {
                property = properties[j];
                if (property.getAttribute('name')) {
                    propertiesValue[property.getAttribute('name')] = property.getAttribute('value');
                }
            }
           
            objectGroup.set('properties', propertiesValue);

            var objectsArray = [],
                objects = g.querySelectorAll('object');

            for (j = 0; j < objects.length; j++) {
                var object = objects[j];
                var objectValue = {
                    x       : parseInt(object.getAttribute('x'), 10),
                    y       : parseInt(object.getAttribute('y'), 10),
                    width   : parseInt(object.getAttribute('width'), 10),
                    height  : parseInt(object.getAttribute('height'), 10)
                };
                if (object.getAttribute('name')) {
                    objectValue.name = object.getAttribute('name');
                }
                if (object.getAttribute('type')) {
                    objectValue.type = object.getAttribute('type');
                }
                properties = object.querySelectorAll('property');
                for (var k = 0; k < properties.length; k++) {
                    property = properties[k];
                    if (property.getAttribute('name')) {
                        objectValue[property.getAttribute('name')] = property.getAttribute('value');
                    }
                }
                objectsArray.push(objectValue);

            }
            objectGroup.set('objects', objectsArray);
            this.objectGroups.push(objectGroup);
        }


        // PARSE <map><property>
        var properties = doc.querySelectorAll('map > properties > property');

        for (i = 0; i < properties.length; i++) {
            var property = properties[i];
            if (property.getAttribute('name')) {
                this.properties[property.getAttribute('name')] = property.getAttribute('value');
            }
        }
    }
});

exports.TMXMapInfo = TMXMapInfo;
exports.TMXLayerInfo = TMXLayerInfo;
exports.TMXTilesetInfo = TMXTilesetInfo;
exports.TMXObjectGroup = TMXObjectGroup;

}};
__resources__["/__builtin__/libs/geometry.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util');

var RE_PAIR = /\{\s*([\d.\-]+)\s*,\s*([\d.\-]+)\s*\}/,
    RE_DOUBLE_PAIR = /\{\s*(\{[\s\d,.\-]+\})\s*,\s*(\{[\s\d,.\-]+\})\s*\}/;

Math.PI_2 = 1.57079632679489661923132169163975144     /* pi/2 */

/** @namespace */
var geometry = {
    /**
     * @class
     * A 2D point in space
     *
     * @param {Float} x X value
     * @param {Float} y Y value
     */
    Point: function (x, y) {
        /**
         * X coordinate
         * @type Float
         */
        this.x = x;

        /**
         * Y coordinate
         * @type Float
         */
        this.y = y;
    },

    /**
     * @class
     * A 2D size
     *
     * @param {Float} w Width
     * @param {Float} h Height
     */
    Size: function (w, h) {
        /**
         * Width
         * @type Float
         */
        this.width = w;

        /**
         * Height
         * @type Float
         */
        this.height = h;
    },

    /**
     * @class
     * A rectangle
     *
     * @param {Float} x X value
     * @param {Float} y Y value
     * @param {Float} w Width
     * @param {Float} h Height
     */
    Rect: function (x, y, w, h) {
        /**
         * Coordinate in 2D space
         * @type {geometry.Point}
         */
        this.origin = new geometry.Point(x, y);

        /**
         * Size in 2D space
         * @type {geometry.Size}
         */
        this.size   = new geometry.Size(w, h);
    },

    /**
     * @class
     * Transform matrix
     *
     * @param {Float} a
     * @param {Float} b
     * @param {Float} c
     * @param {Float} d
     * @param {Float} tx
     * @param {Float} ty
     */
    TransformMatrix: function (a, b, c, d, tx, ty) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.tx = tx;
        this.ty = ty;
    },

    /**
     * @class 
     * Bezier curve control object
     *
     * @param {geometry.Point} controlPoint1
     * @param {geometry.Point} controlPoint2
     * @param {geometry.Point} endPoint
     */
    BezierConfig: function(p1, p2, ep) {
        this.controlPoint1 = util.copy(p1);
        this.controlPoint2 = util.copy(p2);
        this.endPosition = util.copy(ep);
    },
    
    /**
     * Creates a geometry.Point instance
     *
     * @param {Float} x X coordinate
     * @param {Float} y Y coordinate
     * @returns {geometry.Point} 
     */
    ccp: function (x, y) {
        return module.exports.pointMake(x, y);
    },

    /**
     * Add the values of two points together
     *
     * @param {geometry.Point} p1 First point
     * @param {geometry.Point} p2 Second point
     * @returns {geometry.Point} New point
     */
    ccpAdd: function (p1, p2) {
        return geometry.ccp(p1.x + p2.x, p1.y + p2.y);
    },

    /**
     * Subtract the values of two points
     *
     * @param {geometry.Point} p1 First point
     * @param {geometry.Point} p2 Second point
     * @returns {geometry.Point} New point
     */
    ccpSub: function (p1, p2) {
        return geometry.ccp(p1.x - p2.x, p1.y - p2.y);
    },

    /**
     * Muliply the values of two points together
     *
     * @param {geometry.Point} p1 First point
     * @param {geometry.Point} p2 Second point
     * @returns {geometry.Point} New point
     */
    ccpMult: function (p1, p2) {
        return geometry.ccp(p1.x * p2.x, p1.y * p2.y);
    },


    /**
     * Invert the values of a geometry.Point
     *
     * @param {geometry.Point} p Point to invert
     * @returns {geometry.Point} New point
     */
    ccpNeg: function (p) {
        return geometry.ccp(-p.x, -p.y);
    },

    /**
     * Round values on a geometry.Point to whole numbers
     *
     * @param {geometry.Point} p Point to round
     * @returns {geometry.Point} New point
     */
    ccpRound: function (p) {
        return geometry.ccp(Math.round(p.x), Math.round(p.y));
    },

    /**
     * Round up values on a geometry.Point to whole numbers
     *
     * @param {geometry.Point} p Point to round
     * @returns {geometry.Point} New point
     */
    ccpCeil: function (p) {
        return geometry.ccp(Math.ceil(p.x), Math.ceil(p.y));
    },

    /**
     * Round down values on a geometry.Point to whole numbers
     *
     * @param {geometry.Point} p Point to round
     * @returns {geometry.Point} New point
     */
    ccpFloor: function (p) {
        return geometry.ccp(Math.floor(p.x), Math.floor(p.y));
    },

    /**
     * A point at 0x0
     *
     * @returns {geometry.Point} New point at 0x0
     */
    PointZero: function () {
        return geometry.ccp(0, 0);
    },

    /**
     * @returns {geometry.Rect}
     */
    rectMake: function (x, y, w, h) {
        return new geometry.Rect(x, y, w, h);
    },

    /**
     * @returns {geometry.Rect}
     */
    rectFromString: function (str) {
        var matches = str.match(RE_DOUBLE_PAIR),
            p = geometry.pointFromString(matches[1]),
            s = geometry.sizeFromString(matches[2]);

        return geometry.rectMake(p.x, p.y, s.width, s.height);
    },

    /**
     * @returns {geometry.Size}
     */
    sizeMake: function (w, h) {
        return new geometry.Size(w, h);
    },

    /**
     * @returns {geometry.Size}
     */
    sizeFromString: function (str) {
        var matches = str.match(RE_PAIR),
            w = parseFloat(matches[1]),
            h = parseFloat(matches[2]);

        return geometry.sizeMake(w, h);
    },

    /**
     * @returns {geometry.Point}
     */
    pointMake: function (x, y) {
        return new geometry.Point(x, y);
    },

    /**
     * @returns {geometry.Point}
     */
    pointFromString: function (str) {
        var matches = str.match(RE_PAIR),
            x = parseFloat(matches[1]),
            y = parseFloat(matches[2]);

        return geometry.pointMake(x, y);
    },

    /**
     * @returns {Boolean}
     */
    rectContainsPoint: function (r, p) {
        return ((p.x >= r.origin.x && p.x <= r.origin.x + r.size.width) &&
                (p.y >= r.origin.y && p.y <= r.origin.y + r.size.height));
    },

    /**
     * Returns the smallest rectangle that contains the two source rectangles.
     *
     * @param {geometry.Rect} r1
     * @param {geometry.Rect} r2
     * @returns {geometry.Rect}
     */
    rectUnion: function (r1, r2) {
        var rect = new geometry.Rect(0, 0, 0, 0);

        rect.origin.x = Math.min(r1.origin.x, r2.origin.x);
        rect.origin.y = Math.min(r1.origin.y, r2.origin.y);
        rect.size.width = Math.max(r1.origin.x + r1.size.width, r2.origin.x + r2.size.width) - rect.origin.x;
        rect.size.height = Math.max(r1.origin.y + r1.size.height, r2.origin.y + r2.size.height) - rect.origin.y;

        return rect;
    },

    /**
     * @returns {Boolean}
     */
    rectOverlapsRect: function (r1, r2) {
        if (r1.origin.x + r1.size.width < r2.origin.x) {
            return false;
        }
        if (r2.origin.x + r2.size.width < r1.origin.x) {
            return false;
        }
        if (r1.origin.y + r1.size.height < r2.origin.y) {
            return false;
        }
        if (r2.origin.y + r2.size.height < r1.origin.y) {
            return false;
        }

        return true;
    },

    /**
     * Returns the overlapping portion of 2 rectangles
     *
     * @param {geometry.Rect} lhsRect First rectangle
     * @param {geometry.Rect} rhsRect Second rectangle
     * @returns {geometry.Rect} The overlapping portion of the 2 rectangles
     */
    rectIntersection: function (lhsRect, rhsRect) {

        var intersection = new geometry.Rect(
            Math.max(geometry.rectGetMinX(lhsRect), geometry.rectGetMinX(rhsRect)),
            Math.max(geometry.rectGetMinY(lhsRect), geometry.rectGetMinY(rhsRect)),
            0,
            0
        );

        intersection.size.width = Math.min(geometry.rectGetMaxX(lhsRect), geometry.rectGetMaxX(rhsRect)) - geometry.rectGetMinX(intersection);
        intersection.size.height = Math.min(geometry.rectGetMaxY(lhsRect), geometry.rectGetMaxY(rhsRect)) - geometry.rectGetMinY(intersection);

        return intersection;
    },

    /**
     * @returns {Boolean}
     */
    pointEqualToPoint: function (point1, point2) {
        return (point1.x == point2.x && point1.y == point2.y);
    },

    /**
     * @returns {Boolean}
     */
    sizeEqualToSize: function (size1, size2) {
        return (size1.width == size2.width && size1.height == size2.height);
    },

    /**
     * @returns {Boolean}
     */
    rectEqualToRect: function (rect1, rect2) {
        return (module.exports.sizeEqualToSize(rect1.size, rect2.size) && module.exports.pointEqualToPoint(rect1.origin, rect2.origin));
    },

    /**
     * @returns {Float}
     */
    rectGetMinX: function (rect) {
        return rect.origin.x;
    },

    /**
     * @returns {Float}
     */
    rectGetMinY: function (rect) {
        return rect.origin.y;
    },

    /**
     * @returns {Float}
     */
    rectGetMaxX: function (rect) {
        return rect.origin.x + rect.size.width;
    },

    /**
     * @returns {Float}
     */
    rectGetMaxY: function (rect) {
        return rect.origin.y + rect.size.height;
    },

    boundingRectMake: function (p1, p2, p3, p4) {
        var minX = Math.min(p1.x, p2.x, p3.x, p4.x);
        var minY = Math.min(p1.y, p2.y, p3.y, p4.y);
        var maxX = Math.max(p1.x, p2.x, p3.x, p4.x);
        var maxY = Math.max(p1.y, p2.y, p3.y, p4.y);

        return new geometry.Rect(minX, minY, (maxX - minX), (maxY - minY));
    },

    /**
     * @returns {geometry.Point}
     */
    pointApplyAffineTransform: function (point, t) {

        /*
        aPoint.x * aTransform.a + aPoint.y * aTransform.c + aTransform.tx,
        aPoint.x * aTransform.b + aPoint.y * aTransform.d + aTransform.ty
        */

        return new geometry.Point(t.a * point.x + t.c * point.y + t.tx, t.b * point.x + t.d * point.y + t.ty);

    },

    /**
     * Apply a transform matrix to a rectangle
     *
     * @param {geometry.Rect} rect Rectangle to transform
     * @param {geometry.TransformMatrix} trans TransformMatrix to apply to rectangle
     * @returns {geometry.Rect} A new transformed rectangle
     */
    rectApplyAffineTransform: function (rect, trans) {

        var p1 = geometry.ccp(geometry.rectGetMinX(rect), geometry.rectGetMinY(rect));
        var p2 = geometry.ccp(geometry.rectGetMaxX(rect), geometry.rectGetMinY(rect));
        var p3 = geometry.ccp(geometry.rectGetMinX(rect), geometry.rectGetMaxY(rect));
        var p4 = geometry.ccp(geometry.rectGetMaxX(rect), geometry.rectGetMaxY(rect));

        p1 = geometry.pointApplyAffineTransform(p1, trans);
        p2 = geometry.pointApplyAffineTransform(p2, trans);
        p3 = geometry.pointApplyAffineTransform(p3, trans);
        p4 = geometry.pointApplyAffineTransform(p4, trans);

        return geometry.boundingRectMake(p1, p2, p3, p4);
    },

    /**
     * Inverts a transform matrix
     *
     * @param {geometry.TransformMatrix} trans TransformMatrix to invert
     * @returns {geometry.TransformMatrix} New transform matrix
     */
    affineTransformInvert: function (trans) {
        var determinant = 1 / (trans.a * trans.d - trans.b * trans.c);

        return new geometry.TransformMatrix(
            determinant * trans.d,
            -determinant * trans.b,
            -determinant * trans.c,
            determinant * trans.a,
            determinant * (trans.c * trans.ty - trans.d * trans.tx),
            determinant * (trans.b * trans.tx - trans.a * trans.ty)
        );
    },

    /**
     * Multiply 2 transform matrices together
     * @param {geometry.TransformMatrix} lhs Left matrix
     * @param {geometry.TransformMatrix} rhs Right matrix
     * @returns {geometry.TransformMatrix} New transform matrix
     */
    affineTransformConcat: function (lhs, rhs) {
        return new geometry.TransformMatrix(
            lhs.a * rhs.a + lhs.b * rhs.c,
            lhs.a * rhs.b + lhs.b * rhs.d,
            lhs.c * rhs.a + lhs.d * rhs.c,
            lhs.c * rhs.b + lhs.d * rhs.d,
            lhs.tx * rhs.a + lhs.ty * rhs.c + rhs.tx,
            lhs.tx * rhs.b + lhs.ty * rhs.d + rhs.ty
        );
    },

    /**
     * @returns {Float}
     */
    degreesToRadians: function (angle) {
        return angle / 180.0 * Math.PI;
    },

    /**
     * @returns {Float}
     */
    radiansToDegrees: function (angle) {
        return angle * (180.0 / Math.PI);
    },

    /**
     * Translate (move) a transform matrix
     *
     * @param {geometry.TransformMatrix} trans TransformMatrix to translate
     * @param {Float} tx Amount to translate along X axis
     * @param {Float} ty Amount to translate along Y axis
     * @returns {geometry.TransformMatrix} A new TransformMatrix
     */
    affineTransformTranslate: function (trans, tx, ty) {
        var newTrans = util.copy(trans);
        newTrans.tx = trans.tx + trans.a * tx + trans.c * ty;
        newTrans.ty = trans.ty + trans.b * tx + trans.d * ty;
        return newTrans;
    },

    /**
     * Rotate a transform matrix
     *
     * @param {geometry.TransformMatrix} trans TransformMatrix to rotate
     * @param {Float} angle Angle in radians
     * @returns {geometry.TransformMatrix} A new TransformMatrix
     */
    affineTransformRotate: function (trans, angle) {
        var sin = Math.sin(angle),
            cos = Math.cos(angle);

        return new geometry.TransformMatrix(
            trans.a * cos + trans.c * sin,
            trans.b * cos + trans.d * sin,
            trans.c * cos - trans.a * sin,
            trans.d * cos - trans.b * sin,
            trans.tx,
            trans.ty
        );
    },

    /**
     * Scale a transform matrix
     *
     * @param {geometry.TransformMatrix} trans TransformMatrix to scale
     * @param {Float} sx X scale factor
     * @param {Float} [sy=sx] Y scale factor
     * @returns {geometry.TransformMatrix} A new TransformMatrix
     */
    affineTransformScale: function (trans, sx, sy) {
        if (sy === undefined) {
            sy = sx;
        }

        return new geometry.TransformMatrix(trans.a * sx, trans.b * sx, trans.c * sy, trans.d * sy, trans.tx, trans.ty);
    },

    /**
     * @returns {geometry.TransformMatrix} identity matrix
     */
    affineTransformIdentity: function () {
        return new geometry.TransformMatrix(1, 0, 0, 1, 0, 0);
    }
};

module.exports = geometry;

}};
__resources__["/__builtin__/libs/gzip.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/**
 * @fileoverview 
 */

/** @ignore */
var JXG = require('./JXGUtil');

/**
 * @namespace
 * Wrappers around JXG's GZip utils
 * @see JXG.Util
 */
var gzip = {
    /**
     * Unpack a gzipped byte array
     *
     * @param {Integer[]} input Byte array
     * @returns {String} Unpacked byte string
     */
    unzip: function(input) {
        return (new JXG.Util.Unzip(input)).unzip()[0][0];
    },

    /**
     * Unpack a gzipped byte string encoded as base64
     *
     * @param {String} input Byte string encoded as base64
     * @returns {String} Unpacked byte string
     */
    unzipBase64: function(input) {
        return (new JXG.Util.Unzip(JXG.Util.Base64.decodeAsArray(input))).unzip()[0][0];
    },

    /**
     * Unpack a gzipped byte string encoded as base64
     *
     * @param {String} input Byte string encoded as base64
     * @param {Integer} bytes Bytes per array item
     * @returns {Integer[]} Unpacked byte array
     */
    unzipBase64AsArray: function(input, bytes) {
        bytes = bytes || 1;

        var dec = this.unzipBase64(input),
            ar = [], i, j, len;
        for (i = 0, len = dec.length/bytes; i < len; i++){
            ar[i] = 0;
            for (j = bytes-1; j >= 0; --j){
                ar[i] += dec.charCodeAt((i *bytes) +j) << (j *8);
            }
        }
        return ar;
    },

    /**
     * Unpack a gzipped byte array
     *
     * @param {Integer[]} input Byte array
     * @param {Integer} bytes Bytes per array item
     * @returns {Integer[]} Unpacked byte array
     */
    unzipAsArray: function (input, bytes) {
        bytes = bytes || 1;

        var dec = this.unzip(input),
            ar = [], i, j, len;
        for (i = 0, len = dec.length/bytes; i < len; i++){
            ar[i] = 0;
            for (j = bytes-1; j >= 0; --j){
                ar[i] += dec.charCodeAt((i *bytes) +j) << (j *8);
            }
        }
        return ar;
    }

};

module.exports = gzip;

}};
__resources__["/__builtin__/libs/JXGUtil.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*
    Copyright 2008,2009
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with JSXGraph.  If not, see <http://www.gnu.org/licenses/>.
*/

/**
 * @fileoverview Utilities for uncompressing and base64 decoding
 */

/** @namespace */
var JXG = {};

/**
  * @class Util class
  * Class for gunzipping, unzipping and base64 decoding of files.
  * It is used for reading GEONExT, Geogebra and Intergeo files.
  *
  * Only Huffman codes are decoded in gunzip.
  * The code is based on the source code for gunzip.c by Pasi Ojala 
  * @see <a href="http://www.cs.tut.fi/~albert/Dev/gunzip/gunzip.c">http://www.cs.tut.fi/~albert/Dev/gunzip/gunzip.c</a>
  * @see <a href="http://www.cs.tut.fi/~albert">http://www.cs.tut.fi/~albert</a>
  */
JXG.Util = {};
                                 
/**
 * Unzip zip files
 */
JXG.Util.Unzip = function (barray){
    var outputArr = [],
        output = "",
        debug = false,
        gpflags,
        files = 0,
        unzipped = [],
        crc,
        buf32k = new Array(32768),
        bIdx = 0,
        modeZIP=false,

        CRC, SIZE,
    
        bitReverse = [
        0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,
        0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
        0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,
        0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,
        0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,
        0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,
        0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,
        0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,
        0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,
        0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
        0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,
        0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,
        0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,
        0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,
        0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,
        0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,
        0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,
        0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,
        0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,
        0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
        0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,
        0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
        0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,
        0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,
        0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,
        0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,
        0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,
        0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,
        0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,
        0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
        0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,
        0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff
    ],
    
    cplens = [
        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
    ],

    cplext = [
        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99
    ], /* 99==invalid */

    cpdist = [
        0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0007, 0x0009, 0x000d,
        0x0011, 0x0019, 0x0021, 0x0031, 0x0041, 0x0061, 0x0081, 0x00c1,
        0x0101, 0x0181, 0x0201, 0x0301, 0x0401, 0x0601, 0x0801, 0x0c01,
        0x1001, 0x1801, 0x2001, 0x3001, 0x4001, 0x6001
    ],

    cpdext = [
        0,  0,  0,  0,  1,  1,  2,  2,
        3,  3,  4,  4,  5,  5,  6,  6,
        7,  7,  8,  8,  9,  9, 10, 10,
        11, 11, 12, 12, 13, 13
    ],
    
    border = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
    
    bA = barray,

    bytepos=0,
    bitpos=0,
    bb = 1,
    bits=0,
    
    NAMEMAX = 256,
    
    nameBuf = [],
    
    fileout;
    
    function readByte(){
        bits+=8;
        if (bytepos<bA.length){
            //if (debug)
            //    document.write(bytepos+": "+bA[bytepos]+"<br>");
            return bA[bytepos++];
        } else
            return -1;
    };

    function byteAlign(){
        bb = 1;
    };
    
    function readBit(){
        var carry;
        bits++;
        carry = (bb & 1);
        bb >>= 1;
        if (bb==0){
            bb = readByte();
            carry = (bb & 1);
            bb = (bb>>1) | 0x80;
        }
        return carry;
    };

    function readBits(a) {
        var res = 0,
            i = a;
    
        while(i--) {
            res = (res<<1) | readBit();
        }
        if(a) {
            res = bitReverse[res]>>(8-a);
        }
        return res;
    };
        
    function flushBuffer(){
        //document.write('FLUSHBUFFER:'+buf32k);
        bIdx = 0;
    };
    function addBuffer(a){
        SIZE++;
        //CRC=updcrc(a,crc);
        buf32k[bIdx++] = a;
        outputArr.push(String.fromCharCode(a));
        //output+=String.fromCharCode(a);
        if(bIdx==0x8000){
            //document.write('ADDBUFFER:'+buf32k);
            bIdx=0;
        }
    };
    
    function HufNode() {
        this.b0=0;
        this.b1=0;
        this.jump = null;
        this.jumppos = -1;
    };

    var LITERALS = 288;
    
    var literalTree = new Array(LITERALS);
    var distanceTree = new Array(32);
    var treepos=0;
    var Places = null;
    var Places2 = null;
    
    var impDistanceTree = new Array(64);
    var impLengthTree = new Array(64);
    
    var len = 0;
    var fpos = new Array(17);
    fpos[0]=0;
    var flens;
    var fmax;
    
    function IsPat() {
        while (1) {
            if (fpos[len] >= fmax)
                return -1;
            if (flens[fpos[len]] == len)
                return fpos[len]++;
            fpos[len]++;
        }
    };

    function Rec() {
        var curplace = Places[treepos];
        var tmp;
        if (debug)
    		document.write("<br>len:"+len+" treepos:"+treepos);
        if(len==17) { //war 17
            return -1;
        }
        treepos++;
        len++;
    	
        tmp = IsPat();
        if (debug)
        	document.write("<br>IsPat "+tmp);
        if(tmp >= 0) {
            curplace.b0 = tmp;    /* leaf cell for 0-bit */
            if (debug)
            	document.write("<br>b0 "+curplace.b0);
        } else {
        /* Not a Leaf cell */
        curplace.b0 = 0x8000;
        if (debug)
        	document.write("<br>b0 "+curplace.b0);
        if(Rec())
            return -1;
        }
        tmp = IsPat();
        if(tmp >= 0) {
            curplace.b1 = tmp;    /* leaf cell for 1-bit */
            if (debug)
            	document.write("<br>b1 "+curplace.b1);
            curplace.jump = null;    /* Just for the display routine */
        } else {
            /* Not a Leaf cell */
            curplace.b1 = 0x8000;
            if (debug)
            	document.write("<br>b1 "+curplace.b1);
            curplace.jump = Places[treepos];
            curplace.jumppos = treepos;
            if(Rec())
                return -1;
        }
        len--;
        return 0;
    };

    function CreateTree(currentTree, numval, lengths, show) {
        var i;
        /* Create the Huffman decode tree/table */
        //document.write("<br>createtree<br>");
        if (debug)
        	document.write("currentTree "+currentTree+" numval "+numval+" lengths "+lengths+" show "+show);
        Places = currentTree;
        treepos=0;
        flens = lengths;
        fmax  = numval;
        for (i=0;i<17;i++)
            fpos[i] = 0;
        len = 0;
        if(Rec()) {
            //fprintf(stderr, "invalid huffman tree\n");
            if (debug)
            	alert("invalid huffman tree\n");
            return -1;
        }
        if (debug){
        	document.write('<br>Tree: '+Places.length);
        	for (var a=0;a<32;a++){
            	document.write("Places["+a+"].b0="+Places[a].b0+"<br>");
            	document.write("Places["+a+"].b1="+Places[a].b1+"<br>");
        	}
        }

        return 0;
    };
    
    function DecodeValue(currentTree) {
        var len, i,
            xtreepos=0,
            X = currentTree[xtreepos],
            b;

        /* decode one symbol of the data */
        while(1) {
            b=readBit();
            if (debug)
            	document.write("b="+b);
            if(b) {
                if(!(X.b1 & 0x8000)){
                	if (debug)
                    	document.write("ret1");
                    return X.b1;    /* If leaf node, return data */
                }
                X = X.jump;
                len = currentTree.length;
                for (i=0;i<len;i++){
                    if (currentTree[i]===X){
                        xtreepos=i;
                        break;
                    }
                }
                //xtreepos++;
            } else {
                if(!(X.b0 & 0x8000)){
                	if (debug)
                    	document.write("ret2");
                    return X.b0;    /* If leaf node, return data */
                }
                //X++; //??????????????????
                xtreepos++;
                X = currentTree[xtreepos];
            }
        }
        if (debug)
        	document.write("ret3");
        return -1;
    };
    
    function DeflateLoop() {
    var last, c, type, i, len;

    do {
        /*if((last = readBit())){
            fprintf(errfp, "Last Block: ");
        } else {
            fprintf(errfp, "Not Last Block: ");
        }*/
        last = readBit();
        type = readBits(2);
        switch(type) {
            case 0:
            	if (debug)
                	alert("Stored\n");
                break;
            case 1:
            	if (debug)
                	alert("Fixed Huffman codes\n");
                break;
            case 2:
            	if (debug)
                	alert("Dynamic Huffman codes\n");
                break;
            case 3:
            	if (debug)
                	alert("Reserved block type!!\n");
                break;
            default:
            	if (debug)
                	alert("Unexpected value %d!\n", type);
                break;
        }

        if(type==0) {
            var blockLen, cSum;

            // Stored 
            byteAlign();
            blockLen = readByte();
            blockLen |= (readByte()<<8);

            cSum = readByte();
            cSum |= (readByte()<<8);

            if(((blockLen ^ ~cSum) & 0xffff)) {
                document.write("BlockLen checksum mismatch\n");
            }
            while(blockLen--) {
                c = readByte();
                addBuffer(c);
            }
        } else if(type==1) {
            var j;

            /* Fixed Huffman tables -- fixed decode routine */
            while(1) {
            /*
                256    0000000        0
                :   :     :
                279    0010111        23
                0   00110000    48
                :    :      :
                143    10111111    191
                280 11000000    192
                :    :      :
                287 11000111    199
                144    110010000    400
                :    :       :
                255    111111111    511
    
                Note the bit order!
                */

            j = (bitReverse[readBits(7)]>>1);
            if(j > 23) {
                j = (j<<1) | readBit();    /* 48..255 */

                if(j > 199) {    /* 200..255 */
                    j -= 128;    /*  72..127 */
                    j = (j<<1) | readBit();        /* 144..255 << */
                } else {        /*  48..199 */
                    j -= 48;    /*   0..151 */
                    if(j > 143) {
                        j = j+136;    /* 280..287 << */
                        /*   0..143 << */
                    }
                }
            } else {    /*   0..23 */
                j += 256;    /* 256..279 << */
            }
            if(j < 256) {
                addBuffer(j);
                //document.write("out:"+String.fromCharCode(j));
                /*fprintf(errfp, "@%d %02x\n", SIZE, j);*/
            } else if(j == 256) {
                /* EOF */
                break;
            } else {
                var len, dist;

                j -= 256 + 1;    /* bytes + EOF */
                len = readBits(cplext[j]) + cplens[j];

                j = bitReverse[readBits(5)]>>3;
                if(cpdext[j] > 8) {
                    dist = readBits(8);
                    dist |= (readBits(cpdext[j]-8)<<8);
                } else {
                    dist = readBits(cpdext[j]);
                }
                dist += cpdist[j];

                /*fprintf(errfp, "@%d (l%02x,d%04x)\n", SIZE, len, dist);*/
                for(j=0;j<len;j++) {
                    var c = buf32k[(bIdx - dist) & 0x7fff];
                    addBuffer(c);
                }
            }
            } // while
        } else if(type==2) {
            var j, n, literalCodes, distCodes, lenCodes;
            var ll = new Array(288+32);    // "static" just to preserve stack
    
            // Dynamic Huffman tables 
    
            literalCodes = 257 + readBits(5);
            distCodes = 1 + readBits(5);
            lenCodes = 4 + readBits(4);
            //document.write("<br>param: "+literalCodes+" "+distCodes+" "+lenCodes+"<br>");
            for(j=0; j<19; j++) {
                ll[j] = 0;
            }
    
            // Get the decode tree code lengths
    
            //document.write("<br>");
            for(j=0; j<lenCodes; j++) {
                ll[border[j]] = readBits(3);
                //document.write(ll[border[j]]+" ");
            }
            //fprintf(errfp, "\n");
            //document.write('<br>ll:'+ll);
            len = distanceTree.length;
            for (i=0; i<len; i++)
                distanceTree[i]=new HufNode();
            if(CreateTree(distanceTree, 19, ll, 0)) {
                flushBuffer();
                return 1;
            }
            if (debug){
            	document.write("<br>distanceTree");
            	for(var a=0;a<distanceTree.length;a++){
                	document.write("<br>"+distanceTree[a].b0+" "+distanceTree[a].b1+" "+distanceTree[a].jump+" "+distanceTree[a].jumppos);
                	/*if (distanceTree[a].jumppos!=-1)
                    	document.write(" "+distanceTree[a].jump.b0+" "+distanceTree[a].jump.b1);
                	*/
            	}
            }
            //document.write('<BR>tree created');
    
            //read in literal and distance code lengths
            n = literalCodes + distCodes;
            i = 0;
            var z=-1;
            if (debug)
            	document.write("<br>n="+n+" bits: "+bits+"<br>");
            while(i < n) {
                z++;
                j = DecodeValue(distanceTree);
                if (debug)
                	document.write("<br>"+z+" i:"+i+" decode: "+j+"    bits "+bits+"<br>");
                if(j<16) {    // length of code in bits (0..15)
                       ll[i++] = j;
                } else if(j==16) {    // repeat last length 3 to 6 times 
                       var l;
                    j = 3 + readBits(2);
                    if(i+j > n) {
                        flushBuffer();
                        return 1;
                    }
                    l = i ? ll[i-1] : 0;
                    while(j--) {
                        ll[i++] = l;
                    }
                } else {
                    if(j==17) {        // 3 to 10 zero length codes
                        j = 3 + readBits(3);
                    } else {        // j == 18: 11 to 138 zero length codes 
                        j = 11 + readBits(7);
                    }
                    if(i+j > n) {
                        flushBuffer();
                        return 1;
                    }
                    while(j--) {
                        ll[i++] = 0;
                    }
                }
            }
            /*for(j=0; j<literalCodes+distCodes; j++) {
                //fprintf(errfp, "%d ", ll[j]);
                if ((j&7)==7)
                    fprintf(errfp, "\n");
            }
            fprintf(errfp, "\n");*/
            // Can overwrite tree decode tree as it is not used anymore
            len = literalTree.length;
            for (i=0; i<len; i++)
                literalTree[i]=new HufNode();
            if(CreateTree(literalTree, literalCodes, ll, 0)) {
                flushBuffer();
                return 1;
            }
            len = literalTree.length;
            for (i=0; i<len; i++)
                distanceTree[i]=new HufNode();
            var ll2 = new Array();
            for (i=literalCodes; i <ll.length; i++){
                ll2[i-literalCodes]=ll[i];
            }    
            if(CreateTree(distanceTree, distCodes, ll2, 0)) {
                flushBuffer();
                return 1;
            }
            if (debug)
           		document.write("<br>literalTree");
            while(1) {
                j = DecodeValue(literalTree);
                if(j >= 256) {        // In C64: if carry set
                    var len, dist;
                    j -= 256;
                    if(j == 0) {
                        // EOF
                        break;
                    }
                    j--;
                    len = readBits(cplext[j]) + cplens[j];
    
                    j = DecodeValue(distanceTree);
                    if(cpdext[j] > 8) {
                        dist = readBits(8);
                        dist |= (readBits(cpdext[j]-8)<<8);
                    } else {
                        dist = readBits(cpdext[j]);
                    }
                    dist += cpdist[j];
                    while(len--) {
                        var c = buf32k[(bIdx - dist) & 0x7fff];
                        addBuffer(c);
                    }
                } else {
                    addBuffer(j);
                }
            }
        }
    } while(!last);
    flushBuffer();

    byteAlign();
    return 0;
};

JXG.Util.Unzip.prototype.unzipFile = function(name) {
    var i;
	this.unzip();
	//alert(unzipped[0][1]);
	for (i=0;i<unzipped.length;i++){
		if(unzipped[i][1]==name) {
			return unzipped[i][0];
		}
	}
	
  };
    
    
JXG.Util.Unzip.prototype.unzip = function() {
	//convertToByteArray(input);
	if (debug)
		alert(bA);
	/*for (i=0;i<bA.length*8;i++){
		document.write(readBit());
		if ((i+1)%8==0)
			document.write(" ");
	}*/
	/*for (i=0;i<bA.length;i++){
		document.write(readByte()+" ");
		if ((i+1)%8==0)
			document.write(" ");
	}
	for (i=0;i<bA.length;i++){
		document.write(bA[i]+" ");
		if ((i+1)%16==0)
			document.write("<br>");
	}	
	*/
	//alert(bA);
	nextFile();
	return unzipped;
  };
    
 function nextFile(){
 	if (debug)
 		alert("NEXTFILE");
 	outputArr = [];
 	var tmp = [];
 	modeZIP = false;
	tmp[0] = readByte();
	tmp[1] = readByte();
	if (debug)
		alert("type: "+tmp[0]+" "+tmp[1]);
	if (tmp[0] == parseInt("78",16) && tmp[1] == parseInt("da",16)){ //GZIP
		if (debug)
			alert("GEONExT-GZIP");
		DeflateLoop();
		if (debug)
			alert(outputArr.join(''));
		unzipped[files] = new Array(2);
    	unzipped[files][0] = outputArr.join('');
    	unzipped[files][1] = "geonext.gxt";
    	files++;
	}
	if (tmp[0] == parseInt("1f",16) && tmp[1] == parseInt("8b",16)){ //GZIP
		if (debug)
			alert("GZIP");
		//DeflateLoop();
		skipdir();
		if (debug)
			alert(outputArr.join(''));
		unzipped[files] = new Array(2);
    	unzipped[files][0] = outputArr.join('');
    	unzipped[files][1] = "file";
    	files++;
	}
	if (tmp[0] == parseInt("50",16) && tmp[1] == parseInt("4b",16)){ //ZIP
		modeZIP = true;
		tmp[2] = readByte();
		tmp[3] = readByte();
		if (tmp[2] == parseInt("3",16) && tmp[3] == parseInt("4",16)){
			//MODE_ZIP
			tmp[0] = readByte();
			tmp[1] = readByte();
			if (debug)
				alert("ZIP-Version: "+tmp[1]+" "+tmp[0]/10+"."+tmp[0]%10);
			
			gpflags = readByte();
			gpflags |= (readByte()<<8);
			if (debug)
				alert("gpflags: "+gpflags);
			
			var method = readByte();
			method |= (readByte()<<8);
			if (debug)
				alert("method: "+method);
			
			readByte();
			readByte();
			readByte();
			readByte();
			
			var crc = readByte();
			crc |= (readByte()<<8);
			crc |= (readByte()<<16);
			crc |= (readByte()<<24);
			
			var compSize = readByte();
			compSize |= (readByte()<<8);
			compSize |= (readByte()<<16);
			compSize |= (readByte()<<24);
			
			var size = readByte();
			size |= (readByte()<<8);
			size |= (readByte()<<16);
			size |= (readByte()<<24);
			
			if (debug)
				alert("local CRC: "+crc+"\nlocal Size: "+size+"\nlocal CompSize: "+compSize);
			
			var filelen = readByte();
			filelen |= (readByte()<<8);
			
			var extralen = readByte();
			extralen |= (readByte()<<8);
			
			if (debug)
				alert("filelen "+filelen);
			i = 0;
			nameBuf = [];
			while (filelen--){ 
				var c = readByte();
				if (c == "/" | c ==":"){
					i = 0;
				} else if (i < NAMEMAX-1)
					nameBuf[i++] = String.fromCharCode(c);
			}
			if (debug)
				alert("nameBuf: "+nameBuf);
			
			//nameBuf[i] = "\0";
			if (!fileout)
				fileout = nameBuf;
			
			var i = 0;
			while (i < extralen){
				c = readByte();
				i++;
			}
				
			CRC = 0xffffffff;
			SIZE = 0;
			
			if (size = 0 && fileOut.charAt(fileout.length-1)=="/"){
				//skipdir
				if (debug)
					alert("skipdir");
			}
			if (method == 8){
				DeflateLoop();
				if (debug)
					alert(outputArr.join(''));
				unzipped[files] = new Array(2);
				unzipped[files][0] = outputArr.join('');
    			unzipped[files][1] = nameBuf.join('');
    			files++;
				//return outputArr.join('');
			}
			skipdir();
		}
	}
 };
	
function skipdir(){
    var crc, 
        tmp = [],
        compSize, size, os, i, c;
    
	if ((gpflags & 8)) {
		tmp[0] = readByte();
		tmp[1] = readByte();
		tmp[2] = readByte();
		tmp[3] = readByte();
		
		if (tmp[0] == parseInt("50",16) && 
            tmp[1] == parseInt("4b",16) && 
            tmp[2] == parseInt("07",16) && 
            tmp[3] == parseInt("08",16))
        {
            crc = readByte();
            crc |= (readByte()<<8);
            crc |= (readByte()<<16);
            crc |= (readByte()<<24);
		} else {
			crc = tmp[0] | (tmp[1]<<8) | (tmp[2]<<16) | (tmp[3]<<24);
		}
		
		compSize = readByte();
		compSize |= (readByte()<<8);
		compSize |= (readByte()<<16);
		compSize |= (readByte()<<24);
		
		size = readByte();
		size |= (readByte()<<8);
		size |= (readByte()<<16);
		size |= (readByte()<<24);
		
		if (debug)
			alert("CRC:");
	}

	if (modeZIP)
		nextFile();
	
	tmp[0] = readByte();
	if (tmp[0] != 8) {
		if (debug)
			alert("Unknown compression method!");
        return 0;	
	}
	
	gpflags = readByte();
	if (debug){
		if ((gpflags & ~(parseInt("1f",16))))
			alert("Unknown flags set!");
	}
	
	readByte();
	readByte();
	readByte();
	readByte();
	
	readByte();
	os = readByte();
	
	if ((gpflags & 4)){
		tmp[0] = readByte();
		tmp[2] = readByte();
		len = tmp[0] + 256*tmp[1];
		if (debug)
			alert("Extra field size: "+len);
		for (i=0;i<len;i++)
			readByte();
	}
	
	if ((gpflags & 8)){
		i=0;
		nameBuf=[];
		while (c=readByte()){
			if(c == "7" || c == ":")
				i=0;
			if (i<NAMEMAX-1)
				nameBuf[i++] = c;
		}
		//nameBuf[i] = "\0";
		if (debug)
			alert("original file name: "+nameBuf);
	}
		
	if ((gpflags & 16)){
		while (c=readByte()){
			//FILE COMMENT
		}
	}
	
	if ((gpflags & 2)){
		readByte();
		readByte();
	}
	
	DeflateLoop();
	
	crc = readByte();
	crc |= (readByte()<<8);
	crc |= (readByte()<<16);
	crc |= (readByte()<<24);
	
	size = readByte();
	size |= (readByte()<<8);
	size |= (readByte()<<16);
	size |= (readByte()<<24);
	
	if (modeZIP)
		nextFile();
	
};

};

/**
*  Base64 encoding / decoding
*  @see <a href="http://www.webtoolkit.info/">http://www.webtoolkit.info/</A>
*/
JXG.Util.Base64 = {

    // private property
    _keyStr : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",

    // public method for encoding
    encode : function (input) {
        var output = [],
            chr1, chr2, chr3, enc1, enc2, enc3, enc4,
            i = 0;

        input = JXG.Util.Base64._utf8_encode(input);

        while (i < input.length) {

            chr1 = input.charCodeAt(i++);
            chr2 = input.charCodeAt(i++);
            chr3 = input.charCodeAt(i++);

            enc1 = chr1 >> 2;
            enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
            enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
            enc4 = chr3 & 63;

            if (isNaN(chr2)) {
                enc3 = enc4 = 64;
            } else if (isNaN(chr3)) {
                enc4 = 64;
            }

            output.push([this._keyStr.charAt(enc1),
                         this._keyStr.charAt(enc2),
                         this._keyStr.charAt(enc3),
                         this._keyStr.charAt(enc4)].join(''));
        }

        return output.join('');
    },

    // public method for decoding
    decode : function (input, utf8) {
        var output = [],
            chr1, chr2, chr3,
            enc1, enc2, enc3, enc4,
            i = 0;

        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

        while (i < input.length) {

            enc1 = this._keyStr.indexOf(input.charAt(i++));
            enc2 = this._keyStr.indexOf(input.charAt(i++));
            enc3 = this._keyStr.indexOf(input.charAt(i++));
            enc4 = this._keyStr.indexOf(input.charAt(i++));

            chr1 = (enc1 << 2) | (enc2 >> 4);
            chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
            chr3 = ((enc3 & 3) << 6) | enc4;

            output.push(String.fromCharCode(chr1));

            if (enc3 != 64) {
                output.push(String.fromCharCode(chr2));
            }
            if (enc4 != 64) {
                output.push(String.fromCharCode(chr3));
            }
        }
        
        output = output.join(''); 
        
        if (utf8) {
            output = JXG.Util.Base64._utf8_decode(output);
        }
        return output;

    },

    // private method for UTF-8 encoding
    _utf8_encode : function (string) {
        string = string.replace(/\r\n/g,"\n");
        var utftext = "";

        for (var n = 0; n < string.length; n++) {

            var c = string.charCodeAt(n);

            if (c < 128) {
                utftext += String.fromCharCode(c);
            }
            else if((c > 127) && (c < 2048)) {
                utftext += String.fromCharCode((c >> 6) | 192);
                utftext += String.fromCharCode((c & 63) | 128);
            }
            else {
                utftext += String.fromCharCode((c >> 12) | 224);
                utftext += String.fromCharCode(((c >> 6) & 63) | 128);
                utftext += String.fromCharCode((c & 63) | 128);
            }

        }

        return utftext;
    },

    // private method for UTF-8 decoding
    _utf8_decode : function (utftext) {
        var string = [],
            i = 0,
            c = 0, c2 = 0, c3 = 0;

        while ( i < utftext.length ) {
            c = utftext.charCodeAt(i);
            if (c < 128) {
                string.push(String.fromCharCode(c));
                i++;
            }
            else if((c > 191) && (c < 224)) {
                c2 = utftext.charCodeAt(i+1);
                string.push(String.fromCharCode(((c & 31) << 6) | (c2 & 63)));
                i += 2;
            }
            else {
                c2 = utftext.charCodeAt(i+1);
                c3 = utftext.charCodeAt(i+2);
                string.push(String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63)));
                i += 3;
            }
        }
        return string.join('');
    },
    
    _destrip: function (stripped, wrap){
        var lines = [], lineno, i,
            destripped = [];
        
        if (wrap==null) 
            wrap = 76;
            
        stripped.replace(/ /g, "");
        lineno = stripped.length / wrap;
        for (i = 0; i < lineno; i++)
            lines[i]=stripped.substr(i * wrap, wrap);
        if (lineno != stripped.length / wrap)
            lines[lines.length]=stripped.substr(lineno * wrap, stripped.length-(lineno * wrap));
            
        for (i = 0; i < lines.length; i++)
            destripped.push(lines[i]);
        return destripped.join('\n');
    },
    
    decodeAsArray: function (input){
        var dec = this.decode(input),
            ar = [], i;
        for (i=0;i<dec.length;i++){
            ar[i]=dec.charCodeAt(i);
        }
        return ar;
    },
    
    decodeGEONExT : function (input) {
        return decodeAsArray(destrip(input),false);
    }
};

/**
 * @private
 */
JXG.Util.asciiCharCodeAt = function(str,i){
	var c = str.charCodeAt(i);
	if (c>255){
    	switch (c) {
			case 8364: c=128;
	    	break;
	    	case 8218: c=130;
	    	break;
	    	case 402: c=131;
	    	break;
	    	case 8222: c=132;
	    	break;
	    	case 8230: c=133;
	    	break;
	    	case 8224: c=134;
	    	break;
	    	case 8225: c=135;
	    	break;
	    	case 710: c=136;
	    	break;
	    	case 8240: c=137;
	    	break;
	    	case 352: c=138;
	    	break;
	    	case 8249: c=139;
	    	break;
	    	case 338: c=140;
	    	break;
	    	case 381: c=142;
	    	break;
	    	case 8216: c=145;
	    	break;
	    	case 8217: c=146;
	    	break;
	    	case 8220: c=147;
	    	break;
	    	case 8221: c=148;
	    	break;
	    	case 8226: c=149;
	    	break;
	    	case 8211: c=150;
	    	break;
	    	case 8212: c=151;
	    	break;
	    	case 732: c=152;
	    	break;
	    	case 8482: c=153;
	    	break;
	    	case 353: c=154;
	    	break;
	    	case 8250: c=155;
	    	break;
	    	case 339: c=156;
	    	break;
	    	case 382: c=158;
	    	break;
	    	case 376: c=159;
	    	break;
	    	default:
	    	break;
	    }
	}
	return c;
};

/**
 * Decoding string into utf-8
 * @param {String} string to decode
 * @return {String} utf8 decoded string
 */
JXG.Util.utf8Decode = function(utftext) {
  var string = [];
  var i = 0;
  var c = 0, c1 = 0, c2 = 0;

  while ( i < utftext.length ) {
    c = utftext.charCodeAt(i);

    if (c < 128) {
      string.push(String.fromCharCode(c));
      i++;
    } else if((c > 191) && (c < 224)) {
      c2 = utftext.charCodeAt(i+1);
      string.push(String.fromCharCode(((c & 31) << 6) | (c2 & 63)));
      i += 2;
    } else {
      c2 = utftext.charCodeAt(i+1);
      c3 = utftext.charCodeAt(i+2);
      string.push(String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63)));
      i += 3;
    }
  };
  return string.join('');
};

// Added to exports for Cocos2d
module.exports = JXG;

}};
__resources__["/__builtin__/libs/Plist.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/**
 * XML Node types
 */
var ELEMENT_NODE                = 1,
    ATTRIBUTE_NODE              = 2,
    TEXT_NODE                   = 3,
    CDATA_SECTION_NODE          = 4,
    ENTITY_REFERENCE_NODE       = 5,
    ENTITY_NODE                 = 6,
    PROCESSING_INSTRUCTION_NODE = 7,
    COMMENT_NODE                = 8,
    DOCUMENT_NODE               = 9,
    DOCUMENT_TYPE_NODE          = 10,
    DOCUMENT_FRAGMENT_NODE      = 11,
    NOTATION_NODE               = 12;


var Plist = BObject.extend (/** @lends Plist# */{
    /**
     * The unserialized data inside the Plist file
     * @type Object
     */
    data: null,

    /**
     * An object representation of an XML Property List file
     *
     * @constructs
     * @extends BObject
     * @param {Options} opts Options
     * @config {String} [file] The path to a .plist file
     * @config {String} [data] The contents of a .plist file
     */
    init: function(opts) {
        var file = opts['file'],
            data = opts['data'];

        if (file && !data) {
            data = resource(file);
        }


        var parser = new DOMParser(),
            doc = parser.parseFromString(data, 'text/xml'),
            plist = doc.documentElement;

        if (plist.tagName != 'plist') {
            throw "Not a plist file";
        }


        // Get first real node
        var node = null;
        for (var i = 0, len = plist.childNodes.length; i < len; i++) {
            node = plist.childNodes[i];
            if (node.nodeType == ELEMENT_NODE) {
                break;
            }
        }

        this.set('data', this.parseNode_(node));
    },


    /**
     * @private
     * Parses an XML node inside the Plist file
     * @returns {Object/Array/String/Integer/Float} A JS representation of the node value
     */
    parseNode_: function(node) {
        var data = null;
        switch(node.tagName) {
        case 'dict':
            data = this.parseDict_(node); 
            break;
        case 'array':
            data = this.parseArray_(node); 
            break;
        case 'string':
            // FIXME - This needs to handle Firefox's 4KB nodeValue limit
            data = node.firstChild.nodeValue;
            break
        case 'false':
            data = false;
            break
        case 'true':
            data = true;
            break
        case 'real':
            data = parseFloat(node.firstChild.nodeValue);
            break
        case 'integer':
            data = parseInt(node.firstChild.nodeValue, 10);
            break
        }

        return data;
    },

    /**
     * @private
     * Parses a <dict> node in a plist file
     *
     * @param {XMLElement}
     * @returns {Object} A simple key/value JS Object representing the <dict>
     */
    parseDict_: function(node) {
        var data = {};

        var key = null;
        for (var i = 0, len = node.childNodes.length; i < len; i++) {
            var child = node.childNodes[i];
            if (child.nodeType != ELEMENT_NODE) {
                continue;
            }

            // Grab the key, next noe should be the value
            if (child.tagName == 'key') {
                key = child.firstChild.nodeValue;
            } else {
                // Parse the value node
                data[key] = this.parseNode_(child);
            }
        }


        return data;
    },

    /**
     * @private
     * Parses an <array> node in a plist file
     *
     * @param {XMLElement}
     * @returns {Array} A simple JS Array representing the <array>
     */
    parseArray_: function(node) {
        var data = [];

        for (var i = 0, len = node.childNodes.length; i < len; i++) {
            var child = node.childNodes[i];
            if (child.nodeType != ELEMENT_NODE) {
                continue;
            }

            data.push(this.parseNode_(child));
        }

        return data;
    }
});


exports.Plist = Plist;

}};
__resources__["/__builtin__/libs/qunit.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*
 * QUnit - A JavaScript Unit Testing Framework
 * 
 * http://docs.jquery.com/QUnit
 *
 * Copyright (c) 2011 John Resig, Jörn Zaefferer
 * Dual licensed under the MIT (MIT-LICENSE.txt)
 * or GPL (GPL-LICENSE.txt) licenses.
 */

(function(window) {

var defined = {
	setTimeout: typeof window.setTimeout !== "undefined",
	sessionStorage: (function() {
		try {
			return !!sessionStorage.getItem;
		} catch(e){
			return false;
		}
  })()
}

var testId = 0;

var Test = function(name, testName, expected, testEnvironmentArg, async, callback) {
	this.name = name;
	this.testName = testName;
	this.expected = expected;
	this.testEnvironmentArg = testEnvironmentArg;
	this.async = async;
	this.callback = callback;
	this.assertions = [];
};
Test.prototype = {
	init: function() {
		var tests = id("qunit-tests");
		if (tests) {
			var b = document.createElement("strong");
				b.innerHTML = "Running " + this.name;
			var li = document.createElement("li");
				li.appendChild( b );
				li.id = this.id = "test-output" + testId++;
			tests.appendChild( li );
		}
	},
	setup: function() {
		if (this.module != config.previousModule) {
			if ( config.previousModule ) {
				QUnit.moduleDone( {
					name: config.previousModule,
					failed: config.moduleStats.bad,
					passed: config.moduleStats.all - config.moduleStats.bad,
					total: config.moduleStats.all
				} );
			}
			config.previousModule = this.module;
			config.moduleStats = { all: 0, bad: 0 };
			QUnit.moduleStart( {
				name: this.module
			} );
		}

		config.current = this;
		this.testEnvironment = extend({
			setup: function() {},
			teardown: function() {}
		}, this.moduleTestEnvironment);
		if (this.testEnvironmentArg) {
			extend(this.testEnvironment, this.testEnvironmentArg);
		}

		QUnit.testStart( {
			name: this.testName
		} );

		// allow utility functions to access the current test environment
		// TODO why??
		QUnit.current_testEnvironment = this.testEnvironment;
		
		try {
			if ( !config.pollution ) {
				saveGlobal();
			}

			this.testEnvironment.setup.call(this.testEnvironment);
		} catch(e) {
			QUnit.ok( false, "Setup failed on " + this.testName + ": " + e.message );
		}
	},
	run: function() {
		if ( this.async ) {
			QUnit.stop();
		}

		if ( config.notrycatch ) {
			this.callback.call(this.testEnvironment);
			return;
		}
		try {
			this.callback.call(this.testEnvironment);
		} catch(e) {
			fail("Test " + this.testName + " died, exception and test follows", e, this.callback);
			QUnit.ok( false, "Died on test #" + (this.assertions.length + 1) + ": " + e.message + " - " + QUnit.jsDump.parse(e) );
			// else next test will carry the responsibility
			saveGlobal();

			// Restart the tests if they're blocking
			if ( config.blocking ) {
				start();
			}
		}
	},
	teardown: function() {
		try {
			checkPollution();
			this.testEnvironment.teardown.call(this.testEnvironment);
		} catch(e) {
			QUnit.ok( false, "Teardown failed on " + this.testName + ": " + e.message );
		}
	},
	finish: function() {
		if ( this.expected && this.expected != this.assertions.length ) {
			QUnit.ok( false, "Expected " + this.expected + " assertions, but " + this.assertions.length + " were run" );
		}
		
		var good = 0, bad = 0,
			tests = id("qunit-tests");

		config.stats.all += this.assertions.length;
		config.moduleStats.all += this.assertions.length;

		if ( tests ) {
			var ol  = document.createElement("ol");

			for ( var i = 0; i < this.assertions.length; i++ ) {
				var assertion = this.assertions[i];

				var li = document.createElement("li");
				li.className = assertion.result ? "pass" : "fail";
				li.innerHTML = assertion.message || (assertion.result ? "okay" : "failed");
				ol.appendChild( li );

				if ( assertion.result ) {
					good++;
				} else {
					bad++;
					config.stats.bad++;
					config.moduleStats.bad++;
				}
			}

			// store result when possible
			defined.sessionStorage && sessionStorage.setItem("qunit-" + this.testName, bad);

			if (bad == 0) {
				ol.style.display = "none";
			}

			var b = document.createElement("strong");
			b.innerHTML = this.name + " <b class='counts'>(<b class='failed'>" + bad + "</b>, <b class='passed'>" + good + "</b>, " + this.assertions.length + ")</b>";
			
			addEvent(b, "click", function() {
				var next = b.nextSibling, display = next.style.display;
				next.style.display = display === "none" ? "block" : "none";
			});
			
			addEvent(b, "dblclick", function(e) {
				var target = e && e.target ? e.target : window.event.srcElement;
				if ( target.nodeName.toLowerCase() == "span" || target.nodeName.toLowerCase() == "b" ) {
					target = target.parentNode;
				}
				if ( window.location && target.nodeName.toLowerCase() === "strong" ) {
					window.location.search = "?" + encodeURIComponent(getText([target]).replace(/\(.+\)$/, "").replace(/(^\s*|\s*$)/g, ""));
				}
			});

			var li = id(this.id);
			li.className = bad ? "fail" : "pass";
			li.style.display = resultDisplayStyle(!bad);
			li.removeChild( li.firstChild );
			li.appendChild( b );
			li.appendChild( ol );

		} else {
			for ( var i = 0; i < this.assertions.length; i++ ) {
				if ( !this.assertions[i].result ) {
					bad++;
					config.stats.bad++;
					config.moduleStats.bad++;
				}
			}
		}

		try {
			QUnit.reset();
		} catch(e) {
			fail("reset() failed, following Test " + this.testName + ", exception and reset fn follows", e, QUnit.reset);
		}

		QUnit.testDone( {
			name: this.testName,
			failed: bad,
			passed: this.assertions.length - bad,
			total: this.assertions.length
		} );
	},
	
	queue: function() {
		var test = this;
		synchronize(function() {
			test.init();
		});
		function run() {
			// each of these can by async
			synchronize(function() {
				test.setup();
			});
			synchronize(function() {
				test.run();
			});
			synchronize(function() {
				test.teardown();
			});
			synchronize(function() {
				test.finish();
			});
		}
		// defer when previous test run passed, if storage is available
		var bad = defined.sessionStorage && +sessionStorage.getItem("qunit-" + this.testName);
		if (bad) {
			run();
		} else {
			synchronize(run);
		};
	}
	
}

var QUnit = {

	// call on start of module test to prepend name to all tests
	module: function(name, testEnvironment) {
		config.currentModule = name;
		config.currentModuleTestEnviroment = testEnvironment;
	},

	asyncTest: function(testName, expected, callback) {
		if ( arguments.length === 2 ) {
			callback = expected;
			expected = 0;
		}

		QUnit.test(testName, expected, callback, true);
	},
	
	test: function(testName, expected, callback, async) {
		var name = '<span class="test-name">' + testName + '</span>', testEnvironmentArg;

		if ( arguments.length === 2 ) {
			callback = expected;
			expected = null;
		}
		// is 2nd argument a testEnvironment?
		if ( expected && typeof expected === 'object') {
			testEnvironmentArg =  expected;
			expected = null;
		}

		if ( config.currentModule ) {
			name = '<span class="module-name">' + config.currentModule + "</span>: " + name;
		}

		if ( !validTest(config.currentModule + ": " + testName) ) {
			return;
		}
		
		var test = new Test(name, testName, expected, testEnvironmentArg, async, callback);
		test.module = config.currentModule;
		test.moduleTestEnvironment = config.currentModuleTestEnviroment;
		test.queue();
	},
	
	/**
	 * Specify the number of expected assertions to gurantee that failed test (no assertions are run at all) don't slip through.
	 */
	expect: function(asserts) {
		config.current.expected = asserts;
	},

	/**
	 * Asserts true.
	 * @example ok( "asdfasdf".length > 5, "There must be at least 5 chars" );
	 */
	ok: function(a, msg) {
		a = !!a;
		var details = {
			result: a,
			message: msg
		};
		msg = escapeHtml(msg);
		QUnit.log(details);
		config.current.assertions.push({
			result: a,
			message: msg
		});
	},

	/**
	 * Checks that the first two arguments are equal, with an optional message.
	 * Prints out both actual and expected values.
	 *
	 * Prefered to ok( actual == expected, message )
	 *
	 * @example equal( format("Received {0} bytes.", 2), "Received 2 bytes." );
	 *
	 * @param Object actual
	 * @param Object expected
	 * @param String message (optional)
	 */
	equal: function(actual, expected, message) {
		QUnit.push(expected == actual, actual, expected, message);
	},

	notEqual: function(actual, expected, message) {
		QUnit.push(expected != actual, actual, expected, message);
	},
	
	deepEqual: function(actual, expected, message) {
		QUnit.push(QUnit.equiv(actual, expected), actual, expected, message);
	},

	notDeepEqual: function(actual, expected, message) {
		QUnit.push(!QUnit.equiv(actual, expected), actual, expected, message);
	},

	strictEqual: function(actual, expected, message) {
		QUnit.push(expected === actual, actual, expected, message);
	},

	notStrictEqual: function(actual, expected, message) {
		QUnit.push(expected !== actual, actual, expected, message);
	},

	raises: function(block, expected, message) {
		var actual, ok = false;
	
		if (typeof expected === 'string') {
			message = expected;
			expected = null;
		}
	
		try {
			block();
		} catch (e) {
			actual = e;
		}
	
		if (actual) {
			// we don't want to validate thrown error
			if (!expected) {
				ok = true;
			// expected is a regexp	
			} else if (QUnit.objectType(expected) === "regexp") {
				ok = expected.test(actual);
			// expected is a constructor	
			} else if (actual instanceof expected) {
				ok = true;
			// expected is a validation function which returns true is validation passed	
			} else if (expected.call({}, actual) === true) {
				ok = true;
			}
		}
			
		QUnit.ok(ok, message);
	},

	start: function() {
		config.semaphore--;
		if (config.semaphore > 0) {
			// don't start until equal number of stop-calls
			return;
		}
		if (config.semaphore < 0) {
			// ignore if start is called more often then stop
			config.semaphore = 0;
		}
		// A slight delay, to avoid any current callbacks
		if ( defined.setTimeout ) {
			window.setTimeout(function() {
				if ( config.timeout ) {
					clearTimeout(config.timeout);
				}

				config.blocking = false;
				process();
			}, 13);
		} else {
			config.blocking = false;
			process();
		}
	},
	
	stop: function(timeout) {
		config.semaphore++;
		config.blocking = true;

		if ( timeout && defined.setTimeout ) {
			clearTimeout(config.timeout);
			config.timeout = window.setTimeout(function() {
				QUnit.ok( false, "Test timed out" );
				QUnit.start();
			}, timeout);
		}
	}

};

// Backwards compatibility, deprecated
QUnit.equals = QUnit.equal;
QUnit.same = QUnit.deepEqual;

// Maintain internal state
var config = {
	// The queue of tests to run
	queue: [],

	// block until document ready
	blocking: true
};

// Load paramaters
(function() {
	var location = window.location || { search: "", protocol: "file:" },
		GETParams = location.search.slice(1).split('&');

	for ( var i = 0; i < GETParams.length; i++ ) {
		GETParams[i] = decodeURIComponent( GETParams[i] );
		if ( GETParams[i] === "noglobals" ) {
			GETParams.splice( i, 1 );
			i--;
			config.noglobals = true;
		} else if ( GETParams[i] === "notrycatch" ) {
			GETParams.splice( i, 1 );
			i--;
			config.notrycatch = true;
		} else if ( GETParams[i].search('=') > -1 ) {
			GETParams.splice( i, 1 );
			i--;
		}
	}
	
	// restrict modules/tests by get parameters
	config.filters = GETParams;
	
	// Figure out if we're running the tests from a server or not
	QUnit.isLocal = !!(location.protocol === 'file:');
})();

// Expose the API as global variables, unless an 'exports'
// object exists, in that case we assume we're in CommonJS
if ( typeof exports === "undefined" || typeof require === "undefined" ) {
	extend(window, QUnit);
	window.QUnit = QUnit;
} else {
	extend(exports, QUnit);
	exports.QUnit = QUnit;
}

// define these after exposing globals to keep them in these QUnit namespace only
extend(QUnit, {
	config: config,

	// Initialize the configuration options
	init: function() {
		extend(config, {
			stats: { all: 0, bad: 0 },
			moduleStats: { all: 0, bad: 0 },
			started: +new Date,
			updateRate: 1000,
			blocking: false,
			autostart: true,
			autorun: false,
			filters: [],
			queue: [],
			semaphore: 0
		});

		var tests = id("qunit-tests"),
			banner = id("qunit-banner"),
			result = id("qunit-testresult");

		if ( tests ) {
			tests.innerHTML = "";
		}

		if ( banner ) {
			banner.className = "";
		}

		if ( result ) {
			result.parentNode.removeChild( result );
		}
	},
	
	/**
	 * Resets the test setup. Useful for tests that modify the DOM.
	 * 
	 * If jQuery is available, uses jQuery's html(), otherwise just innerHTML.
	 */
	reset: function() {
		if ( window.jQuery ) {
			jQuery( "#main, #qunit-fixture" ).html( config.fixture );
		} else {
			var main = id( 'main' ) || id( 'qunit-fixture' );
			if ( main ) {
				main.innerHTML = config.fixture;
			}
		}
	},
	
	/**
	 * Trigger an event on an element.
	 *
	 * @example triggerEvent( document.body, "click" );
	 *
	 * @param DOMElement elem
	 * @param String type
	 */
	triggerEvent: function( elem, type, event ) {
		if ( document.createEvent ) {
			event = document.createEvent("MouseEvents");
			event.initMouseEvent(type, true, true, elem.ownerDocument.defaultView,
				0, 0, 0, 0, 0, false, false, false, false, 0, null);
			elem.dispatchEvent( event );

		} else if ( elem.fireEvent ) {
			elem.fireEvent("on"+type);
		}
	},
	
	// Safe object type checking
	is: function( type, obj ) {
		return QUnit.objectType( obj ) == type;
	},
	
	objectType: function( obj ) {
		if (typeof obj === "undefined") {
				return "undefined";

		// consider: typeof null === object
		}
		if (obj === null) {
				return "null";
		}

		var type = Object.prototype.toString.call( obj )
			.match(/^\[object\s(.*)\]$/)[1] || '';

		switch (type) {
				case 'Number':
						if (isNaN(obj)) {
								return "nan";
						} else {
								return "number";
						}
				case 'String':
				case 'Boolean':
				case 'Array':
				case 'Date':
				case 'RegExp':
				case 'Function':
						return type.toLowerCase();
		}
		if (typeof obj === "object") {
				return "object";
		}
		return undefined;
	},
	
	push: function(result, actual, expected, message) {
		var details = {
			result: result,
			message: message,
			actual: actual,
			expected: expected
		};
		
		message = escapeHtml(message) || (result ? "okay" : "failed");
		message = '<span class="test-message">' + message + "</span>";
		expected = escapeHtml(QUnit.jsDump.parse(expected));
		actual = escapeHtml(QUnit.jsDump.parse(actual));
		var output = message + '<table><tr class="test-expected"><th>Expected: </th><td><pre>' + expected + '</pre></td></tr>';
		if (actual != expected) {
			output += '<tr class="test-actual"><th>Result: </th><td><pre>' + actual + '</pre></td></tr>';
			output += '<tr class="test-diff"><th>Diff: </th><td><pre>' + QUnit.diff(expected, actual) +'</pre></td></tr>';
		}
		if (!result) {
			var source = sourceFromStacktrace();
			if (source) {
				details.source = source;
				output += '<tr class="test-source"><th>Source: </th><td><pre>' + source +'</pre></td></tr>';
			}
		}
		output += "</table>";
		
		QUnit.log(details);
		
		config.current.assertions.push({
			result: !!result,
			message: output
		});
	},
	
	// Logging callbacks; all receive a single argument with the listed properties
	// run test/logs.html for any related changes
	begin: function() {},
	// done: { failed, passed, total, runtime }
	done: function() {},
	// log: { result, actual, expected, message }
	log: function() {},
	// testStart: { name }
	testStart: function() {},
	// testDone: { name, failed, passed, total }
	testDone: function() {},
	// moduleStart: { name }
	moduleStart: function() {},
	// moduleDone: { name, failed, passed, total }
	moduleDone: function() {}
});

if ( typeof document === "undefined" || document.readyState === "complete" ) {
	config.autorun = true;
}

addEvent(window, "load", function() {
	QUnit.begin({});
	
	// Initialize the config, saving the execution queue
	var oldconfig = extend({}, config);
	QUnit.init();
	extend(config, oldconfig);

	config.blocking = false;

	var userAgent = id("qunit-userAgent");
	if ( userAgent ) {
		userAgent.innerHTML = navigator.userAgent;
	}
	var banner = id("qunit-header");
	if ( banner ) {
		var paramsIndex = location.href.lastIndexOf(location.search);
		if ( paramsIndex > -1 ) {
			var mainPageLocation = location.href.slice(0, paramsIndex);
			if ( mainPageLocation == location.href ) {
				banner.innerHTML = '<a href=""> ' + banner.innerHTML + '</a> ';
			} else {
				var testName = decodeURIComponent(location.search.slice(1));
				banner.innerHTML = '<a href="' + mainPageLocation + '">' + banner.innerHTML + '</a> &#8250; <a href="">' + testName + '</a>';
			}
		}
	}
	
	var toolbar = id("qunit-testrunner-toolbar");
	if ( toolbar ) {
		var filter = document.createElement("input");
		filter.type = "checkbox";
		filter.id = "qunit-filter-pass";
		addEvent( filter, "click", function() {
			var li = document.getElementsByTagName("li");
			for ( var i = 0; i < li.length; i++ ) {
				if ( li[i].className.indexOf("pass") > -1 ) {
					li[i].style.display = filter.checked ? "none" : "";
				}
			}
			if ( defined.sessionStorage ) {
				sessionStorage.setItem("qunit-filter-passed-tests", filter.checked ? "true" : "");
			}
		});
		if ( defined.sessionStorage && sessionStorage.getItem("qunit-filter-passed-tests") ) {
			filter.checked = true;
		}
		toolbar.appendChild( filter );

		var label = document.createElement("label");
		label.setAttribute("for", "qunit-filter-pass");
		label.innerHTML = "Hide passed tests";
		toolbar.appendChild( label );
	}

	var main = id('main') || id('qunit-fixture');
	if ( main ) {
		config.fixture = main.innerHTML;
	}

	if (config.autostart) {
		QUnit.start();
	}
});

function done() {
	config.autorun = true;

	// Log the last module results
	if ( config.currentModule ) {
		QUnit.moduleDone( {
			name: config.currentModule,
			failed: config.moduleStats.bad,
			passed: config.moduleStats.all - config.moduleStats.bad,
			total: config.moduleStats.all
		} );
	}

	var banner = id("qunit-banner"),
		tests = id("qunit-tests"),
		runtime = +new Date - config.started,
		passed = config.stats.all - config.stats.bad,
		html = [
			'Tests completed in ',
			runtime,
			' milliseconds.<br/>',
			'<span class="passed">',
			passed,
			'</span> tests of <span class="total">',
			config.stats.all,
			'</span> passed, <span class="failed">',
			config.stats.bad,
			'</span> failed.'
		].join('');

	if ( banner ) {
		banner.className = (config.stats.bad ? "qunit-fail" : "qunit-pass");
	}

	if ( tests ) {	
		var result = id("qunit-testresult");

		if ( !result ) {
			result = document.createElement("p");
			result.id = "qunit-testresult";
			result.className = "result";
			tests.parentNode.insertBefore( result, tests.nextSibling );
		}

		result.innerHTML = html;
	}

	QUnit.done( {
		failed: config.stats.bad,
		passed: passed, 
		total: config.stats.all,
		runtime: runtime
	} );
}

function validTest( name ) {
	var i = config.filters.length,
		run = false;

	if ( !i ) {
		return true;
	}
	
	while ( i-- ) {
		var filter = config.filters[i],
			not = filter.charAt(0) == '!';

		if ( not ) {
			filter = filter.slice(1);
		}

		if ( name.indexOf(filter) !== -1 ) {
			return !not;
		}

		if ( not ) {
			run = true;
		}
	}

	return run;
}

// so far supports only Firefox, Chrome and Opera (buggy)
// could be extended in the future to use something like https://github.com/csnover/TraceKit
function sourceFromStacktrace() {
	try {
		throw new Error();
	} catch ( e ) {
		if (e.stacktrace) {
			// Opera
			return e.stacktrace.split("\n")[6];
		} else if (e.stack) {
			// Firefox, Chrome
			return e.stack.split("\n")[4];
		}
	}
}

function resultDisplayStyle(passed) {
	return passed && id("qunit-filter-pass") && id("qunit-filter-pass").checked ? 'none' : '';
}

function escapeHtml(s) {
	if (!s) {
		return "";
	}
	s = s + "";
	return s.replace(/[\&"<>\\]/g, function(s) {
		switch(s) {
			case "&": return "&amp;";
			case "\\": return "\\\\";
			case '"': return '\"';
			case "<": return "&lt;";
			case ">": return "&gt;";
			default: return s;
		}
	});
}

function synchronize( callback ) {
	config.queue.push( callback );

	if ( config.autorun && !config.blocking ) {
		process();
	}
}

function process() {
	var start = (new Date()).getTime();

	while ( config.queue.length && !config.blocking ) {
		if ( config.updateRate <= 0 || (((new Date()).getTime() - start) < config.updateRate) ) {
			config.queue.shift()();
		} else {
			window.setTimeout( process, 13 );
			break;
		}
	}
  if (!config.blocking && !config.queue.length) {
    done();
  }
}

function saveGlobal() {
	config.pollution = [];
	
	if ( config.noglobals ) {
		for ( var key in window ) {
			config.pollution.push( key );
		}
	}
}

function checkPollution( name ) {
	var old = config.pollution;
	saveGlobal();
	
	var newGlobals = diff( old, config.pollution );
	if ( newGlobals.length > 0 ) {
		ok( false, "Introduced global variable(s): " + newGlobals.join(", ") );
		config.current.expected++;
	}

	var deletedGlobals = diff( config.pollution, old );
	if ( deletedGlobals.length > 0 ) {
		ok( false, "Deleted global variable(s): " + deletedGlobals.join(", ") );
		config.current.expected++;
	}
}

// returns a new Array with the elements that are in a but not in b
function diff( a, b ) {
	var result = a.slice();
	for ( var i = 0; i < result.length; i++ ) {
		for ( var j = 0; j < b.length; j++ ) {
			if ( result[i] === b[j] ) {
				result.splice(i, 1);
				i--;
				break;
			}
		}
	}
	return result;
}

function fail(message, exception, callback) {
	if ( typeof console !== "undefined" && console.error && console.warn ) {
		console.error(message);
		console.error(exception);
		console.warn(callback.toString());

	} else if ( window.opera && opera.postError ) {
		opera.postError(message, exception, callback.toString);
	}
}

function extend(a, b) {
	for ( var prop in b ) {
		a[prop] = b[prop];
	}

	return a;
}

function addEvent(elem, type, fn) {
	if ( elem.addEventListener ) {
		elem.addEventListener( type, fn, false );
	} else if ( elem.attachEvent ) {
		elem.attachEvent( "on" + type, fn );
	} else {
		fn();
	}
}

function id(name) {
	return !!(typeof document !== "undefined" && document && document.getElementById) &&
		document.getElementById( name );
}

// Test for equality any JavaScript type.
// Discussions and reference: http://philrathe.com/articles/equiv
// Test suites: http://philrathe.com/tests/equiv
// Author: Philippe Rathé <prathe@gmail.com>
QUnit.equiv = function () {

    var innerEquiv; // the real equiv function
    var callers = []; // stack to decide between skip/abort functions
    var parents = []; // stack to avoiding loops from circular referencing

    // Call the o related callback with the given arguments.
    function bindCallbacks(o, callbacks, args) {
        var prop = QUnit.objectType(o);
        if (prop) {
            if (QUnit.objectType(callbacks[prop]) === "function") {
                return callbacks[prop].apply(callbacks, args);
            } else {
                return callbacks[prop]; // or undefined
            }
        }
    }
    
    var callbacks = function () {

        // for string, boolean, number and null
        function useStrictEquality(b, a) {
            if (b instanceof a.constructor || a instanceof b.constructor) {
                // to catch short annotaion VS 'new' annotation of a declaration
                // e.g. var i = 1;
                //      var j = new Number(1);
                return a == b;
            } else {
                return a === b;
            }
        }

        return {
            "string": useStrictEquality,
            "boolean": useStrictEquality,
            "number": useStrictEquality,
            "null": useStrictEquality,
            "undefined": useStrictEquality,

            "nan": function (b) {
                return isNaN(b);
            },

            "date": function (b, a) {
                return QUnit.objectType(b) === "date" && a.valueOf() === b.valueOf();
            },

            "regexp": function (b, a) {
                return QUnit.objectType(b) === "regexp" &&
                    a.source === b.source && // the regex itself
                    a.global === b.global && // and its modifers (gmi) ...
                    a.ignoreCase === b.ignoreCase &&
                    a.multiline === b.multiline;
            },

            // - skip when the property is a method of an instance (OOP)
            // - abort otherwise,
            //   initial === would have catch identical references anyway
            "function": function () {
                var caller = callers[callers.length - 1];
                return caller !== Object &&
                        typeof caller !== "undefined";
            },

            "array": function (b, a) {
                var i, j, loop;
                var len;

                // b could be an object literal here
                if ( ! (QUnit.objectType(b) === "array")) {
                    return false;
                }   
                
                len = a.length;
                if (len !== b.length) { // safe and faster
                    return false;
                }
                
                //track reference to avoid circular references
                parents.push(a);
                for (i = 0; i < len; i++) {
                    loop = false;
                    for(j=0;j<parents.length;j++){
                        if(parents[j] === a[i]){
                            loop = true;//dont rewalk array
                        }
                    }
                    if (!loop && ! innerEquiv(a[i], b[i])) {
                        parents.pop();
                        return false;
                    }
                }
                parents.pop();
                return true;
            },

            "object": function (b, a) {
                var i, j, loop;
                var eq = true; // unless we can proove it
                var aProperties = [], bProperties = []; // collection of strings

                // comparing constructors is more strict than using instanceof
                if ( a.constructor !== b.constructor) {
                    return false;
                }

                // stack constructor before traversing properties
                callers.push(a.constructor);
                //track reference to avoid circular references
                parents.push(a);
                
                for (i in a) { // be strict: don't ensures hasOwnProperty and go deep
                    loop = false;
                    for(j=0;j<parents.length;j++){
                        if(parents[j] === a[i])
                            loop = true; //don't go down the same path twice
                    }
                    aProperties.push(i); // collect a's properties

                    if (!loop && ! innerEquiv(a[i], b[i])) {
                        eq = false;
                        break;
                    }
                }

                callers.pop(); // unstack, we are done
                parents.pop();

                for (i in b) {
                    bProperties.push(i); // collect b's properties
                }

                // Ensures identical properties name
                return eq && innerEquiv(aProperties.sort(), bProperties.sort());
            }
        };
    }();

    innerEquiv = function () { // can take multiple arguments
        var args = Array.prototype.slice.apply(arguments);
        if (args.length < 2) {
            return true; // end transition
        }

        return (function (a, b) {
            if (a === b) {
                return true; // catch the most you can
            } else if (a === null || b === null || typeof a === "undefined" || typeof b === "undefined" || QUnit.objectType(a) !== QUnit.objectType(b)) {
                return false; // don't lose time with error prone cases
            } else {
                return bindCallbacks(a, callbacks, [b, a]);
            }

        // apply transition with (1..n) arguments
        })(args[0], args[1]) && arguments.callee.apply(this, args.splice(1, args.length -1));
    };

    return innerEquiv;

}();

/**
 * jsDump
 * Copyright (c) 2008 Ariel Flesler - aflesler(at)gmail(dot)com | http://flesler.blogspot.com
 * Licensed under BSD (http://www.opensource.org/licenses/bsd-license.php)
 * Date: 5/15/2008
 * @projectDescription Advanced and extensible data dumping for Javascript.
 * @version 1.0.0
 * @author Ariel Flesler
 * @link {http://flesler.blogspot.com/2008/05/jsdump-pretty-dump-of-any-javascript.html}
 */
QUnit.jsDump = (function() {
	function quote( str ) {
		return '"' + str.toString().replace(/"/g, '\\"') + '"';
	};
	function literal( o ) {
		return o + '';	
	};
	function join( pre, arr, post ) {
		var s = jsDump.separator(),
			base = jsDump.indent(),
			inner = jsDump.indent(1);
		if ( arr.join )
			arr = arr.join( ',' + s + inner );
		if ( !arr )
			return pre + post;
		return [ pre, inner + arr, base + post ].join(s);
	};
	function array( arr ) {
		var i = arr.length,	ret = Array(i);					
		this.up();
		while ( i-- )
			ret[i] = this.parse( arr[i] );				
		this.down();
		return join( '[', ret, ']' );
	};
	
	var reName = /^function (\w+)/;
	
	var jsDump = {
		parse:function( obj, type ) { //type is used mostly internally, you can fix a (custom)type in advance
			var	parser = this.parsers[ type || this.typeOf(obj) ];
			type = typeof parser;			
			
			return type == 'function' ? parser.call( this, obj ) :
				   type == 'string' ? parser :
				   this.parsers.error;
		},
		typeOf:function( obj ) {
			var type;
			if ( obj === null ) {
				type = "null";
			} else if (typeof obj === "undefined") {
				type = "undefined";
			} else if (QUnit.is("RegExp", obj)) {
				type = "regexp";
			} else if (QUnit.is("Date", obj)) {
				type = "date";
			} else if (QUnit.is("Function", obj)) {
				type = "function";
			} else if (typeof obj.setInterval !== undefined && typeof obj.document !== "undefined" && typeof obj.nodeType === "undefined") {
				type = "window";
			} else if (obj.nodeType === 9) {
				type = "document";
			} else if (obj.nodeType) {
				type = "node";
			} else if (typeof obj === "object" && typeof obj.length === "number" && obj.length >= 0) {
				type = "array";
			} else {
				type = typeof obj;
			}
			return type;
		},
		separator:function() {
			return this.multiline ?	this.HTML ? '<br />' : '\n' : this.HTML ? '&nbsp;' : ' ';
		},
		indent:function( extra ) {// extra can be a number, shortcut for increasing-calling-decreasing
			if ( !this.multiline )
				return '';
			var chr = this.indentChar;
			if ( this.HTML )
				chr = chr.replace(/\t/g,'   ').replace(/ /g,'&nbsp;');
			return Array( this._depth_ + (extra||0) ).join(chr);
		},
		up:function( a ) {
			this._depth_ += a || 1;
		},
		down:function( a ) {
			this._depth_ -= a || 1;
		},
		setParser:function( name, parser ) {
			this.parsers[name] = parser;
		},
		// The next 3 are exposed so you can use them
		quote:quote, 
		literal:literal,
		join:join,
		//
		_depth_: 1,
		// This is the list of parsers, to modify them, use jsDump.setParser
		parsers:{
			window: '[Window]',
			document: '[Document]',
			error:'[ERROR]', //when no parser is found, shouldn't happen
			unknown: '[Unknown]',
			'null':'null',
			undefined:'undefined',
			'function':function( fn ) {
				var ret = 'function',
					name = 'name' in fn ? fn.name : (reName.exec(fn)||[])[1];//functions never have name in IE
				if ( name )
					ret += ' ' + name;
				ret += '(';
				
				ret = [ ret, QUnit.jsDump.parse( fn, 'functionArgs' ), '){'].join('');
				return join( ret, QUnit.jsDump.parse(fn,'functionCode'), '}' );
			},
			array: array,
			nodelist: array,
			arguments: array,
			object:function( map ) {
				var ret = [ ];
				QUnit.jsDump.up();
				for ( var key in map )
					ret.push( QUnit.jsDump.parse(key,'key') + ': ' + QUnit.jsDump.parse(map[key]) );
				QUnit.jsDump.down();
				return join( '{', ret, '}' );
			},
			node:function( node ) {
				var open = QUnit.jsDump.HTML ? '&lt;' : '<',
					close = QUnit.jsDump.HTML ? '&gt;' : '>';
					
				var tag = node.nodeName.toLowerCase(),
					ret = open + tag;
					
				for ( var a in QUnit.jsDump.DOMAttrs ) {
					var val = node[QUnit.jsDump.DOMAttrs[a]];
					if ( val )
						ret += ' ' + a + '=' + QUnit.jsDump.parse( val, 'attribute' );
				}
				return ret + close + open + '/' + tag + close;
			},
			functionArgs:function( fn ) {//function calls it internally, it's the arguments part of the function
				var l = fn.length;
				if ( !l ) return '';				
				
				var args = Array(l);
				while ( l-- )
					args[l] = String.fromCharCode(97+l);//97 is 'a'
				return ' ' + args.join(', ') + ' ';
			},
			key:quote, //object calls it internally, the key part of an item in a map
			functionCode:'[code]', //function calls it internally, it's the content of the function
			attribute:quote, //node calls it internally, it's an html attribute value
			string:quote,
			date:quote,
			regexp:literal, //regex
			number:literal,
			'boolean':literal
		},
		DOMAttrs:{//attributes to dump from nodes, name=>realName
			id:'id',
			name:'name',
			'class':'className'
		},
		HTML:false,//if true, entities are escaped ( <, >, \t, space and \n )
		indentChar:'  ',//indentation unit
		multiline:true //if true, items in a collection, are separated by a \n, else just a space.
	};

	return jsDump;
})();

// from Sizzle.js
function getText( elems ) {
	var ret = "", elem;

	for ( var i = 0; elems[i]; i++ ) {
		elem = elems[i];

		// Get the text from text nodes and CDATA nodes
		if ( elem.nodeType === 3 || elem.nodeType === 4 ) {
			ret += elem.nodeValue;

		// Traverse everything else, except comment nodes
		} else if ( elem.nodeType !== 8 ) {
			ret += getText( elem.childNodes );
		}
	}

	return ret;
};

/*
 * Javascript Diff Algorithm
 *  By John Resig (http://ejohn.org/)
 *  Modified by Chu Alan "sprite"
 *
 * Released under the MIT license.
 *
 * More Info:
 *  http://ejohn.org/projects/javascript-diff-algorithm/
 *  
 * Usage: QUnit.diff(expected, actual)
 * 
 * QUnit.diff("the quick brown fox jumped over", "the quick fox jumps over") == "the  quick <del>brown </del> fox <del>jumped </del><ins>jumps </ins> over"
 */
QUnit.diff = (function() {
	function diff(o, n){
		var ns = new Object();
		var os = new Object();
		
		for (var i = 0; i < n.length; i++) {
			if (ns[n[i]] == null) 
				ns[n[i]] = {
					rows: new Array(),
					o: null
				};
			ns[n[i]].rows.push(i);
		}
		
		for (var i = 0; i < o.length; i++) {
			if (os[o[i]] == null) 
				os[o[i]] = {
					rows: new Array(),
					n: null
				};
			os[o[i]].rows.push(i);
		}
		
		for (var i in ns) {
			if (ns[i].rows.length == 1 && typeof(os[i]) != "undefined" && os[i].rows.length == 1) {
				n[ns[i].rows[0]] = {
					text: n[ns[i].rows[0]],
					row: os[i].rows[0]
				};
				o[os[i].rows[0]] = {
					text: o[os[i].rows[0]],
					row: ns[i].rows[0]
				};
			}
		}
		
		for (var i = 0; i < n.length - 1; i++) {
			if (n[i].text != null && n[i + 1].text == null && n[i].row + 1 < o.length && o[n[i].row + 1].text == null &&
			n[i + 1] == o[n[i].row + 1]) {
				n[i + 1] = {
					text: n[i + 1],
					row: n[i].row + 1
				};
				o[n[i].row + 1] = {
					text: o[n[i].row + 1],
					row: i + 1
				};
			}
		}
		
		for (var i = n.length - 1; i > 0; i--) {
			if (n[i].text != null && n[i - 1].text == null && n[i].row > 0 && o[n[i].row - 1].text == null &&
			n[i - 1] == o[n[i].row - 1]) {
				n[i - 1] = {
					text: n[i - 1],
					row: n[i].row - 1
				};
				o[n[i].row - 1] = {
					text: o[n[i].row - 1],
					row: i - 1
				};
			}
		}
		
		return {
			o: o,
			n: n
		};
	}
	
	return function(o, n){
		o = o.replace(/\s+$/, '');
		n = n.replace(/\s+$/, '');
		var out = diff(o == "" ? [] : o.split(/\s+/), n == "" ? [] : n.split(/\s+/));

		var str = "";
		
		var oSpace = o.match(/\s+/g);
		if (oSpace == null) {
			oSpace = [" "];
		}
		else {
			oSpace.push(" ");
		}
		var nSpace = n.match(/\s+/g);
		if (nSpace == null) {
			nSpace = [" "];
		}
		else {
			nSpace.push(" ");
		}
		
		if (out.n.length == 0) {
			for (var i = 0; i < out.o.length; i++) {
				str += '<del>' + out.o[i] + oSpace[i] + "</del>";
			}
		}
		else {
			if (out.n[0].text == null) {
				for (n = 0; n < out.o.length && out.o[n].text == null; n++) {
					str += '<del>' + out.o[n] + oSpace[n] + "</del>";
				}
			}
			
			for (var i = 0; i < out.n.length; i++) {
				if (out.n[i].text == null) {
					str += '<ins>' + out.n[i] + nSpace[i] + "</ins>";
				}
				else {
					var pre = "";
					
					for (n = out.n[i].row + 1; n < out.o.length && out.o[n].text == null; n++) {
						pre += '<del>' + out.o[n] + oSpace[n] + "</del>";
					}
					str += " " + out.n[i].text + nSpace[i] + pre;
				}
			}
		}
		
		return str;
	};
})();

})(this);

}};
__resources__["/__builtin__/libs/util.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
var path = require('path');

/**
 * @namespace
 * Useful utility functions
 */
var util = {
    /**
     * Merge two or more objects and return the result.
     *
     * @param {Object} firstObject First object to merge with
     * @param {Object} secondObject Second object to merge with
     * @param {Object} [...] More objects to merge
     * @returns {Object} A new object containing the properties of all the objects passed in
     */
    merge: function(firstObject, secondObject) {
        var result = {};

        for (var i = 0; i < arguments.length; i++) {
            var obj = arguments[i];

            for (var x in obj) {
                if (!obj.hasOwnProperty(x)) {
                    continue;
                }

                result[x] = obj[x];
            }
        };

        return result;
    },

    /**
     * Creates a deep copy of an object
     *
     * @param {Object} obj The Object to copy
     * @returns {Object} A copy of the original Object
     */
    copy: function(obj) {
        if (obj === null) {
            return null;
        }

        var copy;

        if (obj instanceof Array) {
            copy = [];
            for (var i = 0, len = obj.length; i < len; i++) {
                copy[i] = arguments.callee(obj[i]);
            }
        } else if (typeof(obj) == 'object') {
            if (typeof(obj.copy) == 'function') {
                copy = obj.copy();
            } else {
                copy = {};

                var o, x;
                for (x in obj) {
                    copy[x] = arguments.callee(obj[x]);
                }
            }
        } else {
            // Primative type. Doesn't need copying
            copy = obj;
        }

        return copy;
    },

    /**
     * Iterates over an array and calls a function for each item.
     *
     * @param {Array} arr An Array to iterate over
     * @param {Function} func A function to call for each item in the array
     * @returns {Array} The original array
     */
    each: function(arr, func) {
        var i = 0,
            len = arr.length;
        for (i = 0; i < len; i++) {
            func(arr[i], i);
        }

        return arr;
    },

    /**
     * Iterates over an array, calls a function for each item and returns the results.
     *
     * @param {Array} arr An Array to iterate over
     * @param {Function} func A function to call for each item in the array
     * @returns {Array} The return values from each function call
     */
    map: function(arr, func) {
        var i = 0,
            len = arr.length,
            result = [];

        for (i = 0; i < len; i++) {
            result.push(func(arr[i], i));
        }

        return result;
    },

    extend: function(target, ext) {
        if (arguments.length < 2) {
            throw "You must provide at least a target and 1 object to extend from"
        }

        var i, j, obj, key, val;

        for (i = 1; i < arguments.length; i++) {
            obj = arguments[i];
            for (key in obj) {
                // Don't copy built-ins
                if (!obj.hasOwnProperty(key)) {
                    continue;
                }

                val = obj[key];
                // Don't copy undefineds or references to target (would cause infinite loop)
                if (val === undefined || val === target) {
                    continue;
                }

                // Replace existing function and store reference to it in .base
                if (val instanceof Function && target[key] && val !== target[key]) {
                    val.base = target[key];
                    val._isProperty = val.base._isProperty;
                }
                target[key] = val;

                if (val instanceof Function) {
                    // If this function observes make a reference to it so we can set
                    // them up when this get instantiated
                    if (val._observing) {
                        // Force a COPY of the array or we will probably end up with various
                        // classes sharing the same one.
                        if (!target._observingFunctions) {
                            target._observingFunctions = [];
                        } else {
                            target._observingFunctions = target._observingFunctions.slice(0);
                        }


                        for (j = 0; j<val._observing.length; j++) {
                            target._observingFunctions.push({property:val._observing[j], method: key});
                        }
                    } // if (val._observing)

                    // If this is a computer property then add it to the list so get/set know where to look
                    if (val._isProperty) {
                        if (!target._computedProperties) {
                            target._computedProperties = [];
                        } else {
                            target._computedProperties = target._computedProperties.slice(0);
                        }

                        target._computedProperties.push(key)
                    }
                }
        
            }
        }


        return target;
    },

    beget: function(o) {
        var F = function(){};
        F.prototype = o;
        var ret  = new F();
        F.prototype = null;
        return ret;
    },

    callback: function(target, method) {
        if (typeof(method) == 'string') {
            var methodName = method;
            method = target[method];
            if (!method) {
                throw "Callback to undefined method: " + methodName;
            }
        }
        if (!method) {
            throw "Callback with no method to call";
        }

        return function() {
            method.apply(target, arguments);
        }
    },

    domReady: function() {
        if (this._isReady) {
            return;
        }

        if (!document.body) {
            setTimeout(function() { util.domReady(); }, 13);
        }

        window.__isReady = true;

        if (window.__readyList) {
            var fn, i = 0;
            while ( (fn = window.__readyList[ i++ ]) ) {
                fn.call(document);
            }

            window.__readyList = null;
            delete window.__readyList;
        }
    },


    /**
     * Adapted from jQuery
     * @ignore
     */
    bindReady: function() {

        if (window.__readyBound) {
            return;
        }

        window.__readyBound = true;

        // Catch cases where $(document).ready() is called after the
        // browser event has already occurred.
        if ( document.readyState === "complete" ) {
            return util.domReady();
        }

        // Mozilla, Opera and webkit nightlies currently support this event
        if ( document.addEventListener ) {
            // Use the handy event callback
            //document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false );
            
            // A fallback to window.onload, that will always work
            window.addEventListener( "load", util.domReady, false );

        // If IE event model is used
        } else if ( document.attachEvent ) {
            // ensure firing before onload,
            // maybe late but safe also for iframes
            //document.attachEvent("onreadystatechange", DOMContentLoaded);
            
            // A fallback to window.onload, that will always work
            window.attachEvent( "onload", util.domReady );

            // If IE and not a frame
            /*
            // continually check to see if the document is ready
            var toplevel = false;

            try {
                toplevel = window.frameElement == null;
            } catch(e) {}

            if ( document.documentElement.doScroll && toplevel ) {
                doScrollCheck();
            }
            */
        }
    },



    ready: function(func) {
        if (window.__isReady) {
            func()
        } else {
            if (!window.__readyList) {
                window.__readyList = [];
            }
            window.__readyList.push(func);
        }

        util.bindReady();
    },


    /**
     * Tests if a given object is an Array
     *
     * @param {Array} ar The object to test
     *
     * @returns {Boolean} True if it is an Array, otherwise false
     */
    isArray: function(ar) {
      return ar instanceof Array
          || (ar && ar !== Object.prototype && util.isArray(ar.__proto__));
    },


    /**
     * Tests if a given object is a RegExp
     *
     * @param {RegExp} ar The object to test
     *
     * @returns {Boolean} True if it is an RegExp, otherwise false
     */
    isRegExp: function(re) {
      var s = ""+re;
      return re instanceof RegExp // easy case
          || typeof(re) === "function" // duck-type for context-switching evalcx case
          && re.constructor.name === "RegExp"
          && re.compile
          && re.test
          && re.exec
          && s.charAt(0) === "/"
          && s.substr(-1) === "/";
    },


    /**
     * Tests if a given object is a Date
     *
     * @param {Date} ar The object to test
     *
     * @returns {Boolean} True if it is an Date, otherwise false
     */
    isDate: function(d) {
        if (d instanceof Date) return true;
        if (typeof d !== "object") return false;
        var properties = Date.prototype && Object.getOwnPropertyNames(Date.prototype);
        var proto = d.__proto__ && Object.getOwnPropertyNames(d.__proto__);
        return JSON.stringify(proto) === JSON.stringify(properties);
    },

    /**
     * Utility to populate a namespace's index with its modules
     *
     * @param {Object} parent The module the namespace lives in. parent.exports will be populated automatically
     * @param {String} modules A space separated string of all the module names
     *
     * @returns {Object} The index namespace
     */
    populateIndex: function(parent, modules) {
        var namespace = {};
        modules = modules.split(' ');

        util.each(modules, function(mod, i) {
            // Use the global 'require' which allows overriding the parent module
            util.extend(namespace, window.require('./' + mod, parent));
        });

        util.extend(parent.exports, namespace);

        return namespace;
    }


}

util.extend(String.prototype, /** @scope String.prototype */ {
    /**
     * Create an array of words from a string
     *
     * @returns {String[]} Array of the words in the string
     */
    w: function() {
        return this.split(' ');
    }
});




module.exports = util;

}};
__resources__["/__builtin__/path.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/** @namespace */
var path = {
    /**
     * Returns full directory path for the filename given. The path must be formed using forward slashes '/'.
     *
     * @param {String} path Path to return the directory name of
     * @returns {String} Directory name
     */
    dirname: function(path) {
        var tokens = path.split('/');
        tokens.pop();
        return tokens.join('/');
    },

    /**
     * Returns just the filename portion of a path.
     *
     * @param {String} path Path to return the filename portion of
     * @returns {String} Filename
     */
    basename: function(path) {
        var tokens = path.split('/');
        return tokens[tokens.length-1];
    },

    /**
     * Joins multiple paths together to form a single path
     * @param {String} ... Any number of string arguments to join together
     * @returns {String} The joined path
     */
    join: function () {
        return module.exports.normalize(Array.prototype.join.call(arguments, "/"));
    },

    /**
     * Tests if a path exists
     *
     * @param {String} path Path to test
     * @returns {Boolean} True if the path exists, false if not
     */
    exists: function(path) {
        return (__resources__[path] !== undefined);
    },

    /**
     * @private
     */
    normalizeArray: function (parts, keepBlanks) {
      var directories = [], prev;
      for (var i = 0, l = parts.length - 1; i <= l; i++) {
        var directory = parts[i];

        // if it's blank, but it's not the first thing, and not the last thing, skip it.
        if (directory === "" && i !== 0 && i !== l && !keepBlanks) continue;

        // if it's a dot, and there was some previous dir already, then skip it.
        if (directory === "." && prev !== undefined) continue;

        // if it starts with "", and is a . or .., then skip it.
        if (directories.length === 1 && directories[0] === "" && (
            directory === "." || directory === "..")) continue;

        if (
          directory === ".."
          && directories.length
          && prev !== ".."
          && prev !== "."
          && prev !== undefined
          && (prev !== "" || keepBlanks)
        ) {
          directories.pop();
          prev = directories.slice(-1)[0]
        } else {
          if (prev === ".") directories.pop();
          directories.push(directory);
          prev = directory;
        }
      }
      return directories;
    },

    /**
     * Returns the real path by expanding any '.' and '..' portions
     *
     * @param {String} path Path to normalize
     * @param {Boolean} [keepBlanks=false] Whether to keep blanks. i.e. double slashes in a path
     * @returns {String} Normalized path
     */
    normalize: function (path, keepBlanks) {
      return module.exports.normalizeArray(path.split("/"), keepBlanks).join("/");
    }
};

module.exports = path;

}};
__resources__["/__builtin__/system.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/** @namespace */
var system = {
    /** @namespace */
    stdio: {
        /**
         * Print text and objects to the debug console if the browser has one
         * 
         * @param {*} Any value to output
         */
        print: function() {
            if (console) {
                console.log.apply(console, arguments);
            } else {
                // TODO
            }
        }
    }
};

if (window.console) {
    system.console = window.console
} else {
    system.console = {
        log: function(){}
    }
}

}};
__resources__["/Background.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
// Import the cocos2d module
var cocos = require('cocos2d'),
// Import the geometry module
    geo = require('geometry'),
// Import the geometry module
	util = require('util');

var Background = cocos.nodes.Node.extend({
    init: function() {
       Background.superclass.init.call(this);
       var sprite = cocos.nodes.Sprite.create({
           file: '/resources/background.jpg',
           rect: new geo.Rect(0, 0, 488, 400)
           });
       sprite.set('anchorPointInPixels', new geo.Point(0, 0));
       this.addChild({child: sprite});
       this.set('contentSize', sprite.get('contentSize'));
    }
});

var Background2 = cocos.nodes.Node.extend({
    init: function() {
       Background2.superclass.init.call(this);
       var sprite = cocos.nodes.Sprite.create({
           file: '/resources/background2.png',
           rect: new geo.Rect(0, 0, 425, 335)
           });
       sprite.set('anchorPointInPixels', new geo.Point(0, 0));
       this.addChild({child: sprite});
       this.set('contentSize', sprite.get('contentSize'));
    }
});

exports.Background = Background;
exports.Background2 = Background2;
}};
__resources__["/Barrel.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
// Import the cocos2d module
var cocos = require('cocos2d'),
// Import the geometry module
    geo = require('geometry'),
// Import the geometry module
	util = require('util');

var Barrel = cocos.nodes.Node.extend({
    velocity: null,
    mouseConect: false,
    init: function() {
       Barrel.superclass.init.call(this);
       var sprite = cocos.nodes.Sprite.create({
           file: '/resources/sprites.png',
           rect: new geo.Rect(0, 0, 64, 16)
           });
       sprite.set('anchorPointInPixels', new geo.Point(50, 0));
       this.addChild({child: sprite});
       this.set('contentSize', sprite.get('contentSize'));
    }
});

var BarrelBase = cocos.nodes.Node.extend({
    init: function() {
       BarrelBase.superclass.init.call(this);
       var sprite = cocos.nodes.Sprite.create({
           file: '/resources/crate.jpg',
           rect: new geo.Rect(0, 0, 72, 72)
           });
       sprite.set('anchorPointInPixels', new geo.Point(50, 0));
       this.addChild({child: sprite});
       this.set('contentSize', sprite.get('contentSize'));
	}
});

exports.Barrel = Barrel;
exports.BarrelBase = BarrelBase;
}};
__resources__["/Bullet.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
// Import the cocos2d module
var cocos = require('cocos2d'),
// Import the geometry module
    geo = require('geometry'),
// Import the geometry module
	util = require('util');

var Bullet = cocos.nodes.Node.extend({
    velocity: null,
    mouseConect: false,
    init: function() {
       Bullet.superclass.init.call(this);
       var sprite = cocos.nodes.Sprite.create({
           file: '/resources/bullet.png',
           rect: new geo.Rect(0, 0, 64, 64)
           });
       sprite.set('anchorPointInPixels', new geo.Point(0, 0));
       this.set('scale',0.5);
       this.addChild({child: sprite});
       this.set('contentSize', sprite.get('contentSize'));
    }
});

exports.Bullet = Bullet;
}};
__resources__["/main.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
// Import the cocos2d module
var cocos = require('cocos2d'),
// Import the geometry module
    geo = require('geometry'),
// Import the geometry module
	util = require('util'),
// Import box2d Physics Engine
	box2d = require('box2d'),
// Import Barrel
	Barrel = require('Barrel').Barrel,
	BarrelBase = require('Barrel').BarrelBase,
// Import Bullet
	Bullet = require('Bullet').Bullet,
// Import Background
	Background = require('Background').Background;
	Background2 = require('Background').Background2;
	
// Create a new layer
var Box2ddemo = cocos.nodes.Layer.extend({    
	Barrel: null,
	Bullet: null,
	Background: null,
	Background2: null,
	world: null,
    bodies: null,
    holes: null,
    contact: null,
    ballSetPattern: null,
    selectedBody: null,
    mouseJoint: null,
    init: function() {
        // You must always call the super class version of init
        Box2ddemo.superclass.init.call(this);
        
        this.set('isMouseEnabled', true);
        this.set('bodies', []);
        this.set('holes', []);
        this.set('ballSetPattern',0);

        // Get size of canvas
        var s = cocos.Director.get('sharedDirector').get('winSize');
        
        this.demo();
        this.scheduleUpdate();
        
        // Add Barrel
        var barrel = Barrel.create();
        barrel.set('position', new geo.Point(5*420/14+15,6.5*420/14));
        this.addChild({child: barrel,z:20});
        this.set('barrel', barrel);
        var barrelBase = BarrelBase.create();
        barrelBase.set('position', new geo.Point(5*420/14+15,6.5*420/14));
        this.addChild({child: barrelBase,z:19});
        this.set('barrelBase', barrelBase);
        //Add Bullet
        var bullet = Bullet.create();
        bullet.set('position',new geo.Point(5*420/14+15,6.5*420/14));
        this.addChild({child: bullet,z:20});
        this.set('bullet', bullet);
        //Add Background
        var background = Background.create(),
        	background2 = Background2.create();
        background.set('position',new geo.Point(360,200));
        background2.set('position',new geo.Point(360,200));
        this.addChild({child: background,z:-2});
        this.set('background', background);
        this.addChild({child: background2,z:-1});
        this.set('background2', background2);
        
        // Add Menu
        var up = cocos.nodes.MenuItemImage.create({normalImage: "/resources/up.png",
                                                    selectedImage:"/resources/sprites.png",
                                                    callback: util.callback(this, 'moveUp')});
        var down = cocos.nodes.MenuItemImage.create({normalImage: "/resources/down.png",
                                                    selectedImage:"/resources/sprites.png",
                                                    callback: util.callback(this, 'moveDown')});
        var right = cocos.nodes.MenuItemImage.create({normalImage: "/resources/right.png",
                                                    selectedImage:"/resources/sprites.png",
                                                    callback: util.callback(this, 'turnRight')});
        var left = cocos.nodes.MenuItemImage.create({normalImage: "/resources/left.png",
                                                    selectedImage:"/resources/sprites.png",
                                                    callback: util.callback(this, 'turnLeft')});
        var shot = cocos.nodes.MenuItemImage.create({normalImage: "/resources/bnx150x64_02.png",
                                                    selectedImage:"/resources/bnx150x64_02.png",
                                                    callback: util.callback(this, 'shotBall')});
        up.set('position',new geo.Point( 32,32)); 
        down.set('position',new geo.Point( 32, 370));
        right.set('position',new geo.Point( 32, 64+32));
        left.set('position',new geo.Point( 32, 370-64));
        shot.set('position',new geo.Point( 32, 64+64+75))
        var menu = cocos.nodes.Menu.create({items: [up,down,right,left,shot]});
        menu.set('position',new geo.Point(0,0));
        this.addChild({child: menu, z: 9});  
    },
    
    createCrate: function(point, scale){
    	scale = scale || 1;
    	var sprite = cocos.nodes.Sprite.create({file:'/resources/crate.jpg'});
    	sprite.set('position',point);
    	sprite.set('scale',scale/2);
    	this.addChild(sprite);
    	return sprite;	
    },
    createBall: function(point, scale){
    	scale = scale || 1;
    	var sprite = cocos.nodes.Sprite.create({file:'/resources/ball.png'});
    	sprite.set('position',point);
    	sprite.set('scale',scale);
    	this.addChild(sprite);
    	return sprite;
    },
    createShot: function(point, scale){
    	scale = scale || 1;
    	var sprite = cocos.nodes.Sprite.create({file:'/resources/bullet.png'});
    	sprite.set('position',point);
    	sprite.set('scale',scale);
    	this.addChild(sprite);
    	return sprite;
    },
    createHole: function(point,scale){
    	scale = scale || 1;
    	var sprite = cocos.nodes.Sprite.create({file:'/resources/hole.png'});
    	sprite.set('position',point);
    	sprite.set('scale',scale);
    	this.addChild(sprite);
    	return sprite;
    },
    
    update: function(dt){
    	var world = this.get('world'),
    		mouseJoint = this.get('mouseJoint');
    	
    	world.Step(dt, 10, 10);
    	world.ClearForces();
    	
    	var bodies = this.get('bodies'),
    		holes = this.get('holes');
   		for(var len = bodies.length-1, i = len; i >= 0; i--){
   			var body = bodies[i],
   				pos = body.GetPosition(),
    			angle = geo.radiansToDegrees(body.GetAngle());
   			body.sprite.set('position', new geo.Point(pos.x * 30, pos.y * 30));
   			body.sprite.set('rotation',angle);
   			for(var j = 0, hlen = holes.length; j < hlen; j++){
   				//console.log(bodies.length,i,body);
   				var hole = holes[j],
   					hpos = hole.GetPosition();
    			if(Math.sqrt(Math.pow(pos.x-hpos.x,2)+Math.pow(pos.y-hpos.y,2))<=0.75){
   					this.removeChild({child:body.sprite,cleanup:true});
   					world.DestroyBody(body);
   					bodies.splice(i,1)
   				}
   			}
   		}   		
   	
    	this.testHoleCollision();
    },
    testHoleCollision: function(){
    	var world = this.get('world'),
    		contact = this.get('contact'),
    		bodies = this.get('bodies'),
    		holes = this.get('holes');
    	//console.log(contact.IsTouching());
    	//console.log(holes);
    	//console.log(bodies);
    	//world.DestroyBody(hole);
    	
    },
    
    demo: function() {
    	var world = new box2d.b2World(new box2d.b2Vec2(0,0),true);
    	this.set('world',world);
    	var contact = new box2d.b2Contact;
    	this.set('contact',contact);
    	
    	var fixDef = new box2d.b2FixtureDef;
    	fixDef.density = 1.0;
    	fixDef.friction = 1.0;
    	fixDef.restitution = 1.0;
    	var bodyDef = new box2d.b2BodyDef;
    	
    	//create ground
    	bodyDef.type = box2d.b2Body.b2_staticBody;
        fixDef.shape = new box2d.b2PolygonShape;
        
        fixDef.shape.SetAsBox(20, 2);
        bodyDef.position.Set(10, (400 / 30 + 2)-1);
        world.CreateBody(bodyDef).CreateFixture(fixDef);
        bodyDef.position.Set(10, -1);
        world.CreateBody(bodyDef).CreateFixture(fixDef);
        
        fixDef.shape.SetAsBox(4, 14);
        bodyDef.position.Set(0.8, 13);
        world.CreateBody(bodyDef).CreateFixture(fixDef);
        bodyDef.position.Set(22.95, 13);
        world.CreateBody(bodyDef).CreateFixture(fixDef);
    	
    	//create Hole
    	fixDef.shape = new box2d.b2CircleShape(0.5);
    	fixDef.isSensor = true;
    	for(var i = 0; i < 3; i++){
    		bodyDef.position.x = 17.9;
    		bodyDef.position.y = 13/3*i+14/6;
    		sprite = this.createHole(new geo.Point(bodyDef.position.x * 30, bodyDef.position.y * 30), scale);
    		var hole = world.CreateBody(bodyDef);
            hole.sprite = sprite;
        	this.get('holes').push(hole);
        	hole.CreateFixture(fixDef);	
    	}
    	
        fixDef.isSensor = false;
    	
    	//create some objects
        bodyDef.type = box2d.b2Body.b2_dynamicBody;
        
        /*create shot ball
        bodyDef.position.x = 5;
        bodyDef.position.y = 6.5;
        var scale = 0.5,
            width = scale * 30;
        fixDef.shape = new box2d.b2CircleShape(width/30);
        sprite = this.createBall(new geo.Point(bodyDef.position.x * 30, bodyDef.position.y * 30), scale);

        var bullet = world.CreateBody(bodyDef);
        bullet.sprite = sprite;
        this.get('bodies').push(bullet);
        bullet.CreateFixture(fixDef);
        */
        //create some ball        
        for (var i = 0; i < 9*3; ++i) {
            var sprite;
            //bodyDef.position.x = Math.random() * 15;
            //bodyDef.position.y = Math.random() * 15;
            //var scale = (Math.random() + 0.5),
            //    width = scale * 32;
            //if (Math.random() > 0.5) {
            //    fixDef.shape = new box2d.b2PolygonShape;
            //    fixDef.shape.SetAsBox(width/30, width/30);
            //    sprite = this.createCrate(new geo.Point(bodyDef.position.x * 30, bodyDef.position.y * 30), scale);
            //} else {
            //    fixDef.shape = new box2d.b2CircleShape(width/30);
            //    sprite = this.createBall(new geo.Point(bodyDef.position.x * 30, bodyDef.position.y * 30), scale);
            //}
            if(i<9){
            	bodyDef.position.x = 14;
            	bodyDef.position.y = 2.5+(i*1);
            }else if(i<9*2){
            	bodyDef.position.x = 13;
            	bodyDef.position.y = 2.5+((i-9)*1);
            }else{
            	bodyDef.position.x = 12;
            	bodyDef.position.y = 2.5+((i-18)*1);
            }
            bodyDef.linearDamping = 0.3;
            bodyDef.angularDamping = 0.5;
            var scale = 0.5,
                width = scale * 30;
            fixDef.shape = new box2d.b2CircleShape(width/30);
            sprite = this.createBall(new geo.Point(bodyDef.position.x * 30, bodyDef.position.y * 30), scale);
            
            var bdy = world.CreateBody(bodyDef);
            bdy.sprite = sprite;
            this.get('bodies').push(bdy);
            bdy.CreateFixture(fixDef);
		}
		fixDef.isSensor = true;
    },
    
    getBodyAtPoint: function(point){
    	point = new geo.Point(point.x /30, point.y /30);
        var world = this.get('world');
        var mousePVec = new box2d.b2Vec2(point.x, point.y);
        var aabb = new box2d.b2AABB();
        aabb.lowerBound.Set(point.x - 0.001, point.y - 0.001);
        aabb.upperBound.Set(point.x + 0.001, point.y + 0.001);

        var self = this;
        function getBodyCB(fixture) {
            if(fixture.GetBody().GetType() != box2d.b2Body.b2_staticBody) {
                if(fixture.GetShape().TestPoint(fixture.GetBody().GetTransform(), mousePVec)) {
                    self.set('selectedBody', fixture.GetBody());
                    return false;
                }
            }
            return true;
        }

        // Query the world for overlapping shapes.
        this.set('selectedBody', null);
        world.QueryAABB(getBodyCB, aabb);
        return this.get('selectedBody');
    },
    
    mouseDown: function(evt) {
        var point = evt.locationInCanvas,
            world = this.get('world'),
            mouseJoint = this.get('mouseJoint'),
            barrel = this.get('barrel'),
            bullet = this.get('bullet'),
            barrelBase = this.get('barrelBase');
			
        if (!mouseJoint) {
            var body = this.getBodyAtPoint(point);
            if(body) {
                var md = new box2d.b2MouseJointDef();
                md.bodyA = world.GetGroundBody();
                md.bodyB = body;
                md.target.Set(point.x /30, point.y /30);
                md.collideConnected = true;
                md.maxForce = 300.0 * body.GetMass();
                mouseJoint = world.CreateJoint(md);
                body.SetAwake(true);
                this.set('mouseJoint', mouseJoint);
            }
        }
        
        if(!barrel.mouseConect){
        	var pos = util.copy(barrelBase.get('position')),
        		rot = util.copy(barrel.get('rotaiton')),
        		slope = Math.tan(Math.PI*rot/180),
        		intercept = 16/Math.cos(Math.PI*rot/180);
        	if(point.x>=pos.x-96 && point.x<=pos.x-16){
        		if(point.y<=pos.y+36 && point.y>=pos.y-36){
        			barrel.mouseConect=true;	
        		}
        	}
        }
        if(!bullet.mouseConect){
     		var pos = util.copy(bullet.get('position'));  
     		if(Math.sqrt(Math.pow(pos.x-point.x,2)+Math.pow(pos.y-point.y,2))<=16){
     			bullet.mouseConect=true;
     		}
        	
        }
        //console.log(barrel.mouseConect,bullet.mouseConect);
    }, 
    mouseDragged: function(evt) {
        var point = evt.locationInCanvas,
            world = this.get('world'),
            mouseJoint = this.get('mouseJoint'),
            barrel = this.get('barrel'),
            bullet = this.get('bullet'),
            barrelBase = this.get('barrelBase');
		//console.log(point,mouseJoint);
        if (mouseJoint) {
            mouseJoint.SetTarget(new box2d.b2Vec2(point.x /30, point.y /30));
        }
        if(barrel.mouseConect){
        	var pos = util.copy(barrel.get('position'));
        	pos.y = point.y;
        	barrel.set('position',pos);
        	bullet.set('position',pos);
        	barrelBase.set('position',pos);
        }
        if(bullet.mouseConect){
        	var pos = util.copy(barrel.get('position')),
        		rot = util.copy(barrel.get('rotation'));
        	pos.x = -pos.x+point.x;
        	pos.y = -pos.y+point.y;
        	rot = Math.atan2(pos.y,pos.x);
        	barrel.set('rotation',rot*180/Math.PI); 
        	//console.log(pos.x,pos.y,rot*180/Math.PI);
        }
    }, 
	mouseUp: function(evt) {
        var mouseJoint = this.get('mouseJoint'),
            world = this.get('world'),
            barrel = this.get('barrel'),
            bullet = this.get('bullet');

        if (mouseJoint) {
            world.DestroyJoint(mouseJoint);
            this.set('mouseJoint', null);
        }
        if(barrel.mouseConect){
        	barrel.mouseConect=false;
        }
        if(bullet.mouseConect){
        	bullet.mouseConect=false;
        	this.shotBall(evt);
        }
        //console.log(barrel.mouseConect,bullet.mouseConect);
   },

   moveUp: function(){
   		
   		var barrel = this.get('barrel'),
        	pos = util.copy(barrel.get('position')),
        	bullet = this.get('bullet');  
        if(pos.y>(6.5*400/14+10)-10*11){
        	pos.y -= 10;	
        }
        barrel.set('position',pos);
        bullet.set('position',pos);
     
   },
   moveDown: function(){
   		var barrel = this.get('barrel'),
        	pos = util.copy(barrel.get('position')),
        	bullet = this.get('bullet');   
       if(pos.y<(6.5*400/14+10)+10*12){
        	pos.y += 10;	
        }
        barrel.set('position',pos);
        bullet.set('position',pos); 
   },
   turnRight: function(){
   		var barrel = this.get('barrel'),
   			rotation = util.copy(barrel.get('rotation'));
   		rotation -= 5;
   		barrel.set('rotation',rotation); 	
   },
   turnLeft: function(){
   		var barrel = this.get('barrel'),
   			rotation = util.copy(barrel.get('rotation'));
   		rotation += 5;
   		barrel.set('rotation',rotation);
   },
   shotBall: function(evt){
   		var point = evt.locationInCanvas,
   			world = this.get('world'),
    		barrel = this.get('barrel'),
    		position = util.copy(barrel.get('position')), 
    		rotation = util.copy(barrel.get('rotation'));
    	
    	var fixDef = new box2d.b2FixtureDef;
    	fixDef.density = 8.0;
    	fixDef.friction = 1.0;
    	fixDef.restitution = 1.0;
    	var bodyDef = new box2d.b2BodyDef;
    	var velocity = Math.sqrt(Math.pow(position.x-point.x,2)+Math.pow(position.y-point.y,2))/15;
    	console.log(velocity); 
   		bodyDef.type = box2d.b2Body.b2_dynamicBody;
   		bodyDef.position.x = 5;
        bodyDef.position.y = (position.y)*14/420;
        bodyDef.linearVelocity.x = velocity*Math.cos(Math.PI*rotation/180);
        bodyDef.linearVelocity.y = velocity*Math.sin(Math.PI*rotation/180);
        bodyDef.linearDamping = 0.3;
        bodyDef.angularDamping = 0.5;
        var scale = 0.5,
            width = scale * 30;
        fixDef.shape = new box2d.b2CircleShape(width/30);
        sprite = this.createShot(new geo.Point(bodyDef.position.x * 30, bodyDef.position.y * 30), scale);
        var blt = world.CreateBody(bodyDef);
        blt.sprite = sprite;
        this.get('bodies').push(blt);
        blt.CreateFixture(fixDef);
   }
});



exports.main = function() {
    // Initialise application

    // Get director
    var director = cocos.Director.get('sharedDirector');

    // Attach director to our <div> element
    director.attachInView(document.getElementById('box2ddemo_app'));

    director.set('displayFPS', true);
    
    // Create a scene
    var scene = cocos.nodes.Scene.create();

    // Add our layer to the scene
    scene.addChild({child: Box2ddemo.create()});

    // Run the scene
    director.runWithScene(scene);
};

}};
__resources__["/resources/background.jpg"] = {meta: {mimetype: "image/jpeg"}, data: __imageResource("data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAIBAQIBAQICAgICAgICAwUDAwMDAwYEBAMFBwYHBwcGBwcICQsJCAgKCAcHCg0KCgsMDAwMBwkODw0MDgsMDAz/2wBDAQICAgMDAwYDAwYMCAcIDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAz/wAARCAGQAegDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwDw+x+OnizU0YR+JvEPng7nVtWm3DvnG6rafGbxrnI8T+JCpyQf7UuOff8A1leWyEi6lljycAjg4zWHqx1aDT5JdN1W+8tE8ySB2H7sHkhf9kdq/O4e0qSaUmvmff1KtOnFSlTTXpc9vl+NHjZnyviXxJtPf+07jB/8iVPF8TvGBRXHiHxAC3/UQm4/Wvm2HxprG0Z1O8xu27d9WP8AhKdV3ZbVb9if4Q/ArV4St1l+L/zOSOb4dSuqf4L/ACPoiT4mePLt/k1zX4wP7upXA3fiHpjfEfx5LhF8Qa+ADnH9pXO4n8Xr50TX9UnViL66Izg5lZaZJ4m1WNlC6rfKVPQSn+dNYSsvtfi/8xzzak3f2f4L/I+j/wDhZvjqPEY8QeId3U/8TOfIx/wKlX4s+PFcibxB4ibevfU5+P8Ax6vnC58T6nIwLalfsx7mU8UieJNSwANTvOOp3k0/qlffmf3kLMqN78n4L/I+kp/jD4qtbZo5vEWtxloycnUJgU/M965Nv2ifE93dG1k8T63EQmwldTmG/HI/iry+38Y39rESbqWbahZi79cdqsa5bKZoLlWIS8ijkX+8jlsc/lmnSo1YXU5P72Ori4VbOMUreR7Db/tFaq8KrL4q1mCdAFMb3swJIHPU0y7/AGhdeiMezxHqbjvm/lz/AOh1wkdvpset3ltNapelJmWaZWPlz8nkHsT1/GtJn09fv29qvpkisW4Rlyucn8zrozrTV+WNvQ6Vvjd4kllWSHWL4Kw+8dQlyfzapofjL4qvHJGs3o2D/n9Y4/8AHq4271DSLbYXhhmbPIUH5aevijTt8flwQozcEhD8o96ick9Vf73/AJnRGk2/ejH7jsJPiz40mJJ1HWGQcAm7kK/zqa0+IHjCZQzajqaAA/Mbpxj9a5uTxNBCiNELR0yA2GKkVux+KbVLNVYcnBAByK82vipwej/F/wCZ6lHBU5K0oq/ov8izbeP/ABSgbzNY1NgTtP8ApMhx+tMl+IXixsxHVL8onIY3cg49OtSv4stbxFi8tGOOSUxtFY1/4nhsLlyNoXHysIzz+Ncqxk3Lf8X/AJnX/Z1JLWK+5f5Fub4teJTGEj1W/wDlO1ibpzsP03ZqrN8UvFcvyR63qPychvtcwD+4+asG8+ISXD+WxJVXznYPmGO571Db+KYru7ETNHGnZtnCivSVWolfmf3v/M8qdCHPy8q+5f5HS/8ACyvF7mVjr+oKI+MtfS4P/fL1BcfGzxHo0SC88QakS7fKiahNz+G6s+doruP/AElhJASXJWMgYqC58L6XJb5kZxuG4AHCgeh70fWf55u3q/8AMVbC1IL9zCL9Uv8AI0Jv2kddMLo+qa4iEEBhfSqSe2BnnnFYOtfHnxZo96rtr+vBCiyqrahMOOnr6E1neKrHTdOKbzGqv2XO6P3rl/GA8nWreA75lcQKO5VCef0P616eHqRppuEm0+7b/U+exjq35ZpJppaJdfkeqN+0j4gBwNW1zKY+ZbuT5uPUGhvjb4rvYy/9q6yNw+Um9m/oa8i8U3V/qHxSvm02+m06SSRo0BG1AF4CsD0P+NZD+JtaRSzaxet5bshywxkHnHtT+rua0k/m2NY505OM1dLTZHuS/FPxZcsudb1UPtAVTey8fXJqSb4m+LIVCnVb/C9P9Nfj/wAe9a8Dm8WaxPPkalfc8Ak4qObXdXkLltSvVCfK2H4HGQf1rGWCqy0Uvxf+Z1U85oJW5L/JHv8AP8RPFds7NLq+pMWXcVW6lBH61DH448TTDzG1nU3/ANprps14IPE+tG2R31W+Y4HO/wC8varZ8Y69F8o1O88rsp4NZ/UMRb+IdFPOcKvipfke/WfjbxHcBgdV1AhUOMXLc1WvvF+vhwyXd07jgO075ftyQ3FeGQePdfIO3VbpG9CRTZPHniLd8urXAI+hzWVPK8Vv7TT1Kee4RfFTt6I9ysvG3iG2nzJe3EhA3fLcOdvv1qW++JWs3E0f+k6kquQPMFw3P5k14S3jLxLJE+NZuM4y2MA4pU8S647qp1e7UbdxLEEDHer/ALMrXv7T8TneeYRQ5Y07r0PdLTxzrLysn2iYANyxk+Y/nU7+JNSkjkBvLvKfMMuCa8JPiDWLgAvql2zEZDK2OKfb6lq5jcnV9Q56FJRn8qqOW1Yvm9o0Ss3oP/lzf5HuZ8TapbwIYp7ibzBxmYY/KqMfivXll8xpCQZCqqHyQM1482sauISX1a+LAjadwBNFxJqL7salfHy/ulpMZrSGBktJTuTUzSlN3VK1vJHtEvxG1nTGjjnEzNLypbIwKz/FPxK1K507zftbxRj5CocgjP8AKvK7WXUkdPNvbtxH/EZi1dFoV0dXv5bJlaQTxN8j/wB7HBranT9lL4vxCeIdaLVrK3Y6nwl8UrvTrB9811MqNsRfMJx35/CtV/i/e3URCPjHIBkJIrz3Tp44bOczEBQImkjwQJmLbQAexHX8DXdaT4dsryGG4jtY4kTGVc5APqadeNP4v1FgpycFTuvuQH4r3ohIkmXceM53VZ0nx/qfJEwbd0KgEVck0u2jJT7PYAv3UVHbaHElwhBiQIeoOAK5FJyWlzrUXF6tfcWYPG2s3ETNvYhejDFOsfE+pBnzd/Mf4XXP5elW4PD7zqgSaMsB7AYq8NEi8ltyqJQRuIfHp/SuebaejOmnGL1M218QalPIQLh0YHBXsT9anh1i/gfZ5sav1yIzj861k06OKEBAucBh3yarpYSRSvuwSic/P0Oa54yrOVuY39lR5btFe+8T3tvBkzruLfdA+U/SnjxHdfZtzyxrNjr0JHtTzYvN82fm7jeML9KhNhLcArI7SLng5GBW9OMm9ZHNKtRgtinDr97Khd5Qfm70j+LZ7SZXNygx/CGGG+tXBoXlsSrgZGCM4q3a6BGsIOA5bqMg5rvTsjz5O7vEqwfEF1PmMWyeOD8tV7rxN9utZpdi8fe2L27c1Zv/AA1tdZBDlVbJVW6Vg6lamGKaEB4XMbMRu44rShSizDE1a3LeX5Fy18b3VnC2C5WJQ4G7JHNbVn8R7q7kxsmx9a4W1JfRb2R9znbEgx0weaowiWFQGZ1YDO0OciuqrQhUXvHl08TOGsT1IeM5WixiUn/dNPXxDPhWMU7Mx7AnFeZRSy5/10n0LmpIlc8h3XH+01RTwkVFam7zCt1PTI9aukVgklwd3XIf5acl/fX3I83I6HDEn868zjiZgxEspYdt7f41e0nTbvUblYbdpSX/AI97bU9zzSnhEveTHDGyk7ct2d9eavc6dCGnAVQflyOWPoKKyNY8OReHbGKBGaR9wZ5C5YMfbNFYS0erPQim1roeaXASDdyACCKq2Wnx6lDaLGCUnLK5HUj0pmpyrDOQ27DEsB7U/wAN6gtvb2yhvLdASvynn3rklSk/eW56DqxjaL2Mrxn8LtR8L6lmG2Waym+5KzhfKfup96zF8J6khbdaRsp6jeFJB9DXqv8Awl9vqHh77BevDOkw4LPgEenPPHr1NcRPClnqYScLtAOxgOCvbv1qnjcTBWdjkp5fhKtR6tehiJompQRKi2duQD3kyR/jSN4b1KYj/Q4M5z94V0cdrFId0vC/wlRkikutPVnDozs2MDgjipWZVk7SsdEsnwz15pfgczNoV/bSEtZr+BFI2i3rAk2iY+9neOBXUQ6e8sHzjI7/ADEE1FcaArKCu/YThhktmtf7Uls7feZyyajFcybMG00lZ5AJ3jjQDBUN8xq3dXyvq9ssaF4o3jRUJ5IHNaVv4LNrcN5SKykbsY5FVrHQblPEkUohlMO/5mZe4HtWkMSnJyctLdzjq0eVRjFdRLbxWY7+f92/lXUryCMH7hLEjB9K04rwyjLWxPf7oOam0fwv9nigm+ySedtDElzjOB2xVq4jeGdX8u6R2/gERIFeVja6nNSpL8T6HLoOnBxqP8DEuNVaaXEtiREv3drYxVQagv2lTHDvGM7C7Yrp3Em8NGN6jk5tyCPapLnzbpAPKhiydzYiIJbp6dK5HPTb8T0HON7/AKGdaays4wbBY2XjoCD+fNay6goCw/8ALMrnO3BU+lFv52QxiGUG1MIT+dIFfzSJbWWUDk/JjJPpXBVheV4nZSxME9fyLMEpNguF3uTjcGwcVUk1VjIyMtzHs6ZZWFXbB0CqrQxxIDnDKS1VNTjuopGaOMFGPG1R0rlp0qjnrobyxsIq6RzGrXEuDveSTfkhQoAX6etUdNecszOJWC9BtGQO1dnDYs0SmW0S5ZgeDwU5rK1TS4rORVitBuHzHGTlu4PtmvYoYhW9nI8ubU5cyQy21CZoRIk1yDnBOdw2/Srf2+6EMgNwh3EGNmHTHtVeyt/L0/CwvG+fujNXLG2Se3ZZ4ww6c5HPpXNXkl7rZ0qpaKdjC8a+I4ZdPiV2DXUh2AhQFPP+Fc5rGoNdX0MqDEyvEqITwzrgLn23Afz7V0niLwg09zHIIJDFC4YBRkdaybDw/ezazI72cgiDkx/KeT2/X+VfQ4OtQULSd9D5DH0K1Wq21pe+nkY+tNqV74xvLrT2UPNM+JJBvf5j8+SflJByPpimx6Ze2ECwrYB+vzsASxPU8cCt5fBVxYTkPb3ChyWYA8ZPXqK0bHQltHQGyIGMkgHn64qqmaQjpHX5io5RKcnOUmr+RyMXhzUnyps3dW5BIC49qIdF1SGI+XYyEZ5VgpU/rXT36f6TnyZSq9FQcfqKksZljgBe2lzzgFRjr9Kxnm1dL3Ir7zop5Fh+b3pv7v8AgHNrZ6oAG/s9dhOMYTC+3tQdL1hYvI+xRIM5wNpP5k102put1bnbaursuCEQYPv0qq4Xj5bhnA6Mgz/KnDNMQ43aX3mryjDr7cjCj0TV4w3+gxNx1YKTT5PCupmDzm0yJAx4cyKP610Fteo8RBimZuwJAB/StSOe0lUxNbTAqoIG4kL9MAfzrCecYiL1imKGR4KpvUd/kcO3h3UZJABaW3v865b2yDU0fhLULeH/AI8bXLNgkXC9D9TXWJJCk/yQTbRxnLcfrUYt7e1dx5TTI53fM7cHv3qlnFdrVIpZJg46cz/r5HOx+H7pZT/o9riP5RiZWI/I1Yt/Dd877xbW52Dkl1H9a3pPsJJK2YyT2/yaTzI7lCi20yD1wuD+lUs1rLXlBZNhelQyLnTdSiiH7qHyz1KlDz7VBPoOr3KRkQxyIx2/O6jn6Z6V0N1HFckbohGIh90KDk/lVJrRbiUZiuNzdNhUKB+Vb08yrSV2kYPJ8PCTvN28hNJ8MX1vKsl3BELZPvlJFNS6nqtloTyS26g3AXAPmBmTPersMTpGqpbzlB95JD8pql4u0n7eB5VmsRbBIhj2D+uaxp4qrOunVSSLr06VKg1Tf3mLaeIZbfQ7xXDb5pYVUqQSu1yxrrdD+JsgTZIPMZsL90ZxXNyeBr57K2QQS7mYtIFHzKMHmtvTPDL2nlI1m25eASCG/GvQxE48jcVc4cDRmppt6Gld+MVkUu1tIWU4GOh/KkTxpJa3Cf6KNwxlSc5pLOzCq/mW91CA3bGPwqaS9glG0wOxHVj9415Cq1fsxPcmqT0m0bkfjKR7eNhEYWHJAAHH41c/4Tg3J5DDJGMbefrXPC4t7iNVjtbhmB54zUyLErjy4XjJ65BzXJOniG20rG9OeGiviR0y+LJY42Eag7v73BFRjxbNMzRuFYt1IPIrnxIiFs+fknrt6fSqz2scdwGXzME85NKlRxBpUq0GtGjfHi+aFnjKozEY3MVWqknjGWBBsC7lJzg1XudJ82ANEmUBx7/nUFxowlZHAlRk9W+X0r0KMqnNZnnV1TktjVtfHXnECUqqscHIziteHxIb+Ldtc7eBhsAD1rlrWxJUx+UAeu/rmtGzTyECGPCjoQ3JroqTm/dsc0IQW7Oji8WIISkgcgDAOa4vWtcXV9WuriIEoEKANnJrbeFZ4wkMZDZydxrPvPD1xHbKIbbL5+YgZzW2Ck4yOLMrv3VsY9sI49OuA0R89hGsR3EKMDPNM07T7k3BcqrNjCEt92tS48IzJAFMMpQuJC38R4q7HpxiRG8gKFAHzLzXdOvGKuedSwcp6ydkU10rUJIcFLRn93AxUkPh/Um72rLnn96tTyPGsHAG7P8AcxT7OWO4XaEkiLZUEDGDz/gfyrlljXFfDod1LL6VTRyIrrTL60QOTaIV4GJQxOeOn413vw5tVt9OGIxl+rda5afSUCLkyMQM5Jrs/BEhjs40UAh+AfUVn9Yc2rsr6pChtr6md4/t1tUJByd3XNFL8RPLYbPm+Zsj2oqq71VwieFa3rNvPIROk5hbG0J8jbsevORn2rLfV7bT9p8q98xcrKftCHzB6D5Pl/WtbXdJbzn3OknkfKuPT0rDkaVZhlIwnZdoOB6V1RlBLR6HPWhUbs2i5dTaVqQxbReILaNB8rXMsUqr+K4J/KvVP2PvC1t8VP2j/Afh/V7G31fRrvWLe3mMi4WWNmwUYZB/WvMtJ019Qspp0s3leIBStu20gngcdMV7r/wT10S50f8Aa1+HcUxVY31y3kMbDcwff69qxqyp1ZQjurl0YVYQlJPofrnoH/BK/wCCl/EGf4eaKzK3+3g8EdM+1bi/8Eo/gq2APh5oijHZXP8A7NX0T4Gt1e3I2joD/wChV1TWShVIQV9msJQsvcj9yPlZYitfWb+9nyf/AMOo/gr5e3/hX2jfXa//AMVTP+HTvwUK4Pw/0Y/8Bf8A+Kr6y+yj+4KPso/uCj6nQ/59x+5f5E/WKv8AO/vf+Z8mj/glB8Fo33L4A0cEjB4fkf8AfVOi/wCCUvwYgfengLSFYdOHIH/j1fWH2Uf3B+dH2Uf3B+dL6nh/+fcfuX+Q1iay2m/vZ8oy/wDBKz4NSDafAWj7RwMB8gf99Uh/4JSfBcBR/wAIDo5C+qMT+e6vq/7KP+eY/Oj7KP7go+p4f/n3H7l/kafXcR/z8f3s+Tk/4JQ/BWIfJ8P9GGeT8jcn/vqk/wCHUPwX3ZPgHSOP+un/AMXX1l9lH9wUfZR/cH50fU6H8i+5C+uV/wCd/ez5QX/glP8ABjaR/wAIFpHr/H/8VQn/AASn+DKY/wCKC0ckequf5tX1f9lH9wfnR9lH9wUvqOH39nH7kH1zEfzv72fJ8n/BKL4LSH5vh/oxzz91x/JqYf8Agk/8FTw3gDR2HbIk4/8AHq+s/so/uCj7KP7g/Oq+qULW5I/cv8g+uV/5397Pk3/h1D8FgpA8AaMM98Sf/FVGP+CTHwUH/Mg6Tke7/wDxVfW32Yf88x+dH2Uf88x+dSsDhk7+zj9y/wAg+uYj+d/ez5HH/BJz4Kbg3/CA6SWHfdJ/8VSS/wDBJb4JuhX/AIQHSwpO4j951/77r678o/3F/IUnk/7ApvBYd704/cv8hPF139t/ez5G/wCHTPwT4x4B0rjtmQ5/8epy/wDBJv4KI7MPAGmAk5H+s4/8er648n/ZH5AUeT/sD86PqeH/AOfcf/AV/kNYzELapL72fI7/APBJ34Ku24+AdN3Hqf3mP/Q6T/h018Ff+hC07/yJ/wDFV9c+T/sD86PJ/wBgfnUf2fhf+fcfuQfXMR/z8l97/wAz5GP/AASY+CRbJ+H2lE+pD/8AxVI3/BJr4JMxz8P9Hx6ZkH/s1fXXk/7A/Ok8o/3F/ECtPqlD/n3H7l/kH1zEf8/Jfez5GH/BJf4JAcfD/Sh+Eh/9moP/AASW+CO7d/wr7SN3c7X/APiq+ufJ/wBgUeT/ALA/OpeBw73pr7kS8TWe8397PkL/AIdIfA8/8090XHT+P/4qp4v+CTnwShTC/D3SQeh+V/8A4qvrbyj/AHF/IUvk/wCwPzqlhKC+wvuQ/rde9+d/ez5Jj/4JP/BOJSF+H2kjd1+V/wD4qox/wSY+Cef+SfaSR6FH/wDiq+uvJ/2B+dHk/wCwPzo+qUP5F9yF9arb87+9nyKf+CTHwRRgV+HujKfcOP8A2anD/gk78E2HPw+0c/RZP/iq+uPKP9xfx5pDDnqgpfUsPe/IvuQfWq3WT+9nySf+CTnwT2gL8P8ASVHptf8A+Kpif8EmvgpGcjwDpIP1kH/s1fXa2wIzsFIYiD9xePYVLwOHe8F9yD6zV6Sf3s+R/wDh0/8ABMdPh/o4P+9L/wDFU8/8Ep/gucf8UDpHyjH3pD/7NX1r5R/uJ+Qo8o/3E/IULAYZfYX3IaxddbTf3s+Sj/wSn+C7Ej/hANH+bv8AOW/9CpW/4JT/AAXBBHgDSBj1Vx/7NX1n5R/uL+Qo8o/3B+PNH1DDf8+4/ciZYms95v72fJv/AA6u+DOOPAWjj/vvn9aUf8EsPg2B/wAiFon5Sf8AxVfWXlH+4n5Cjyj/AHE/IVSwdBaKC+5FLF1lopv7z5Nf/glj8G3Tb/wgejgA5+UyD/2anJ/wS0+Dif8AMiaQfxf/ABr6w8o/3E/IUeUf7ifkKTwOHe8F9yH9cr/zv7z5RP8AwS7+D+ePAukAf8D/APiqVP8Agl58H1PPgbSD/wB9/wCNfVvlH+4n5Cjyj/cT8hTWCoLaC+5B9cr/AM7+9nypH/wTD+EaAj/hCNJ65GN/+NO/4dj/AAj/AOhI0n/x/wDxr6p8o/3E/IUeUf7ifkKX1HD3vyL7kT9Zq/zM+WV/4JnfCVBx4I0kfg3+NDf8EzvhMw/5ErSfyb/Gvqbyj/cT8hR5R/uJ+Qqlg6C+wvuQo4irF3UmfLX/AA7Q+Ew6eCtKB9fm/wAaf/w7a+FQ+74N0sf99f419ReUf7ifkKPKP9xPyFJYLDraC+5B9Yq/zM+V7j/gml8KpAT/AMIbpoz3BcH+dQSf8Ey/hWyfP4PscHv5sn+NfWH2beo4A+gFMazXy2JOcdiBT+qUP5F9yJdWbd3Jnx3r3/BMH4QOoD+C7LAYA4mlGf8Ax6vx/wDiTp8ek+N9UtIYRbwWNzLbQInPyrO4Uk9/l3DH+1145/oo8SWsTLnYow46V/PP8YYDD8RddSQggateKDk9ftUxH4V8/wAQUoQpx5Elv+h9BkNSTnLmd9v1MSWCSWFSCnzLggnmul8HIYYol4ynQZ7VyFjcM14sRV0A656HjtXbeHYF3gghSvf1r5enNqdkfR1oc8FKRj/ENMTZII2ke+aKT4gyMLhgM4LAZNFdNab0PPjE8T8R3ohTaFG6TLNgdawZITuRlWQ+YoZc89a19WVrmWViM+VkAegrLmiMcFvNkmJEXIB5HAr1sNFL7zixc3e6O2+AIF3qmoCSNWXywGz/AHq9n/Ywbyv20/h+o6f29AOP9+vEP2fGzq2pAE4kIIr2r9jHfF+2v4DUkn/ieW7D/vuvJrR/22PqepBv6o2+qP6BvAZxEf8AdXH5tXXoSyLn0rkvBCgW/HXgf+hV1sf+rX6V+kXfU+BsLRRRSAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigABIHBooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigABIHBqN+YpPxqSo3/wBTJ+NAGB4hGUP++K/nl+MtydQ+J2vhmG3+1bkYB4U+e3+Jr+hzxGoEZPowNfzy/GiAL8VPEUak7V1S4Iyf+mrn+lfN8R39nD5/ofQ8PtKcr+X6nPR3Cm6G87mHyjFddoUvlug4Ibv2rz5nZbwCPseTXb+HpP8ARkLHDen9a+Yp0byuz6KrV9yyZl+NbjzLpwTnDjFFVfGM4W6Y4BG4Z5oravTd1Y54SVrs8qnTbfSeYgQSRuTkcfeNZE0CQ29mQeGiB46Hit24j8+5fsyBsnt3rDmRvstiMEnyv6V6WBdl8zjzPZM6X9n1R/bd4O2cfyr2T9jy4H/DcXgV+oXW7dcf8Drxr4DuYdevAgIDeo617D+xwNn7bPgjPH/E7g6/79cDX+1r1R2xd8Hbsj+g/wAEuJIGIAA+X/2ausj/ANWv0rkvBf8AqF+g/wDZq62P/Vr9K/Qj4WTu7i0UUUEhRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFRP/qZPxqWkcjyXoAwPFA/1Y7Fhn3r+eH4pTSXPxM8RvJ946zdKDjGQJZMV/Q14nGFj4Pb+dfz0/FiMj4oeIdwOP7Uuge4/wBc1fO8QOyhfz/Q+i4eSc538v1OPK+QwAUbnbg459a6XRLvciuvzDG0k84rnr+ExFFyCXY7cVu6HavsUFFT/ZXnmvn005aHtVLJWRm+LxG0sjseQM4opvioebcsOy96Kqoct9Eedw4n1OVDjYTgn06kVgLIsdjZhyy5j+b1Bx2rpdNtvO1KXYCccH1yM1zF5H/xK7V24fyyfpW2Bk+dizKm3CL8jqfgVIH8WXTKQSBk/wB3Feu/snP5X7aPgk9CNbt//RleN/AHnxLfe6D+dewfssf8nm+C29Nbtv8A0MVz1HbFJ+Z2UrfVH6M/oQ8Dvujwevp+Jrr4/wDVr9K5DwMP3WT1x/U118f+rX6V+gp3Vz4IWiiimAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABUbqfKk49akob/UvQBzviqQAo2RjAH45r+ev4pMH8ea6q8MNVu9x+sz47+mK/oN8VuGijH+3X8+3xQTZ431lN+55NVuiueOPtMhx+Ar5niNXjTXm/wBD6HIHaUvl+pxF+XkurZeIiHHJ71vW915Op23lscsG3Y6Zrn/EdybeSCRQSUapdA1+KXUovtDhMbuCMZ9q8bDUZcvMz0cTXTm1FjtVkZnkydzDcT7DBoqhc6ist1IIFOw7gc9AMHvRW1Sjd3RyOpZ2ZzVizx3jSRsExId3qeTXLSRySWECDn55Axbvya6lVK3k3Ybg/wDPiuXmIFpHjPys+TnrzUZe7VGduZNJU6fkdF8A0MXiq7RiAXTivWf2WZ0b9sfwc5J+XXbUYH/XQV5D8CpfJ8aT85AHfmvWP2ZJfL/bE8HkbeNdtTj/ALaCsav+8r1NqMn9Td+zP6HPBBxEPcH9D/8AZCuuj/1a/SuR8E8Rr/wIfqtddH/q1+lfoEFofDMWiiiqEFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUH/VPRQxxC9AHKeKOVi/3xX8+HxeCyeM9fEpYINWulVgeV/ePnH55r+g/wAVjYIv98fzr+fr4oIF8da7HIqSbdYvg3o/791A/LFfM8SS5Ywl6/ofQZDG8pr0/U811PRjb3IeK4eWMnA2NllP0qOK11MyYSW5UKflyigk+1W/FnhsW8c88W9MtkbSRisOHT1ubQytOfNixu3OScHuBnrWFCanC6HiaThL3tPQ0lsLy2TZdPdbiMESIQpJ6Y4opNG0+aSzjnMzyJ5mBmTPT2/CipqOzsSlzK6RiXUgiE/Thl5/E1yk0ubELj7zOQfxro9RjYW0+0FhncGPfFc2YQ9rAd44B4xXPhFeUn5no5o7ShJ9EbPwRLP4qnVR8xUE5r2L9nKxa1/a68HTMT/yGbPI7czAV5B8FpAfGkpX5coM17T8BYyv7U3hNSTn+2rLr6eaDXDXnbER9Ttw0VLBv0Z/Qj4IOY/zI984/wAK66P/AFa/SuR8GIIwVHRSQP0/xNddH/q1+lfokdkfBNi0UUUwCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKH/1D0UN/qXoA5TxWSWjB4+cc/jX8+nxRZ2+IGvRqBhdWusdsfvWP86/oK8XkzLGc4w4/nX8/XxTKL471kjAV9Uuy4zkg+a2P0xXzHEqvCC9f0PocgdpS+X6nHeMLhoPDkgwQRIMnPuBXOtZxrOHVAp2g59+v9K3fFG1vDUxwu5pEx79/6Vh3eRJGAfvR/wBDXDg9ItM3zFWq3ZsaFAZdHikwFV3Y8euDzRVjQpPL8IW44wH/AJ8UVz15Ny0LcGkjg9SmGyUjgkEVzBO23hz0Iaui1S4jkkdc4JU8CuZmlT7PbhmIALDrXThVZv1HmDvGMn2sbfwjdF8Ys275cYxXtPwG1D7T+1X4VZDhV1izXH/bVa8U+D8cZ8WOMgjHevWP2c2cftV+FQB8p1u0z/39FefWX+0r1OrBNxwrT7M/oq8DnfExPJyD/n8hXXR/6tfpXI+COITXXR/6tfpX6GtkfEi0UUUwCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKG/1L0UP/AKh6AOQ8ZsfKB7rtI/OvwC+KMaS+MdY27PMXVrvj382TGf0r+gHxiAETIGNwzX8+/wAVZQvjnxDGy7JItTuSfVsyyH/61fM8Ru0YP1/Q+iyDeXy/U4DXGWLRLpRnmRN2f6Vn3zAvDj/nn1/CtTxZCf7FuX7B1/8AQgKztRt8CFhx+7H8q8/CO8G+5rmGtRo29FXPg+3O3cPM5/MUU7QAyeE4gGIyfX3ornmrtm8tIx9DznU18uSYfWuZI87yR9/G4YI6V0viJhFqDg8gufw7VzaXE6ymNAQIhnOzrXXRTcWjDE1ItRRu/B6J08Xy5VY/KiGcGvXf2doFb9pbwi6BlxrVsWyOv71a8W0jWJtM1eSbIjMlvtOFxz6V7T+zA0kvxy8HO/U6paMf+/q1wYyMo14T7tHpYKcKtKceyP6JfA4/ct+FdbH/AKtfpXIeBpC8Df7w/lXXx/6tfpX6BFWVj4iSsxaKKKokKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAob/UvRQ/+oegDkPGRxBH7OP51/Pp8Vbj/AIut4oY7nP8AbN2Fzzx5zYFf0HeM+Y1HQhh+Ffz8fEeAH4k+KWIJZdZu8fTzjk18zxFtD5/ofRZAvel8jh/F8YOgXZKhd0y9/cVmajMEEIBBxGBx9K1vGSg6JOCM5uIuPWuf1SdUkUBP4a87BfwzbMH+9fodTo8OPCMLc5/+vRTNKLt4YtgGxwOPbNFYzjdm01pH0PLvE/iOWTWJZVtQIg5+8h+b/Csy215Dd/PYQj5txPmNyD0HFbvii+GnayFcNySDtbO859O1RXumXccaNEghLuPMZfmJUenHWtJVYJ8u1zOFCpJc0ZfgUofEDRjnStMuX7vN5obH/fz+lesfsg3l3ffGvwmGtk+zPrNrmSN9whPmrgHPNeWyLq0MjRKzwwBtu2RIyW/HGcV61+y/p0ui/GXwiyXcpD6xaCSPaAshMq8n6VhipwjKnHrzI6cFTqS523olrpY/oo8A8ROByNwOfwrso/8AVr9K434ff8eh9eAfyrso/wDVr9K+/R8fUfvMWiiimQFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUP/AKh6KH/1D0Acb41lKZ+or8APi2ZIviXrqAHnVbtv94NOzf4j8K/fzxzwrfUV+BPxaDt8WdbjkTZ5eo3JG7jI81/6mvmeIm0oNdL/AKH0WQfFJ+h5/wCL2ZdGLyBlJkQ9M8g81jaiqsyEDJ2dDWz4uufM0t49vzGYAHPHWsnUrceYpPUIB+lefgo8tFI1zHWeh0FuPN8P2O3KhcA470Uy0LPoFlGDtBYZNFYTd2atqyOE8T6OdRu2dFCuCCd5z3zxUsckun3LndvSNBkHscUalKXvW3/Msb5H5YqhqcxR3YyBEdB79q8zFS5pWfQ+iwEOWPP1Z02r+Ef7ZttPuItwCHzX9+a7b4K6h5Xx28KIqbkXV7NT2/5arzWboUzTeD1YhThOtO+CVxJ/w0P4YV2DI2sWeD0P+tWojzznC/RoJpU6dRy0uj+ir4enNofdgf0rso/9Wv0rjvh9gWhwcjI/lXYx/wCrX6V+pI/MpO7bFooopiCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKH/ANQ9FD/6h6AOK8d/6t/qK/An423An+LPiVY8K0WpXXA9POb/AOK/Sv318ef6mSv5/vieQ/xe8Sl2IL6ldAn1zIT/AEr5viJe5Fs+i4eV5yOG8SIW09TnkTiqOoSCSXK8rjGfwrT8UxqlvhWPEv8AOsq4txEIwCeh/HivOwbvTNMdJe2sjZtXK6VpwHf5qKltLfGlaaeoZf60VzSWpp7OTSaOH1NlN3dIvBVjnNY9ywjsVYjBcYNa+qWw/tq4bOMk1i3n+kxiMn+MgH8a4q0Y8zPpsGnyp9D07wegn8G5DYABHJ7VX+A05n/aM8OFt2BrFpt9v3q0ng9DB4XfLkIGIAqf4HRMPjj4ZlV+W1m17f8ATVaypSj7SKXdFYiPNCfkj+jX4cjFkR67f/Qa7OP/AFa/SuK+HkgS0APfb/Ku1ClQvpiv1BfCvQ/L52voLRRRQSFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUP/AKh6KH/1D0AcT8QPlsp27qP6V/Pr8V97/FXXyOP+Jhcsf+/uB/Ov6BfiW/l6bcHPG0k/lX8/vxRlz8R9dkT5hJeXGc9RiUYr57PmuWKZ72SNqTa8jjPEjiO3QsThpefyqheSBmXBzgf0rS8TlJNMRwPnWUc/pWfdFpQASMBSeleZhmlA1x9vb3R0tpltI09QB8q8UUmnFksLHJ420VzVFaRtKUkkkzh9Uhjm1CYDaGDs5G/5iMkYxWUujvJHKSmwKw2lxyBWwuDqsx34+c/zqbUFfEezzDznrXzePryjUcEfa5bCM6cZM6Lw9pnmeH8RyKRvPynofwqz8LYorL4zeGF4WU6xaYCfKAfOSn+GN9tpLI+CFOar/Dsxx/HfwtzgtrFqxz2/fLSwVR+1gvMMdGKhOytoz+irwCM26/Wu2jJ6ZOB09q4nwD/qF+v9RXbR9TX7F0Xofkc/iY6iiigkKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAof/UPRQ/+oegDhfiWB/Y92cZIjb/0E1/Pt8T4ZH8b6yyoy77qfkcdZRX9AfxSm26Tee0Tf+gmv5//AIgX8f8AwlOppnBS6mI98yivnc/TtGy7nuZLKKcrvsctrkIk0qNsAfvcYAwDVOeBfMGePlOPet6WGDW9Oktw6CWMB14xkg54/I1n20TXgWN4XLA8gqeB615mFbcbNWOjGSTnzLU1dLtml0uz3Abh2oqy8sVuYYQqjG3HOedworCoveKnOmrJs8xkuBFrbjGwFuAe3SrlxKwaJy4KtIVPtzxWfqMZttckc8726Ht/nFR6leh7ZByMTZznrz1r57H4aTrOSPtcprWopM9H0i5DaTJhck5I9+KzPh5mX41+G5XkB36ra5Xb0xMlWtFnSXTUIcDyxzis/wCH9wg+MHhs7gAdVtsf9/0qcJCUasVLuLHWnCT7I/o4+HvFpH7gf0rt4+prifh4wFhCvXgc/lXbR9TX6+tkflFR3k2OooooICiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKR2HkvzS1HL8sL575oA8++Lqn+xb89hbvz/wBq/nx+I+jtP4nv3Dsu66lXceg+Z6/oK+L8pHh3UT2+zSEf8AfBr8EfFkST+JLtSRhrl3PPPVxXzmd4j2co3Xc9nKqXtFJHDwaUzzYhbzHA4ZSVyR71btba4fdvmuV2f60s45P1qWbRv9LCBgAzH6itV/C0Nr5Ew5DAqwOfnNeXTxEJ6Lc6auDkndrQqaZYqmpw4BZS6EDOSfmHNFP8NKkWtKxI2xzA8Z6AiiqqSs7GCoQtdI811i483XpY8EMWIGeg4rD1GWSS2ByCqS7Tg9MGtHxPKYfEDNnBEpzWVekXUFzGrDaZgMDqCe9ePjKbhN3PsMunePL5HdeGL9YtAUkYdc71PU/SnfD2TzPi34ZbaF26xbKQeufOQ1Fo+m+XoJhyRuPDHkmpPAEgtfizocQHmONUtmA7g+ag/pXLScXUg09bo7a8bUp37H9JPw/jKWUBOMFR/Su2j6muJ+HhP9m2+eTtAPtwp/rXbR9TX6utl6H5TP4mOooooJCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKjueIWqSo7rmBvpQB5r8ZZRF4W1NjnCWchP8A3ya/BfXY/tXiC7JT70rgEf7zGv3k+ODBfBmsMen2KU/+ONX4K6rcNLrF2qNmNZGOencj+tfMcRJPlfa59Bkb1l8iC3skkuRt+bYwzn61o6qgFg4BGUJwKx49SMV0qhcbc8g9frWmtys2nyhwVcjcpzkfSvAwlOXM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")};
__resources__["/resources/background2.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,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")};
__resources__["/resources/ball.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,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")};
__resources__["/resources/bnx150x64_02.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,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")};
__resources__["/resources/bnx600x150_02.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAAJYCAYAAACAfB8PAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAP+lSURBVHhebL0FXFVruy2+7/mfc8+3v93b7u7u7u7u7u5EUQEbBQQDFAMFsUEBuwMDE7sVBUVUsAth/Md4F6+Hu+/d+zedi5VzrTnmE+MZz/P+VL16TZQuXRYVK1ZGpUpVzL5qtRqoXqMWKvB2qVKl+HhplCtXDlWqVEH16tX5vEooW7Ysypcvj6pVq6JatWrmMd2uXLmyeUyvsXs9r0KFCuY99Fo9T3vdp+fY16d/XO+jTY/VqlXL7PXZNWvWRI0aNcx9+rtalaqoWb2G2VevyuOoVBnly5ZD1cpVUKMaH69RHTVq1UTN2rXMpr+rVq9mbtdv2AD169dHnTp1zPHrOLXXe2urW7cuatetg+o1a5jn6330Wm1VqlU1+1p1av+4X/fp/fUaPb9yVf5eacek49IxatOx2U3fy35PfR99Nx2Pbuv30Xvoc/TZOg69vz6zbv16aNi4EbcGvF2Hn1kLderV5nP4flX5G1evYvaVqlRGxcqVzPHqtfZvva/uK1+xgtnsd9Rn6flly5cz95cpVxalypT+sS9ZupT5u1iJ4mbT7SLFiprbRYsXM3u99qfixYsjZ86cKFCgAAoVKmQ2PVi8ZAkUKFQQefLkQf78+ZEvXz7kzZvX3C5YsKB5XpEiRczrihUrhqJFi5pN9+t5dtPjuq330Xvo78KFC5vn2cf0nvbz7Xvob71/4aJFzIHnK8Bj4GYPXveZx/gcvcYeg/42r+NnmI3Psd/HvlY/TumyZcymC0fP03fSe+j30FaiRAnzvvodChbmd+Xn/fhM3i5UxPHe2nRbv5U23bbP0+v0Pe331d4emz7P/p3+97Tfw/6+6U+abus72H2JUiVhT7T9TD1ufzPd1jHlL1jAfAd7rLqt+/Lm5znllidfXvM83W8fy52X54u/t56n27ny5Dabnqv7dTtHrpw/9rqdKUtmZM+ZwxzTT/oiuXLlMj+mrIz90YU6A660E6wf2f4Qeo1OiKyNToC1TLqtx+zJtT+e/XHtj6rnlSlTxrxWJ93+UPps/Vj2b3PieUVosz+ovZLSg0Ov0ZWlvTZ77HpvPa9chfI/rlTdtu+hq1fHoE3fX99DVlPHJuul27pq9fk6Fn2G3exx2cf0Ofq9tOlz7XFor+dob4/H/m1ekwZiewwlSxIs3PS3Pl/PtZZDx64t/fHoMd2n49JtWRt7jPa59pi0t7+b/U3txabHdIz6ntrbC1LHbAFpLxqdHwvY9PdlyZYV2vTePwksuXPnNi5A5rVOPYf5b9CoodlkdmXWtbcmXuZSZlX36zX1GtQ3t6051XvotfaxJs2aGrejE6mTqr2ea/ZyMXzvWvpcvpdu1+Tn15WboqnXe6X/bH2W3lvHott6XTW5CbkeHpc2vYf+1qbXWvel12izLkGfr03HpuOXa9Cmk6P7rfvQ6+130+t1THazx6Pvmv73ketq3LQJGjVp/OO30LHY38b+Pnpf+zvpc+Si9Fpt1u3pfbQ1bd7MHKuep+MTSCpUqmiApPdp0aolmrVoblyk9vrddXz6TH0/e16bt2xhnqv303P0XN3WZu/X8enY9bj9fPtd9J7a9Dmt2rQ2j+v9ZdkELAH6J10dckX6UL2x3lBfyp44+4Pp4HTbgk9/6831wfoACyz7Wr2PfgQdtD5cP6q9qtLHDBX4A2mrQqBakNXjaxvyYLWvw88QUHRbQPsBOP1gaVt6cOl9tAmketzGSPYE6vh124JIex2/7teJ1Im1VkB7e6J1/Bbg9rvr++s76gfXe+i23ke/gZ6r36YFv3sTnWRuDfg8HZP2jflb67vo83WM9jfUb6P3sX/rM/4JLAtqXaTWiulz27ZvZ35r/eYtW7f6P0Ch99M50THpMW0CUeu2bdCuQ3uz19/2foFP76X77Kb79F11TNrrb32WjlffQW40Z+5c5vf7SSdbflQHK2DpS9irUifM/kg2SLXAsSfMAsherTppuq0P1nvZA7YnzL63DYYr8kSWkSnnptuyPvrxBSILLAFFx2KBpft1Uqx1017P0Wvt++lvWa/yFRjIMhmpVZuWj5uSkmpMWGrUJFD4d5WqfF4VWiTer61SZSYg/FuvMXu+R3orpdvW8lhLoJNqEgFuxoqmgdBcWM1pGZrRQrRsbfZ16xF83Oo3aITadQhyfqaOpUHDxuZ+fW7NWrSsfEy3baKhz7IWxJ5QXQgClk1ErMWxwNHz9Ptr022BSpueJ0BY8LTv2OEHKAUmvV57vc6+l/1br7MWy3o1a3DkHhVjGYsl1FtgCQj6YGOm+aPIglg3YH8s7e2PaK80i2I9lh5Y1pzqQGxco9fY7MpkTWku0V55Mu32ZOp1sjxVlQ0RNNZqaa9NLlObHrPPEbBkAbUvyyunArOwiszMKjFDrKzssZZcrVwuQVWjpgFP2XIVDKAqMisuU5aZIcEm8OkxvY/eW5sFsnW99rO1txZSv5s2Yy157I0a82Q2pashqHRbAKpXn78vQVSnbn3zOQKXgKb7LcDthaDvaX+DSrRuOie6T1YvvcWz4Yq1ShY4TQkobbKQ8gJ2ayQXKNcpq0VLZ7dW7doaK6t98zSrZoEsy2XdnrXe1trrXAlYWbNnM3HaT6XLluId+YnCuiZ1bdSEJ60xf5QGdVChasX/I3ZKH29Zc2yvVhu7CBS6z8ZVNs23aat1M4pjBCJtihd0vw2AdWA2Dqtel9aoFuOxGkztGzCea8K4qxFPXmPGf/zbfq61gAKtPt/GTAKUwKVNtw2YCDDd1iaLJlpF1kGg0qaTK3Bp08mU5bMnVSCy9wlgFmyyqBZg1tqauJFWsT4Bo31NWibdrkdQ6XYtWiZ9hiyUtWAWaAKWgKb3F7D03rqt99Zm41BZNr2HvoNeq/cSYAVkWUsBSKBKvwmUNtwQsFrKohFEui0Q2vt023ocGy9aV2/DHN1vjY6ApexQ5/onZQBKOXUibDAn0NjgV4jUC9PzQTbeMu6PV79+eF09+gGq16mB+k1o6rkJnHpfAcVmHZYzsa7RxjUCmJ6nH6lkqTIoVpyZUUnyZ+UrGpelH0ybrnidBLkPY1kUU/HkW67KBvb2eK1F1PsLzDZA1m0DvjTrZK2VrJcslQCn+3Sy7Mm2x6C/LdcnEOpEWvdmrZG1QHquTr61ULqtY7efob0FUfMWrczzdEzW0un4jeVO48Z0PuQhdGKt9dD3twG8HrPJgInN0kClGO+ftwVQG/7YkMa6OeuVbNxt40ebqFkezb5Ov791hYZu0D8WWDoQvdCQcWlZlb36baxlQaW9cWnKatJMv14jMDVtxeyibUtj+fTDyA1azkXAsgSjJf9sIK2TqRMhqyFQFS/BdJybvd+ePJ1MnRBteq3cqN5LX15f1JKXui/9DyUgWYJQewM+nmS9n0AkUGkTaKxr1GMCg8CjvY3TTPyTRiQLcDZms8+1F4D29nV6D3tBWIuo97PPbdioiQGWvU/vq4vaJgn6bjYI117nS+fBXkQWUOkzaes2LahkwQQyWSWz52aBajNIa4Hs+9hzbjFgg3cHQetICgR8hVTKCnWu6QrLGMLLZk2WmZbZNWY+jXG2KbC1DDYdViwhUyqzL5DJzDZvw2CVwKpZz8F0yzoIwJZTsum8ZXhN/EVQ2VhHwJLVKlqMnBAtl/YCmB63zxMQdPJliSyvYzMova82AU4g03ew2atllu0x6CRaIMk66nMNYGk1jMViTFa7vuImWu56ylBFb9Di0J3a2E1/V69NEPBxPc9uep0sj7W42qe3djapsFYufWBvAWlPrkDzTwpHsY/ut5mlfW76E25dpnWJdm8tmKUn7AVoDYbOb/rPti7Q/sZ6Xfrj0UUtTitbjuwOHkvAEtJskG65Gx2QwPJ/Wag0DksI1YfZA1UWJiDKLyv4a9a6OarWclgVAUAWSCfNWgWdRN1WbKDbAkzpMiQn00DlABYZct6nzb6+FMtP2vQ87fUe2gt8+qzGTZqZvV6jx/Te2nQSrQsSYKwLklWwmaGOQUC28Yp5DYEkgNRpoCCa1iQNXDZW017AsnuFBtr0XPNaWjlt+hy9nz7Lukabnaa3djZTlKUU4GwW9iNTT+MTrfVSQG1BYakhWSBtxpqpnCVeUpxUmju0Abzus9xU+qzWnnOb9VluU3ub4Gmv16QHn4ClrNAE7zJb8o0/AJVWU5NbMwFjGqelL2avdrkYmUtDxBFAdRs5gksdsA3+dNDlaE10UnUiLUAsEGygbIFlrYUAVKKkwFOeVoosMP/WCbdA1OsFOoHJAlG3ZdG0tydQ758euBZg+jwLLFkIWRpreRTgFyvFuI51vao1RbA6YkibRQpUApj2ekybnidg/fP5eo7u16bbelzvK0tnLZreV++h5wiE9v3tZzZu7gik5c5sZqqL3Waeul+/t3533Wf5Mev25E1MZi8KiEZA99vn67k2iLcJgc22bfZtn2P5Qvt5lpczn5NGTwknCqlksUzwbmuCli+xBKhN4eUiLYJtEde6TRPYNeUPXb82GjVvbH4EfUl9oA5Cab9OqCyWNgHExk8WHCUJnFICCrcSiqmKEVjFy6BkCZZouLdBvCySgGPfQ+8jkFig6nP0uAWytYB6XECyMZQNyrU3cRpPdNmKdMPcyrM4XJIFbAFAYLMuTtZIGaTAYUFmAWUpDAsga9lksSzwtNfr9Z56vQWndbH2ufocPde6W72nrL+8gsBRnu5dQLHAEiAsWKxF0jmwXsTyftZIWOBZwOhc6TnaW5DZmEx/2+zWnlP7+h9eKY3pt3G5BZYpQtus0Fblf5RP0vgha7EsR6XnabOEqgClTQG79rJc+hGUKRpGPS1tlxswagmefFkhAUabgCV1hYCl2wJWsaKlUKQwi8BFShpLZOMsgckG1RZg1t3pft22llGP63P0GoFNn63betxaPwO+8rSABFOpcnweAaW/dVubQGNBZSkL/W3vS8+P2dvWJcr6ODJmRyym9xa4/l8WUECzcZtApb+1CWTW+sji2HKVTrgNwnXSrYvTfXbT63Tb8n0KUyzxrNenB9c/gZX+cYHYAku3LU1hKwnW7QpcYt7lCo3FUqClSrUNAG25RW8ikFg2WdbK1tysxZL/b9yC7o+gUgYoyyVQlSZiRU6aKz4dm22tik6uwFK4SDFjpSyoZKEELAGqcCHKMLgvUpTyjDTqwbo/WR8BVUCyhKaAYzkpAcrGXfosgdMCzLpP6yrl+kqUoVsloGSxylSoiOKlGd+VLPUDWLJOAojlwixY9LdeI+Bos0DU8wUQAcNaRL2/dYWWpBX4tFmLZV2i/m7QpKlxmQKIyEsRltblaS/QmBhJJTX+bb2FTrwlQ/W4XOePummaG9X91lrp9dYypXeB6a1UepdoQWdLbgKUzSxVrP4RvMsVKitU+m3rfQKODsa+iS0Oi4XWZutx9kD0PLlObSIP9biNx6zmRxmaTrhcmiOOoo6HoNFWoGBh87cFXKHCRU2cpc0CUCe6cHFW52lddEItEGRZBAa5Mp043bZA0UnV30VKkBMjeLQJNHqu7ne8hwBRi++rE0/qgluFKtX5GDNZ3qfHdZ+eU6laTfNYxapyS7LIDjZfx2PdmAWVgOVwqToGgp7Pr1rzf2IyG19pb62gXqPNuksBrEkrJkPtWFpp3xZNW7dE7YYORt8G4NaipY+TrGUywErL7LXXubCVE1shse5YFlJArtdI9UzH7YZNWfROI2QFUG3pA3+5RJsZKutWEpg5axZHSUcSCFkspd/W3RnLJGIurXQgyyUzbANIW+awPl7WTY9ZhYIBXFph0iog5D5lOWysZG/nyZsf2gQmSysIbArcHQG84zUClgAiIMlKWHclcFj3pb0Ao03PsZmbrIkeEzD1Ov0tkOn9BBaBplQ5Ug0EksBSo059sy9YtARfQ4vKxwQKPU8AEVjs66xFErisZbOf6zgWxoEVVWYSCAVOR6xmg3Zr6WzMJlBZK6YTLGAJVM3bMtNu0wqNWjQzwNKW3mWlL3cJWDon5nykKTpskd0qOnTyTfmMx2ITDX0XG+PZvXV96Wuzen97v86r3kfnWVmhFA4mxlJGKFJLfjF9DU9AMkVo1f/4IoHJqg9klUwdTAVNcSlpdUXrg80XTgOXVTvqC9rSg9yQdXH58lOIVoBCujTrJSDJRYpqELgsl1WoGHVBacCwlknWy27WIqUHmkBkg3G9RkCyFstauio1apuTLvAUKEK3W6qsAYCAJKtVvDRdKTfdFki0CVh6jl5rsz0bQwlgsog6Dn2WwCpgWcun51mXKpAJfNaFCpCWqrAAU/lKgBKwLLhMhYPnxNYLjbworTZpQWcL+Pb31/mwrLmV0Oic2GORGxbIbaxpga5zbeMz61b/j1IW8SGWQABTjCVgGYslvyjzJfLSkqOmTJK26Y0tp5W+HqbgTfUlK/+w1srudYVYM6yrxJRS0vglGwPZYNpmiNYtCmyFi5Qg2BwxlsBWoEhRWhAqPHmydNJ08gQax8n7H4BZq6UfSGBTDCVA2efK8tlg3fE+VWgNaR0JrELFGNvRQglcApLuEyD0t6xXkRKM3dLuk8USsHQyrCvWSRJwbJapvUCp11iLaAFtYzO9xtYutbe0g/bGmrAe+k9g2QvZ4Z4cpKxcmnWvlnszMVwac/9PVt5yXumzUH0P/cb5C1MZy4tYv58tuFvAyuBYFco/6ShZLNUKHXosAkoaGpmv9HpwuTZldekRaykIU2OipRKw0uum9LglSq3uSSUcKwMWSPLmo+SYe8VTCrAVdGsT2PSY4i0Bq2Ahh9WSxRLw9IVltQQMbdaVpQeKQKbNWi8BSKARWGQ5dJJ1WwCxANL9Ao1OvB4XiAQwbbpfj+s+PV/vVaKMYjpHzKRNtxWDWYtkrZN1lXq+Xq/P1N5aBFkry3+lD/7Tx2iG3qhPuQzdn+IrbXKNuqh1DhyhicOV2SzUUhwCqUButWlG9CgNXZrGzUqPxOWJiNVFr3jWJkg2NNG50zm0Vs6KPK2MSnGbpaOkRv2RFSp4F/+gGMsqK41CUUJ7ifBVkkmTjmgvxNrYy6acNuXVwSsjlLbK0hLKOq1qoWChIgQMrwa6Oh24ACZAKcuTVVKsZUs5efNRo22slsNiWVco66Pb2mTF7JWlEyZQyUJZ8Om23JsAYwEksGjLnZ96dIJHj+mk63GBwLo+C0T7mH1eerdogarXadNztem2gCqrJ6DZ1zosoSP7tMH+P7NNq8CwfFllNo/UaqAgnuqDNm3QoBlVny1a8qJuY6yUjdls3CZg6b1lCXWB2bDFqjCscPKH1CdNuqMs23KAApuqAZbEVrZtwxgZBFu1UOXAEutKBhSvy2IZ5l2RvCyW1UH9qLNJ0kKLZdWZ1iRawZ0l1GygKAumxwSsogSrLTbr/fRBRs+eVlgWsGxslbdgIeOaBIZ8hQqb2wKPTnzegmxUIAC1yTzLallgCVTWZAtA1h3auMpaL51oWRqBSO8ny6MtZ94C/DwmDHxMJ9wCxoJClkjA0GMCmV5jgWhBo9dYN6rn6LZ9n/SuVO9pP0cnWy5SVuqfWrF/Wi7Dl7Frp2ptCgEJKAGrTiNH5ta0JZUQdIE2UUlPe+i25eSs27LAsvIb7U0QTmslDlBAElAEIt1ODyxb4tLjeq4VIxpuUtUViTR5ngUsYckASxmhxFlyheklJSrHyDrZDMDuf5hQBuyWsNPB2+BRFk4Wy6oHrLjfFIVJVMr6yCoJLJmzZOMJzmcAIsBoL3Bpy1+4mAGXLJasnACox621cjynyA+3J3BZTsrGVQ4QOgClvUCmvayYNgFEABIo9HnWsggE1oVqr9fpcWuNLHisK7R7axkFKusC9f7WFTosmiOz1YnX3rpEWS4LDmvFBMAqbEMrp9Y6gqthc6o3m4gtV3WjhbFYNhSwcZ7e015ojs9RnMgqg2q8aWoUm4QZq5Wm55LXsLo0gUcuUVbKFuitykPg0vP0HFOoTyv2a6/g/UdJR6YrY+ZMpgtG5szyHToYHZQRw6WRgLakUIOqhUYkRuuSFLUablkrZQemYSKNuDQqTH4hWTG9VmZZX1buS/FUjpy5kS07W88YV+XOQ4AxO5RVypWPFEQBZosETv4CRegiC9LCFWYMUNrEXvpbez2mH1Zgs9ZM721iMXYcFWDHkECVp4ADqAKT3KCslfY64cXkCmXRFHsJRIrJCICCAiCfYzJFPsfc1msUjMvFMa4qJamN4itllbJuaS63WEnGcqogcC9XKJDZ2M6CzAb1Niuz2aT9rW0SoOxUWajAX6ueegFa0Jrwt65SI43nY7zIkEG/ja2v6nbJUiKhHeSvtvTu12aAhj8jOKxqVSAS0Gz5zVoyK9O2ggJLRstQ/AAfz7sV+gkHxhWqH0xmzOqiTIuUkfUqSHVwRroiBDSjaGzIKnfLpmZvKQcBzCgr1YyQplTQARSnCyym/jf18TG+EBAEGAEre45c+DtDJmO5BDLjHtNcnr3qLIC015Y7TwHkys0+xIJsQeImS2Y3aw1Mul+R9AGBJVAJSAKIwCWLpb29LRAJMPn5uMAlcGjT7XwWjHyNuc3nFSUYtRUnWEoq6VBwL5eYBlJZwRKlK6AQy1L5WT0oQ2AJdPZxvU7P114g1nHKItmtPJt5tZVhQ695LC0xEEAtyEyGajJmlbwcKhBt+lsgK1SY1IzNqmkh9Vtai2apEMvnWc29tUQCkayXzqHVwRmJdppMySpBjGQpLfEyZTYaDgss3TZ0g8yXgnhZG/lMo4+SpkkgIbAECEdR1qE7r0d1qIAly2ULk7JYpuMmTdFgswsBVBZLVsSCRlZF2Z6AlDVbLmTImNXss+fIYyyMfkRtusoFAN0nYCgmEkhy5GHDZL6C5n5tuq37BRrDNfG1Onm5CSobq9l4ybpCvU6uSZbJWieBS5v+tuDR5+bl5+q9tBcY9JiAV5juwlo8+3ztZa0ErHwFi6GkiFeBjQAUwOzf2gvUAlEFdkNrb8FVlh3gApb+lpsVWNNTIDZjFZgEIm32tgClTRehQGdDBEuxpAeYoTcYT1lFiFWDpBcNCDy2ucRItdN6AyyorEZO5110w48uHQFLf4ggtT11pv06LRu0nIwV8Rt6gbpzAasma4NGNZpG2Bk1g4CZppEylMI/mG6BSoG3o1TD27Q6cm05cuY14BJ4RD7K/MvaCDTZcuU1ANFjdtPfOukCmW5b16aTJRBk5/05+dpcfEx7gcUCR9ZH9+URYHn1W+DYv/Ue1pLpGCyo9F7WHQpYBVWTJFgENgtQx56Psc4pi6X30ePWher5pdPAL6slAAlUCtKVAVZka72AJWulTQA0Fi4te9X31PfWRWFiOZa9rFVXJi2QCVAWcAKWpWB0Lmzpyyo4rKjRNpX8UH2kWSllhvY+a8msWkSvsY/b4F0EqUBmSjqWe7CSYUuQCii2+8UG70bYT25F4KpWx9EkauuEVtVgrZwpOqcFqJaw1JfUD2OvKgFLsYBiqJy58v1wWwqaZYUssOxtAUs/rrVWul9WzcZLOuHpgZWDj2fLnQ9ZCU4LNN2nzYJLgBK4rLWyFkz36fP1fgKjgKXnGmslXkoXkLRmEjLSIul+8xp+F235eeHoPQVGPV/PsZt1kRZwitMq8YKqoNpimvsUCM3nKHYjwGwSIYuluE1u0lYHbMJgrZl+H/vbWM7O0ik2MzZJSJq40ro+7W2MZbNB6/bSK0csuW0tloClOF0t+MYVqoVaWaHogPQDL+QKrTtU7GQ3AUmdMyo1aF+1NnXv3Cwd4ShE86pLK2sIZNos72RTf11lJkbiVSYzrkBcmyzQ35mzITvBIEukv63rs3sBSwCTJdN9+hEFhvQuSwCwQBIgBC7tLdAsqLIxXsvNzy3A+ESWJi+PS6DIoxhO99Hy5OQxZmdsl4OWVfcLMIVpFYordpLiVbEWT4gFlp6XlReJXqPn6n20FVFRnfXPogysi5cRyBzWSKApJ8JVxW9aMwHKbrJqFoxyswKHwgQLJGu9bCyWPpsVgAQeCyhLk+gitNSIrYJYFa/N+Ky8SKCysiOr/hX4FOpYRbBRldBKyfsJWAqpfhLKLKmlO35MIUkDlm0/0t7KXNV6pU2AUmuWARatlx43TaJpcZmyEZsOa6/MzYJCgBKQ7F63ZcUEmCw5chtg2dv624JIe1kRWSldkVlycmAFAaMrW9ZBgJGFyUOuLD/drcAmMGXWe6a5R3uf/s5CF6xNIBCoBADtBSYBxAIrM+M/PUcgtKArwM8sTqssyyWAFZGEmlapZDlZmjLm9fnomgRY7fXeApXdBDS5SQssgUuA0nvY4N4CL721s+SttVwCj6VTLG9nuTeBSSCylEt6SsXQIzye0gR5GYK8LI+7fAX1ElQ3LtZxn6PBxAbwVs1raSMLOhtjCVgKqUzwLtmM7fPTXsVoy7wLUJYMtU2ZslYCUumK5GHY76fbNeqR8SXIZOWsJMXW6hQ46nb6coqslcAkF6gYS38rLrAmPCsBI3ApxtHtzNlzGeuUMWsO/JkxiwGVnpsxW0789jczSwLHujTtszHrzJybcRuBKPAJcNoEMlk3gVHuTUARYCxoBABtsjSF6KJz5nFYKQFNmyycNoEvN1+vOEuAkksUyPTeApU2vXdOHkt+uWc+N49iI2WFCtx5UnV/IXJ6er1eK3Dq/ZQUWKDaZEEXjsBmEgCBN42QFWiUsFgOzZagrOxHwNLvrovR0i6WKDYkLi2ogCUgKTYTmCpWUnnHQV9YKfg/LZrVt6UHlngsAUuhlAGWSFLbPGpnKViCVO1c2gQuW4jU3mZ7ZStXNMCqWJ0pJ7eSnNJSnFNbFJTqtvgk7RWQKjAV0adgVffl5igfWSXLNcn12axPoJJ1MhaKJzJL5pzIkT0vMmbKjuy5CiIDb2fmSc/N7a+M2fD7X5nTTiQ7RcSRkRMTsDLzfbLInRKgFhQGIDnzIXO23MiYi0ApmBOZSdRmzl2Cry2ITLnyIE9hukGe5Kx5iiBLbsVMtKTZHVbLvB9J20wsQdm03rDwclU84XkLqWSkrRSyy/2ajJLZrTg4XUA8aQKYwFWoJMdGlXEUfE09kdxXyTKOLLAIJ/rYrNNybXKV6Tm3YpyMYzk73S7FmVolOKXGBP78jW0lQ57C/p42DBGQbNyUvichvYRcFkyWTOArV95BjCp4F6AELt1WZqlKi8IqBe+Gx7I0vG2BNw0QaWytmQLDzE/NEgre5eoEPIHKzlqwgCpflYE+QSNA2S+mL6kfxwJNgNJzanLYmepfApuAZTM+uTddWTaW0v0Ch1xcjtzk2zLnIO+VFdmz5yeYcuDXv7Lgjz//pkXLhcyc8ZWRZO8vmTLiN/Jy2WiF8zAx0f1ZOU1HVkwuUhZMbi0jM1Bt2TMzo8zHmiOpgWJFNSMrH0oUpXy5OIlhxp1i/fOTFimQn5aNrxO4/sqc3YA6MwGaicRuDlYR8vIkFZBCgj92Lma9OTlopTDDjLwKNdQhXJDPK0i3XYDzxnhl25ldeYswoyzBklEpxmgly6MAgZWfgC5AkBSp4CBmZQUFLFlZ3Raw7CZQ6TcWZ1dI45h4UQtQ+u3N7bQSmc2gdcEa+oYAl5WysZRtMLF9BLZOKEBpE8AqVHTEW3bTa+2sC7EKtu5sskJLw9sZUpYyELgslWBB5YifJCdx1LtMTaqK+BZHyiyg6IvqS1mLpauoMCfaaNMX14+gx2W99APYdN9mXPrhLB0g1/VHjhzGmmSgq/vt78zGMv3JTVYqO63NH9lzI1NOB9AyZ86NDBly4d+/Z8HvWRhTFSmFv0TC0o0KpCXIL1WmqW9WswG6t2iLIZ17YmrvYZg9fBTmjhqFReNHw3vaSKyYNQ5Lp03CsumTsWTiBLiPGoM5fM7kXv0wvEMPdGvUGm1qU19eqQ5KVCyHPEULIWu+3MjPKzY/+UABKUOeXMhEMBXIURy5slOnRCCajJGgyqXMthgpiBLk6soxseEx5ZbyQz2UBKbDSpVNs3CK6Rh/0popJtR7WOpE9/0AmCxcWuXAErCmGpAmG0pfyrISIOsCFWfJKskFCkC6X38r1tLeukex/Ta4t2WfH00yxITidVksM23GVqTtUA6rThDArA7LzisQ2GSpLBNvZMBpZldknq4QAUiA0f2GpU4rreiKysdJe/k5wC0vZ3JpL1eoeKI8Sz9lSb6ZEgn3ckFZaAmy01LIlf3OLPHfjKMELAXaGbLSCjHrUhyUlS4vO63Kn1ly4Y+M2fHnn1nxx++Z8fdf2cwJLUu307JBY4wbMABeM5yw2Xsh9q/xxqmg5biwbRWuhq/DxVBf7tfjRsQ2XA3bhOu71+P2fu7DNuPmvgDc2LMe1/ZuwMWda3F+5zoc3+SHvWs8sWmJC1bMmI25I8dico/+GNCsPVpVY/t/2XooWbwuLWkl/JY/F36n1cyci4F/vuKcbKjEgGAhYZyPczPysvJRQoPlSnESX0kWxUs7appKGrJlEyXiSCLSu1F9b8WBSgLshWhjMVuSEugMx8YLWZvAZPVm2tsaaHqS1cZVApIAVqWqutLV/aSZFo77bF+Bra7YjnAF7MKSgGViLCtNFrDMNDd+Sbk6WScBys6tssy6rT1pbwg3WikLJBMTyITzypElUrApcNkvK0skt6Yr0BKXOVknFA9UgU0XZUi4CVz5yMr/zRri75nFyDMOYlyVgW7w9wxZTPwjC5aTpZ9srCfmyJcL2Xjy/spJMOXKQuBxohzLPO1r1cek7v2wyd0ZJ4P9cDlsAy7sWovLEetxMWwNzu9ahSt71uHSnrXcb8TFiLU4s9Mb58NX4vS2FTgTsgRR4e44t30xTm9ZhJMbF+JE4Hyc3eKBKyE+uLl7Be7sWYF7Eb44t2Eujvm7YufiyQicMx5zR/fFpAHd0Ld9M9ThcRRnK1tWAitDTrpzxmo5pK6gZctcuADy8D61uulEF2TpSxYvH8swBXnB5aSLVVyouM4mDDYpENCUbcpi6fe0v62tGlig6Xxo0+MKO+QSBSwrXrQJlJIo3bYEqwWSo7dT1ILNHh1d6qIb5D5tF5aApSRQ1JWJseywrB9jBRlXWP2VpQ9sX5oslFVyWlWmLJWxTrRMskLpQWTZaBtsyoxrsxyTsrWs0rxLn8WDLSBNFm/nUmBMAP2L8dOvv/yFv/5mFkhXIleg5yvukjXLyPpiRr6H3GLubHlQv1Jt9GvZCRO7D8Dc4ROwcvpchHn74VhAIPav8kOErxdOblqJ82FrcW7XSm7LcW33UtzZH4DLu7xwfd9CXIuYiwsh0xAZPAWRG2fhcKAb9qyejl0rpnJzQtjyKdjhNQrbFw1FiOcQ7FrUE8GuHc22aW5XRPgMwnrntvAcWB0zOhSDW+dqGNeqCnrU5cREsegFyNnlV8lH9Ui6u+IVkbdUZWQvVha5SzGrpGssTHcoiyMFh+JBWS3tLY+mvck4eb8tjuu3tnGkzoGSCJNM8Nxos5ZN4LJ1UoUHyshtScjWGmW5bFyl29aq6bbtVLfqB9UaTYc3gaW6s8qDxhXKLyorVPBl5nwyTrD6dgHKsuoqAQhUWXLkJA2Qx/BTRtdN92ctldygzV70RRQsWwtlLZeuHKX8AtWfmTizMo0KsGy5gmtLYv6dha4tUza6uKwGQMr0ZOlEPWSiNcvMLQ/jrLqVahlATe7cD7N6DIL7kFHwHDcBy6ZNx1rXpdgwbxnWuMxB8EJXWh0CiNbm7gFvujt3XNg+A8fXj8fRgOF4enwpti8YjHXOneE3sT28hvSCp5sbPGfPx+J57vBy94aP1wosX+oHX58V8PddAR+/nQhYH46NAcHY6OsL/0WL4O/uA49ZSzBrwiKM5PEMbN0WvetXQfcqBdCuXFa0KJsDDcrmQ/WS+VhXzMuTTsvF7Dy3ykDFytG6kEsjaPIoHEjj16zVEqgsPaJwQL+btVICmSV+TZFcQNasVwJLf+sCNySx+DyeAwXyqnZYS6WAXpZLe4FJlkp7W3YTAO14A8ttpQeWitACltFj2azQDoeVGkEclsozlm0XwBSoqxwjSUu2XLlNemwKmnSFBTmgVeASePTl9GUtsSc2OX3xVqARoLT9noHui+ARmLTPQI5KP5Jea61aBlqnP+gWfyWI5B71oygIr1ejDrq36YR5Q/pjtetUbFu+ALs3eOPoVrqmnasIGMZNIX64vscFD48txuMTS/DgkBeitrhg64IB8B7dGm596mHGoAFYNHEglrl1xL2za7FhwUIsd5oLH2dao3VjcO38McQ+uIYX8U8R9yIeMQkv8OTVSzxKeIb7z2NwO/457j+8gtirIUi85I8TAWOxf8NsROzYhP2Hz+LIsVsI3XkBa9ceg9eiELhO8YHTsImY2rcnJnVrgaldqmJ466poW5sy7RIMzMWPEWBZeQFmYUwql6eYypK2NuZSrCn3qN/TXsC2Tqoqg0BkwKTpz0qo0mQ9eq4VORpeMU0Roc+17tDKcOQG9biApccdMZij29xOQbTTByVdtnXnH8G7LUIrtnKAim1KLIraTVmc5UWyc7S2gKSDFqciPZIAZZQEaVePvpSuHFmnH1eJ6n68WgQikZra6/mZs+RgCp+PwTctGIGVLT85pOLkfegWc/Lq/bNAPvzC9D5ntvxox2xu3oB+2OwyEUfWzmec5IfoQwys9wTh3oFN3K/A9cNLcfeYFx4dnIWYsOG4FDgaId6DsMSpCxaO6Yr5Ewdj6ZJFOHD0JO7fj8f9T0DCByD6xA7cOOiOFe5j8fLze5y6cBRrFo7D3mW9cXL9BOMWI7ctQFTYYlzYvQi3ji3DvVOr8PDIcsQcX4D7x5Zg45JZmDN2GDPKntjp3R+7lw/GgS1e2B24CPuCPbn3wJ4gT+wP8kboqvnY7jsPwbSQ2+d1Q6hLe4xvUhCtK+dGg1pSudKT5C1DF0mSluGBLFreYowpi7LuWZAXtwjfnLRecmd8XNxdTha9cxUpi18z5TbqCnWWF6RbdBCzdIf821QjmDwZ1UZaKUwXskBmCWmrlDU9AOLcCC4F8Iqz7DQeW0cUbSQZtTybZRiEIdP+ZedG2kBdwLIkpkyp5UYUpCuzM/dJH67qPOtWJjBMC8xlnXTbsN+8chQXiRWXNfqL2Z21UCZeIrh++ysj/spGNj1rdhMrZcyQjVdOEZSmTCd/eTaXEsQ92zTD2nnTcDRoKaIZaN+P3M0TG4I7x7bi7k5fPKQlenxiDt5cXIQ7O0bjiHdXE+e4j2iJpVPHYO0yHxw5egrPE97jO4APqSl4kZiAR7du4GoU3+tUIC6Fz8GmxWMQunYzvn0F3nG7de8Z/BavwLI5U+A7ewTWuo9HyMqZ2OwzHeu9pmPF4gkE32D4zXHCkukuWOo6C7evXEJ4xH74L1+OtYumYcGE0XAbPQSuowbCeWgvuAzvCU+nwVizYAJC/WfjRLArLkR44vDG2Vg9rTemtCyGTuX/hZbVsqFi2YIm0xJBnD07Y6ECPNGFqzDzKkV6g1wZweAggFkHZVyas0AxtO3WH4NGT2GHejvDzjuCfgbtaqtjYvYjIxdpKxFkWuAvVl4EqmIwW2N0FKnJRRJYDlA5OtjtIBdDjtazg01qOo6VYZUSvx9ZoUgt22VjZLO0UjKjNuOTldLfeTgQX6ZVgFIlXmi3chK5QQsqxVYCVibGQwKQoy4nYjKnAZnc4H//+gd+zZqV4Pobv/3yK37/LQN+/zsXfv4tMwnJvOjbpTW2esxgBrYBjw4F4/GxLXh0chtuHw4gmHxxN3wB3h7xxpPw+TiwdCiWjG4Gn8m9sdnXAwcPHMWdp0mIIZISCKbnb9/jetQ5nNwehKObvHA0eCYOrR6Fkyt74djyodjsOYmx0zLcfvAWqanA15TveP7pK2I/AneeJ+DG42e4E5uAM2eP4ehOfxwKWICjG9xwbNUEHPKfiuMbJuLctlE4u20c7p1YhecXQnDYfzJWz+2GlS5dsNqtF/xde2PVrH7cBmLljCFYN3s01njMRMTGAAQvX4O1873gSx7NqX05dC76O5pl+RMlcmZB/jysNhQigPjbZybxmpVlkyz5SQjny4LspC4UyMslKuaqWbcFTkXdRMyLDzh4+gKcZroZpl/gkoFQgqVzaFUaNvbVuRO4bIeS7SpSuchaMEfhmy47bbSAwiPj1cx812o/gGUsli3pmNHTfFDu0Aj+GTsJXMr6BC4dkMAlxCtIr8i+uhp1G/yQk9igXF9AQLKgEqC0WemKgCVQ/fz7X/jXb3/ivwmqP/j3H39mwr//yIT/75ffUapkcXjPmIg74cF4eXobnp8JwbOoMMSd3YoboQsQE+6Gd8cW4fzKgVg0tgamDWkG7/nzcOLIBcQ9jUXMw/N4+uQU7t89jusn9+Po9kXYuXIAQr17YZvXUAR6TUbQsjnYtmYZtgdtwNHQUFw8dgDXok/g4Z1IPI4+hFfP7iLh41c8JjCffErBm6+f8PDmcZwOXwqPKe3hM7UTlk3qBnfncVi2wBlrGOMFrlqIrd4TsNtnOE5vcsfOtcuwbvlaWrZlWDJ/MRbPnodFs12x0HUmXKdOwMxJo/k+I0jMNscq12bYuYYWcMkMBCxxhZ/zYIxuVAQtyxdA2fxZaKVIqxQoSeK1FMli/sbZ2cOnslR2h+oiE4lkXbi//5UdvQeOx42YJMR/AZJ5UfkzsVDYIi2c4bTSQhmVlKznUdIlY5C+00hA0iYOzDaNKGGzsytMP6R0ZGZ4SnVTTTBFaPFY6WdzixSVjFgHYAVotvZkXaJIzVxcrcIgnGZUoJHFsooBBd/pweS4khzBuTYB6w8Wkf/9x99my0Aq4f/795/46Zc/DeDk9k4ErcSrMxFIOLUDry7uw9tr+/Hk9HrcIh3w9qI/Lm93w+xBzeAyrBu279iFuwkJiOcPmPDhPeKuHUTSaR88CRuPc/59sHtBOwRObwLfqd2whCd05dI1iAgJwaUTEYi5fBCPzm/GtQOuiAzqh21zWmDTjBbYPqcdeatxuBu5gsH5A7z8loIbt87h2LbFGNmuKXwWzMfJM/tx+XIkrp8/hfORe3Exai/OnQhF9IHNOOjriuPBixB5YDWidnrhNIF9LHguDq51wb5VM822x28mdvvOQJCnK5ZMHoTZA9vAtXdtBLq1QfiyHpjcvRIGNauN0c2ro1+dCqidj/Ltn/+Lv9efxv39lYN0S25l6ZTokILJVpBeoQDrquTJKlZvirCjV3Dg8mNcuxeP97w4lq1c59CEqYmXoYxcY6E0mbWJsURvqGEkrdNIbtQqV60Vs+1rslCOnkWW+Kh+tRbLGinjCvWHVf1Jl56PMZc05Lb0YsszNuaSxVKcJWCl1zhZDsUE5IyptDkyvyymJie2/G8G6uJjMrEMIxpBTPovf2bAT//1M/LnK4wFThMZDIfizdlQJJ7bjjfREXh6KRzPzm3Cp2tbTKDsO2cwFsyh6zl/ES/5g31MplV5FIsrJ/bi8emleHeBcVbEAuwLWIZje/chICAAm1b74czucDyKvoLnd8/gYZQfDvj2wspRNTFjYGNMGdIKC12mIGjNRgSt3UoLsxzLmWkuG98GW2a0xt1963AgYBYOrhqFpWPb41DgHOxbPwa7l/TEXp9e2L10AMI9+2H3oh4Imd8SwfMJ5Mn1sHxEAyweVQeLRtbG/KHV4TagCuYOro6l45tgvUsnbFnQCwf9+uIUE4yojVNxfr0TIv1GY49HH6yZ2QcrZk7EjLFOcBk5BS4jJqJX6w4owZRfvQJS3OZi0pMzbzFkzJsbtVo3RLFqZZCBGXuFGk1x4PR9HLmagN0nbuDus0+If5OMNh27mqxb3ki8oQJ7yzXaEEb8lxIyab5s99KPEhCtl+3cti1sUr1ai2WFfsZi6Q9lhSJIxWGpQCryU6i2igS5Q92WC5R/NqWZNAZde8uiWwumuEpm2WGhchnhnLgXAUubirgC1a9/ZcJ//vvfqFKmFAPnuQTTfiRF7cSLs1vwPGo7np/bgTd3QvH50UGE+Llg+XxnXL10Ed8YA73/9h5Xb1/A4W1zcTJoKm6FjMbNncMQumI0Vi2nVXuUiKdIxesv8bh9IZiZmw+ukUlf6doLwztXwujebeC9cBlOR17Eu4+p+EqQfv78Gq9fXELcrShcjdiO8PkjGbv1RGTAMOxd0Q/7/Qdhw5zWWDKqESa3qI5xDethUOOKGNGyCia0rQnnLm0wvVcPTB3cEzOGdoLXyK5YMGIIFo0eTl5tBLzGj+Q2HB5jhsB95EDMHdKHQOuIWX0bwKVPTbj0JhCHt8Oqye2xybUtwt07YqN7B/jNaAvvqd3hN28qj3k+OnTugaxUT2QrKs1XYWQpnA+DXMagzZAu+DNPTtRo0BbHL8bh2PUkRJyNQdjJW4h9k4qd+48ZbkvGwUqrbaZoDYPN9q0iVsG83KNiLce8Cg00dkwnNHMoaLEc8yiIjzSljEp/RkFqp82onCOrpcYJAUn+U5bKEGxpdUAF8CYATEtVZTqFdhugy9VZnkp7yxYrsBSgZLm0/+XPjGZrXacx9mzwR9KVg3gRuRGJUVvxhlYq4XIEkp+ewfNTq5l1jcT+A7vxme7u0/fvuHX+IFn0KdjjNRDHl3XDfr8B2OQ9DSEbQnD66Bncv0nu6UYEXlw9hphbl7B1ySgsHlEb7hMGIHjdJty79xRvvn1HIt8vKfYhntwIo1tcj9jIlYhh7Haa1iPUexQCFvTE4vEDsJAs+uzuDTGNRehZJE39pgzFJpKtIaQPjm5ZzXJREGuJ63H16DpcPb4R946F4vHxUPJnQXgcuRmPTm3CI97/+AQTEG4PjwXjwVFmt0eCcP3gJlxlHfJKeCBOsSqwZ+V8+M0cBLehXTC8VRsMa1ILo1tUwbSOZeHepyKCndpjrXM/9KGFKlpE9E0B/JY3O3rNGIrFW5Yja4lC6Dl4PK4+/ISzdz5iR2QM9p5/ijPX4xD/9hu69e5v1B5Sfah6oZKaqAoZAm2WbLUNIza2Ug9CtVp1f4zVtINZZHQcWnpmj2lZoerNXP1LzRQ5HO1e1Tj/ipoqSWC0CYWKtYRKgUuAMkhPKx9YasGQbuRVBCodnFykrJXcYQ7pmHIzDshB3ipHfmTKSkvGUsy/fv4NnZq2wdld6/A6ag8Sz2zF6+gNeH83DO/uHgNencKJ1VQYLFiAR7HxYPaPVw+jsW+pE3bxhO/xHYagBeOxaaUfjhw4iBs3b+Pe9QuIv7IHb86txa0tk3BgSWfs9ehBhUIr+HpPN1buDbmERw+ice1oEG7t9cTl0Ik4tn4ENvE9Fw5vgbHtamFwsxqY0KUl5tCirJs7GQfXs264yx+3jm7CneN0yZGhjMuCcTZkHW4f3YLrB9bh2r6NLAlt5f2rf/wtsF1nEVvbjf0scqdt+tsUt/euw80DG3CDr795MAB3eUxxUTvw+upuvLwSztvbcSbcH+sWOmNKj67oRO1bk0LZMKR+IczrVQ5T2+RAi6J/k2rIjMakVpbt9UBP8nTzl27BjaepOPv0E/aefoCDtF6HLj7HnYR3CDmwhwlZIwwZ6QIPv2XwW7cRS1dtgLunL/xWb8SG4FDsORCJXgNHI1dBh7hQxkPusaoBlgL12kZvL3dpGz1EltsqjhQwPxUh6rPlyGpatAQqgUvivTKVNImFOpy09iRlhrJWApZ1g+n5KgHL0gmWozJEKLVSmbJlN7TDX9QyqRD7FzPAbhyKGxm+ifHTXrw5s5tB+i4kXtiJ5LsHue1C4NwRWL1xKwPPr/j+JQkXWCxWSr976WCsnzsGOwJW4eKlc7h+5xrOngjAxd1TcGxdT6ynC/Ge3A0LJvaE27hOmDOyI2bQ3ewO8MLd0yE4EuyGg+vGInRRN/iOqoUhTWqiX73KGN6sPuYP64cti+dQvbAK0XuDSRuE4N7xnbh9ZAeu7g/EVYLgCgERvW8DN9IWG5eRW1tJINFaMQ67Qlrk5sFgU9y+cZDWiM/7J6gsuAQsbdcIruv71/4A1/3jQXh6dhviLzIkuLQLb28fwJtb+xAbFYqruzdiG13hOFqyTszuupUtjlYl8qMUf9+GXephiM9ALNjiiS2Hj+Dykze4EZuM41ee4/BlAutSLKJICEc/eoJtEYfBhBFkUpD0Dcx4eZuhwIe0LPLYqYscpd7E6MNEK8ktaq9mj/QDUMxtVlakqTe6rzR1gwnetQ6hWf+EwLKgkuRYTLtQqOBdoDKqBS0a+Y8GT+sGrexXVsohpsvtIEOzZzL1o0xcBPM3psW/sTm1Y8OGOLdjHeLI9SSc3oBXlyIQx+zsy5P9SDhH1zerL8KP7OGXf4/nj67j0m6y3Vud4etC1n2tD57euoPX968jmsz3lS2jsd2lHVy61IDHuFHYHbof1x6w7PLyDW7evoGTmxch1GcoTgeOwn6fHlg2vC5GNiyOvtVLYXq3tgiY54QD65bR4uygCxPxGoYbR7YjmsC4uG8NAbXRgOraAbq7g4GIptWREkKW6sreQOxc7omzO1bjGsERvXctQbLZ4dr2+OM2ubf0lir97Vt8H20Cl+P2OrPdPkCOji407sw2vOTF9upiCD7e3M/fKAyPT4XgwfFwXNkVglDP5eTtZmJ88/aon60YqlUqhoELe2PapplYQ8u3ib/fvadfcOpaAo5Gx2HzkfPYcTwKt5+9x55jF3A3NhEXb8Tj4v2nuBn3CpfvPsazpE84dPIcQdXIWCoTxKvjO63z21gs0kx2Ppj2us8xpcexpqTCKpUDDbBM+xeDd7k/gepHCUdzp9JApRhL7tCmpendoPXPslS2wGxdYYasVHRmyoI/GQv8nDEzGtWtySvdD6/OhePlhVC8urwRcSc34WP8Idw754t1ZK9PnLuDF1+T8OjYQdza5YED/s5YMXc6A+0oJDx/iNhru3F+qyvWT29JkV5HrGC8c+HybbxNIWNO4ubV8+t4djGIMdsiXN01GuumN8OkVhXRu0pZgqkLgha64eROAuTIJtw8QTd2lNKZg2sNkC7TgmiTdbp+KMjcNoAyVmqDAdgPoPH28WB/krgLaa1ooejSru4NYnVAFmwNQRX4/wSW3N/ttO0O31u3LajuHFyPe4fXm1hM4EqiS3x7dQ+Sovca13j7GMHLz7mwKwC76coCps6G7wRX9GZzS+uudTFo6UgsPbkUaw+uwfpw0iD33+PY1Wfw2BSMxRtpSZ9/xJrNR5g1XkfUree4Gf8OV2Je4AWt1fELV1GnSXPj3pTtqYdBJLiaPKwrrKKW/7TZYGZsJm87GjkcC30qETQEqVY/tcASqCyABCLTsk6LZTksK78wXTBp5QDbWiUrZYlRmxHK/alUI1D9r3/9jeoEavhKd7yICjHbs5OhBE8gvt89gkfnlrAAPB2nIvbi5pUQo5c6xXrgBrdJ2LJmPV68oBW6d5yWYRk2uw/E7FGdsG21L548SwLLfdwS8eTBYb7PKlpBH1zcPA4+42qga9ViGNayNlY4j8HpUNYVj2xD9OGNuHY4GJf2OQBzhbGQXNv1/bQwBxQr0ULxPhMjHWIMxOdf2k3tFgWAlyICcfPwFgfQFDPxsWCSnyFLltBlbsLF8FU88QTUwQ24SoD902IJVOmB5QCVw3rJWglY2u4f2WDAFX+RWfGDffjwIALPLm3G/ZMM+lnKusfPjWatNIzlqgWjx2HxyDHoxl7PJr2aYtjKIdjKeNU3PAgHo2Jw8uZzjPd2xfTVsxC47zAW+kYg/MQt7D59EVEPWURP/II4kl0DRk80smjp4hQKmXhba4ZTL5e+/1FAS98D6RiY8j/AkjrmB7CMipGlGisfNlpqPZkuUjWmIswWTa2JEtrcFKBJjKfN6qeUXYiok45Ke9WvBKq/GbD/ljkXCrP0sGG+iyE941ibE52gwnHyrd24cng21k53Ionogf0BfbHDpTOWTmxE5UEr7N0XhcSE57h2yp+F4MlwHdjZMNiPWGb5QtrhG1PFu9HM/i764fWFubi1jWz24HroU600ZTTdsMtvKS7uCeaVTtAwQI4mQG6RxLwcFoArEYqL6OL2US26ly5vN+MoAwaCRwBQPLV3Na3PehM/Xdu7BVEhAcZaCITRexmAH1mHU8HBPF5nHF6/HDcPEZTUd+mxmwRpemBZUP0TWAKXLNddglig0v7B0UA8ObUZT85tReKNPXh3h7HWzYOIvxDBx5jZ8jPu0PWe3bMBR9b7M/EYigmkIRox0eowmrzcvjnw27MKoQevIex0NLPGQRjvOwKTl7piysI1OMbY60b8Kxy4dAcP33zDxXuxqNu8A88xwx/WAK1+XrfVMylaQvG17X9UbGWHoYjnkvLF0g2Okg45DVkso41WDJWmT9dt0xdInZZApU0KR4FKmwWY/VtaKQFKm9JYK8T7PQstWeYsWMDyxf3D2xDLE/z8NF3QvhV4fXkH4xVnzB49DBeOHMTdsFlY2KMK5o8fB4+ZTji4+yQSXz3CBdYG96x0gvv4oTgXec1YqK/fPyLmBqmFAx6Ij/TApa0jMad/JXSvVpys/ADGVusYeG9mnMPsjwH1zT1UP0RQ0BexkkBicL57jcNCCWwEjzbd1nZlzxoTL908tJEbrRYtkMB0mcnGxV3BRtp88+Bm4/Jk7W4e2I6tiz3hM2EqgbSDVs2f4KIl4uf+CNZlmQgeuwlIDjAF/WPbYGiIR8c3GWC9ZELzhiWmLyw1fb53Ei+jd+JJZCAtfRAVrBvoqv1xaXsAzvH7+k6Zij71WqBCmQIYOW8AnFZMQ8Sxm1gTvgtD3EdiIEWJ3uGe2HjkAM4/fI3LT1/h0IU7rFx8xsqNu5C9IBUlBSjRYa+AeiZlNGy3t7T4YuvlGgWo9I20YuRFmErQoBjLZIVaEFzAMlLjNHmMbYBQpF+I+iyBSgArQNmsBZL2Ao+q6joAqTplrQQw7f9gkK7975lyYUDntogKXYUY1v0en9rONH8tYk8G4FKYC5wHd8UxssR3z6zBiaV9SFz2YTbzHK++JyPu40s8CJuL3csmwXveHMQlfTVc1rMHt41liL9EC7FnNmb1qo5O5Qph4dABtCi82iN34Cazq+hDjCl2Bxu9+pV9DK7599XDG4xbu7GflooWK3pPIAEmPonukSda21WebG3Rus1Y6RbdpizV+VDeR+I0iLVBqSyuyZXu3WrAd3ZbIDxHzyD/5YU7RzebTFEuVcCShbKAEtC1/QAWwWdvW6slYInnUhD/mrFoMjNDPDmE74/pEm+Hm2zxKb/j/SPkw3ghXAsjwLevReSG1QwTlmFAc47wrFcW9fs2xt6TdzCXyckYn/EYs3IE5m13wgZe3L7bInDlySdEXnuMqNtx6Dt8MoaOnY6xU1zRvlsflKta2/REylLJYqnvUZIbCyzb52hcJElXlXWsUkbNNj/lpb5KY4zkCkV2ibcywEobjGHmq6ehNzvdXS66QmmxpQOS+1ODwO8cNfl37pzIRZeXnXzVLwzWf+d7/pb1b9SqXgkH1lCJcDQEj07zKt+3kj+2O26Hz8PQTq1x4NglXL96gwCaj7WTe8HHOxBxiR8R//oZHt67iru7Z1IY1x1P4z7g7etXBOAmBrH+TL9Xwt+tOTpVLQqXAe1wZttyA9q7/LHvKIaixVC8pFjH4ZqY0jPTM8BJC8x1W/f9c1PQbrebDNDFMV0ICSaBGcjMcRvWuU3DwTXrcOcI+aIDWxhz0aVGbMbOJf5YMHQELu2kpSKnJfBqu3OEn0N+S6qMu0c24w5d8f3Dm02QLren7eERWkdp8EN8cZ+WUkqOpye3I/7MZiRdDUNK3EnwD3wh9fCWGaIK849Phzp0aLS+itHObV+NvatWYMeSZZjRdxAL2JWwKjQME5aMx5S1YzBu5UT47PbAtqv+WH5gJQ5euI9LtFzO7htx6Nx9xCS9w3smP89fJyPy3FVMnDrHtLNpFID0WKZ9v3xZNO7Sjq1pHDxSmhNt1EQrsQLZdzvcVtbrJy00LmBJOWrH59gOGzNFJU0RKsukJgYJ/QUo24okyUZGgTNPXtOalYXV9r9IiP6cJasxi77TJtP9bEHsiU24v88PFwNn4GnEPIzr3AA7w0/g3O1HuHlsM45sGA9/D3fci32N64ypHsYn4MH1Hay/9YP/7Cl4EXMTd65swvOrK3Fyy2RM7lYDE9mscHzDEgaz21ik3mlAdYvWw1oHG0RbcOlvAc6AjuATeCyoHG7vf7b0wNJ7CljHg0RibqXMeSo2L/Tk7e2GtxKwxLYfXL0ePuOnYNvi+ZTQMA5jTHZ97yZjoW7zOTeZqckqCVRygQrQ7x0mWLkJWDFy3YznTgd78fZWPCNwXp/dgffXd+PD/T001cfBHxLfbh3E28vhrBRsNq9RzHVlF6kR8lznQwOxxXM+Ni/ygMfYSejdvBN6T++Fnu49MWW5EzxDfTBvmwt2XNiKjaQuztyNwYIVOzHBxRuT58zH8Ikz0bnnUPQdNAJ9BoxGKcZshnpgG5iApV7Num2ao/uQvmxly+coWqtBWROXWQ7UuAYDLLlCjeMWsMRd2UZHM+eJlsrKYAyY0lyfJBrSvecgmHJQQJ+LbvD3rBTxSXacJR9+ZcD+K11hjzYdcHYDg2Vaqjv7t+LIylm4ETIBE7s2wOrAoyw5vEQ0zf3FLfOx1MeTmqcneHh3L+6e34CYU9xY39vr2RfHAucigSn3k/O+8JhQHaNaV8eW+Qvw7MR2PDkZYtyCcSe0DGKvxWRrL8tlQWYYblovuSiBSRmc9j/insO8nbbJzdrtFl3kbbrPc1s34sDqVYzbtmL9HGcWlilN2b+NatWNdH1BiInciYshW7BpngeWjB1Hi7Ych9euZM2RrpKtZDqeu0eV8a1jtkeLZeIoujsC6smJLbRSDnDJEt1i4H941Ry84MXy9coBfGLw/vHhbnx/dpjgigQensCXGySVzwXyuwfigY57X7BJSC6GrTMc4WoXZ6ya4YrlI53RqUNj9KCCttXodpjlPwfzt83H8iPLcDkpCv6hIZi1ZANK1WqJbKz7/pqZ3d6U5yjUKVCUJT4tXKUZXwzqjbSG4VCRyuUw3nUaytVmUK9WMkmfWdaxShkDLNENIkjlCgUsQzNIs5PWOCpZq5FlqG2dJKekyXaUY0aCSZmfFI7So2emT/5btSuCqhSRvdrNNc2KbKJMZCIOrxmO+SM6YPHSYBy5/RaRJCJvBU/HUmZ5UTde4NYlyoPDplF8NwGHlw7DriVjCLpJ+Hh9G1n1yRjRuASWjBjE2CwYsee3I47puIJcXfHKohSTGCtACkObgKbNEcDzNoFmt9tyPTyZ6e8zQPwHuMzr+B6nNwVhp88SA6ztS+ZiXPvuPIEMtBnLPSTAH53agnv8PvtXroXnqIkI8VqMbYsW4xRFfFdpsRXIC0j3Ca6HxwPxmLSB/n7KAP0+XaKxPPxsgezlOVpfMvn7fWfi4yWCKf4CkuOP4XP8UeD1RYLrLL7d2YfU27tI29Bakwd8fGIrm0QCELllKdWwAQwNAuDJBlyPMfx9mVR0bM4JQR2qYuE2d0xcOxV+Z1bixItDCKX8Z9PB0zgQdQeBYXsxbY4H6rdobxgATcYpLC6T03TslBwF81kp0Rk6dTS6DOvlmHL4/wJWAWqrTGeFxmgzvpJZU6ppyzXq2pUbFEclSyVw6TEN4pCwv0b95pRqaOJLYQbs2fF79uycs5ARY7p0oDtYjwcnNuIUr76NsxtjVr9amD19KU6z6n726D5E76Ckd8p4nIx6gKs0+WcDRrJmx948vwCEbmOMwivy4/Vd8HXqgGENy+OA10K8itqFxxfoViNZzD3KQP0IyUSeIJ0kgctuil/MiaRlcABPwXDwjxhMIJLrvKfUnZtu2/jMAlHAs4A8tTEQQfPmmUB+32pvloFamnhG7/uEfFwMT24sS0anNgRi9VQ3+E6civ0rGEyzBHNhGxMIihblAsVN3WexOuaUA2jK7uJObzUAE0Ae8jPjTm7Fh6usIJCn2knR3+cHp5GaSEB9uYGUd9fxPf4ivt4/hE9s4Hh7eQ+esc768Kg4MNUeNzKRWMM2N3+c2rwKUwf0JUUzjM0jk9C+aR20H9MWE9dMwtozJHYfbUPElf0M5MNwmmTppUcvkMgSz5Ezl1ClLpcwUbNFmlbejnkyA1U4iqDb8L4Y4TbePMc0LVMA+H9YLMVYygpVF1SMpcBdCkMLLGUGJgOkpcpI0IhZ/4s1wL+y5sVYJzecuXwfhStUw68U75niM0Faix8UxCzu8sGdOLJzB1vVe2Ewl5ybOdEDJ65/QWTkGVwMngWPyUMRuu8MolnaObKSjPGM8WTXryH+2Qt8SLqPmyf9ML5DFUzt1pmB7TZ8vBaCl+cZi/AqvXeKJ4QnIuYE+Z6TPEk8QbGRW3iC6VZotXSiBS65FwFK98u6Wa5IBOMDFZT5mN3u0a0ZFyorR/dnN4HwVNBG9ilON1TE8Y2r0L16MwS4zWHnzzYqIsjNkSWXzOdK6GZsncfWr54DcHDlKurYp+KA3wpc3M4gm+CKobRaFkvHLCBZQGn/+vxOPOZnP+JnP4/cCsScZbnID9t8nGmpbpAFvkttz20kvzqP5Mcn8P3OQbw8G+F43XF+Z4L2Orm487Skx4JWIJIdSwc2+mBkhzaY3HUg5lHXVbNqGUxlw4jvER+su74Wm5kM+YaGs474BmduPcOF2/G4cPMRKqo5QotqMcMTX6lpOWpLM3PySxVHpyE9MIVqVztHVe7Pjor8EWM5Ai4qBtOGeKgdXoVm01yapruSpcqSiwVlNUAw+2vfZygu3X/B+hIwbJwz/qT4LEMeivjYEDG0Sz8c2RGO69ev4ubjF9gUtA2jhizHnshE7D1zHYc2ezCob431Acdw/dIxhK8ezjrgNJy+cBsvXj7Gl/t7cXrdUAyuVQSr2AwRe34HY4xDpmb2kvLkWFqrx3RBcSc28GrdbK5YXfU2VlEME8u/b5DjsScv9hTBqBhrz2pDQsrS6HkCm93+CTBHXMSskPHZyUCSoJMm4ULYSpzdvh6dKzfCHAa413bRlR3ciudnmcFRnHj/EBMOb3+49R5Jec147PSiBmzKZLaFsYREcCkjlNv7H1CxdHN6C14QmDH8rLeUCz2jWxW4ki6Ggb4Oe9bMZ9OsB6vFAtYNpCadRfLDI3jPGuubi3vZD7mZr2fWTZrjvqoCEYwJmSEeXOeN41v9qMlfht6NyMh37IU5A6nbql8d4xeNQNDF9fDdz/7ICHqPuBScvE5Q3XmFVUEhJknTuCW5OQEsnxSnbLBVwTk/29SGUps/iYA3ygcaJGWFP8aOMpA3BKkZ+k5XKDcoayV5zP9YLEdblyyWdDyaoyBZ7NylAThLdN94yIaFp29Qr017yot/QQ0Oyji4+SASaVNj2OoSde8lJkzwReCWc1Q0vsSeLQux3qkRfBcswrlLV+kmh8N9CoPdyIekF6Lw+toGlki6YUDNXAhf4ovUu6fAoAMfYvbj8529SGAm9IIB60teae/PShXB0hCBpRP7lC5EmZROnAD0lBZM9z/jSdOJvLGbLDqBIdcoMAlIApfdLMDuH6e74iYLpr1KO8fXB8F7ggNYIkk7VmiIMW274mTAWtwhc//s9A7zOY+Yoe5d5o+VE+diPGXMF7dvhFOXrtizdCWiNm/C5R100QSAjkfHqcxOWxILzvG8GF6c2U7LvM+AK4HhwfdnjKuenmcgPgYnt65A6qvTlCHQNT4+hLdndiGOVjeOKozHh7bjMbPUh8ywVfy+tGs9O4D8sc/fF8cDfBGxdDG61KmD0V16UVw4Ap1a1cf0AFfMWu+MgP2HcTHmGy96clo3EzFp1iJkYUydMQfDHoo6NWeigBSnHGQi0Z8m5sxaNhd9XYb9AJYaKwQsM8SPbvGn4gSSmXRLtrQYlZz5WKHWpskp0rYr6xPpKcGe1IprN4Zi+PhZGDjKmeh+gRO3nxr5xeGj5zFixBRsCj2Np19SEP0cOHrnGZwXB8NlbihJ0GfYzIByzYQGmDOV7uHcFexdNw7uY3rj6L6zuHH9KBtG5xj2fGiDcqbcgg9P2Q1wD6nPmQndDcf3K9uo2wpm6WYHPlyLYIxB7dY5SkxYd0w4zQyRgIundXvAK/Za+GpezTuMezTW7BhPaihnLdBqCVCKvWJoKeQiBUAF08ZFRToYbyPE40l6eoJEZ8Qm06bvxbaqaxF+jJlW02JVQa86LShJXoGo4M2IPxVB/O8wgfdhxl5bmB0ObdQCB9auwgqncZjRvS8ushActXENuTkmHqw+6HMUT8WTOE7gBfD2yi68pJvX90u9f4xy7L1IjiGIkk7jJeup3mOH4D5LTzwoEFH4eisM0SH+VM6G4vrOMNzaLXfPpIS0xlXKjKJ2+BsOcbcf298CV2MDi+9tOEFmbNehmNpvGIZ0aoKJCykTuhKH8DMJ5Lwu4Bbbklw8luO3bNTY5+DoAvKVGtKbryDHY7LHUbr6vOWKYGmgH1pRMauRl2bEpUatGzVyDqPjM+oGad6lblA2KKZdoMqttedIRWiv8o106tLoPFfB8vUXeK/Zhsu0RlF3E/DsPXXnL97g+qOneEh2/O7r93iYmIyIo9cwatombA57joN7DmHDxKqY3r83Dh25QQnxKMzvWRPbt53HpQvhOH9oNmZ0q4ap5KZir5EMVHvE12f49uEqg9VI/tB78JUx1rsrOxhm7EfK/YP4do3AurQdr5ghviK4klj+0JV+hk2hH87vpmvayvtDGa9sxw0Wh2WtHhNgNuZ6Gkn3Y6wGAcZgWqCKPUOQMVYRsB6ZGIyiQbLrB/3XYvGwsUzrVzPe8kVLdgQ3LlkFAc7zcMhvNR6QetBxvLuyG1Gb1iN4tjumdOiFZROdcCTADz2pUdro5oJr23fg8mZaUB7Hyyjye/zspwSDXOGHaCoZrlDvTyus70gzSGsdjeTXUUh9e4YX21p4DxtGaRGZ+KeHkXKPgsCzYTiwfDEubg3GuWC6emagylSv72epZ+dGY7UifL0RQjrn4IY18HGahKYEw4Se/TGxdz9MHkXJd/AxuAdEYsu+O7ga+w3b2YhRmg0Zf+aiQIFD6bKXYQ8jjY5GfWZgO1qb4T3gunIxZ3IVok7LIasxCzmYcdw5zHw1Y7Ec5iuNZtDEEwLLFJg1FYaklzgsTbFrw3lSMQlv8ejFe9yOfYM9Jy7h4qOXeJn8jUh/hYNnbtD9fcP9hI949vEddrGAPG1mEHYcewjPqW2oeCwD/+ATCPedhdntysJrIQvEx3fxRI2Da6eimN2xNWXJzH6QhA+IA1Ie4NvbK/iecBrfnxxG8qN9lCsr/eYVqxLHzV34eiccn27uROLlnfh++QBOrGV7GEGSenk3XjApSCTAYsh2R22m0I8clmItgSvuzA5aKtYueWLNyaV8+DkFds9oAa2EWK4x9jTjrAOhiPBejjl9hjD2CcKRNSvQtFR5VC9UGktGTmVThS9ucgRSEukSiRXv7tuOzbMXYW6/UZjQuhMtSTj6s1t4OFcsPb6aUpxNtDCha/COMdSry7tMzJhAQH+4shMpdw8Yl59EaTXNGMX9t6jCu4FvSSRHk84jnCTyqinT+X0P4BsFkd/vHWI5ZzV2uM/DuY1bcIxKkOgIB70iyfS5kDUsjq9A6FIv7Fzmjf3rfTFtYDc05IUxscdozvzqi+Gjx8CVVs2FcZxP+FrsvHAYPtv8MGjBcIxfOAkj3Kdi2rKFKF2L7HqlEnBaPg/lm9cyXevqWTSLL2jhrDRgyUhRmuwYoSxgmaBdvWGs/SkT1AtkscRjqf29RcceePj8Dc7feISnlB0eOX8dO05GI44ygydv3uPgKZZmWDF/wSrx65QUrNx0HDNn7oSv60R0r5oJC9zWYt0Kb0xrmxHTmI4fPrIPOz3bwKVdBbh2acb4ioBJfYmPKc8oRY6hG7xtUuzUN2ygILj0w+LjFe7PIPUJr9oHu5ESwxNB8pABFq4GLsV5jiBiFIwvsh7X9pg2slvha1ioXWpAJbcoICn20m0F3IpxFEBLHyZwKaOUe5RbiTu7Gbf27EDoYh/M7TXIuK49lKo0KsFFrCi7duk5HNsXLsGFLYz5ru4ybuzF6TDsWLAEXsOmonfN6lRlBMO130jUzFkEHpSm3Nm7B9fIkMcwLvp47wDeXo9gmSYEby5sJ/mpCycSn54cRQoJTHx7aC6wr295wb08hm8E0rLxE8iRefL7ReDL7TBa6n0IcnHBdja8Rm5g+xmt66VQ8lqU9lwiUJQd7l3lw5FOi7Fj2RJErF6Cfs2aoFX5epg+aCjGd+2BwcO7YcSKEfDc74llu3wwZ9M8eB32xNID/lhDkHYZ3RtZyuQ30ucOA7sjayHKzqk+1kwJxeOyWI6hIFxU1SyEWdjBvAtYZo5SmhzGVLc5DELF5XrNWjL95JImdZriyt1Y3HjyElcfPUcS5ayBEWdZlnmNRLYP7z15mV0xH0zMdTsuEWOdV2DmhDkY0zALxreujdn9u2FC7ZwYx0Fl4YcOYoPLIDgPG4AJ/XvgyfUDSEm+ztcKVAzQ2GODr48c4PpM7ub9df7IzIpS7iD13QV8ey4W+gi+xx2isu8E3l7Yxat5GtPwSHyn2/x0PdSUPuLZ63eZdUTJTKQUEIASL4elxUOMzegun9FiyNJIVCeQiQpQQiCtmAjIKzxJm+a4w7VXHxMP7fJagkbFOeeCAe7EDj2xee5iHF5JC0TlwRtaTpVbIlivWz15LtpT47bVwxtrZy9AJSY9zclgi4qJ3klClUqIl1fDDSf1hbIYAfP7I36vpAu0VLTUn6P5OzxBasoj3r6DL3H6zgcMZTGTxfrIQKpv6erfXNqNU2xz8xo2mQnPMmaBwQzWVxvXKQXG6e3LDf2wc+lyNoF4s+vbi421HmjF7K1tleaY33cCRvTogbbUzQ90H4RRnhMwZZUz3HcuxLJDq9B1bHf8VSATGvVog+Z9O3I0Zm7OfijsKEybIXAOYGmMUdbsWRzAKsmuYxGkYt4lmXHMqGLgruVFqKES6VmlbiOE7j+BSW5svCQlINAIXFRb4DkLlxt2nGSl/BWOX4vhQI2PuH3vCvbvDsOZk/uQeCcI8Q/WsaePbHDgEExtWxJzZyyG/6zhWO27FIsWUbwfvoGp9EmkJpxBSirBJGv1lSDS/uNlx+3vbOZKjXX80F8ItDd0E68Z1L+lFXt9gRr2SXjKwJl1DspLqAiIPYjPFyPwZN9mXNpMa8VapTLIBNbIPt3eYyzLa2rCXpzl/bRuX24eYHzEPka6RIFPwHp6aqO5L2oTOazJznDt09tkb9sXuKNRwTKoRQa6L7vB18+cgwhPNtnyfRSAf7wRikPLV2CjywJ0YuPB9H4DsYdd0S3ICTXhoJMeteoglOC8dYA0Cd118mN+96eR+PrwGL7GMQt+w++cfAffv95EKr93Ci8yc5vUw8ebe80FtW/1PLh2Z2WCFYFYsvVPj+/FltmemNNvKPYsX22AtcdviakdnudIgHMhK43idCtnUWyY48k5X75YQva8YcFy6Nu0M1yHjsaIfp3gsmwqFmzzwFImOnPWzEKdrvXxR8FMqNaUC5y3aWEsVcY8DjVMyRJSFLN+qJmmWuZPiV6u7Ia6+qkAp7mIMVXAZeYzMK3UJBNpcpq0bI8e/YeiYauOCNyxF49efsWZG0/InD/C6Wv3Ca4EWpdvuHQ3HtsOROPWk1hcu3YGT24ecoAkfhdrfBwhdNUbn99sprU5jUsHFmBi87yc9TkRu65S0jFvFc6xKKws6Ms9mvv3dwgibu+uIvk9LVMiAfT1vnp02CWYyI1BPcGX8vU6Uj9dpRW7xfR6E3b6zjYn48tzNmMkHEHKi1P4fG4XblOPfpM/rLKuRCpTP93djeQH+/E+2uF6Ei8SVLdY4H141CQAz5ipyXop8H9J8L29EIaT69axfWw864ND8IF1uzWTndCeFmtyxxboW682PEaMRNBM6sLoWj+wpvn9wS6coYRll7sHhrRsh87VapGiCESfujUwqH5jtGWCNLFdJxxnZhV7lrHhk3N0c5eRksDvy5JNymfGVbqoeBGlpKg7ktYbdIex5xjHkRTlcX1hlrh46FCsGj8DpwPWkKTlmICtQZwNNpolpcksn23AVrpo1TclJRLReozNHzu8vGi1lhNcixnrLuWQuh6oWqQcRncYCJf+w9G8cS0UrEjtOqc5ZymYA7nLF0bdVo1RiRdDDg6Cy85mZjEFkiOXLs0x4EwEzEoe6YBlgvdChWS+sjkaDmmxMpDorEhd8/LVG/DyzSe2TNEpvfqIE7RUoYejGKR/wLlbsTh74yEOnr2CO/GcFUUF4tFzT3CVCsfEmL1IjN5I7mQ4Dq/rhktbBrC9qh8bGlrj2qGpNPOHsctzLObP9ceK9ccZOC6E/+KFeBh9DmdPs48wJhofWWj9EnvcuIUUWaRkxhkEVQreITn1BS3XE/NDEw34TJcROGsC3j7hifnC+OstW8e+nsPHp+R/ovcjOng5nlL6Ikvz4SYJx3gGwTEHTar+nkLDLzfD+TdfE3PCgEqu7tP1fcaifbwejlcnd+D4qjWYP3gUlk8djw9UvC4ZMgITOW/0ZkgQfCYOJy80ED4jZjL+2mxey+ESlAVt4wjJQEzt2QP1GIudDlwD586dsMdzMU6uXY5hjZqxGWIUAeePt7f4+W9vkl4hoD7pwnqA7ykPORlH3zOW8xceIDWZVvvjA4acJxgv8tycP0SidzkTol7Y4uKDs5yLep+yHLnC0S17UtJNUnU5u8BJexxdv47A4gUcuoz0hw/Wu7lj/WwvbJg7H8Est7WjeK9pqZqYNWg0pnNWa50qFU3LfnFangLVy5upf5mpq/tN0xNJQZkFoMhpFWAt0TGyUjNN/5EVFiqilbNEN1Q09b5GtFJR1+6a9qBEtgU9+/gG9xKScJPdHQG7jmPzoTNUHibgJumFa89eI/zSU0Rfvk4N+SI8jnLF7RNLEXOO7HTYEJwK6Y87p+fgbdJRfEjgcNj9nGu1oj9nWC3CVGZTI91DELzropHIJn5Nwcf3n/Ds1RNTszoR9QhnjrOi/54/uH7cFFL8PCoOICK4dAVrhswTRK1ejIPklb7zqv76+RKSGY8Bj/CRPM8H1hUvbVmJpFO7TLz19QVpizcEqhQC9w5Sa78X7+OOEOxRJiiOZ2z18WoEDaYsGgPp+/uodyKTvTkI01h0Dl81Dx8enoZzx07wG9oTyeeZGAQsYpzVHYuGTKCCgy79Nl3bq0gkXj9ITf9GzB81GpU40GPbYnf4jh6J8wFLkEL6I2azL4bSOqxf4MnkIpBfhxfGZ4YB33kRMZZM5XdIwW1+r1jevscWOJZ0khhzkYJ4QiXu+UDGf6dPsRVuLJy7Uc493wdXdnA4b+gOuA8dBqcevVg0X0sViB8tF+OuNX4Elh9ObFpm9PlrXdxZklqMTZ7uWMpSVVXOpu/QsAUbZcdhbOcu6NGnLbrPG4Re4/ugZouGxotlz6NFF7jcslnehZNrCnJjsmdmzRNYRQqzOzsrF/yihuun0pzc62imqAhXjkOMS0g0zaFPX711tFA9T8SdV+8QHfuS1MJrgisSYcdvMs76aEjONbsvIpLF1Zfn3FlUnkDXx3rYZW8OwxiMsEUdGX80xu6V3ZHy6CTjoiPYuohs9M7RbMSciqmTZlI+c4yx2SP2uyXgMt3r8w8JFP/HYs+hx9i5iSeK8RRZQv7IL/Gd1grfuZkRIM+QQL5rDUs+b+N5lfNvY8W+P8HXrzwJb6MQyy7j2xTaJTHWSo1jVvmJrvYbrdprZpWxR5H67JjDItLqKXgWoap0P/UBU3mCCo8Pk2qgaJBarOGNWiKKrWCvrh3FKK5wGjp9LL6QbY8NWYEpnIngzFrcVWZgeMQYSO8Xe56u/TAL6FPQoEgBts1PNrr+7V4zQJIJ7ynQO7ZkHia2as14xwtnOHA39TVjq/fXeOx082+4J83gSFge8ze4iS8vaNlizzCDPICoIH9EbVDZajsmtGsLX5bVdi7S0N2diFi+FMOat8VyqkFDGfttmc+gnQ0foh1Ok0Y4sHYpx2Z6YNV0UheU1mzz9MGI9p1RmTO3Rrbrjtlk5vv1ao9u47pgiv8UbDgZBI/gJWjRtx0KVeSwXDZaSE0qnlO1xMJl2KVTSgsmaNEHR3nwp9KsBWmFVU2/vfPgsRl7k/ThM15wntSj5y+MVbr8hPu4JETefIYT0fHYuOs8Fi/bgnHTFmLW3OV4SEb8zr5JRmt1YdtkrJpWBxFeXRlMtmelvzFcO5bA2mmd8ebVUfIrzhyIUY0nkoK90GkYN8kFGyPOIfT4DSYGT/A8+TuuPP+KRZ77sXmVN4F1hS7unrFO+KwfOd5Yp5Qvd5nSuyCSrDN9CD5/J+9lAPca376JpriC2+RzYpgtvriuk60M6xav/mtI/hDFVJ6x2wdmX8l0Px+iGdrtYaMsn0ee7OsjUhnP6Ypjjxl9lCQofbiqacLTK5TI7CWFUANnveYg+UwoPrDkM7tvb4xs2h6ntiwzYrzUr3eoQqClfXUR29xno1/tqnCjSwx2nw8P5+EE30mk8LVfjoQhYFh/zOo/EFuXzeeA3eVmrAA11wQQLwTGVClMTIyL5LEmvz7GC+IkrSrdYPhWSotEo2zjcBFXjGnZgSHBIha+fY0ubP7QsRjZqhO2e/hg41x2QLn6UGmh4b7+Zip0CEs8q2d4YPVMd6ydMYcx1zzUZ4G5eZmqcO43HGN69cLA/p0wjD2ZC0JnY8v5YHiSC6zUuLZZNMEMc6PKQeS5Gm6kJtUqG1nzZGXLYGn8VIpse9601eMDgzabiXcMq4y2XDOhnrx5iwv3nuAER+JEsUB5jmWcq4+SzCwAz5WhnPwyF3F0GwdXd8Pt3RN4dTRH0IyGHAXUlt04XmxbOojgeV0wulUWnDu8EK+vrDBTVw6sGkbiczNW+s/Dmavx2HP2ITaEXUDIyZvYf+UJZs1cg1PbfXgQUUhOlgXij/2SvA4em/T7HhUFflNG01V+YICbTMC8J+he8eC50X3gw3VaxgA8u3EQz5kYKE6Te0mme/n2hSCTVUsVYB8TBFfxgdYJz8mjJRx3pPVvLtB1nqHlOoYtSxdgEFurvn6Lp75qA/rVr4OHG1jHjIpACrO65WMGE3gNsG+tB74nnufxxTAmYsLBeGnbIhfM4AC5cS2aY4uXJ2aN7E1gETQczZRCvusNVZ8zu7SnKtUZq7lwwcOjO0j46liouXpwFJ/u8dhf8vk8HjCRSYnbbzLV+xFhOO63FmFenFe/dTOHknQkITsG62a5IYoynYgVfuhVqyl5M54TusKg2Suwevpi7CKPdYbzWdUQEsgAfoXTIo544lxW90WUM/dHRSqAuzdoBbcRdIls659J1elkr/FoObgVClWjdyM9ZYbvFnAMwNVCB2bpOzLzeQtrDhqnJquZQsx7FgrztLzYnLkL8Tk5FR85D0ru8AtPhYD28OkLymPu4tyNp7jw4LmhFm7Gf8LFh28QHr4F7x/swfUdI3F8bW/O6RzLeQyjaI47si9wDEEXgg/PNrKDpDrnQ00mq8wgdlAFDqUth8+xh7B/D5WWJ+8hktnmkQu3ELz3PJwWrSQlscCQf8mMi/D+DD7d38+aIa0M7pIsjUag8yQmA9t5hN+46T9dDq/IhRFYKQl4G3eRzaMUBJKhfklL48gqE0zgL2Aa8DFeM/Hbh9tISaQb+kjA0YV+J5hFzH5/y785fWY6ZbhOfbvxt3iFQE5fHtuqCd5RcpzCGIvaY2xxm4BOFWsgxHeh4ZtSvj9n8E3QJj/gqIBpWDioG8ZxpMCmRe6Y2ac7MX2U4DqBr5zRIMt1fZ0HJrduie3enMg8cRRpEEphGOt9IdH7+jwJUN6W2C+F8dX3WFYfOIZAycEJEqERHDeuAvdGt3noXashXz+LlII7IhkXuvUfhb71OVaJZO1aF1koL6ydNZ+qh2UUBK6hW17EUZoLOc1mHhOTaQgiuBqSZ6vJUeEjOvakJR2M/v07o3Yjjg6tVxONOnVEvVYtUKIyA3oKOfMy2SteRmths3OeZR0tIC8jpRnxRpqcl75Rk3Br1KmPKzfu4BPB9ebLNwrrU/Cd50sn7sO3bzh/8y6Cwg7jyOVHOPeA7dks4zx5GMmAlkPIQpniru9Lt7Ocs6n6UpnpTMnuPJKHbSjMW0XZSXcO3ufgtOhl8JxSAQsHVGQZLABHD4fg2FkK/Z7EIDH5HZ6+Zpv36cvYzkwGdEkm4GazpnFTbxl3MAbRihIq7FJLw5PNybSC1ec3aeB5zQNmfHj1BD3OXrbM78S7BGWQLAekvjPMvgNQBCCfpyQg5StjmO/cZA1JX6RwE9vNIAnfYy6gAycCr5zNjJYWceHgkZjdox2SSbx+v8Rjun8UJ1bORYeyVbDJay7fI47Afck4j8fK16/mLC+fkZxS070jTy67ktiJnRRF9SeBlXyfWW/0HqSwvhlKHb0r0/0AdoJvW+TMRCgc8awcJHKs042IjQytdpPnojW9c8gAK+FMOMtXtFgsGO9YSGbddzXGtOuACR16w2+asyk+qw2/fYX6mDN4rAGXv/MiasqYCZKHi9xM+TP7IBXEe0yeCc9JHF3O+qbTgMGoxWC8fZ0GmD10DIb3YOxFV6cRCTm4akaFhtXRnr2dbQd3QynOvShUztFvqjpiMZLrOajVM8F70eKOxQs1ukjjhXr0HYinCW9M7x6n3hhUpfAfxV7vefvEFf5Y2w/h9O1n3GLxiIRgwk3q1iNmsrN4Fp5ELeYs9eG84phGx2yE/8QaOMOxQPt82zPe4YThE65Y49yGbe/1kHh7HbaHHsGVx69x++VzDp39xHIOYzx++FGa+u93yEQzzvl8mRlajBjpK3hxKozcDfsLSXySVeSsULk+od8BrK8pGk70FrfP7CWDfoSrTWzA148vCEBaNr4/gyvzPA0xSkmh+0xldmkSAmWZCZy99ZRZp4NDUjlFTar1mVofo47844s7mNyuKzY5Dcd38k8p15lR0lXe5tjv9qWrsmtoOl9H4BLA3z7RSr66hIUThiLIaTw8+vdkMD2FwsW2LHaTwCUpSp0zX89Y7sJuJFEwuLhfd/42U7BsKrNnNqHe2ReKeA6hu0rNV9QWas8iIwi0CBLzIWyw2McGD8ql3X0NsLYs8KZLm0HOrDabZ6fRUtIykcMa16kfutRogjWzFpoFFQQsP7blS2YduXUlh4y4c/bWTJKl87Bk/EwEcKZ9rxZN0Lou2/XbdiN3Nw7d2E6muWlaHygHE5HcHERSoUkN9OQ4px6cRliJkwdzF8kPydxzUGVcolwpzceiOtTIZqo4SjjUrI+azIGyj56BQ+DwJeWrsWCJPOPP3yYjmi3ZFwiovSeuY/+pu7jAelrSPQ7V2DWRV9ZSvLy5Hse2D2HnbiC2evXH9sU9cGLVEA7o74UXjzdx/voYrJzQkmlvf9xgHW7d1rO4zCTh1stXeMDhsUkceXLrwWtcOMEA9xH1SGTJP5J0THl8hAT8YexfPA8+LAPhLV2iScUJKIEq5Tm+fIszFiw15QWbNEJYGzzDue8rjWX6ykuD49XMc1N58r8aspWkSiotHIve9IX8O4nv+ZKbMkwmAwTWGrcpqF+4PGKuHMOjC0cwgFfyJX93pFBk950zSfGQTaRUQXSpUMsAQjwbUj7gU+IZJJLNn0gXemjRfKwaPpgnbiz6t2iEa8f5vZ4wSL9xhLkDL5j75whUDv1gcDyBGq5Ad094jxqHqDXsY2SDxGMOK5FQ8NTaNYij5OcVf7cX5yL40TuxZ8k61gkXszzGKTOLKZluVB+jqRMTePb7L8XKmXN5/BUxvecIzsVgiYbWafkkN6xynsnOqGU46b+S03lmYPGEeVg6zs3EaBN4zMVYjWlQpjo8+7O802swR4TXcixAmp+LbRXiwppa4aJ8UbQY04HF63noOawPdXuSqHMxipoq6RRhdTov5Q80f5LPiFXNw67oas3bYSyF9RN9FmAq60qjZ7jAaZ4nzlG2qhqhQHfl9j2s8uVg/gvMaMKH4cZxLzy/voWE3AAqKcfg0t4JBNsYhC9ux3IHp6hEzWaZgdnijJaU+M7AluD1WLf3HvZyftORm08Q/fQ5HsUnkdF/h4g9u9mdEmEY8o/UJSmTusfm0vn9+hopiGqIySk3CQK6N2WB3xiDkI03IOFAkfPs63twMgz7lKmlfqAlSiK0tGkqsoDD4JqxVrLqknSPyQr+5Va/v+J78jaTgPePjpgWs1Gt2uJz0l3Trj+qTj0kUIGaTEb+y2PGfI/Pm9LREKoXXCcw4/sma/ecspdDtEwbKQtuTX7JF9smjuEAk9EY0rQxrXsABXxMRu6cYCWAJZx7DM4lBWI304FFTpjSuzvjodlY6TQNJ9azy4dNtzfYLCt5zuF17PQ5tIeSLGq3WHI6w5FL62YuxIaZfgSFJzzHjkcLKhc8x01i/yNLTUtWoWe95mharhpVuu60mrPhN3kOvElPbPLkRMNgDmKZ54b542bAY7wrx1hOZy1zAaqQOC/FVc0Gs7HCY4wThrXqhvyluZZ39TIo18yxKLoW8szLWKtW04bUcM1D8UqluBIbGYaabLEvXpxjjJgiVmpUFf1nDkX/OSPQ220ouk4fgNr9mqFM83rIWZYLQrLQ6OEbgHharttxrx2ukjFYNEcGhW1ey6ujF/XavAo2jsGji+RIXBph3dQ6DHYbsw9wKucPbGcmyEWTZrRisNkN1yPZcMDlQbYffYzwUw8RfvYOx+lwSO2Hd+TN3iNi33Hq03exhBFq2p/eR+8jQOdiQf9+SLxGF8QCbbJIQ7myT9dolCIJLJGpdHPvSbJynNCViGAcphCOUTjvf42vqYqjHHIcw2l95utSVS56xsyTpKveSzGXSigfmVBs94MTu7gXjRmJr6/uwX3cSMzt2smAKjWa8R+zu9QnDPRvHeE0m9Zw5Tx3fCC5yRJU7HF2FlEXNqxtC04lDEE4XdyMgZRbkwOL4gpiKc8vUx3LLPQBm1BvHzWxmhKBxKPbjNv0HjceC0eOxhZ3LzZoBPCiCsGJdWsQ7rMSh9ZS/0UJ9BP2QUrqvGWBF1Y7eZHmWYh1LnPZxFsTo9p2wtLJnEzIgWozB4xEdbbOT+o91LhCHwo1vSfMoDaLawWtW85y2FJOO5yOReNmwmPUVAPq4V27okXj+mjOqTNuHMImqzWcxOukhS5o248WTfo9ZoSSLf9NHjQ/Vy8rWEqTHrkmtGY35C/GZgqKuSo0qIZ6XVqgauv6qNCMq6kzSJP25td8bO+iRisodJehIO7Fc67S/Rg8ffvBsOX336Ug6uoD+MyiYmFRF375IVg5pxNClg1AyMy2DOqdOcBsIYPE5tjs1hBHVvXEoY2MRUgfRARNwLqQ86Qx3uDUrXjOVP8u+4PHRO2mnQyKKVx7zx/7/c0Ic9UuHjSciyHxtYmXkPKSMQoBpQaD1FdMzaXRIn8k4LznSdPEvWOkBM4we3PEUI/JzDPuIdEI1iCT4+mCEphxfuIJTiU/Rj5LQbsBFemIL5SvrOKwXVnIIM/ZSLp/iVOMGyGEwTjY2fKN4yjlzr7H0moxgZnTvSenOPfje9KCJUSxbY1yk1lTMI5Bewq7bCJmMW3vNQBDqck6w+XpUl5cYX2U3+HuScp+jpqJO1/uUHNGCcxjHrdTx5bwmz4DrkOGcoEp1vqCg8hZBXLU90oWsJdRE7YMjw+GMUnaZGIp30mzCaz5HIo7D1O790erMlXMFJqAWQtMUN6Qtc12VepjKS2WNwHkw8ZU9zFTCdwFnFgYgCUM+BePm0ZgOZtYy8NpOupXK4+mTeqjf7M2HJk5HaPJ8BcpX5Jd7n8z1tIcWsda16bnVMpSUhHyelr6+SctraHmU62emT8/i9CFuH6xVj2gskFt9GXrcJ7VubOGfkh4/4XW6iWuP+OqDolv8Zqx14M3ZOYTk3D81DUsGN8LHsMqYUbPMnAfVpvTf/uxyt+basoWHA7bgYI+gm56I8RdDuaV/RhhWxYY7upEdCzO3U+gGvU5zl6Lw+EriVi2mpNdOO/h/c19ZjBbuPcSzOja15CeiDuKr6z3ieOSGO4rx/x8Vws6uSPV1F4y27rDasDupVwWjo2cRAm+vbuI1I98Pl/zjZyVVAJfWeYRCy/CFB/O4Vsyyyp0kcmcEX+N6/F4Dx0I9/79cZAguXZwF3rUrMKi9iqWcnYz/CJ5SWB9Ydt7Ssx5LGE25Takt5HAvGFJ6OiqZXDpNxiLWRnAs8vYOX0SxnXtjeEMhM9Sj57yIhqpBKTAlUxVQzKTgK8PIlkYION/ehd28EKdO6A/Zo8YwSxvHvas8KfUZhv2rfDl8nUrqAHzYFKkRg8mTqEbsXamXOccAsaFbP9cNC5RHhO69eQwXU6DZjF6MBexqsFxCDMoPvSZ7EbwONNtTsNyqjb2r6NObv5sxzikUTPgOcYV/pQJNa9ZAVXrV0NjTnWcP3ISnGnxanJEkTrns5JN0IJSki1r9QsjZ2eAr5ENFVjy+amEVulicVGL7mgi8t+0UNm51EaZ1jVRvVcTHD4dyZHXySYr1OoOjwmoB0ncXiXh5advHNRBCxYTjzgmZqejzmPd4hHksPiFOIbac0w1rJ1UiQx8R145Lam2rMqCdF+8uh2MvTv3YcPmY9h++BYOXX6I4yxs76QiNSj0OHwpEFwToM6V7SRUqcg8HEq9txMWDB5iwPDlVgTJw8PktVjve3CEUpUdPDjGKV8Yd72/jOfXdrLtawupjlk4G7GaYdclfEkg8KTj4gl8c57NCocoZT67l+/BIJqkqNF3kZX/TBnw00O7ETDNCcGTh2Mm62Z3Oc15/RwXjG/VEB/O7MS3iyz7xF8zqoRvL1gSen4N/mNGYx4t1rvoMCRwptVuap4GN+2InQFLCSzKeqjmGNOpNwY2as51EDkTLIHKjBgSsE943A+Ok/Jiyes+j4V7iRQ/kCid060D2+THw6knQwjWAg+vCeDo7rVUi3ojyM2HTSceJIGp79+91RCf3uOnYcWUeVhJlziwWVu0q1wDC0mQ+tM9zh0+DtXzFEWvBpz6PNmV8dR0LB49FYtGqczkbeLHBVSSLhjmRKvlxlU0KK0e2JsNFRlQkg03Q5t3NFZuRMfuyJdPyxdnY3ylxdipLuZocMVahTTclp1cNblG9E9FtChSXvYVsopdkK6vbNMaaDKgE6q0a4h2I3ob/kokqTaVeZ6+fYfYDx/w4GUiktg08YH0wK2Yl7j14jWefebI54hw7Nk8F29u++Hu8ZmI2sOl3DazTWr7MMTumYq7p6bDaRb7DCd6Ye+pWzhBC3WWbP7Zh684fPUtp8pdwvZD57DaPxCx5LjeRCsjWstVsvozlphlFJYf2UTxjbU9xB1gNeYgJVgEVjxP0NvLjL3P8jyyW+bQZvgzS4vm+MVUubyXZ0lVnSVdQY3WnnDc2LIZb88RTDyxqY/5Xhymq5jr/vEQHF+xDq5ck+YQ18KZ0akTeTiqMEhwBkweTMUEFaucxvw9nq4s7jK+qvzy6g42EjgLRvU3vJM09hvdFqBb7SYcZ0lyMy4KO7m66+iOfdCrdkNcJIXx/RXju6dn8ZkbWNj+dp+81m3OZbh31LR2JZ8JQ9SKBXDi589iyUhxzg6vlVxHcT3VIT4ImMm4ynkhQpd44gpXgo3cspYrZUzjKCU3eHHCn/uYyajPxGzGwCHwmcIxm06uaF2hJhqUrIiZQ8ZhCeu0XmOmcb2haWzF44IGq3y5SoYT5nHqzIKR0w3w1MlelMsPZ+McjgYlK3O8gbNZtq8uA/esWv+I3e9atF3NzLJYhUqkjYpkefCnEgzes2TLjLLVSJA2aYBqTZqgIDU2//VLFowYPctYKhGkn1nDi3/7Bs8IqmefPuH5u0+IffkW7wmsF4nvzID6+yz/POXyIMsoIjvGicSSyHz6yJjmywmKCcYiwm8wFs6fiuGMk3pSmrxx11HKmJn8U9p8kWvVaHzR41evcOPZGyxhqeKVht5y2+g6F2PbdjCp9+cbLOBeYUZGq5X8YC9Lc/s56meXKcd8f8H0n2UYNbI+oAtcMma4mZLHHN0oSyWGux3KiX5BHIFNKbFhwNmUkfqQ7oc1ucendxuBnt9YBrCcv7Bt1ni2cY3mggFr0bVODdzeSutzaR9pD/b1PaOlenGdbDgz0cQH2OY6iZnVQNNA+oDxncfICRjYojWSnlxlfe8cdnA4yrD2PanJaswhKJwek8SuZoIq+QnjvUd0xY8IsEen8JGUyjcC7Su5rW/sEvIbwd+MLnFIs3akM+bQMq3APtYDg+d6skSzxGR4R9atMmMHNpL4XMwYafFYZzLqs9Chah305ejHReMmkhx1wwjyUgrixU95EiTKDBePnUmrNYmFaLLz/J3ncaGChbRii0ax44rKiw71myILZ/IX4GDiESxQL584HQOp7lCj86+ceyZrpRhLJGlurkpmRrtzWNtPBYlqLSem+k6hEmyl56LZ8p9/8L7abTrjFcGS/N1R2nn18QNefGaB+vMXvPxAATFVD4q93nIA/6tPvJ/8zcP3CVwc6TWGDpgCpxF92drFrpYwTpYLWImgHXsQtDeStcFn2MbYap4/B3q8eM4M8wtJgGRTl4x5SXEyg/fb9x6bLufrIRvhNWIMJnVuhxdszkykDPfd5VBq+sKNDPhWeDgbJqSqpM6dw3EFrBhNcOEUv8U8KZcpFfnGeuXrS/txIZgjjDazi4f6qtu7thKYjLFuhLDwfASJtIQHfThvwdULkzq0x2VmS3N6d8L+ZYvJ/RAU7VqBPAG+c/hHaiyTBhaYvz/nRfOCgT+BtZ1ju+dNGMRJQ3tMc8PUbv0woXcPZpdxBkBBHLw7uDW15U1acZwl5dRvmSjIWsVcxrc4Wr+HjPVoqb7xAhBwTWBPOiGOxea5PXpiNIWB/Zq0pUhvKSUwq1h/nQ9/p2VYwcU217rMZBPtWgr3VrCp1tUAa/G4yZjQtQ8aU32ghdJ9SYIqO6zGNq7OpB/mcAVaT2aA7qOncVr0OGqz3KmJ9ySwxtPyTuYCB5NJ1s7FDE6cyfYHVxdhz0MrWjxvdh059emPbqwj5qI82UwdYiG6YBnN/+fkbBopsxBmcbbw5CGjqhHKapzQqKJcVANq1fgcbFTdsG2n0WbJcgkAL999wTsC7fWXNwTFV7rKT+CMNFq0b3hFtxn7NZ5u8gOWBu/FnHWHcT7uE6K4YNCtl+/w7FsybsTFMVhngfjuU/gFhVFfPRex8R8Q/z4Ja8K2cfWEE7jCOQLrA6g9p1s6tDKABdYuvDKnUKh3gOQ7KQhuslgxXFTg1k62TDH950QNujW6NAbeMQTVPc4Kde3fl6WkxbRMkbRUu3GWy5lErQvGUc5UeHGC7WPqVSSVQQ0yzm8JwBaqA3TFu/fphkR20Yxq0w5ng4LQn2n3Xi8qVC/vxReWWWSpOHQe315SyvKKFAZVr+FcNcNr0lD2cYTjEJcJHtC0FVbOnUlq47XJCr2HD+IKFj3YxNAMz0lPMMKntbuJ5LhLVF1fpKrhPF01VRePmGkqoL/DYJ7P+8Zex0gPF0xq3w1NK1Sl1n0UlyOmOtXPm13iC7i0ynwsGeeEbR4eOLt1KzNJFywYPhFevG8R46uGjIMm9uiDhWMnck7GdDQrW5kSaXZCd+VKtOP5XIJoIfslvWiJNnssowt0YqA+wcRfCvBFpJZko7JWtC3AZWmm9R3FBG0CRg7oiXajOrJTx7GIfI6SXDiegXx+EuxFyhVzzHnPx1RRA0kFLLVW5+AQEGWEWTmnoQHHPV+/wwGymvcpgHH/lgtFvqCq4Nnbj4h9rZKIw19q2ZC33z8ZwB07+wizvXYjkqUfTeaNYRfPa85sf5f6nYspfaT1+0a91wd4Ba/FdC4g6eY/E8MXDkFXXtn1WnTE0vlTePXvYxPDIgxr3Ir8jYcjQ9R4as6LUhPBTS62dGsXR/1Q3yQd1Td27bDTwAEszgx16t6FU2o86Qn34ZQ/mwpWcw4XteCnWWP7zFri+6uhJnB+Sk5ox9zZCKRmfGjDpri61hv7OLVPHcPb3RcSYI3w9mQ49Vd8vpQJCawlJtzH99d3kZxEeuLDAwMsz4lsDzsaxhR+Prqx7nqYUuFULrmSwgxybt/uGNKCnTAd2uHzczZKvL5pgJXC2wZcsReYDFAZwTgw5cEp0g8M6AmuL5zhkMSRkN6kHTrVbozGxSubeCl0uR82sMVsGZtVFLQvn8Kx4mTmN5H3krVxHznRzMfqUrMeunO8tjsJU++pzujZoBnqFi6DQS26Yu6o6YZyUMa3aCx1V/PJ+JOFX8BpOQKWiNGN81iY5lyG3//4C9m58Hv7mk2xgoAb1r0TxrmMQnNadc3vz12Ms7KIndxsvqlQWUv3ElgS+mnxHTP/SKuis5io6bkCWKbchTB6kg9jn+9I+vzNuMXPlNO8/PgZ995Qlsws0agL6AaTuWCSFBEvkhhvcYD9yvURCNp1AvdpkRSTxb97i4+pX7kowGf+ncgsk61kdx/AM8gLXhEu8DvljWXsEu42vD+2bZyLB3sjmA1OwYC6Tcywi7dasYGSYcl/H7DDRY2ft8K24/utA2Ze1CeqIVj/wCNaKwFrcpeOlJUs4gCSLVSucgECXy46zgD4dtgW08auDFNLrRzwWILAaW5wHjAMnn26ML0No7SnHzVMLMp2Z23QhQVvyoe/UM2Q8pwx02tKhV9SPpzEIvgbqiTePcDuhTOx1Gmkqe8tmzQBXVlri7tOEvbrSzM/dEq71hjQrCOm9O9DID6ipaMbjaeqgtmlwJUSS27uKcElYKVZLYHr6+X9+MRBIVGcNq04q2y2fOSVWnEZF38j0PNlFrhs0gySqWMRNH8hZ7WuJSCmGPfmSXc4vktP1jpLYQ7DCc9JTpjAjuxqzA671WkJJ8psFnHMkYAlK6Xyz4rpbgZYirHcqfIV4TqoU1f8/vufXPovIyoXLsvMcRxf2w/du7bELK4UW7RqJTOCQZYqZ74cqM66s2n/cnRCc8Y7N4EpD8cY5WBxOlPBPMhcJB8yssXH1WcDZ1XeMwtEymq9+PIet5ghRnFGOI0PrRbjMAbyIlFjubxb5E1exeduwWMNZ2DFvcGTpI948YFDs+kuE78qnnqPa4/jcZUjIIM5QGQL12MOjN6KeUGr4LR0Glr3qEeV4yLMGzQSo1u3Yxv9TmOtpF2XlOTKlq24uHEHHh4Iocg0wkiKP91mBkZO6AFnct7mADJNqVnvPBuHfYNYrwzEQQ7r0BZHxYP07B+vHiGrvRKBTpza7OTO0UQN8XDrMjyLWIOxnbojkPHWCPbfvSR18Y1dOyl3TlKyw5b/N+yaeUVwvY3BNwEr6RGB5cIsahLnzweyKYFNoBzj9PUVH0t+zbreAYyiC+zdpB0WUTdPwZdh8vGS76UEQNQFuS65RHFiP6wWXWIKSz6f2Tj7lgsUeJBuaVCao6YYNM8b6aAJ/GcsNCy6+Cqv8ZPZibPGWLQFwxUrkeBlEbkeV0gd362XsVpuw8YYi9WuSkMMb9/XBOpyhwraZa38KPrTbVk9URF+ZOdn06Vm/CMD/uvnX5ErQw4MYrlPmWQblm56TxnIst80s7RN3iJkGPLnQKWKJEjNyhRMHaWnUaNqPkpMMxbKg/KkHXozvR7jMQ7jfCZhAKcYH7p8DbFJXC2CtENiajIefkzGqfMPkcSFt+PvMc1/dIP1O/5eLLntPfcA+2/GYy1lNmfvxxkV6uO3X8x6LlIzqDX/9K2XiLxH7fz1F1i1dR3WsZgbyB9x7pa56MPx0f17daEaoAdT4qF4c42NDWpCJVn6iG1TZ8lznQ/cRt03ARLNsg/riSI9U8hgx3Dw7M2da4y18Z0wiytScN75UkpMuLr8KXavvObagrJ6GtAROM2FfNcijGjTG5sm86SfC8UOj5mYO3Qk3Nhkut55AjjpFp+5xo0kNKlvWOgmmJJfM7YSwN4TPG+fYNecmQhcMMOMLBpFqbA7FQ34yoL3F2a5lA+rC7oTLe82No6ylYjdOCwrvbrPCgJVrS/kEq/+sFopMSRfH0Uabusr3SEu7MU3ztQ6ycU2uzGrLMlhd22o/1KwvXG+t3FZ4pgEpkC6ro10hwrCJXtREN+J6tdudRuaOGvBmEkmCG9Wpib6NOGSMEMJIrrDuQzm5Q4FLN22wFo6eTrHUJF2yFMQGdgK+PPPv6A+NVhKBiTTKVm1NOZvXogWDDtyceWxvIzXNcvWTJuROEuyGZFcf+TOgiZ92sCfczc3sIjquc8d6yJXc37lDC5T9gh32OZ8h6u5x3NZ2/iPiTjME3gmjMXlNYOwam53lj5u4Dbb5I9yXNGGg9FYtvkkDl+KpwWLx/5zNxFx4rxZZuPui0TEvGcmybTyAy3g2i3sxbvKhSlTr+Mo5cGhVKV2YHDYqQotl/vMH8BKIusdzbGNipeiAjml5QJnoHN+w0d25GgFh69UjD7jWCEBaxpbm7x51e314dIkkpfwR7/HfsdPjK9u793M+M0Nm2cuNm5vDKflvN27je5uH1xGDePMhSmU+7bne7Hzhtqnryzh4DVLRm9j8fU1G0gFqEQC7B1jrHfx2M6SzVbKlbdTLNevSWNsZcmF0lQGpolc2HM11+xpySu8Li4epVX9xKZcvoexWC/vkiZh0wRX05DVSqFAUcAyjbcPTxl3nXKdoyEZxL/ixL5ZvXqiFvs+63Gb3qMvF1JfgRUc9ObJTNCAgXHVdp/lBMtEAmucsVgjO3RBE4rx5tJduo+bgh7MCusVqcjpM60wvc8IY7XmDBtvwLh8mquxWLJWjo3FbFfGWRVq0ABxWeU//kBB7qf35dJ4bDUrR0lyw16kNDgLtjh7UvNyPcpytRhjFS1M18e5VpohmatoflRvUxcrOPPcPYx9/MeXYpDPENTsXYMS1dlmuYyoB4m4yi6dWK5qeodjou8em8yhF104T6AeVwdtyVE6C/GczRTLPedg+FTOHl9/CpvCriDiUDTOXnmAWDL2yjC/8f9kbg7X+QFdxg7H7PWzKIKJxdFbe7HprD+ajm2FpiXJ1nN42Gt2F6vvT53NZ9ZyXtXKQBM7JXKgSNL5LVx5VVQErRYBpuA9mnKZmb0HYP6AUQj38if778O1B1dQcnKArnAvQthuvoZcjy9Z6AF1a+Os/wJ8O7vLDE4b15Md2r37YgXXGGQrMd6RQvjCtjSwuI3XD5GcyNjqA1URBNbXd7Rcb19g8/TJVIDOI2nJSTzNW+ByJBOK5CR+0TcMgGdjYAMOhOX9rx5zyAlB+fU1VRAvmRnKaiVwH09eS/EbVQ8pT6li5ZSZb+S1OKDLZImf2WmUzLkR+z1noh67YXrWaYgunEm11nWeaUD14CjwxaQOZg8dxRXLFmCZ00wDljnDRpvit+KsqX0GGGCJj6pVoCzac/DHqHa9SIg6LJY278mz/i9gbXDlCKS6zY21+pX9EX9xZdw+TVuT05qBpiz3qE7o5DODlqqSmQNSphY17yU4zEE0vDorCpUtCj+m2Sv2r8T49RPQzbMzXNgVO9ZjDC0NU3Z25py4wabUx++55l80yb/dFHT64eSGPmSDu/JktUbI7JYslLZH1xY1MHLKcgLqDO5RyvxOy0spytcmZNFlprKI/YWSlr0nzqLRxI7oOKcnnx9qWuwjbu3AcK9RaF+5oRlI+5pDPsRqP6Zq4djydTjCxbkvk5NSvPWaK7C+5qysRHJV7xns3ti6CmcCvDkvYTCcWQ5RCWQ9O1KidzjmKhz298Gqia7UMTGu4g/kO2YMUriCmHoLF02aymYC6qaatsANukrQ/X69zJOb+BRfGKwjkWoIxlaf39JSJT3D949s7Eh8jo1c43kLi9Ueo8aT82qHxLibVJG+5uMv2dgwmI2tzTC2L4vUn19w0MkTBv6U7ry6a4D1nQD7nkB3yFgLz8hpscNHwJLV4jp2ZvUvXDmNFLaXxbA3sH+DpiSMe2B6187UqQ807tB7vBs5KWeCYixpj6nUkc2H66BxBljzqO1qRCXCcHJhC8dONkqF2uyAbsPl5fo3bm/YdkcAP8kQp7J0CtytxVrLWqVkM39wDe8sbHDOwDWRarML2otE8oA2bZGHFqwcW9mKVua6lXmyoGwNukKtSFGQRcTSlJ1O8ZyG9Zc2wTVkthkK4a8VqdjifvDCASOVibz7klbrOZ6Sc3lwTqMOg1i/6otdHr1wdssEnN7QGQu7VcCkAa0waooPQk9ylakXqYhlv+Db1I8EjENLb/dJn76DNBdnNLlghMdwzNk5C8P9hmMnaYCHkvXu9kNX1sseH+GilhrFzY6bixywsX/FGmZ3nAG1cxNnL+wz0+xU1nl7fg/iDu3jCG+2U9GqeTM2G8NBJgHOXPib4xsTjh2nvmk1Vjoz0HZdwCVCunKl1Pr4xCl4nKnNFb0OYEyHfkZysmh0X3y/dhifycanPiLL/o7arQ+xZMwVrLMb6A1BxVgr9QMVo8/vwnvSMJ7g+ZjdezBmDhuKzx/5nO9v8PzxbQO0TlxFayNHCTG4ovuktXrDhgtyYXjJjatvpMYTZPGiMUicxrJ97AFZeWm97rOrW1TKDc52OEVSl0NJlo8ahDYcMruZ8V8L6sMCZi1BwPTZPOaxXEbPib2Bk4wSdA4bIkysNXwserADu0P12ibOchkyih055ajRqoH2NRph1sBJpoyjeqJiMrfBEzF3GLNCWreFjL9WTJmFWX2GI+svGfEnKYffNNCYfRJunGnv1HsQSuTLj99zZTXLyhUkD1pFspm8ZNs1eK12A86qogx2yWEf7Ly/DWE3t+IMyyRX2Cq/+9RRCvC+4s5zatLf88d6z5UjEmMQ+/g6NVRc0JpB99Ujszk2exi2ODVlWtsH63edRY/xy0xBOZoWK/YduS+qQxPYWi2qIu7tW7z6nIyVO0JQqVNdLN69EAEXVmLG+ukYxeU5Qi9uwdxtzhg4tDueU7v+8hzX8eNA/VP+64zOe68H1wnkLKjHXJggjlOLX3Ak98tTHI6xim7PZZ553lqnCRjKFF29c+eYRSqTXOvkAv/p8xhXcZY5V7eK2baOFonMfcI1yn1cMb5jXwxo0JDsPbukSS98vsKyTxz7/N7H4Mu7NEuT9NwRxJNVx8dXXFr4GtP2gewuno3JbF5dNY/a95Q3bJ59icNhIejTqDE6cr2/25F8LwLrcyJBKkApo1SslcROoURm3PHX8ZWSH7yi203kFs/W+xfUnD3lfXTFKVcoq6FlPrhiCWqxO3nFmKGMk2pw0YIpbKkjuTtmgpkzOn+EE0s6Mwww3BgHzeXocFmrZmxyENi0iSRtWKoKWlSsjam9RtNaOYClAF7A0qbXLyB5upyq07msL+b5Owd+y8gAnhYr019/Y1BLatWYMdbheoYZ8+Y0Y4zycUR7Va1XqEGlubmqRJVaFbCGsVXo3VDsfRqGXXc24UBMGE48jcDKiPWmg+Z5YiozQgp32WiRwJarxJRPuPv0MafzuuLlNV/SP1wTZw2v3IX9uThQNLYej8HE2RvgtnQjNu09RVlzIh6+TGbQ/pH9ik8QtG8PhnJRy/KdqqD3nD4IZXll2b5lmODLtXTC5mHX7UCMmCE1KteGZiLxcP8WHPBZhcNsHd85x5ujHzezJs1R2Ic4xOOEKIggbJ41l2WZRdjnvQzb5rmga/X67I5ZQBXAVlouF84DnUsd90S0YwfvRc7mBK2xGO/HV05iVJfuVAW0ZjA8Gqk3qEWnXPjrI41NYlcyA+5v7xhXvWOL/xtmdYlPOBSOwPiURAnyBabsA2kJZxLIbbhONTVgkkwzcPeZ5YqOVWpQHdCcYHnGeRN0hQLUe+rwX3Iuw3vOZEgkn/WOQOOgOZWAvj67xQG+h9imtR6bvRYQMEMoReqAGR2awK19Q1rFrqjDmft9eGFMalUP9bjguMvACQTIQMzsy1iVXdkq2Yg+cGHb/LxREzjwzhFnzRg43GSGnWs2MoXl+iUqsUm1P49fbnS8KV4LVNP7kuOiPsudqhItQCVeqwgXN/83aYd/ZciEDH9lRHOuCualacycRJQ5T3azUL3Cqkps0f+pOLsr8nIachUOha/XoQE6O/XAqOXj4bJ5Nlaf24AVJ7zRy70fRntMx0KSjPdj3yL+yxeKfL+wKM0FFI8sRfT2SbyqOE/q0kRc2DQWgR5DcSzqJleY+MgRR0ls6TqDJRt2YvL8lZi6mIpGTpjz5TjHwGPbEch544PnDkapBpUx1WsWghgvrWP3zrTgSfAK4Tz15eOwmys1vOEcq1tsKti+wIdiO854Ys3s9j6OAmIL/L0DIkq3IpRzTYOc55NFX2Ju7/FehHZkng9Q1715zhysYKCuOKIZObp97uxIPkNQPdDchAdkpadjZMsuZt2/GFIYn9klk0rXCgII79kky8zvaxIt1Fu5QbLpb1kDJNjA0lb85bN0JUPJvE+hlLctbp8n/8Q2tLdcW3F4uy5m+t+OJYv5XKpY3/N1BFWKOC6CFJ/oSnn/s9sXsZ0a9XEETRPW3Rrw6u9KFcG4zi0ozhvBOWJuTFZ8uSQx1yTav4scXRe0o+7pHifptOXKW7NHTDc6K5GXKtHMGc7fb9x0Wiy6R4JMVqpxKU7yI0FqM8MmZaujdpEy/M4djcUSSbqQQBGwJnUfZoAl8Z+K1Z6Mp0pTIvPzr3/h57+zIAO3iqwRLuRMC0l08rDGLD1WDhWhObqJDascWkoavhqZ9zx0i9lKc/x2BQ5fq1IctXu1QL3+rVCwdXEUb1sCWUvlROO27XA6+pqJlV5wabe4GxxPeJhV/7gdnCQ3moNq22A+5z8lfEnm8DUqIligfsB2/WtsFVscsA11unVFvX7N4RzgjDOvz+LY8zCM9RpretVatmyN/qN6IfRaKPwjOYhj60LM3MF4z2Ms1+1jgyYL2SFsGQ+d6409i5abtqjrrOrf2RuCPT6UkjDOCHbxwIZpc7GVixIc9l2GTiyt+LJrxU88z2gnNGHzyMZpw/CNwPnOdnlNtbl0OJy69q6G4d/s4YbUO6c594G0gGTHaRZKwXaqYittb1nGItBS3wlYiZzqfIpM9xCTzo/mELOkOJKf1M0f2rHZZG/duIDRkygNK2ETB8OIVGaR+MBuIo4TOBi8jQEwGXVKUBowdZ/UsxNXbXWnXp4Z7g2WjwynRZ0W9wrkP0RSycHRAmELZ6MalQUvuGb07N6d0bdxO6yb7c0ylNwaM7wRJD2HMr6i9ZrN7HA+B76148JLA1u0Y+OEkylotyCRWa94eXSs2ZzP5/giEqraZg8RYz/YWCvRGEu4eJNqiOULcOWK3/7Gv7i0zS/MDBW0O/fozwpHLxSjtZLFykYeywCrMCvRudj+pdWbirK3sGCpiuzBL2FqhdmKFUZFxl6VWtVF5gp5UKBmMWShGLASh7qev3ofCYmvGQ5w8nAkZ5HPoxtpkgNLl6tBIhr3Xqgt6xP/T8U7dvokkHEXwdqSKss249tjiGd/HHi6F+eTTmLtyfUo37AyurPyLy6mX+9unCE+HbtIeB5i0+aC1a44z6G0quoHsZ63cdocqlOXM3jn8ias/kduWIv1jKM2zKQilS3ja9jZu4bE3mGqLce06Yg5rOrryqtPUaPfeOrSzxJUHND/hVqqz8zE5owdYxSWU3t2o76L3UDs+/vMk5f6iUE2QZQiUNH9WZDJYtEc0epwzBCzvNhzJ3gShxp34zx0OFI+EnjJbzCHisxWHMC/eNRQw399e892NQISXz/g/N6d6Fi/IupwPZoZA3vhNFu5PjxgLEVeiwsGOYDE7avWyKYe/ttNjkfiYLjki+F4zwUPYrjIZU0WhU8t528TvAINWDHxn+VhXJkALjCpGK3McPYwAoZWrDeH7Xau1QBeVI0Obd0FzclNNa1QHS0q1OOkGT6fLlIWaw4nEY7tNBhz6P682GRhLNaEaahEmuPPPzLh339lMS4xQ8asXJidWn9yWpXNRD8uK8hO6MpcU/wnzezOV4AEKWUzWt4iPyWt+ThbsyAbKOp3b4VaLWojezEqShvUQyGu5JWZhKrWyxnL9qIn1L3fYZH0zomVnFuwAq7OfTDbew/2RScZfRaSP7LM88UwVpryF/vpC3pMGo6eM3pjiMdAXHx/CReoVd9LmXGLQS3RukYtnFzGeeoTXCjkb4B67F1bFsDWJi7Pto/DLEIWezgs0hQX0/2rQfmaCbWVK0asIYO+jn1za1ieET/lPXwMdi9egsXDR2BQ05ZoS7exbPQgymSo1CSTjniePM57OMTZUsPadEV/rvtzfjdjI/X63aaloAtUPGTcFaVAqbQuye9JbAogabGWcYmfYtlMehTzWG4ZRXXlCnbGMO3DhZOHTHdM+0rluPIFrR8piu9ynalfsN5jMfVdVRHoPQPv1aVDikHH85W1wm8s6Uij9Y0ara/MDMVhfeU6hR85NDeF1YKUa3TfnMOVxDCiIZd0Wz9jHPtKDqBfTUeLlw9/A9cRo+BKF6VSzawB4+AymO6R2d2wtp3RqmJ1eNCCS83amLr4NtXroGFJDhXuPcIBLNIRc4c7MZseRA0/4zRWLnw4g0vAqlykpFko/vdMOfBH5pxmze9WnJisEU/1WQ40dWcG8TW4MutPpchjFaQsolrVihzsUAI5i3Oleg7OajaoM/K3KYt/58/E5sSaqNysATIVV7MiO2JzZ0Jdov9oNOc4vKRE+cNbI62JZzCv2uCBk08Q8/qrcZegnCaF80jf0DUmkcOa4O6GQfOGsQuoO0I4Q/Pm65MIuRWKThN6oAHXpFZ8tGWuF6ZQMdooT0kMZVmnz6je2E6VQhjnbkrasobqxt3UgEftZFF5qQ9WTpqCdawJ+pLcW0lQLZVEhPzN9tmcveU2E9Xz5+Xf/UkrcGR32Gpc5zz0SCYEezg+sRdnLrTnLM6uDRtjPyU2R9bMxAmOVrx9/gQSblylYWKxWS4vma6LLWTakr++IsjoCuUWWfeLiTzAMeIDKKprhV1cbk4F+bnsymlYsIIJvKFO7PckUtm7GLF9C5a7upFOYKZJefJ3EaZP2HEUy5IORYMiScXAS52qDQ8vOwbSPTyLL6xMiAL5yGVkwNvdmzTj+w8zJOq6SUPQiYsa+MwkfzVyhCFKxUcJWNJUCVhjO/dBS64iIvBMoEK2EQendaSrrlu0EgewDaG7ZGdQOmDNYAe19zgXAyzJaqpSgpOBbvCvrFxInssHatpjTQoWBKwmBFgR1p1lsQywRJBmykvzxRRRbdL565VHg2FtUYJXwN8ZKYVoUAoNe7ahpSpgprlJgpqNUtRSZWqYZXUTWC+UIEss+pNPH7Fk/W6EnbiPW8/ZOKraNHv0NVyEawmAQ2wwjZKSsX6T0IJTlPu5DsPlN9HYdz8E/Wb2RYPy1dnJ40UwMGinyrF5ibJsovAiR8kW/Q3+COY8J41lFHAOr6JaIcDfdLKsoPQ2YBZ5N5YjvFmMndipB5sWOmFsi55UJvigI1cy61KzEguvldGueBk2l1ZAWzLGVXIUQeUsxVAxc270rl+bGvES6FitLJqXK8m1/sqhNUnjtrWqoR9lyVIl+LqxXYpjr59c4xyuN3R3bOv/9imBM+LDMaVbD/Rq1IiNtvu4lPBVdKlaixRDJY6vpOJClAKJ0nvnjuJw4Aq6ulsEFq3S0xv49JSWkxzW91jOJIu/Z2qIySRLUyl9/vac8RXd4TeBiq1in6+SKGXJ6mNkKNUW59mu34mBdndKf04gnjPdO9eoyIWZyLgzcFedUDHWTK6e4cwZDipaa9+oZHlaJq7A1qMfO3cqsbzTEvWKVcawDn2xYKwkM9RnjZhEEA7gLHjSD3SDfmzQUM9BNf52f2fIiozZ8iBD1pz4IxvXYGLj6iyujahapHRZ2XLlJo+lrLAYSzoFCqIkrVSJ6hXQalBXFKnFXn0qG3KVLYluY/uiQJXS+INpZAa+KBvLP5kpAixVthp2cb1BWSoh6MO3L3hCkC1cFYIwdkjf5shuqR2S2YghmYz08bGvPmMAu1bcdrih8+yuKNu2GlYd8seRuD0Yv3QimrI9fAOzuhUsi4xo2dGM1QnhgAst+RsZtMYsfrRqykz4Uf5xhDyVQLdqElNhss2jWncwQzEaM8tpyjixbYUqqMXiehDbmvrVqcVVUWewd2EPSVYGxbfPsp9uDfml1ibuOrNlHbuaWTbh3KmvNzjD9E40Ei6xw5lT8x6eiOAw/q3sEeTC3r6LsdFjNq0CF0D386Qki0z5Z86JYMv88NYtmF015pJ4p7GQAK+ePQfreAspYSYfRReYwhjtxe1LdHc3SGFcolJUylEKBmNvkb+i4I8qVCQxpntxzwAr+aWsF+U0VJlKVZr6mO6Z6+dwCBd7GqlkpeXynzKMi4z3Md3YqQzq3Xp1wiiOTFeLl6yVSjQapDadxXQBy3XIeM54r2RiMLHvAlbvhm2MxRrcthfmj3E2GaWohXFdBrIPkWMnJ7LsRXeoxRMUY2XKnIPnn+w7gfUr+az8OXNjQsdu1Hk1McBSx1flqpqPRTVDvpz5UbluHbQZ0t2AS5P9MlNZ2mlqf9Rr35TrD2bm+Brex+xRUlQtxlSGvvoC5zh8V20mxTHb4fDFu1i+eT9OcWEBDWqjfMv895Yrgr/jVOWIU6e4+lQPLD/JYRUz2nMB7MHwCnNHyIMtcGKdsGmduiQwXU1TwIBGbdCEa7lsnOdqlsCNWEGJMMsNS5mdrGBgvpmitBm9e2JItYYkOhtQuNYao6iyHNOhj8lserNtLXQ+F1XasJwKCWZCY1j3e8kTxblYz68cIbXQBpUpZPTlmEkpPD9f2mk6ZDi+GV8fs9j8jN3VXCQJjHnYwk0A0C09JUgozgPLNfHRJzm4g7EadWVapGlkW04cZi0wxG8VJ7ZQ6dmzOz5TDWFW1/gUj08M9CUK/Ebr9C2O7i6Oc7qeUS5DEKkZAy8kVSbQ4hwiQmqlyfQTaK/4N6U1b2+fwiteFB9Y2nrHSYWpt09yLOQMgovfi8edylkSRzmUpE+rVqYFbDaDdjdanrksKE/tPYwBPGMnZootyvPYaMWm9h7CC7eCySZrF66AgZRNzx3FyTgEkNQSUpiO70G16ISZFPbNNGLCshzBkIHAksXSghJanjlnlhwY0rwNlwtu7VCSkiA1wFL7V4FcnDZTszJK1iPlwAm42bi0Sa0uLdFjRn+6vwJcVyXvj3WfBSptzVq355wFIYfjG2WxaLqcOYPJbwvnfnJmafSzl6C2z9GIwTLhrSfPMITzn4Z6cIbAxXVoNqEVxvpMwXHOe/K/uAojl05GLcot/NhkoQnFPeu3Qgu2pK2n+9EK8yGcfqeip5oUJlErNUOF4p594MVYYvl41rVoqif3H2HKFX3Zvbt55nikcmjHI/bwuVPTpVrdewbDnzmWyG0UZ67nLo5x5ILw6CqnfR/jnP6jLLHcxueXj/DpOReKekLG+wmBSHCoh/C7yivUon/mnIVkWRtukOadJGfShf0Edkt0YiDcsXoNo9hMOMcGDq4q8f0NiVQSouLBvr2K4VgmXoxGK0/AkGn//OQi5UCc9X6Rk2f4+SnJsXjPGuItql63c7GA6cMGoSu5tXpsGm5EI9CElFCnKlzBizO3RJpGeLoy4SBvxpppDIfltqldxUiKF7CsM5sZ9jzydlN6DWUwz8CcFkmSmWn9hlC3PpS6rHKsiXZATdYN+7fsRi7MoYHXGocTuw3F2G6c+05QCViqC5Yk2y9g/Zkll2mi0LxaqUp7cKr2EOJBnu+HxdKQ0oIU+lXQEFPWerSqZhE2Zk5cPgcFqxU2C4ZrLKBWV9WaOlpI4G+idC61QFIkC1iyVidP3UTXzqPhvMAPVzifNJoDPhI4REQW7QkLgt0HjkWDPk2xaDcHZJxajTZTOmH0slG4+uks/C+sQU/nQahP6Y73qDHknaZTgdkKLdlGtMp5GhtX13JWuoMxnzdkpBkmtpKKT48xZOg5E8FjNJfy7UFBIBsqezWsi6CJQ/H9FNNyNn5qPsKu+YvQslQlHGNKH7bWF+VzFkNvknqf7tMaXT/FXkBJYh4ZxYEYdVEJ3xNoMV6yefUFYx65J1qaL7RUX2jRpHRIjqGkmJusS9L5gxjLDhxJfJqVLYEolnHwlBbvEwP2TyxEJ5JYJbn69QUbaqWRZ20QZNcfUHB4ixP2XjFT/fr+HuII3AD3WWjLeLB4Vi6D/F//hT/+89/4879+4f5X/PWfv+OP//gF2f73ryieKSOqsW1vNqXBuE/LeoWSIbaVda1fhVngGCwkZTCbv9d8xkzSqbsMotyYrfXtqtTlrK/BBliSzkjVWrNgeQMst+GsD/4DWF50g3KFmhBYiFZKLlDAshZLUpq2VWphcKt2hraSGrlSFfJYheg3CxaiTrkil2ktVY48VWH0YdtTq5E9kZGFxczUauVlpijLpXHMGdncqiGnx04yFSagOEHLTKha4rka/dqNwMBBU3CVa81d0LQaWrG7HNG9cOF61GnYFW1GdCLx6YtFEYvRZ/5AjF8zljzWcQRcDEaLnu3RlAe4aMgQtm1NRmdarDYVq7FDZipHNUrLTWXjEJYZqC9aTAXBAiohNQBjLgeVOdGsj+s8BN0aNoNL7/ZUJLB1ikv6JlMhypEzeH50LyfyNaEeqjJPfAW0rFaHnk6KTTbjcjCbuKNUuqrv8TzhDKCNJXrL+h3dmBhylV6SE/g3xX1yZQJYyvM7zOT4PMVGzNomdRiACpnyIGCxq6NQTQDJWhkV6SdOshGgBFoC7NuzexxDSr3+AY5nSrqHT48us/uGgCrDTvRf/o1s3LKzFpftzwxmy/TrH8j4WyYM6DMKS73XoSmHqWX+179QjuvatGCmvsZ5FJtoWSU4uYvWvCn6cWzkcq4+5krWXRbLuf8Yo9jwII3Tvmo9ymcGmaywAYP2gc27oFahChjQqjtc6S4lVbYWa1z3kcZirSKjP4uLOuXn7Ku/s3N6MuuFf2bKht8zZDZGpjHjNrlCrUyhurNxhZrJLQ1NJeqx1MlapV1jTOSSYTnLsjjNsTU52JufW4NDOOxBK9VnJSmXm2Nsjp1kRwn9nKyV+CwnlkvGdR2NXp04hpux1s3nb1n+ScKSVcGYNy8AnbqMZFF6KFc7WIQFDN5nBk3HPBaeLyWRtd7ugWbNW6JJqapmSL+02h3qUYvF9Fa3j9DEBy+ispHAmjdsFNxp1VT8XMC02o1/j+k+AN240uug+nWpAOCEGs4FTeYQEcl6kwksxUdbWS8syVVhWzIzTHpIF/TsKl7T/UkG843xzJtnbM2/ewVxF4+TPtiLO9Q/3aXo7+NtxVcEUALBR1CBkmRZsM+KhahOSH0XiwtcybQvmwxq84KLCObYJOmwRISKAyPDLhcIggwf4kxXT1LMbSTepSulAuIOa5xasaMWFzcqmDEj8lB2nOfPLMjxK0H1O1vZf/+N7Vd/4q///hMe7v64cfMltm85gOL8rEJ//45mrPVO797OrGILgmvV6AFow2qDz4TZpqgsYM0cOA5TyHEJWB2rN+A0m4EYzqy7UYmqpqmiNsccDeAIb5ehk+FBQlRsu0o6Jsbi32vYsj+pSx8eWzbTvfUb3aFmqYnHEqdVr2Q59Gnc3KgbpO0zWWFJzjjKS9lpnap1kY8tPKO9nVC9YxOzkqr07zmpd8/Kkd05eGVkYldsJsZfIkhXriaXQmC9pvzz1M3bmMSquFO30ejdbhCWrObagW9TsTp4J/wC93Om+xr07sM5S1wjeRpZ9Dmbp8J7P9uWjq1A+LWt6DKlD4YwS+lQgWa6S2cj3Whduxnq5S5oUuYD61YgkLMF5rBcoQksc4aSc+FIoEVsa5/WdRj6cR5UAw7lP79qOSW8oUi9yjYtzu80mRRnJHzmDHjNQehUrhamDOJsrU8sKovdJhel6sB3M9nvPRtFyFV95UZQfHp4FY9P7cEZLkJ5hOz2HXbKfGCpRzJio0ZgM4UUCgfZmBHuQ8kKuRzVBHdTLaHw4PtrymrI2H8R1/WBnBfBm/KGw4PFf1ERAbLz6i/04+ijJiyjFaeArtDfWZH95wzI+mtmZPx3BmT5NSOy//I7cv6WEb/9rz+waN4anD33HOdOx6AP5T0Ffs+A0uzjG8rBHWHzJ+MVF1k/MG86apDtXzKOSlC6LzHurkMctT8vzsXqUquxsViDWnQ28mQBq04RWhwCa9YQ1heVARJMFlgiSAWs4czSs7H4rMG2GXPlNzFWFnovgaw2DYDoBgHLUYTWRD9S8cXZyVqWDHFjkqJDFzghe6F8DMQKc1XzosimBQbYwJojN9eOVuDOv3MwxezcuhsecpJyPP1h2MEoTOBBTWIL+eSewzBq+Cxs4Ro7vuu4+PbBK3DlfMwh1PwEhxyH2zp/rD4bhAURUxB4chXmB3igPxsP3Llkm2pZfTmPSYRcp8q1UZTxnHMvKiW48tQGrm6l2GHe8GG8EqkMJbBcGJSP7NAN9crVZLdwX44b3IbvXK/wO1vAUuJYEnl9H+8ePsCYHt3RgpUF58FDUYXr3zgNYrli/Hi4cXMaPxLTxo/B/FkzsMrTE3uCuaYgVRd3Wab59orqg8/PEX+Ls+3DOPGFhKoWbEq6c8k0VLxjs+qbGAr12C6/buYIdChdF7u58KXmbKVQCJj69iUBRWv1gYqG19Jukb1XvMW/v9Pqhfi5o1O1SijLKz8/SyW5/syGjD//ZSxV9n9nQp7fcqDAv7gk8n9nwt//ygC/ZRtw/soz9hnEcaiwD4pm+gt1ONusGqforRg7CM/2rWdWPQyl+bvNV1xEekGCPQFrIheTcmeM1ZXAEsfVgdl084r1zCSZusWqYVDrviaT9OE4o4XjZhlr5dRztKkTrpm+EO04FTALrdWfJNO1aFcOsgN/cThbRnq7qsXKku9rAPVP5CElVbYa1yssySJ0Pkb3tUgQTvByRbk2DZBVk9noBhVvqdtV8yc1UUQBfDYO48rHk1OF/nk8CbXoe3FYtXobA2eKvrqR++gzkmOcmbL6bce6TRFcIPM6pk6YgskT3XDg+DX4bdsFV86N2nJtPVeVWokew7pj5fy55KamU/RfHx3YLKCeti7V6hlgjWnfxcz2DOJUPP0gboMHEVyDDaUgLqYLO19al6uE+4zDuGgMA9lTSLp+nCz6cswY0Qt1WMrJREltdrYv5WdMoNt//Oe/8MtP/4l//fQf+Pmnn/Dbf/xv3v5f+JV/Z/nvfyHXLz+jfJ5saEWS2IvA05IhLy4zXmNnzdvY6+QzyYRTjyWxX/Ir1hCTbuLgqoVoU5ykcQjLQhwVKReZopoiy0BSn8otStVglKO0VkoOorjAZsOSRVGSzaA5f8mAjP/9lwFX7r+yI88f2ZHz31mR91+Z+Tvwov4jK3aHHqQrTMDxMzEIXheKCoxnavJE12YTg98EWuKrhzGuVR2UZnDtzCYJxUpSgbqxqDyhxzACZiYzuGam3NOmUl20qdbY1A8blKyJoe0G0MJNNBIZAUvx1VSCaxl5rFUcI9mwbA38TVcoYFnaKTOTvgwM1isWKokWNAoWWKUlm7HqhmYtmqLPxBH4rUhOrlFYgBKIYoyvODqSMggBS4uOZ2M6+RdXWShCnqs+l8jo3qo3upE3mki14SwGfpO6sbOmfR9aqBUI2n4c4fu4vt6ec5jBtqRpU9xw8MRV7DsajdmrV2LdmY1w9WV5h/HF0U2buMr6RMqEW6IhQaJMpneDlijJjKMX936zpmKr5yKzGvu84UOokhyJ6RySMahND1QsUhbrxg4mqJgBkoG+HMp4jjolBbc//8dP+ON/M4tifSsrg1+5FrPx9l//pmX4OxtPYDajjMzxJ08ui6uZfv4NudgwUCRTJhTNmIErkpbnQP3e7OFz4SLjvnipmIssuhH60RqlJpGB//gYcZF7ODm5FoK5AoQK0HJ/BljKMAksKSG+UCOfStmNXsshXozbr6A+SegiJBpz/5YFuX/Ninx/5EC+P7Oj4J+cWZa7FMLX78Cdi7cwit/96vmriHn8hgstvELEjqOoznNSO29WDvcYaAje50e2onOlklwIoDDG9aCMR6321FnNphBwfHfOa6ch0O+qC7QZx0B2b9jOuMam5biWYodBLFpPNkBawHkOAta0XmPMyEm5xooFuR4AL3R5r2w0LCZU0mpfml9LYDUiP6bGnNw5uQy0gKVJt0UImPoNGyBf+eL4s0Au060jYGWni9Tyvbm4jqFWMc/C2wJWUQKrTcVGGNxuIAa27QlnBocupBPGEFg9Ow5A8JZDOMDVVc9EUefE1quFTs6YwRreoRNXcC7yMdaHHMXYJa5oxaDTbexos96yDwugY7v3QhV2n0xj46gApTkDzSrUoQnXpBUvM2/KjbzOjCHDMaXfaLSqVp+apAp4z0WawCLtpkUzUCprJmT7r98JHma0f/6JzD//jey/ZUaOXzIh5690Kz9nNPvsPJGZFM8QVFkYzwh4mX7PhNKkX2pWqolsv2ZC/r9yoChjmEYli8CtL4fKrV7KkUHbGLiTfvjIcZBfyKhT746PzChZ85vJOemes2cxVeaoybd8TLorZYiK5Qgkabg4IdcBLILzwoGdKMuJ1Tl/+Qv5fsuGIn+Q9slajPtcyPa//sJa6tdMaYMc9CcqcN++TsRr1mCvsm1uR/AeuvWCLDw3Z7MuC+csWp/Z4IMmxQujCtveR3Xqb5orFlFnJWCN6zYE80ZPR5+GrUzZRuSo2Pa2leugdZUmHFgy8Aew5o+ZYVyhc59xHD43xzD3hXNqyRPOwWK3s9oERT1lp3hB4BKw6pVmrZnKFwHLuELVCiUnrVajulmYxyxuqBnerAGJXhCwxLpnpRsUWrPQmpUqWIy1sOYY2mYgR/P0w2wWORVkDyVb26/3GByNvMFBbLdw+Uospox1wUIOkpjJcszxM9dw/MAd7Dt8F7P9/dGCQ++ncQ3AMLYrBbDjdhqXX6tB8ZjKEsry6hQvh9psKXceKNkvx0QOH4mZXBBpFrOd4Uzvy5FTCXOZhO9st18+dTAKZsqKrP/6m2DJhIy/c84X45YcBEs2Wqfcv/MxuhpZhuz/FriYcRFU2X5nWq8MjED6+T/+jSaN2uIk111cwZaxRtVaocifmVGdJr/F/8/aX0BZeW7Z/nDu/fp29zknLoQEAoEQ3N218CqgkMLd3d3d3d3d3d3dC3d3K8phfb/57P2SSrr7nr6j/2eM9xQUEmrX3Evmmmuu9Mlt4/RRjs8y1A0iPWMEFKU4lAsfHlyhyZhifTqyNf3xnU9SA7AEMPcALD1uc5oaS2CbNrSvFcya3X4lamaKl8oKJspOw5LVauQpY00Da9nKcdRrGmxoDwVrAs1dn7+J4N5QtM1gmSQwa0YuZyj9M+q5tBfztfaOTsmHnr0RvJQijSKWUqFqLPFU9dBhSeyoZYpWlRsTuXJaxXxBDlhDuemtiKXV+7bVWlmvuh25WjHE6gaF2I8/8HoCLF2H06O7lgLWT7JyB8h5eUN6wMqUm2WKtJjAJyJvSgCvC6v6zUKkvCXFXwmRPwmJSo1Q9j9gupX+NwjGAsEOWJopyZ+8L4V19XK1rDu+TWe4hbN3/znbi7NyI8DWi8K8K55Nh7ggdmDPFdu0OdSWbd5jRYqUdUZks3oPsCUsQPRFnF+apYPK1Fl10Krn59xZvlTZkHtURHcNv8LwuUdj/nu8MGXREFXLkxPFwjKb2q4u7fm/2bcUvAlIJfG/BDzUKr8QnX6kc/rpy++pXX60hNQpAliS73/x/Zit3sSkw2T83iREuB/+7XvLQ92x/9BFO3nqrh3cexVHvr6WlVFWSOE8Fi7aAYrAZwRCCqTGkk7ro7q+xzfsNgZt/Tq0d0W6+CqnihDwFLUAl1Kir95SesS5kHqsIjd6kn+Z0PL+lMkqJC9ilVMUso4l61jfWu2oHYva/RsP7NzZUJs7ny0iyJ0wCShfR1jfjh1tK2v3H67gbsilCryRqIkqWwnScUFuVctgbTSTitFtejtytEudNlz2amPNkAh1c6x7FmvN0XEtVVQrUok3amMHwomcoOnXjFM0AKtfw65IkQZbceyQvkCK/AMc1m/Mb1PQdUpipQAkfAhYOvKkmwG/JEhoDlg63StPI3k3aM6jAbMiVbKMGV3Y+wmgSdyn45hSN8QHodm4/FSHf0zdwNrWFB/xwWifNOysRhSZu2Sbnbpw206fvmaz566hjQ3hskMb6IgBduDYZdLjNdu4+YztJioElaxmwVhUDmjeyhaMGAHP0smtXRWC/a9Pe1sgJUoLagEnTmOkIHe67o0b0SA0t5KpmCOiRZqDEUfab7+hJf/WUiZg24ghtGx3fv7Hty69JP2W1P51AmomlBrfJaZu+tVS8eO0P+Lp9H1SS/Htb5bq80SW8t9+tviffWu5MxSwcxfu2emLD+zU6Xt2m3MvW1assqrFCtoFbLGVyrxiXIW4+3EE9AEgC2P0s2DSRHvGcoXUodFvAZeKdUUsabjQcilaqTOMeHoXAv4KunGalH/8YtXSlbLmWUKsQZrSVi1lEQtMhlTpB1S87FWm4Oj3ShZBuG5A5GKcePu+zRveH1oFsSKXaWFa7SXW3Bonlclf2nJjHx5MihOwxiB76VmvrXWr1446i1FOzaasyFewEunzkBkauXX7eqVr8uNmDoSKWL0adXLAGtqiD84yHS0ttqF///Z7NxvUVXvhIik3mJL574dnoWTJTrBRxBKwMvOGd8CSTjkzMhLXCYpZ13Y0f1AnLeJjppVAd6MBltrMhOiac8O01ipS0WoDrGbVGtL+t7bOdXAE5gs4fOaOHTzK9k7oTeuC2WpFaIP2RLQeXZC/nL3FubiLto3l1d3cPqwNaSoFQ9uatdAo9WGS3tHtyRXgH1qzWBl0VBkY6xRxaoWetaEZmMr3adUKiUdtC8mc1+Z3qm9FUiaxpF8CIArfioULW35e3O9o2VOwUfL7N79Ymu94R8VLYVnipbTcCdJZjh/TWja+YVm/T2WZvk9pGb5LazWzB2P1OIyzJA1g/4vbLQ6o3+aY+s3br+w2/hIxbBUd3bYeYpvUxKKqr3D3pUGltEiB5zU/fnHBLh4+xNEq9gGpoQQspzolcilqiaL48EoaeiLau2f25OZlomFqa1G6jvUo3dwapSQlpeK4ZqpiVvY33PeS5rCcv6SFOE1sD2/w59C1iZW+cvqMc7UxnUXhJo9hRndk5gh3nT4wf1nL+Rty41wFnThPwOqK9VH3+pznhfvSSn0lSNJy2Ytg+9iAsU5Ga1yuHtGrhQOWqB793nbVW9MRD7KOLLSq+ZHJ2pd0r5JMqYlTFvstLVEKcEmynBXwpSCjiW5wEUtHmsSWZucb8qsAJfaUuktpUB8TwWepeP8R2kGRLAXmD4Uz5oVvqma1S1W1dpBtoygOW5HDe46guMWe+yRR6fTZ21YRTisQMVm1osiDB020U6H37MjhK7Z11znbvOuUNebPaHYlmmEIY5qJ2OyIWS+XLTedSg7Lhdlu2dwlLX/KrM77shey3wG49DUqidVk0YI2tE4NS5/gR0uHRPZ3WvRucDApfsWYl/opzQ9Jmacls2w/p7N8CeHoqF/K/JrbgpLktmK/5gBojE++/JWitpGFcT5PtQxm8HZo+14auVf2+kUYKee9vXr1CtkV9ACR6d0d1AjM+VQnaajsdXiuGPenunBSoh4v5X0q2l3EEsB8EhrVX/dh+nMhBmyYLcgqpCpkwb8VtJrJilrVVEWscIKMFpS2AJGZGqhgoPMgc8JJNPbvuWIroV80BnTRZ9czNztsM9q3ZR6axcoWxqYoLdqzdHkY6Pez4R0GUeCzDd2QVTiKddEPeejwVDc1Y4miaMp01rg8I57qbV0alAy5Y82O1qkWYkk8topnK+TGSf/OaOlLlm7iJ+UOAN2oHs2QE0M/ZSVa6UpvMn5NESsb043P0uAsI6dbad6TQnDJ8i8ppKnM1xIh/NNf4CQz/EFFrBS/prBiWQuyYl3Fapbgnh2RanDDjtYS/mrxhh0Wevu5nT1z2zZvOmTFilawFmVCrFTOYtZvwHg7dx0PB4bVuw9c5h7hCWuCnKMlx7p1UqQr6/DD2Ngd3JLuEn1Pbv6xsjUMgo0vD/iCMueygQydO9WviSivCpGthlVE8ZqZG8Spv+dYeqKUNoZ7fUl+JNV996ul+ZqUnSgjq1HZrGyKAlYlNUsNKQpbpd/5ZiXOAVtdg2iXx5ZMgCn3y3vckjauJko3CF/tPerEMNb/o96S6gCG2HYXsYhAMdK8q3gHLA5YfuDEvEAew/MJbIDQ+32+Ql4doiiKZ/aY0VKpLEWsRUAtK5U4n+X5JZuV+72Q5U+Yw9J+n9r65q9tpVJmt4E0Pm7gjwVUFENw6cZiGN/EnmZshYwmAmVEu0rBVh3pUDEiVR4WJIplyOVY9GGt+1knVApdarZAClPfetVrZXmTpiPVNbDaWBkVxCytacXGFPft3BbTOICl0VyPBt2sb/3mljJhcvv2q3hOfPAVROy38h2FKBcufmEyo82cLAQbLVIIWAnRobnrXyre5SeZCR8ARSwdNkzGOpFApVz6Czk1Hr/+A92hiLFUFGrl85dyIwBFLYn1tXnbFu3Pqct37ETobQu9+tDGjpllpQuWcwuT9cqxcjRyBmQqdtvHrtj+I9dsw7Yj1oDjkZK5SCNUhd20figXnKQWVl0S2nToqgv9ls5qFihuBZKkYnWplg2EeqhRhDEEJG6OeF9xGR4VI190bvTbE8dNt5+oqzLHg40mImWLn95KJcpllSmKa6UoZvVTl7JGGcpYpWSFuJjawuoVrGJV6QIjnutyha+zfx+FWgNxYkSEiw9ECr6ZfmBplCNgudpKCxYqzj1gfaqj/qipBC4HKnWEAM8HNh+wFLGe3bmEmVoZW9J1qpVKmIt/dzLL9T0W6PEyWdYEuWx9tUFWMGl6O30EmbL+MaTb6LPcU8TD4iNe87GnmHUSuR4xb2yAtKYFytmCmXIiyEvnivixWD0Oad7TgaoFjZUoodrcVcz3W3oky3BZlBO5AIU6wh71kSt1HcR9azy0KjPVaNzD6iCE/FnaK66mavisGktuyWLgBawf2YBOBj4ykSUEMEUtDaHdTWhFLAErIzJa2XErYrmlCqKWAOY4C3JnPBFjIDVj8vRIM8rip1mL4h1xGDqfzhodjJxkd9kjPIL4L/TmE2vBQLNmiapuYbIDheP4qdzRucKp3RPXHL+1dsN+qx9Sxw1KJdCT0UVTVKCq12QS1ooXKT0Dzly/pHLcS9E0Wd3ZDm3UVCtQHo6mgbUvk9+yfP+tG4kUzJHXli9bww2YlA5UhX7MYGWIUA0yl7VmWcpbk3RB1ojCuG7KElYFoJVKnNvyxOdNBBFZmQ5q04bNtnAVVyE4WqTw4HRkClvYNUXxDXU1ksYzAEjFt9KZA4wfWF6E+kQv+GkGBz66xj9+H5GOP6uI9/bxTZsxeJKdH7bRKiYvbH//x/9h8+Ur+/F/xbfZjSfY3Kp9rTY2mU6Ki/zmfShOf5jefmTCoIgVdYppAPd4DiyebC3Rg9XNUwInmixQNNmsBulzQs/ByF26kdZacHG1KhvSnd3JuCBmpn2IXBmpjUSmNgmmAWsBw05N3I86uTsdaQfI0TwA9EvW6eWOHM+vw5NDsupwZS8Rpan58xm5C6Bj47+pXFK9roil4t2ZvtMV6oq9CrLfM3DcEHD9hq+D+AoV8eoMVdznwM65ZvGK1rhsbWvEo53/JnXwdt9+0G49eGMnL962vUfOWdXgWrj01nXOJc0IxXMXb7YLd566iHWCo5orV++wplXqOROL3rDKZVhDKsilAw1ItQPXh4Pe5dggVlFeLncx9gMDLQsga4uNT3nSxwFu/IWjpBzRvJ6l++ZLK4IocM+u/ZaBCJf63xJYl+IN2MreaTXTlrTaqUtYjd8DXMdVM2Uxq5G+lBX9Benyz5ktzc90XhT0mb9L6rRPw3rjNep87X2iII4xAwIBQ5SByE4ilrdTyM89QOnjXx9XU2mxVY+fchA94SKe/g46xwmsxi+v0N92NZpCXZXe0lD3TSjby8723YAkpoBdx/FQK2gRoQftHe7QApa2tz8iDgw/ilTmPHe6EfvVRBqdD7e9fEkBTrbCSKVZ9RdQKMRbQ5Z2qNKIgryhpSALyOCjDVYCidFXZUuW2hX1OhowsdNA7ilSj3GYKSSgvCVHgvwtXgxfEKkkj4lH1BKXpbpboErEZCYDGUz0k6iqpDgXuYNfLMW4iJWEkY38sXTFPnFK8ibRyotaKuB/4feozkr6WworiAKxUZkaRJfajmAbwCWDZuyvXeZA+GUuS1y++ZSrqYutNsBqAwsvB99WoH/5un0Wev+FHYHLOst11mXLNkFV1LIB/vSnCFWAy52B2fI41zkJ/rvVbmCZE6WCy8pKygpGRZkLtj032vYytm1sb/uIUf/HG8cYXTS0DAnj24Uzp6104eKWjQ6wde4q1q9YC8vzXRoLTJrbgn/PbyEpC1vFlIXY/sluBRNndQV8qvhprE3G8tYxewVLAo+1Z/MOB6lwAIXcgfzI3E/Ach0e4FGHRxrTR1+X5+OovBrLi0y+LtD/+z1guXToi1iO68LiqAeX7HN+ncb2t5hvL0cftSt9ttjFftusBim7X89utmcLBr6w/dH7V7ujmTEcPQjfyS2fQ1v5MYX7qb14WrW2jJm4yUzaKp2xgNVDY9UipJ6b8fWq384alaImhcQunj0vb6RfmRC0YDsHm21Smjo6cZHj23EKBcea3qzqtwppwKgskyVEWRwPikkR6/sfEzp3bTkkJ0fFIYDpz6ej5k6FZNkFJaKWKKus2tJRjeVFrJRQDAKW6iulQUUsgSwhfygRz+9os0rlDkBU15C16mq8A5pbB1LhaNzyHr+MtksQo6EU6O2YiLep0cSx8jL16lC/o23aedJO07oLWKFXHtucOcuseUhN5n9NnNVO3yatrC5GunmSpXUTd0Wsoa3bWd3SQZaJF6NKYWojNFr56GJCspfG66qfO+2mZU67f5YXpLpt37DKenfvYUkZ3nYuRLQs3NyKMhjOyiZOkaTZrECiTBbwW3bL/UsGy5qQN9Hff7IiP+e09fWGW688NSxT4jT2jEXbcBhu6cxkT/ghDNdjpT1FKzn4+aONryD3Ryx/4R4XYJ8A52fcffNB5oeqzQCqY+XDn9uhnRvcDeU0UCJ1MgRZLVJ18r+hK//6C6tVnkPtbEW/ZaHDDm22CNEdiBY/7ubEC3/uwy7Atn8LmaG4ZeYbX/CHVFY9fzmrFcjxc8R90lK1o0FqEFCB7ML1LoR6hem2u/G9yY4N+w+AQBGnU7VGzoF5GB5bnWq3tjK5i1oSfBpUW//E6CZhEghypFXisEQ1uMaOqJUEZUUqnt8Y/YlN0EcpXzLJFESne8W8615h2syZXSr0CneBSgW86iulwxTUQeUw4JJhRH3qp67UTq0atbc9h9lqAVjn4KkOHr/kBtM9GrRjEIoaFGF/qzpt7SidotbsD+HpcP3WS5sIGNthYiF6oQ/HlxSlusJ3VS5YwvISWpuwQKoOURe3KufL7zwG6qIdKoKdtIryVcN6uAtc7y/xrmUZ4jXc0eaVC+zgwf0QoYmsLmnv3KANNmvENEv4b/FQCcS39N8lc7xWiq8ZXf0NMd0/4tvYMl3tat/VFhQ/uzXD98AVyfyfS4QU8Frz+gQsRSw/KHxF+V8KdS96xekUXWRz0c3XOTr+i+JdqVCPRIEvrpyx+bPH24iBOL60a0567OgOTN3fA6BOYsm9b71FYyNga1dZ7MqlFrVhpUVxDcy2YE2+YQXqBGaGGYvbpHQhbhyUE7OPiS16OQ173XLVaFLKoFfjBs5331sN3rSt4aZ+BYgCThYI0m61mtnsnsNpnrpwXKA2xTh0E9HpGxq2H6ipJJn6mT1CFewa6yl7OQaejlJzYzV9v6hwR8Yu2+70ohsErKTMAT1gaZTjY9iZXPP5Xwh18YliP6f53dJxVFr1Vc96HQm31Rx4ujJLevLkvUuFlwDOjNlL4EXqMuaBGoDUHMWBxVbNe9n120/s4p0XdujUNbt1+4ENwGegBBpx2eMMbtqcJoCDSNANLdhnK0+qy5YoOQcdy7iV+/4ATM4mIXmLW5U8QZYaJn0YHlFa4Iy4SOrCdzSG1ajn7N4pxdTFE6t4+kIWfuaJPZ92zLrkrWXpv0hk3//75/b555/bV8wOc8bLYGPKdrU3k87b+JA+LmKcvcgtHqHqI7UV62z2BtGfN+v7Lz46oPnT21/ToICnIt2wPXIdHey8YQritqwBWoQ3mFZxHyFBoNKqVsCYR97miFMoB6WOcKniAOz6EQ4krOZUypJFFs0lsJiVy+3j5vV2eMJ4q544lV0v3MFGpS5jOaiZQijcR7cfyhHOrlYVHVXFfAg30U2l5pvflUlJEeaDjpMi1eVOltEtWUzBQ6wLvKLkMUkSMsajnv4eEGmM8yPiPvn/K8JJOqVaW/efU5IWBbCkkOeJxGFRuP/4E8BiJ/Oz9KQ/6atEN6RmjJOSe76KVAKX1IK6AvYDHMUPSSjKcIXTlLxb7XZWnxqrM+CZNQ/h25sPdunaQ7tKDdUFzqUjF6Z61GnlpC3D2/S1roTZh5xHOQ+jfeDEFXsAADsgnU2fMCWr5kVpidvYUMzB+hG5BlK4NwUYQTD2meGkauPBJJe8/k1bWHE8PIOJmGWJWpPbN3YOynaOFz10N6vnOhWC1wGaqcsXjtsiDg/052TL5iZT7PGkw3a4y2KbUamvjSrdyeZU7GcXe66xp0N327QaAy33V6ltMB5Q925dt7NHD9nV08cpp/CwEij+CbA8ULm6SZIYvyzGK+rFvns0g/v7BCLnWkNnKDXpC0ZCyGkkwZEjcwyS5w8oJT5cOoa8mhuMh3da7P5t9oHjl1GrltoHTrXELlpokUtJi9s22OzOHa1P0rw2PXWI64QD8aro0YiNZu7k1OMNWpq6NAuLpglYLi2dPZ81gRhV0f41fJM2bgqnzoFLzQDI0QHIjZAXMz76DZflRIDmFxgBcVVSMqgLFMD0UUX8r2BGwPod+3aB61ctMzP+E93gukJdVhWw1BWqxtKAUbWVOIrvCG1fwWF8yW/+LuFPlpfRSm+KwZYQavXL4zKCfufE+RuYsEXb5etIZk+GWg0ohH4sR2ompb02STD6clZW93Yu+oH1EC18S0J1wfSkONQLQdkLOrG+vMo1iO7L7FDnQYqmy2epUBdUyVPARqIhGso8sgxLrZkTJ7CdU4dbFJN9LW9idwO4MIIN5TI8XldSjq6aMQWZL5EpfgYbGdzZ9jWfY1d7bLPrvXbYyTaLbVnNodYsQ1lL9rf4iPv+bmWK5LOebRqz6TyfrayTGMOwDIEN5P8rsDyvh1hGOdGiFcLRYlGbOVGgXw3hHGt4fO6ARDHSo5YtpJyIZe3s43XsIolWsoe0I/h07eXi2WY6wrUsX6xYYgwO7f3i+QBrvfXlTVjj81RW4R8ZWcClGcKFp4d4KwBWjGYrD6lOCpXUiX+z5sUrWH74wX//8XtHdMaDzqkIeT0ff9Y2wXUsIylQRXkCmrXEsOq/adGGDCZwicPUxpYiliiHpIAtBcBKgjhBj4ClZQpZu2f5g3nH1DZ/AQes3+R8yzhHqVB6LF1W/QkeS25t5RGFDWvKVYLyjaxBVbZwh07gBEqs8xi9efeFzZm11OrQxmrxsTP1lY4n9kfFOGLUdHfr+TK/7/DJa3aD6FYdfXypHKgXswSR//OhecqAULCKS4d6t2ljREK+/L+gsPzuJytKjSVvp64cT8qF9n5S8wYskx5jd5CVcxhome27i6UsdkZz4uQMhwha1a5mvyMF+uFfv7DE//YjOqffHaOdEmohAYBNh3qzAYul8/CluhmKlFk1k1hxp/JkDxAXv38GLEeC+qOVwCSHP63ey5At5u0zd+1VCxjukoUM3AQuCQB5nIQGybIiloAlufJHNqO16/jx8nGiMKOb49zW4TzLBw5MfdxGhOZggm3iDM1GHAy5U1iTN1+dBDlsQBJqp1xVrRMFeNeKjVx0Kkz3llyFNylNS7S1sCtScf13NHXfsCX+S/zE1hbKSDPCXAz8E3JhQvXTt9RePwKgxEkRdxJ09HgRS0W7lmy0Q/gLwcf9mNoriYQLpFqlQxexJCdVxMpfGM0ywNL8R6lQNMPvRK8kmTI5gjQliGyAH8II6qX6ZepabaSumzZx+w8/hvP4uN+Ao+oIoDpBvEn307E6LSwOMJ1h5mfMWcFViyjmiES10zfs+pX7FhzUwIplKWml8xDCMxZ2or4AwmptvDL7UMTrhFlfllObVqzJyADjEqQtqVAnFMucxxqVr2jBubPapll4pl/FcB+hm2wdxUZ/PE2XyDv+w52LeB9ctucHD9nm6dNsTI/uboA9rFs3WzhjMiXLFtId33DOt7gFigix4SI9NSBGm87Wss/D3V+g/1c1ligFfwr8oD8byWIGZ1/Ef32IxL9CKlPGMB9vYbON6YcODygVqqCXI6AnpdFqWazAxwb2B80kr3EV7BLLsaeJxMfxIT2KIche7Jd2rLEPcq85tst2jx1gtSB6dxfvYOt/q2IVEmR105CQIiHWCPFl2YCKXBZJYKmIXIHZClimJGk4s/uLff5rIges31hW6ckyStlcRe1nMpNqKI1tlKm+0TKqujwAI77KPYBKIJJ6VAW723zmx4pYyQlGyanFfUoZad7p9n4jrOUrVJjrXxRiAEtUg495z2iJSZXahE4NMtWWDmna3aqVrG5tSHH38CR9+CKCe4VPYdPPWwMKb4nK5BEgonMaOqt2fIGrN+63t9Hcj752385IUoPtZPEi1ax4lkArnbes5U5TGKEYK/64+FaE6KyZP4/VxytdpqyD8GpoA0izJE5txeKltY4J4KM+T0GdlRMfzay2Ej+FGJYd7Azr7iyOfjzFEsTZ4xZ9nuPj546SVhgIP3mANp1IweaMOcUnUSX6LUZ61EXPfD/XoqqzKAIk0a9g2hWF/MPl/za48L0HLY6t99lC01tKj3WD5Vask3QjJ4ZLX5o5ug1plKeOFyOKqcYS6GIp3D/ev2ix7BrGAK7o87Dt+NJHcPQg+jAUAxLoSLaHPpw9xA5mdesfP8CO52PJNxlyGUZCIYVYRpm61KZxbqZNx6HopTCbTZnBchKRVBt9T530JaDSaCYNvGHlPCXtV0xRXM1FjSSjj1+gELSF49IhZZFApail6CQBqNKlusCk2G0KbMnYptdSjrZ0VGPpLpNTN/xODs3LFXYNoUWAecqGhPyFP8NpSfyXk2XWIWzXanOjKurGmWzgaK3+Oifkrjx8adNmLnIKh8FNuriZVA/8AWbgQd6idhvbuueMvY6OtQs3H7k54u6tBy1frnKkQradcwVaHqb5uZCKlMrK9QZcWsZg2jqhE3uI+XNaMzZsx2JS0ZP6qghykEkZK9uJfO2s9y9FIDkzWpaE36MsrWPvT+K7cIbLWQf34GOAdfVxOqpj1CkH8E84H2oR1y7bu5ust99HRnyPwvzuTdIT7f8z0tAL0hmKT2mtVBcppTmjNY9O+G9ELZcGSX842vpA5WMtXPSKvnnGIhjDfOA0i/yudJbuA9HpAx7xHivvRSwtwgpYH24DwBt4vuPVFXOROz7cSdTJ4A8ALOb4Tg6Nr2WGms36/VLUevxe1Er8mNqqYa29cN56rnxsszWbj1FvzbR0FOBZ0LclYmUrHuD4mkgk+yEtRqRjZCPJ8Y8ocRXJ3NIMv0fAkn+H7im5eTH40MxYRXoqPLkUocR3+jbnqcMAliKWyiV1ny4VinlPDoAUsQQsoTMh1Ly4LIXCn0R+EfaKUUDrcmerCo2Qu7R0kYfjX45mCL33xNrjTdWrMU4lnH7tiYdCPzwvdVixbYNOdvDUDec2o4glYG1as81y5wh0wCqXO9jypSli2WHEg/NXZI6FEgFO7fjSmVx7W42TTAs2SnIStepYF64tVMhRxAYnKWFLkla2PolL2eqeXA1Dh9WpYnk7OXcWQNpj72Gr8QzHX4GieSvd4mZmaifYI7zMbl8om843bkkt57650YAq9plWtCim9dHVP4BE1IDsh/4JqDyS9E/AIlJpmVfAkl2KNp3fcYsn9gzraYjy7DZbPtq4hlpwUZEay9xBAYEdQxAtw97h3ytjXbwiRKtY6C6iMWoGgGXnDthBdi2Lc3FL2vWKrHFl+ymltYGHmrXxoM1ZtMtWbjps/eGmsuIbmoToozT3PXWz7LS/QmYUjxFNsl98dIIKc3V8egSseFyXSET61CMsqCzyaAV9FMjcXgScpw57CVhi3VVjfQKW/N0lKc2D04vCnPgL8VdiWB2fxa/pL6sTGISsor9VLY3oftAEN/2//yLcQjnZu2vfSWvL+reunw9AhtylfjNEe+zpde1nTTgNe5XTvo+5o3OeUyc34LJmTVtuedIXZmUokBFNRQan+bnPUgQJbFkrAdCKs0DRBEP6F1giGqYca7n4EAxT3iBrGatbpSbue6UhBIta2y/zsva1iOsRu+zC7LG2d8QAe7RqvsVs24L1DZcd1lPs7qSg381xJZ6oI3g1XMHZhWgV9UB3bNCqswKviOW4Jmez7XucCkFR6L8RrXykKa5/WBp9jKG+ErCAlMAVoeiFhmo/zoSPufb6AX+raLxNY19w5oQFVgcqFe+qxfDG0pUKw9ZI04QPt/HhwpchFmM1u8QbRFKZM9wLuryTPYMq2FDmYk0+s5Me5caFsU6FBrZq9QF3a3vM2IXWnF3PbPBY8bghqDWtr+GYpFD4AXch99Ddfa9uT0uoDJalYNDnvAGzOkCvrlJt5QDETFDjG9VXegQsxyaQFt0mNGWTq7HS4WAidUMu2G0nkYFxlV+Dryvk5wBLqbIXvuhDsRCsUb6Z7dh1zMLxaL/95K1dff7axmGR3Q/jWF1F15mNLnWb43E1kOXHrta2Q3+7zbr94zfhdvbqHbuCEHDk0GmWL2OABeUuA7DKW+4UeRywSuYItpIATSmxGAPpgTVCkIZsspc48Q3InN+GpWVdKWFeK5Eyh4XkLIxkJiVeDTXwaacjPMaLf4gD5Pvwv9qI6/EG3uV78BPdssNiGE5/PExKPIdN0BWM+m8Dqoe3nV+Dcy/GJjsuqD4Byw2f/3nx7mokDZVdjQWwPkjg5UuH3EpzBfqivq3s9YHlgAImXdZIunAhGY6Ahar0I97v3vmTj4+gHO5x0xCHG81CY7kVHQmg7Dx15MWdnCVeyDJLNgvhZIn2ArRfqatgJfOVtsVLdqIkWWujWcRYv3qnFebguRz4PsdE5JufWYilK/yRov07xmQC01fUW9/yOa3O6+c/yqaKqOVFMNVVwoUAJs5KINKEJgUllACWHNJcn0tJ9EqJKZ+A5VJh5sy0pKQ6RSz9YQ9Y4rEUtaTDyoELnFyHO9Zsbq2Ygj988d7eUWBdvfecTu+htWIcM5EtG12fkvS1J6L9WQNGupFMzz6j8YePtEeoMT1gdUbyWjATNRV0Q6mc5SxXchSjmYsjQ67A5ypbuTzV0FvltlKQd5PqVbKn3Cq8wWnalvlLWNHP01q1b3NYle9w3vspreVgsXNii2b28QTXsrD+MWZn0bt14w9D2AMw8YcgTQ9S3J/C2+oS9ctViuPbpJwndH2PFSWUivxLEf5o9f8GLPFUPsrBdYWqs1TA473qAIYP642ju+zoovHs/gF+3X5+QRp0hwN8Q2zJlT8BS9fAMNz9eI/jmABLp+y0MyiHZxny6u+Y2rkVlyly4chTjv3O7EiLQ6xC/qKs1uexmbPW2eyFO232gs22d88pqwTt893PSe0frMd/Ff9HusGEn4AlMKn7UxcoUOlx33+imPd4wBK4xLCrwUsDU5CKpk6iBQFLIEuFRNmt2NMV6nzOZ7JOllZZxbvCnf5ihUZR+ALX90hqgvHpnIPxfuNKDW36fC6cEuIfI+e98yTMVq7dYR0R5s3CYFYr7/JhGtSMA4qDRlhPRjUjRs9y/g73X7z9BKxGtdpjhlqKyFTapb/cKfNb8awlrGzO8lYyU7AF5ayKvLa4Fc1QzIqjHK2bK4fN58Xsx3WFtglZCs1Uy9ZmqmuLf69kTb/PY83T5LVn20kRJ6iljkA5HKEeOUlHeIooFYrt4jmK5YsXcYW5xrVT1TAU6nSKApZmd54rspcGPWA5VcN/q8b6M7icN4MAhge8vcdZ+spxi7oJSBSpZLTGoScV66IdPGB90OfwxXI3dZyTn46QYxVJhLNLOPqJUuFssK5wVOIYUkheGh1EgoWQITcIqsCWTVVLD50wdsw8W7r6IEst223XntPWEOHez4gkFam+RRT5JUW7UqPSnn6siCX1ghSiegQ2EaFevSUNngKOyiSVREqFLvUBJgFLxbxAlhb3bdEN7khTFrwbMuKOrBorbip0ORfLPz0JSZPNEZtNB1hNara004j13hLlb+B/df9puPVhVjgFUE3u2cOpQTVVn9Cpj83heHV77KnnLFjj/EfvAsRzbLycPY8WPrAu8mbqqxxlXPrLm7owwCrlCvkySofZyvC5glYoK/df8la1zBSoGX9PZa1SF7H9ObhdWAWXmqBOtjx9NZsTP8Tq/Xsam9O+DcA5SB2CVunUHtpxIkMofNAV0so1kY7wR3f5Zt6nSH5EUU83aFAQToPut9v2gBV3PPPfAdanGaHkMZ/IUv+Q2SlGle6IUi9Jw9RRohqUPkVxuOUKHvd5XQNTtNIFMLxHY7lmb7LjxilZzsja9B7bro4FcbpE3uyV8A8tkAYrIrzbe9RvbBmZGfbqPsIWr9xv0+dx/uXwZevae7QlgWrQGWaB63Nk3F4aFPvu1ViqrRRUlAq9NKhaS6BygPJ3f2rwBCyN/xS5UmfI7IAlMHnAchHLA5aYdy8V6j8mv9FvEMZrnd5dkGJMM6jfeOMUDid439mdp2/s2Kmr1gYHmFWTJlFfMetjhNO1XgubgyX1rAGDrSljnXVbMDaD1rnHEYFLtx+xb3jGiuWvgEgf/6scZSE8kcKkKeqAFpgzmFNn5QEcFETqvFaYjZnyuatZut/xms9YzBqnr2zHSpKKy/WyS6Xb2eVSXexg1o7W6POMLBO0tgiOc0sPrvt+sbzL7QoW19epq+4qSgGohxrwEl2ekoJ4fBHjL8Dy5n3+j/8MWJ/UC36Zsvf7PdGfgCYgxb4h9UXoiKYWWUVpYO3NoSavvlLh7kWrj/chUzmEGa1pApe/dKBJt6j3zR9rgVytqIqWSsLHkMKlrRiLLTqOOZAxmOqsJhjSrl57iAJ+l9tGHzNpkf2O2sGX5uTCRy2FgE8AEnA8YPl+zto8QNJsMCFsgBgCFewq0JXy9KiuEpD0CFzu14hcApMHLDeEzpYtizNz8FKh/nJFLA9YchIZx42Yzoj5tu8g71OQ3n1GtHoZYVOmLbbBXbvaakxmh6BVl7+SXOQWDe5nU3r1tkY129gRwPfaH7GuP3julKMF0FOVyE7hnk0+o8hkiFjFspdz0asMHwMBWf40BaxI9hJWOXeI5aLeKpw50CqmLmfj0texG2X72vWg7rY8VVXrloCU+bffbLcul16T+StkIvebo24ArOs6LEmXhaW2PYZeeELBrkjlhr6+Vaz/kAb/X4EV9/f/CVw+xanzb8BZWSCKfknEJE1GPQNoAEyHnxzNQL31EfdAd7OQ29A6HPBRl+zVCQIqXY29yfngBkULc2aPhRA2lyuyP1i5UBlev/w4QhdBAdrBQhjolytayXWGi5bvtc07ztm8xXhpAT7VVgLML6S0+Hhrue+zZC58r91DxPKilgDoHGX4/UqBrmjHeTothLSXBpUS9XjAks79nwJLXaF4D4FLSsNpgwZbD6iDx89iLZwD0PefPkZm/MSaM8JZOGm8LR4yyIZQX3VDBjuqc09bOgQD/85drFm9bm6O+Io69vbT53YNw1sRq3n8hXpQFlJh5mLUWAWhGegGc1dmIF0B3qo8atESbo4YyHgiM8ZgRdjWKZe7LJ7sSI3TIzNOUtjq/VDErXMVp0tcPgwvTohETphaODPD8Ht0glhexz6UcSwRS+ZnXmvvlJ2AS9/cOAX7nxQKfjnMP4tY4q/0uK0dP1vvY+z9UmZkxbIwEvnqVKXPRG34FKnRDMsdsHRejjmh83nHk9QdG4diiIaawAGOe4yrMfINtKocnKqRPwSP0xBSYaAr3gWsIBZJRiOKdJZO2YrYkqW7bOnKQ7Zh62nbuO2kZWFko3pKqVB0krpCRaa4EcsDlpcKHVEKGyBgeVFL4FIq1OMV8WlY6Vf0ysYmfSooBxXvbpkiB+cp0kKGyjVZw+YECf1SGTdsTGHdOUg9uEc/m7N0neNknnK1/tHTD7Zp407rwsB474JZXD7v405miHGfwixuxbix1o1LUl3aDLTXr8LsJWd+rz5mCRR6oj+39QogSlPaK5oJ7TlPXshR/VzUgz6WzlGO4r2oG/mU44XMk6IgAr9iFogWqziMffEcFXE8zuYM+1sjf25brZ7bUgljfhYTuoNrD3BFeKPbVSIsto8fdCBcIxMK9Vi4qk/jGqkO/mlx/n+nG1QreelQenj9WMPlTxp3J/TzLatKgeost+kGnW0kTyxdoExtY5/i1nyfYv3uYc6bULC7Z4e9Pb+L5YZqTgHSAP+xyujhKgdUtsr5g60a21IlkRvL9VgW2j3rN8L1JatNHcv96w0nbeX683bwyBUri/Dyyx9g3CnUv4z/k/3r19/YF/K5IHJ5NIOvGxRBit0jj6dtd3fC2XvwHglBtXCTQsU6HxXNdJ1XYErKur1GOo7HErB0ASwHwBJv9RPAUmj8FlVpavbxJbQb0W+kneGCfRiX6h89Zz7oinbO1I4cYjvnzHAOfH1QkorDWjBoiC0cPszaUWupJovEMvnF+0i79vilXX/w0tq25PRshuIOPAGZSyEsK4mmvbADVJncFRy49GsF0gQ4YJUv6ANW0cwlrFQuUqhGQUS2fCnyImEOcqtNXRs0x1szBx7xGHIgm3kfyqKBlA4w3s65TxfjSTcuYnAgyRGa3ur7/wfAcjyWOxUXR78l4w8pST8pSP3AcuDyFexu6weSVPNBdYIfHzJwvgoXJ+fAywftDZGqd/3aVgYOrwQ+Do3YXK5esrJVL1bZajBgrpJfr2NBy07RPpjzJLr/HMRIbHDvYbZt2zlbtuaMnT53zxqyJv8DoxtRC5oFaqtZRbzOlqj2Upp0psVO1OdTLOjR6EYUg/fRFfDStpMCFbFUWymapWa2rBpLsplPQ+isWTI5uiFn/vw+z1Fyr6yK5NRWgsWGET0A0KQFFs4M7F3kR3vwLIqi/ZK1aNgS7dJ0WzdhnNsH1OBZ19BXjx1vM/sPsCYMjmfCsGuu8YwLq7eevrYLjHOq4cMkQAk8RTKVRM1YwoFIgPKAVSp7WXRarNZnZUO4UGUHrBLZSlvJnDx0joG5KnG1Kr+7zj4IZr8tBGErDotXyJTSXbCX+4oK38jrfIPosCLFCdFxafanaOXc9bzF0f8hsDydu4828EcqjYNQsjoRX5z1MF9B76vtNHQWxRAD5RHFgXF7+Edd9fHGLnvIgfMeNauzeFoINWxpLnUFIyNqYPWCarhlYfmyVytS2lk5ZfzpN8xr8V7AbbpmiSBr27A13PB5W7b6pJ3E8qDfoHH2C7sEilh/Q578jx/iuYgl4lSAErC8VKiPbr2Lj0qDbnzDRwHMoxscMSqpuvgr6IY0bHWpYPeA5QjSbFkoyGBMRTckkkIQ04/PcbMT8hqWCrahgziDe4iCkv89e/nenkDPjBg9xUb27Wv7l2GwNniooxl0CGgcSoS14ycil+mJXquubVjPYBhgPcH89g6RTnr4EoUqUKQzugE0AlahdMXc4wFLkUt0g6LYX4FVioG1i1g5KrgXXDIbyWpb1cTzHc4sGFufgVUDLewwvgYcW3rP2VtXxONDajo26W/1XcoCWJ8MO/6H4Pq0Ts9yhACl2WMUO4M6dqnR0CcaQ2lTZKqAhTYrlnvQTqd1lxR4k042FJ8rjgFc2srhqHIlEToWtaI0OGXyVOdKV0VAVYdjnfWtQWA1a85KV62S6qCL4OCX2Fpj/aRD4R0w+q3LnuYOFoJXbzjrItb8xestaapM9ncM3hStFLU0iJb7sRexFK30YxX1ApP4KwFMHxWxlPK8kY4DFHWV47LULTKAFo+lIbSEfj5gZcvmiq58+aAbxF+h1fkCm2f5kvao2wQJxnx7y0XUKKLVU/wMJEFuzjti04JptnveGJvEtXRt2PRmMXX+oOEY/Y9jdYuVoxoN2CG85HYtH79+Z/dehtnq9bstf7YSLjIVyUB9RXGuaKV06KVCRTIBSlFKACtP8e7xXA5YkKgCVtnsRDvaYZmCDeR4gDwkZOLfv3oFW9C+AfXWOkY3MO+3mBPCBynViEeK5WC4/EHdfuD/B+nQgUrGaoDz/vmjFnpwu10/vtf9WBErLu3g2zFUKqQ7hX3/IJb9ATPNa9RVl3gT4p16Ye1Mq1u4BMcwi9M5B1oxCGSlfr1eilQduTndEOvsNuwJNmYpIjBrYUuLErQu6/U6daLDlzUoEdat2GLbdl2yoydu2N6DZy1rniJEqh8/8ZNKeZoXejNCAcuLXG59HnA51z5Pb+WnG7wUqIilH6sr/J0hdWrMhb1NaN9IJyvMKcAqWLCwM7T9BoOQb+PHd2Oc/himbdx1WONUe/Mq2mgIbdZsHPq69bbDa+bY9tkTXPqTn7gueK6dMAW/8uHWrUFjlyqvIEWOhsN6BKgeEO3GT5xneSnCFZ0KpCnm3o1KecUyK6T7UqHSoGqr3MkLuB8HF67k1A9Ou5WrrG+emC0YDqw4Soj07i7x9L7D3OKGHAE7VSpn5+ZNsEWd6tjz/QyxdcYEHZRY74+cDtE3VNHCFdN+QPxPC3j9PfJruB963F7ehuHHl8Hp2p1/lm9s4wp6t1+ooh0bb/4tDuy3Ubxe5d/I5fpDi8c7oWOJdHyt2aqS9oPcUzpXBdfkaLeyc73GKHhrOOvHNniPlcmCWzHjGh38nNh1sDP9qIO1+YyJM2zvoeu272Conb90z8pUqknR/i1R6wf7Nzzk46ZCFfACmhvxkBYVpbz5oD566dBFJ1ky+DtD/dhREDJIBlgq3n+C3XfFeyY8NtMw5ylcsIhbp/+Sol2S1SA2O0aNHGf3yX2RUQDrTZTdefDaunKSZNPsqRw2mmXLucquC55yMx6LU8zGKTNsJjeQ2yIh7o5J6hOY0XCK93vUVw9fhVu3HkMdsErnKA+gIEXhrAQsRaa4wBLQBCxFsbIF0WmnDXA1WVxgBWYqaI1LFmdbqJS7UqEZpVQV9YsH2Ok5k+zhqpm2sXdju70Jw7JrB/jGnbTwG7xJnjNSgax0Ss63//Ou8JNLnwp3KAXnleUHmj5+1J1CEaRyqJHXuwbPzy4773mx67qJY7cP29YZI6xSngCKdOopXh8RxqWIzhrUl8rOcYWsZZkHBlk3aB1tNHfEY1TD53JkgOR4VxWlMxvLQsQEhv6tKyMp6tzNDh67iYncJTaknlurjj3t3/l9qq/UGbpiXVe85ITsH+UoeqnG8u4lySvN+7Eil3OYAVRe8e4G0RTvuhqnWaGApcsUTuiXnrpExFa+PBy8pCv8PCFrQng2NavUwBatZiGU2uotoJKTnFJZf+qno6um2+FFs23mQFayUYj2xk981sChtm7iZBvP7UBZPQ7qO4SrX/zZd5F26+FzgBVprVv1sAIQoqWzClC++kHAEmgUrbyI5QFLYFPEKkCtoV8riX5LESswZ0UTsPo3qofXZgXk0u1sXr+x7pZOkwrluGfY1OzgRnu1doZtHtbRTswfae91/PL5RYu4d9zCH1Bz0Y1p8Ps/jVaeAlRS5rg/9kxAfMDyXanwopVkMR85dilFqV3dZquGdHdrWrl/gxQWd5ePOpK0H0hkrpg3BNIYiUy2Sk4U2ZWSQ8Zzuo+jpql8jlKYyf1gOfneaeF0Vg9mtHjaN6tT144cv2k795x1Xl+jsJbUsFk1ltSi4rUELEUo92O/ZMYx9JoXqkNUzcUj62098sbSmpdqqlQoS/XRdYpxgKWIJU7rsyyEMv2GbPnzuT8U7/ufGJ/ksLYcRLx+h3chNdIzjMeevntrA9BjbZgxDjv1mbZv8Qyb1LYf9ticH+FE7doJYziIPZqxTnsWVmvazDlLjWu99uLte2QzL1y0CylfH28taANYdPFURZDHeMAqm6eiA4/rFqkn8mDoURY9vHisQoR7gSwoK/UV6VHSGm3wTOAKw3TuO3fGe2DlmIk2qH0LVs9acHUh2J4fWIbCYaGFb5hll6YNtF3DO9m9bQuIFDQiT85xGxC900s4JMe+i2cSVUAnhwvyB5ZURUu4PUAEgB6VIEtIbdpoHKOxjNu60fKp/EhJhd4avgOQWHdt4YT5SVBk0CJqxa5H0aUKVNFn19qY9lyBh00PRP+fG3+sYpnLuDeOopaeqoVrWGBu6k5ApgguZa42mbrWboYXa2uWeUvgvZrQsrK21YdNp3kDRrgLXo3LV8dKikE0Lop3br6xLVuPs2GTzvlc/ePnH+0Luv54LK0qBXozwu9xqZbIT08CDjL9zGaPwOVFLu+jjI+1leN07pLNkArjDqFdjZU7Zx5LTgrMXZC7zyA5PrtmJQNK25zZCy2KiBNGYfWGVfMtO/fawM6dOJi0yA5wdHE9VyCGQDHIdF7X27fNnGqLYOjll1URQ4oNeIzKgO7xizd2n53Cw8dDrRi+pZoRFk1fwgErIBsGthTvAlO5vJUcsPTiiXXPlyqAz1W2MrxjC+PQ7Ir7bL4aTMAKwJt8dNNadmTpRGtZsgKXsibarKEDSBXNrHFQOdsxeSDjnS32jlvSb7chu1k01nYM7WQ7x/XmDiFmGi90ExCAcUdHFyN8TLxGML6O0eOkYsSaSw7jtph99ZJXkLvPib9SCpR/lp9u0Oecy4wWUmkQYqip7BWp9xn1ndbT7hy0e3uWWV+ud5XJWgAnPtyfqaOyJcnnZqeOJM5JCiRCVytSk4te1JWkQ71OPRvRrDAXVNMilW5V7ur8Fg8L7J9+5QBoTQesyZwvbl6xls2YNtMOYtl5JfSJnTh5yzJxNOBveIn+PV48+zt19HcEEUUqL1oJUPLz1wEmLbMKWF4q9EhT/Vy1uAcsFe+KXumwv/JkMy4V5snjA1aBIgH2DdzGLxCkTTGYD73I8iRUwUvqJDHnAziDu2LGSI5CLnfXuBZz/atfA0hQ3JJnD+RiPLLgKV2648dQ2yoG17CTZ6/KtIXjl6yQv420xbS8eTIXpU4K5hJCEdcJFmK0Uzh9cQeW8vkruxdUj0Al2Uxwviq8WwERdYRLl35glUC3pYg1snENewtD3QJ166xeQ2391Ck2Dua/TaUa3KepaVEI494fXWWviVxh2xZZ+OZFdnbSIK6D1eFC6wB7exl9lBQHYr7pFo1j4B+4dxP9xjfL87nLCFQax8j4Q+tdL5x82QkExeLHKcw/WRZpy4cRjyJe7Att/QiQMOsAyu4esXMrJlv7cqWsDDO8ksiHgpmHls5eCWOTnLzxSpPygpxWTYqPmsXqWEU6YwFLr1MvqJ3hbaV5a+WWe2tw1zEZKS0dwr268Fpz+w/nxuMoZ2DbDxv04+dv2ulTN+3mnbcWzIGHf/3iO5/tI3XWT/BYqrE+KUcBkyKVIpcegczjNlXAq8Zyng3wWopW4q805hGw0oiF92veXfGePXt2V2PlL1DIPv/iG0uXPotNmTzTokhjb8KiXJ207+AxaiuOSm5fZEeWT7cjy+Y4mkE5fhhbyvqGrp88AYUpng5lq1ld3P3ucgFMhfsdGPfX/CUDEPwVINyLw/IK8wLpfAATaCoUqOI+Cli5kxdy6bB8/qquIyoOMaoXNW7EKpGxoI1tXgti8TiSaC1xtLEt02faygkIDFkba4JHwen1aOCv7LE3e5fZu60L7e3a2WwUL7Nna2bZhgGtbGzjYNsyeZA9P83C61s6xVdo4IksH98TuQBYDOMXX9ENiJxMWd2fZoBah9cRAW02+8DlohbdYBTdoJsbyuNdvy6GnagYe58R0/19dmjeCGtAB14qXQGiUmk4KuajOOMUzVzOMibyAcvVV3TAEj7WLFnPqpao7otYSLPlcTGWwlzGaToOLi7rN/YB5apXNmsem95nMHPT8e4iaseGTZwf7NHjl+3+o3Bri2f7v+ApLy9Rben8xJ9TGvREftrMUZRSxBKwFLVUtLslVq18ASg9AlYKlizEuEs2o49xgeUilqcgFY/1HUeCQirXwL+KtpyiXSrRtxEfnAXjWjqt0xsX2PHVU23PnLlsLbd161myyd61YD6ncTljhs9VSEA568wxIO0b6s/ffEThzoywfo0WRJ5AupdANxsMysMBRjRXohFUP1UsCIjU+fHkTFaAz8NhASy9oCV4oQWsstlVe1Bv8IIXz5DPJrdtwDfrkB1ZOcM68e9WV7p91iSbRyPRlvnYRFyVDQWmJL2Rh1aTFhfYS2qutxvnIFdebk9J6cu7YepatzwHzjuCUbRcUhkoNb731VG+zR3WwpQmXV3lewQcffToBLcnSIQSsNwaPR1htO4SPoV+0JV6zuuuG93VaiFPCuJrLkH0LZ03GI6qokvtRfh60yfMDrdX0l9r0qxkrWS12TGoXqrmJ2DJlG5az97O/lyHwRtgr52EncA8XOAKSJ2FuW0/WzNygi3gRrZMg9ev22YnUJjcfhhmE7GX+vt3iP2+gyT9Fl0WZY8ilkczeClQgNKPlRrdqpc/Wol9dww8j+oqRSwn9IsTsT6tf2XjPIVslPPmLmA6ijl81ER7/T7K3lJbidw8euSkTRw4xC7uWGIn4a50RnflsLGYeGDrCLCWDBtmuxbOtUk9uxJ+G/EiFXM2kQga7AWMu2iGM2euW1ChSk4qo0ikWaE6vPxpCvkAQ+HuAUvkqIBVCidjpcLidJAClgrZcjkqOWAVpzMMSJvb5nTnbO3dA/YGmUy3WtUp4CfYjtmTbeu0KTj+dbKmwWXtMXr5WJYtnDPNYXwmdi6wN5vn2vsNc9gmXmBRu9bYXc7CLeUKfK+KAZwHbsD1lAUEMDpH+WDJpIOoJDMPkZsq3FW0awcxVvNA+WapqGfA7bwZ3OUJOkRYfjejRLgn45KZHDioysC4NHxUyVz4slI7lspdCTqFrylPJV6L4pbmx8z+soBD6+5rJfoHNbIapWs5YAVBz+jS/NwBg5yZyvA2HbGKqm1JmPkVyJjNLVYMa9vZNo6bYhugirrWrW2zJsy0M+evuyWWzTuPsiuY0T7/hgMLHATwSFFvVuiByauzZLamCKU6SpFJhbqvC2TVC1JUUctb/RKPpcz3aQidNz+Ga1T4ubjxXIlOQncIIwhXohfCwsJt1sRptmcxvgeb59v5TUSsVYu4gNrNBusdAzm6Y+Z028T9mGFtWzrZRsmcJThCzh4cwHrCiY7nRLwlSza4DjAQekG1kyvgeWcWJBU6cR/1lVKhfuyjGgo5IKkrLJaFYh25jNKCIpZ+j4BVFFfgVUO7UggzbEYVMHdoT1SsvRDDzYEKmWlrxowlalW3ZUSiGHwdtEIVdXqTRXNz5832+fZq42wLQ0v/duM8i9i22CK5Q/NkzUxb1xdP+tJ5rD3Hqqb3bIcolT0+rWNFCER+O+0wiE9/h+iz1/ZFMUeMyjNLoNKyBJHqERfue9QIthJpcEEmUgXmCHHTg2KktcoB9axMAegE0mGe5EUtSwJ82gGb+xp5rQS8+uUaWU1sz0WzBBPdhnOXaPEwOj9ElaPad+HEbj37Hd6xMI6IxVni1S3CLROn2+4p020E4sdhFPInTmCPzpz2XOhdK1CqnCvgf5SvKPSDV7wraglQSoeqsxS1dE1VXaEnnVF9pYiVmiglUClqOUkNP1Yq9IDlusI8BXNbKnbCCnB9YFD/EfbsdbiFUXSHU7mfPn3WJnHU+w7HJS+vm2mXiFa75y1C+9MG7qiTTe012A4snG8rxo+CJG3o7t+UK1zBTp3hrjLAevz8hT3lsn2/PiMtf4YAJzvOizl+MSTJxShMJYXx0qDApR+r5hLVICDpRVab7QFLNZabJVJ3lciY37ZTiBsjGw1wz+5YbgOaNbfD2Pwc5RzuqZVLIAv74hhcmvvMqDAv4EjDccyPuAzbibUWsXepvdg0195snWXvNs+095uJskSyaC5dvNu+wvaPH2iDapRDmpIRg5Ng6sgR9vQCSxmSvcSJYM7Jzw8sdZNR2g3UdVZojYNLx1rLEtmtCAPgLInzEHkp0mleArMHWXl+XKVQTUoCgATYsicqbJl/zmvlGLCXzUt0LlTRSuThckdwY1/E4rWrmL8Sp4q72IpRY9yFtDEcZe+E3WZq9gOL5cjP61vA6d83T55hB2fNZe+gL5c82ti+vUfdHqj4rErYF/wblzoUsf6V7jBu8a4lVYHL2ykUwMTCu7oKisGZgQCs9JmzOe5K1pAClqKXR5DGZxPIad6L5skL8jhMREexhTt9soZ6HfbBwqOjbOrIuXZs+VS7vnOpXeFdHrp1sa0bP8aGNcPFD+MOKRmOrFhqk7t3tu71GvLFF7e6mH3cf/SalfpYe/DilVvDr4JmqiiqUdVNIkZVkDtlA4/Y9CrFalnZfLzAvCMLQkXkxTpbP1fqLEmUEgMtUAbnDCFalbdc6fNyYiOxnVwykVSINpzn7e0TNqxDU9s2Y5odW7LYLm5YbjvnjbbOnPVYwbk8GYbIE925DWNfHXtmvb3iiuqbrfNcanwNQ68nbDMRjK81esdCi9212G4vnWCrqMPaFS1g9bmVPRDnwB3zRzPTRlT49LS/6NfpXyTQTyXRCbU35/Zw46+1hWRK5b5WbXrn+J3aSiDia9SjNF+jRH2n1NCTKVFuy/JrXitfoLqjWPR79bEJu4I1S9fF5jEET4bKNqF3N+axY2xCuz6c5+3ubhElwkG6WN4Aa4XLogr4dVOm2vGFC2zz1LE2sn5bW8mb/9jFJ3br8Qtni/4Vw+f/w9VWr75yUhl5t8MOSI6smkrdYNwlCm92KCClohNUOlQR77aj/XSDbIzkjyVO67OCuXPDSaSw4oFlMUSjQCUNaiZ45uRlmzpklN3lzvD1nUvs4ubZpMJFNrt3PxvFFSndtdu/aJ5tmzWdu8GtmK5Xs4AsRa1L2/7uer1MQF4il9l/+JyV5ICAgKV5lzgqvWiqs4pmobWG/KtaHM1RXt8LXiBdcQcu/Vy/XhqyMLgAKZaxTzm940mPKRKnt1ypU9i9/RiB3GSDhTmbPb9kq4kqc/pz9X79KruwYald270MQ7HuOAE3tFfyPoCQ/HgWDwXcaXSFNfrMNovav9zesxj7ets8e80hybdb5ln4VmRC/FxPxM6F9gEAvt211o5DDo9rxpsgQ1J2+jJwkbSmbZ083K5sWWzvcS9+jVfX9lkjuFdTwgKQdJfPoa9DQ/QAVLKF3Y89YFUJqM1KfF2XBlVHClQ58XjX11o2H9Gb16hc/ioAqxHWj/VIn5WsWvFqTDv6oiAZbxPZSp/UkatqdRry/fvNAjlq1bViQyueNovTw51eusgOLp5pE0mZcydNsGNn79FIvbQ589bCpv/u5oWqrZQKNdLRKEegci7Z/uGzIpXnzeBtQvvohYyugBdRql8X9SAeS3SDaiy3TJGN9S/xWMVKleQKQ4RLge/CY2zayNl0gPPtwaENdmP3Qru5Z5EdXzkfg/luNp6zsAuRy5xcu8hWjBmNzXMTbg1SmGem+B0z142BHr16Q0cZY1OnLLJ82YsRqn1su7pCvWia/ykilSHsVyvB5gldot7dApbqD/1cES1I72gWLESeluXFDeTFTvYrUljy+rnt2ETeY2+QRQMRnneObeOQUxM7s3oJwFpojzB/PUOB3q1SI/y0RtIhAqTTm4lWG535vu5Gfzy12aKOruOO9BJ7pdprq9LjPOiJ+e6J2jGHNMlDGRCzb7W92bPWelemVsTfoAgnb4ujC6/Ma1i3YB6rVSgP17QyWqYEKZzOrEy+2g4cilj6ugQaLxrVLt2ILZsaXCZFToyLs0BVIG0J93v0Z/QaVYR1F7AUsRS563EfctHoobZx8kSbglna1C4cYCK1aUk0qGBxG4IRnoCljanLeGmFblpqizBmmczo7djJ63bl7hM7wAGqtBlzocv64ZO4T6K/PzTxPgcZdYOODCXouN1BqRiQzrgCHlDJ1U+epEqNvhGPb1ao9S8nTVZXmAxtc2CZICc71g7v4QOnbcbAkfYMl97be3n2LbJ7B1fy7pxoo3FJHt+2t+2BED2+ZrZN790LFrielc9T1Erhf7l+7W4HrCecCnlNfdUGxWi+rOoCyzqawWmx0FQJWK5wRyGqiCXweMBS6tMiqwSBYt/1ZxTBtI4vYKX8Pbsl5RvbolYtpxG3Z7izPGZz+NEFm9GvI6qL8e7ffWv3EntBZFrQZ5gNqFnHws4ApguKVBTkZ7EFIh3q0JHW1qOOr7ewAyvt7R6i1w66Qp4w0uE7gBYB0CK3z7boXUQx9vo6BAZYkd+51sU3P/vvOXHKgTGnGVGdqObk92/TO/ogKF81B5LsydibpBgvX5BURTTSx7pBTdzXJmCpI8ybijcdc0L9mv6MIlu1EvXc1Yiapeq4rrAZZsGrJ4+k651s01EyzOjJrBYH5EQsP5QpUIzF3R7uhk7fpo3t+sZVdmvXSts5eZJNYL57iO/pmav37cq1xxbIofHPWbX3UqG0WeKyfMsWrM7L9EMHAvic5zDjzNX8gj/fSCeFA5jzIuVNLmB5shlHkObMR1fIJnS5cuWRHT+mE/xo4/BmOIlD74uDHA3nXXrv4FK7uXu5Leo/mNzej3Q4wE6tWWSHl81ws65WFfnm47dQo2xdO3nyCtp4UuH795jYPrbgkrWcpkjTegFLABGfpXewCvTKRavzoCsCWF6NJYC5+gpAlSUVBvHNkHJUXWIAhW8CvNmTcQ8mFX6bY3u3davprgsL41bPugUoWDvZrX3QCLuX2rOT6+3a9jXWi3Mfe6azyXNrB2fYtrFVjHcpqTHyDJ2iAxrmbQIY0Svi4CoL4770O1Lku10rLIKOMXL3Aj7OsTe7F1mTIrnhjHK42ihFQn4MNRCYrxYRilPBaQMtTfysrthWnSggZcXKUZFKP9bHKrDptUo1dMAKgnUvlIEOmfRfAjohLrDqlGnCQaompEBeH16rjrWa2OaZY2zH9EncoB5qs/sMcb6hv7L8UgEN1+yO/UU6mPAAAP/0SURBVNGkVYTbKmOXOIL+YN8qO7ViPl18Fxylt3M55L7dvf/G2mE4/KWfWfcIUmndlQbdSUH/ypdAI4AJUJ9Yd0DlAKWtaH5f3Ij1p64wJ9bJqVKlsDK4FL/FhGzXln02Z/BI5+/58sha6pgVzNbW2bl1C20ai6iTMP7Yxhd2YfNS2zt/uhtAa6mhZNYi1rp+Z0YHT1n3CsfSOtY2sVNYAGpBJKBGN1KKlsNRpiAKh8IZS7kXq3pJRkCFqzlgKVLp845t588pHZZB1Cdglcoj+qGi6y7jcQ4udXpOoqTLYZmptcYO6uO//nAfA5dzNrpHSy6tLbFnRzbY02PrnY585bAx1hvC8N1ZgIS1ZMxZfNJPr7MoABVNJNOjrlHgijm50SIRCoYfWWPvD22yd3isR1CLRR1aak/gwWrmzYIlQH7qxgp0e7ndBnclaIPgPJC7XOxK/zPHkvJihFawlktpilgCjH4scNUs3dDVV44ABoBK/UWQy+iNVaFQdfd7NHxvWIGLYNwRrBxQhYxQia63ve1Ca7Z92nii8Aib23cEEpmGTu1bMaCozYVZ12JJ2Xz5aGzm2OODa4laq20+KXPVvHlsoj+xew/e2qQpC+xbFinisV8oQAlc2toRqBSxPJ8Gaa0+pT/5jMZh3pUG3Yk5qUsdp+UzBfnkQZqTUyHJfv/VyodUsrvs/Y0dMNwub1ph706tt0eI+R8fWY3V9VbbNnmsjcdsbRbM7pn1c+3y9qVcRh3vTP51/rVCoWAb1HOMG9+8jHjrgDV0yCTL7weKVAyafammys/qvF5M0Qk1CPPBBZgTAiyliwCUD3qBBSxFt/L5q7EaBgsNsMrkYUCN+98vP2uyng0dWW5LjS9qWnJ/ny4dGetBBWBvvWbOWNs0fZg9PUjndwKjsqub7M7eDdazan3bxfnd2Ct0hedZyefr+nCeTWNAptpLjwAmcDmAwXtFnd5qEYpi8juFqri/fbEz5AiibsyL5Xee3/K4JdsqpPTyNCLp8TzN+msuX3eX3zeKyZeaje6CNRzYKkIx1AlqSn1VE+6uuvt69YbS66EU6ANWJRfFG1dqCY/VgD9TyapiVCeHxINLpthOIu/i/qO5Sjvc2WnG4wJapaJFud84yNrXamgFuSqyfco4e3JonT1l4L55yBibP2Gsnbr02G6JKMWfLHkWjodzlNytg/mXVZ2/qAxhKOTVBQpUilRxweU8RwUwRTL/FTBZGAlYqdngUb3nRjo5s+XHpJQup2aIzZ23weaMHIvPAWtHR9fb47Pr7OXp9UQsPt+jh03rOBjybapdJS2cpy2f0qUnfllV3PnXBtyHnjF+iVtofRH+xp6/fWu1MBEpIqKPFy4/l0M1/xInlS89RmGEfddyAywf1QCHxYusOkPvbA9YKt5LK2LlrYB/Fn8PqoaE8TC+z5Kf7qMgVxLyWCoK1iQUjdUqBNn1C0ftNQaxU3u2thdHNhF5N1hYKN0jSs3FA8e7/cfIixtdh/jhFOlQF7RkMQkzH0tXJ5ApNX56zlLoU+wrimk0dGP9QivDbCwIwjd70qJOuBjM9S6lwoAslS1DgoIACWdnivBKxWoyAyyDk05pByiBrWqxela3TDMHKr1plAZ9b6Syrlgvz+EovR41S9e3JiEcuCrbkD/HzJBrZbP6D7GjK6Y5YC0dONYBq3rx8hCZ31r1wJK2HB6yRZW6loVv+NIhfe0pCxkveaMcGo8Ac9ggO3j2jl3lwMNJFA/5ONbwHUNo3x6hTzqjvUMtq4q78op3/VgpUd1gXOY9uZZYvYKe4j0ZrLs3hHZ6rFzZMhPKsllRtjt64Jr3lNAfcXKvvYOhDju+0sLubLUDSxbY5I6DbHa3vnZu7TzI7pV2YNEMhGUtIRAD2cwtbfVqcdt5Hbtw0BWiG06hjlCh7aW1PNzj0wumolxSY6W5SkWqkgrruygmpaQ6KcdMszggTVLZfNRaLF+IYqgA1VAxSzGcgdVhZrZvvvrW8hUM5m5LgKXi9NrP2CQmwFVFpN1sPEaXjhtmZ5bNBgwbiLgsfj4/bqHUWv0YO51fzTAasw2lQV+0IqqdAkAU8qq19GNfegRsp3mzcK8mksgF32K3d6zABe8X546TNYlvH7Ii0SikUD0MOko7IjQgE9tFpMFKhfBZzRAIf1cWWXFd3khVOc7enMFyA/em0thK9WYQxGcRPpYtVAVho7rCii4FOqqhfC3+rhBrXr6h07wdXj6JsdVYFAzDbUbvsbzZCtvXnHtpEFTJ5vYbgrKjlrP+7NK0nr3mexl2eoOdWTzX5vQcYMePnLWj15/iEnTbmnPt61/pBrUN7flhuXs5fj2Wx8JrcdWZ1/rdkbVWL627Hu0TalboEaQesNyKfY7sXPrCiyofeXnjnJluWfL96W327tx6C7+4wcKv77Wlw4Y4U5CNY8fanT0rndPemvGcCalb34qnyWVNynNpFQHa+fNIbRBxqSucs2C1FfC/G9XdqQsUsBSJnCKUNFelWA2rXAzwebpu3t1alNC7V8DTU5I/o+l/RT5fKk0mBt7j7TKpKdFPP9gXnye09EStbNnz2O/UCJ9zvvfHn5LbV1ypL5MnHwTuUIu9yBvliuQxxyzyzmkn7Vk+oCfufoyCzkM3ACADXLr7F8sJFX3UzxWddGHLODYZcXq/vQNkcC42b2QP+/d/fG3ZSIEFkgdYMM1HEPVTmQI1LG/aYnw+FymvnFUvWgM3mCrUkyg28tWw4EK1WDblRmBgE6tUuBZg5AQcHaQKeI2vVMTr86rFJJVpSRpszMXX6qUAbcHK7nTfthkTnC5+J+l80cARfC2D6T6zA6yfrQXjuHlImxqXq2I/seZVqVSA3WWCEE7Kv871ioX9htreHfvt6LUn+G48sRGDZ9oXRCzvJK8zCIkj9JPKwWmySI8ClQDkad4lSZZHllM1sAmtjyJFPUc/RzdkyCiiK4WVwOf8yel9+AVwWPHCFntzBfvnp0cp3rfYDPTssztDPCLyU811Y+8Km9Stk7UIruKWKTvVa2ntYOIfP3nGguoHQy1jrbB4lsxWaU1ActQBBak+ip9SXaU0GILXgCKTIpvevcWQ2pbIXZqRBi03a09BmIJUIhUW+Z1LEu0a4x2KnPfNedu/daUl44v/3//nS2pEtoy40pomTQ77/Kuk9rd/YND67c/WnmOZz7ntF3Vrl4XfBVwRV2zfwtk2DunJO44d0YF8Ktwdp4W1t6KWai3REY5A5cd2jkiMOuH63jWug/6ONSqtuxdNzrgGAznHsVE/5U5RxKW2SojzKhaqDVDq0REXp2NDvcEN7VrwUY3KNrXqhWsz0oEYTRvEiZcaTtynaFahAF8rYGxUjmWUis1YFKnrZDM1Ae9EFlh2zhlnB3lj7Z01w1YMGedon4Lc1NY5ZVmVz+4ziPFPMNvsv1p2joQeWjDF1ZMPOPO7GGBtXbPRTt18YTcePbENGIck4VTf37/9g88SSaqopccT+iliqWhXKlStJRc/z3HG0QwATpFLYxztFX5apkifEWoeVFZlj+0d87TIcyst5sZ2UiA7bm8v2/Zxk2xulz62duhQl7NfcYf44LKpNpAzuhVQJNZBJqOt5/69R9n7iDCnGr1575EFlartm4tRP2h9SylQwJI0WdRDhUJVHaOsXy/Hu7QoNEJhUp1ApVV6teXlaN+DWacvxgswpmMDC7+8A0OyIxYt5+HXt+zc8a0WEFDMRajvv/qNkyxcF2XhIAUbRl8RvTKnSm+7Zg9j7MMb5h5fz7vj9vDETpvavhfM9Ay8HXYR0Uh5pMtI6smYC+t5SIP8nO6EB0BpywdH5m3Im7OhAvlf//aDpYFhvrJ0uh2dMtRmdGhnPSpxbTYXzQkeEnl+y8IhKeaC1JDlCtVx8piapZpYFVJhA45vanwVEsDXC7cXzKKImypoDkh9JUDWDmpozSo3p7aqZ3W4CRlSuDoHLhvakjEjbC8q2P2LJtk2RjaLB41lXtvBMqXB4ZoFhy7cJRINVKFEoP3OIauUkJVz+ne3GID14shGW4FCZf2CxVwHeWHnb96382cfWmHs1bWtIw7L29TRj1VXeey70qRSoeosz9FP4HK3LWVoC9jiLqxqVugjSLlRk5g/XCWopD0+yaLnLdxNHvBivr5ij0IP2YIuA20h3g2nl86xV2c22Fui2bxB3Tm125BL6LmsXeU61ogzsG7rmSSI6zay5F2WTwQhQ2W9wKqvlPqUCjXKEchCAmr4OkIK2EBApOgm1YLGG8H5qKlIJyUxui3OO2XB0F5OwfDhLgrMh2ct5j5+6dpsfn/DXj69ab27dba03OpL/Esa3jF40gPEDLjbZWSmOKx1I3tDnWG3mO0922PR909Q+NJR9etmT2hSnPEGy616Pl7BTx1/T33uOfqti6un4Pzchm94Efvhq68s/udf2j+44PrFl9/ZRb7Btn+WxRxdwrPKnqBQPb1wIt0ah0GrlsGzioPhOXKwsR3gRlkCTD2AVbEY46sA+C44uoqBDXwDdWiX8oVr0tnVgWJoaQ1DWnJ/sD5HMOtbjeJV2JvsbOtmjLat84fbnkWTbcPk6Tafr6E745xEAEEZpxeS8Ol4aOTltvfPeG7oUEDXujXtLY2HZDubR4+xlVOn4Vz91E5evWf37odbU1bFfGYhPsGfz8YIGkEGx6Ih3FqYD2QCl3OcIQVq7UuGx6qtPGB5qVARy9VYWQilOrhTvkQxe3SO+uIFmmwKXemMds6dafO6DLDVg4c4+Uf0jd12dc9SzpW1sYYlK7lD4X0bNecFqmrbtjBWYfNCB2979x2FPggWmTQofkap0KMUFLEEMrHtVSH+BDZ1QgUzakgNiZijOp4Eld2Zk4Yl89nexWPwtsLXAE/OD/cRzD097yJWDM530axRxYYhUYl+ZAd3rrG6NTBpg35ITTGfmHvQ8bhUXyx7LjtOhNXafeR1vr6nx+3CujUoFmqgEctijUKqWosaNa0lHFfz6tUx3qC1L4mnRNYc7rbfj98k4PLpL6xNJbK/ff4Na+msnieIb9fRcH2EpY88vBhCdRkW2YAXf1C7QH12bbe9h8kf36yiLRnQwQbUr2j1C+dCxhNstbhuppuCpSn+K1BDFs3I+lsWrr5SoNenE3S1FZ1g/aB6bjbYsmIVm4Obz7b5E23z3KG2E0BvQMs+d/AYrtBW4SpXYktN1BqAT9n49p3YTk6DJaRv+yYkIMDxkJFErb2Tp9rysWPs0o1nduzaA7v38L3js75Diq5V+5+1/SxjY//lVAHMmdv6QebpsgQqz3TNif2osZQKvVmh1r8csDJmyOqIrbKlitmL24T+F9grvj1jL88fY87Uxxb0GGBH5s2GC6LYfXjENk4fwd1mbtphAd0ID/aO1Sk4Wfm+Thur/z1iu6VipaasdpV3Iw8xyhomCzxi0r1aS+20ukKvSM9P4evcZkiHQYjWWgUWscOoE/iHuB08e3jJFd8fpSB4HcoKOypX7H9inqEqCEOqwt0badX3bF5jDWvXtUycUUvNnZ7UqXKQRltZ7AUi8fWd9v7yFmyBtjvWukCWHPbrb1ktUZLMnE7jMNUvXJL9GVvFH1NaPPxNf+BI5t++xsL6y4TOROMnbs3869++tVblAwDVUojTjRYGCRl5dDMPtdkxOkpdyGCMhDLS9k3sZSfnc28QonVILd64u5bYXRQiB2aOsE2je9nsLk3xzm9g/RHk9a1dC56tuvXi7nXH8iHWvgJX5gMDsSOvY2vGDUGuNMF2zx/Fm328W7OTBFmmKBLnZeL1GtGyvQ3lkNWvnHH5IVEK+4Yt5zxcFjmKAiT80nY7MmsOokwEm1ce2InrT+wqu4Z79x631Fly2hcoSQUstx0tzyyeJNguyE1GR7vizgmVdhW1MufM6Q57pad50NlngUk40qzQASsnnuq/Jk1sJUsUsdfPDnL5A81R+Fkm47NtGYZrSwcOtnt76Zwen7Q3l7fZ+C6tuZPTlG3dvNa7UVM0WAFWnyMBTHAc1bDr2B4rQGFeGomLgCW3PgFKwNKYxgNZnTKNnOGHitwiGeGvcJORc0qZHBls1di+doy0MqFJTXt9kWL9MWta2hp+wUwQYH1g4KxU6FNp3rBofBI+ONtHRHcRgI0UuWfXOmvN1ft0OWVAkp3GY4J9uIYA8dImdyVix8TFFoTH1Gf/v3+1f/n3f9i//eNz+9sXpDrkJFoqiYcfuqS7P/IkZL1Kd/j+z2f/CkGb3Q6jYOA7ba8Z+7w/tIxDBURzTupG4vAcSacZeRGCFX+rs2tJpX2aOUulvg2D7OhyyFkdEODRv8Wl4CsQsuf5s2jEXmi2yfjozobZFroS6cu8UbZtYj/bjB35qmG9bP24vtR6I20DDoqTu/a1Sqh+VXDn4XCVHKq78yb/Mbm8Y1PbN5zlS49P+yq62PcA6/yipbyZetpxRm5n772yK7ef2qVLt6wUPKQOcTnfWZcOfU5/sivSkxpbpHTorzxweR6ksonUKUIBywEsDrCcHisTmqHfuFVTpFhpe32HljrshL3Ex3PZoDG2rGc/2zN1gkW6+uSEHUFJOqZdB7qdEhaCo9wwNkZypWBbZuRkfxI0Gz16sRXU1g1Ll2LM83DKJLgAaZNH3aBEfhUCqlNDsB4u9WS+xpaPTkp67ca5s9mhOagQ3lxAkXnZzfyW9GjNJQkiFjWfPUXJ+Yjn8RXOx13BO/YGbi18XlvNnBGReZn7MSv0FgbIovBTuH7YVs6aatMHdrPnjHNenFpr0dRRZ1Fu9McC6fdfUtvXeB/IieUfX7LM+RVWP9zs+Qdd5TesR/3798lYQPjB/uWzz3B3TmyXNi22K2zZvEcoGIUiIgJQKUpFASx1kLLNjqW7lE/XiyOrbFKbmnRmB7mw1cLm9mri90nFr13ELKy/IpthcannI7TIx6u81niNynNCa2IyYZNzzltA+wDgnUEft2ManhnUlQWZ1/0N7XqgBtCQ1boxJNXBN9y/0S3nxIBuVOe2pOV1dgr/+7mY523dtNOuPYqwc9w/0iJxOxSmsjiS4a1Poqw7hlKR/uabA6JmULqLq3BwbLx4rCxZ3K+peBeYvPUvpUVSIV3hr8mtaLES9vomkenVKTuxeJabRS1hKn6PE7FRN3FuubHXlrG31xfDWnldaibVDrohW8q8tmY9RCKF+1u83Bs37GkBFOcV2IXTCr3ab3WD5VFE5mczJYjbOeoGNYgNzl8DngdTkCxwTpPH8+J3sKl4Ltg9FAsMlcMfXLQp3ZsyGxvuAPXx1VW2aDDTwF3YOeDJUI2opQUI79Hnop8IeOzwOd9PNmgiXtrG2ePs8MpJFsY3/fWpdfBxzNB6jmDkVMiScKfna5YMEvwA+/w3lg046fv1F/Ht8//zhX3L4cwMv/9mvVvWtwek0A/4Vt1cO80NqSMPrOLgN/NGQCVzf28kpMmFCNj3DLintKttr09uZfzV3Sa1r8kdQmwsvdERTL9A6AFR1pAxNBAx1/e4yBZ7k9s7ck4GXNKd2T3qX6wCZCJyizQsOXa2TMlxnMlFJulrJdFk6aTJF3jHKp1pE6d1tUr2bP8yO79+CQR3P1u+BLroSZQDlvY9J89aQopPaV8z3vHpsxLCyKPPQqelAl7gUrRyKgY+Ckje0QDZRmaihk3LCEnSZNENqrH048/SUNkn5s5KQNGC9vbmTnsGZ7N68GCb2528Pm6004uHQZqGIiEZ266lNS2JWI0LXP1atGIvLqcF5Am0qzdYLCBmnT931QoxetFyQEXY9AAK8kJYOwpYegqm18wshJEG88V8SIwpWlvUror1Oe9SlAmvMHTt1aC0rRrY3kUlgeLNg9OQsf3tJCdQPgKumDAsgt7cdJe97JFAxsoWQJJ5mYtWeE7poz4fy4JopJQPLDc8OLPblo7qTu2+2Z6fpIs7usEW02SMR/azhjfSGE4BD+3OxdhGnK5rwj3pLi1tYt9OtmPuGHt8lBs2V0nJUA/hJxhxIf7T/DCcWVw4g/q/Aksux4pAsQBlVsf6dnv7EjuwYKQNqh/ktPduAK6H36fI5h5+byxg1Hk8D1QyuI29fcTnoMxH98jySAB7gucX7n/n9i60mT06ssTagbSUy/7hvymog0wCWHX8LW6zsHt2PamQycn4sZMwwAtz/vy3H71yZ5fTMjeUCZuXCtUNejbc+uht53gzQ7dAIY93Hq94V1eoAfT38X7w1Vhp4HqSEjZLlyoKy77fX1sNAliD7C7LqRGE6zd8U/TNHdm6pZXLgBlHYCW3ASLDryaNOriNniikp/PmrLS8EKCqp8oDMKlF5UPgOkIIwUIQgjWKEq2KsJVTIMBmjxhi4U8w6VAE0poUvNlj3sGD65WDAOziS32R9yzswTk31T8F5RF1A7rhJQ7DWjDFK12eV+6iA3+HzoXEPsEHS2dD9GNsIt3V0qf8/S+v2MrxA+zsxsX25MQKew5A1o+cYtN6YeMdBkBfq+OkG0Y/ryYlWksaol0Akwp/wyXwA1QLcyF7TjcYRfp7D7AEMJcG/alQoyCNihSFtNO4qGdzO7dymp1ZOdm6hhR0S7SaSXpRyoGJRzWXai8PVB9v02XfwYv0ziEHphjM2WIfnnZPDP4TH+Dz+EJciRJ95YitnTLBUhExvoZH0gBZhfgXEMhBBQrY2VVT7MSahTarWy9rzVGHY+fvQpK+xh/2qYVy6i+oYg0XsTxfUm/lSyoHpUV3sd6vzXKXvqAd3DVe3bckkiliKf0JWD/8GM8HrHSpmfVwgaJCudKMatZRJI6ypV0H2obRkyz8JC8iHc0dVJOTu7fBCxMmOUUu61u/OXaFRbl/l54jl9MsWls90O0tm3V3HqHlqae0Ml+Iqb6ITo0qCqOS1KJAhfxlGZRWsxNbVkNYYt/4krqIhU6d+Yh5ArheX2dpYTeq1BBbMLAtJrV0gVGP2F8IZTlhpu1lnPHuEgBgLSvsCf5b8kYXMKXH4tFyqAMkv6bHRbYX/J5n5znEutKWjxnI/uAqdFpr7cSSFTawfl17zNGj93yzZNKmiPEB92XVYa6T1MdLRJTzRBiYeqMQfn8UOQ2PRj4CmAp3L2q52aOkODD4AtbqAe3Rn4+z0ysmWeeK+bnkxckTfk3p0kUqfo/+mzH8Nz1Qyd/di1ACeQwq2WicCaMeQbXwOui1+nCXuhMPCLkVitsTJbNswiDLmobrIlglfA+o/g4DnzdTNkSZI+wUqVDAKs6sdf7KrfYQK2sV8Hcev7UuvQc773cBS7yVABVXRSpwKYopNSpqORc/inc9qr28vULPxkirYJ9lYPM52W9JrDwKUkktFvceYkvoOC6sXe1qhFcntth2ZL3jYJhls1MpV3EbhmdAHjZPCmB+tmINNwJpCK/dfMBYSNJbNOrokkQjaBYWkr8ex66rWjHcYQJz5rYJfbvx/efFkKk+dZCiTaQKchXfcjjWLt77W9TeJ2xa98Y2oXNTPDyIHpH3SYHXGeGtsN3TR9tjTqsZ9/50pldg0gseDZCcmRlRMJYX250OwYcq5iGUxUuZ3F6x2YO7c+9oAZKglRa6frX1Qzx3ZM0K9/foG/XhKt9Uim2X+nTDJnSne6JZx/9AcR0F2CQOlKxGei0HKn/xHoPM+ZNCwg+szayoHZk90k4sHc8AvKSrsQQsgSqaJwpgqTiPUWSkphKoYuSa7KXAe5xyAVgfMTHRGyYK2kX15UfOz+n1ilQjwxULe8zDx61zJ1oavp9i1L8kymRMnZ7hdT87tWkZTjQ9oSbSW5d+I/Ddf+8crXVvcs7i1ZYIv1lnEwmwFPEEJkUp1Vvf60wKP9bnNTdUlFIaVMTybhUKTFqmUI3lgKUwljTpr1aqaEmb37s3mp4htmnIMGaCO+350eX26NBm/kHcyGnc3AqlyWltq9TifnBl7AlTWLnA+naaZUgha9GiNZZPmzTopirkK8+0nnMcmptxWSIEM5BqxYrbJigEe80Lw+M77yH3FX7OWnvkA225KNrwYgGMD6QuboXY2omD0bHXs/PIbD/QBVrkQ7vHnG/X3LGAbJmru8ylRWotuC1FPTkQx2JqK2B9eAT3RXqMfkzkwy5y/8o5tm7qQHt8jEi8e72Naknnyfqaomc0vgof6MbUrERTQH+A6FR6EqgUWRTJRBGEn/XJaqKQ5HjAUvQSsJQKnfRGwOLP7RjVyw7NHG6nlk3gQDodYigA9UcrRcVoiFsfqP4MKOedxZUwLYro/EksDY2+ntgHvElkZMLrFvMQWyY1NXoDaaHkAQfKb56w+cP6W6ok7AzidZaKm4RzB3eyo+sX2QxsEjKlS21lWBk7GXrLHjwPx7sszPYdPWu5CxV3GnhJZwQqFe96vkW2rCZAANPnPX2WfEjFaQlovh1Dzs0hONRIx23paMMjIZ5YhfMF2Lxe/RywTs+baW/O7rMnRxZDsM1GMtMckzO6PKLOIHJ0Sa6iF0iV3+rX72nPdR0gJtbatelphdg4qUjECqEDzMPophCse7UCZXA+qWZHudGsqGMvITZfEsr9wLJnRBq+6bFwUyI9ZfPj6iMiWQReCvb2Do3DSpvcuQmS3BH2hvt9zGXoYI9R0OMjsWo2exTUI9RdHzH3iI4DLNUjeifH3OfvJo3YK2q4i4ds+oB2dPIrXWc4k85wWKfOrnlwIKR2ibqFxdBtIoXmhPBRru0nWqkOEj+lmkjAiUCj5aXDWEAlYInL8miHj0S6veP6OWCdo85Z3L+lS4WiFbwOMPo6TsmkYNlZepHqjyL9hDvW5A42cV7P0PW7fyNcXgy+quLzPqD3N944UXfP8DpSJ5ISw06wGd6wjv30exII4kw2rU9rO8x294xuXS0zw+nUWfLaKtyAnryKsbtP3nG+5rlVp9v37ui4G4Ya5xCl4tZb3vzQyWj8Z+WUCjXakR5LwPrUFSZmKTER3EWuXHlsbrcRtgzHY0la7+9bak+P7GDY2dMmtu3O8Dg/RXsFLqxy7RxjNg2New+Y4vyzrt6+bWWDqrv1LB2zDETnnjFZXgvJGmBduN51iVOzWlF3F67cgSJfwa3uzdVIAEkpTCc/lMacpSOP8cQCRHt71V5xoX71uD42vVcru8zavAMSto83ti530SsUxYWLSmLiH/GiU+zqmyA/rA93SSP8XVG8o9UkLBk9xHbNn2L3T6yx5aMGWZdajZ0Rm0Avzkztvd3CWtJfTKvVl59VFAoHgS6KSOY6Oi6ehrEMG4vMKOIoV+aZy4nHCpe2i49SnO4a3wd3makU79Ns0/jebr9RadB9JNWKTtAjeyM9srRUhPr0AKiPLIw4ozZ9nq/H2UzyesU8vexzZsZqXNE66gGRjVloDL/3PNLx8tnxWEiS0vp2amen1moU19Jkv/5tgqTWn5HQgxcc2sK05dHLcBs4YoKjHTTe0czQneqVvbbfi9Sz6PbSoeeiLGDJ0kjAUvGuvULHY/3KlfOEsMq5cuWy6R37QFDOdJLWRzgPXyLKTO7U2jrgD1A4bS7r1bApWyD5LW+K3E4ntWAZgCENLl2zxQqz7FCBQl1bNyVZl8+aJJsNwKvq8gG2YBgUa/YYJQpAbsEiMGWZKC9QmbwSvZwjC8By92R0+kNhn3TmrKqZD5qK/Pvn7Oy6OTala2NbNrI7hCfE4tubTH322b5ZY2z3rJH2+DS8EKlQfz5aoyDoitg7HJTUN+Yx6QKztaNrF9uCYXB0DI/Xox9vElzdaeUxgfAZo3H6LeqGHrgjUpKA5lp/OjQXzZS+iDyx8FMxx7aij+cIuFbKpDyl5vrIv0H81nuAe3DGEFj/Gaz9j7ft09ncBqQ+aoHUekNR6g9gOVDxxN6NAy6A9afP642iNK86Um9EecXL05Ro/YEo9pGvV8X8a8SJehOmAyCdoU9OYI0wvHVzV2N9D71UFZvJ89fv2ONX7+0pjo0rN+ywDNlxzqbWSkR606wwgawf/b7v3jKFJ/rTR+9R8f474xylwe+4i+i6whRILBSxcufOaXN79rXbuzagD19mjw9vsg3UHuPasNGbuxiFezGM+utbLlh6OeuVRnZ7+gJfDGPn9p2GWnHEeKIYKgToJFxRa1q6kp1gr81ZUr/H9Q7TMuc5pcgl0wyZbfjB5V4Y//Ur0QWqk/QO1DqXPeQbzrVRDaFVXKvDe89pk43jetn4NjVsO0x9GIb7sl88tHiizezVwg4tnQp1IjNbXSrlz2hofYeIcJ+IhZ/Cm0tHWIlqjipmIcZtC6we0p/bx2gGGBkZXaS7E0it4qUkAcylKdr+aPxClSJVhH+QMvXEZhetwukyVXN98IPtxf6VPoZ/yQQ2Zmbb+gl9bPcciF52IJVSVbN9pED/r4AlcH16/NHMRTV9nnpLzYneBDFwdYpcLupzMiXmri6HkTaJclp/q1UyAL1cZVfS9MNaMyGiwG8TSNqd1zbtPmDP8C7T/ckzjHeKBlZ0yghtRetIkyKWp2xQLeW5zujH3pa0IpnW7ZP4yVHxWK54z0g7mox9/XyYg2yD/Ragru9YjDXmak71dnZbxDq22K1GI6sSUAQnmIyoGjCxr9mevcE3dpurWmXLscpUoLYzrdBGTcVcJWwbo6AYim8dJfpk+YMHurt85QeYs6bWBSx3BUsW1R6x6eOjHCcF3RBz54yzVxQoBBABxYhA9zlcJJ5oWuf6tm/JWHzdD7GkusEpCmb1bGE3WN1ywNIjNv8hrPVtajQAN2dgO1bwMZLbsMzqwFif2b4MYCmNaugtUOFVinrWAUkRSySl+KQ7cFyiA4g4EgNqXSz6BFwWkiOx7+/QPr2AtnnPr+m/dwbF58V1s5jTtQDEExyDHsXRJdELPsD+JQ36I1ZcYPnAp6jp6xYdwJQiiU5eCaG6VMByl1mJtjLMlRZrVp9O2EqWt0MLZ3B6rrZ9/TWzUHyxfvolufUfNc5FLKXC+8/eWWMceuRLqlQoZYMilncAU6nPc09WV+jtGLoOEqm2anXVWEqF2jFENpPdUpAOA4oVQs++BD07i457VuEiMwV/hg7WqGQZNOh54a5aImBLx8AYM9ps1a1P34kst0bZspXrLKgoS5ZIbLUcIIXClO49LewSdUoklj4Rr9xBSB2HjJVfJydu9TgbRXl4+o8ZOXtsF8F8KVJRzD3iuJQmqSne8m59xzdYN5WjrsnCGsDwAp5ZNh4TthAb27YamvCJ9uTkZkjBaTa5RQ1bMqKz3T+CzkxF8C0u2+vGDjXYTridOQM62eW9a5EAB9v25RMo/I9bpO41Y5Km6PYegaBOp7hUqLTlj1wuLQKs2POoJVh61QBZLjbvqbleqt7y/zeMf+OhmUPt3OrpNrlLA7u8Y5HvG07HKfLTATRONIqb8v4MLACl3wsdoVpP/w6Bx9VkOpqpcyk693ufNwVkskvfIlyv7YRUnmo9ape1XTMnWfvqVe2Lr77Eze9nt/oVBJ94CdHf83cxLh1OnLHAHXDyaqyfoQ+80ydexNJHUQyKWAKVs5LkmJcilpQN8bji6uOxKLSSc+m8FFse17at5V2+jIi1FuvF3o6vKoH8pElwVa5UVGBnju0U+KniOSvbwsXs51Fgdek4hG0U/AYQ5kkN2gTl45Vd6J7ecxY36p3FRoW5jx/CX+OSh81i+AssgP4A2KcDR+40iAz3/VEMCYzpUTR7p0sOgOwd7sMc6Q4HUDFErXdwTe9FASjCYLAmmc2wxhVsZMsqtnfhaCTUy23V6J5M/mtha9TdXp9m4Ouuax20u4fWYnNZy66jC+9RtabjeuwBNZi6TnWD8gpVZyhtvECMF7sKbn1j9bga6QL3EWHjI46vcethbySZEd/0ngaFyKMOcfekfu7fNbZdLUZDEhwCEOausoyUNcCfivY4NZYis+/xRUhHSThlhI/A1dcrf3hfiibt88ZRHalbhwKWuledo5M/2KBGlW3DxDFsX5d16g0dEtCyROpsOWzTzv3OJE/A2r7vmKXJnNMJ/1S8C1jesXGPNPVSoEegutEPpsi/sPaljlCpUPXWZ+kyMGT8FVOQkiUslLVspQ8too5s1d5al69sBVAddKvbkG2THFYMPyuJ/kuyQHnh3A279/g5kubmVq0w2ncsd0ozYF7AZdXIO/Aqsa+QKdMyarUiFkoC2fLH969p619ScPtcieUnJesfdzTJXW344ySIO2QEyHRzxtVjb31nQj4qiunndIWOTKW+cB0RKUzv2uhrR+3oMk6ydK5n/drXsF2zRvPziTa/HxaLLWvb7hlDmRWudbdqOoZUsPOrFtog3IYndWyETmu9Pdy20h7hl/Vszxp7RvQOZy8xHECo83PzP6gGDYr1UWSpY9xPIG0WA38JwLxm+E39E0Yq/EDk3Da6h23BUHdSx3qkQHmQCrg+7spg+/8ZsFwq9lMfLgqhfhD1EXMJshZhoUDmwB4nVbtRkEDIG+EV2Wdo0xq2cuwodPcl7R9ff++UHIpEPyRJYgOGj3WgehX+kej10MpXre1oB6VCAcszBvGA5bnQxO0SEzO5EbC8iJUcLddn6TPhbURBXqhwAGYayzi4uNbmD+jropUOWlctWsba4ySTiZxcntUs3XWpVq2RRb6Pdd1gmSJ1rRa6bNkR1WFb58YORatHGK9FOucax0cIWJEItsLeEnWIWjwClrs+6k+Nvkuk2Frjl+4KfQAVwyxQj3RW0U81YFYtxnEjsfS65iXq4hlpU4ckdfMPzsvJZeDLVNBe3LUKuW4rF8HW8Q0+tYxap0dTusqaGLSNtm6khlWzxlofRHIjerSApz1oL85T0AIi2UZew6fhCikydNEYe4jFkSQyYVAI79l80ZJClNSiDLVjMB95d4xoRF1msPzvoUaMA+ERFPCLuzVGRdHMZnRt5DsaABAkF356bK2ft/JTDP5opUj3R7QidX8CliKVD1SOB4Oy0DlfgUuTgRiiYOwdqBB1rTyx10mXRLU3WA0MbFjF5g8dxjZ5Yfvff0exAQmqlPY1/GXp8lXs/NW7DliPMYXp1LO/U5JKOfoTd5W8lOd5N3gr997nfZ6kyd3Cqldj+Y6NMxGXo1/xgDx2es1yNm3n2URc49rjups3WVZrV7OelUTcVixVcTeuyZuzpPXpP8k5KndDD6/FgIp0iJIgL+3Xn+u0py2aaGURbxwV4S65x0aQDt9/SocfZQxLOpQjsYtYOr3mLmP5xXqfzq79UWs5ecx/8rhuKM7jZoV0ju4Gs5h6Zo8XiDzTB7axkUhYlg/vYevGDLAF/TpZh/IlbPqg/jaiRWub1K8v/9Yoi3op41q8RN8ReSJg9Wnp37BNfHUhjc3yKc7WKPrACovRISg6Qju+yIEt8hQDapZiYx4x07u8GavJvdgizbZVPStZzyrFbMGEnnBR65DQLCYlrkRXxX+POaA6Qz2KXt5HVzuRsqNuUk+SBt0jikNzRQ2sNbhmyO04M4bpmgJI1yXASYbsQKazv5fRcWFDNaRJVRvfqycCgdzuMsWvyVnpIiL9QJ2UjEJ7xdoD9gq/2DdckZ+/aLO7TahD8/G4B54A0PyqhdS0DJzTpHOPfvxrytQuqiVEb59Yy6pSyRC1RDlIqvxZ5kw5LBk5snhAPjvDfHDFqBE2kqv0IYTNMtmLWMsqNS0bYrhgdt9UQxUuUJ6CfQeGtbjDBddmT64eE/Qq7oaeXPSUsj6w5u6K9lhfGvwYE24fItng8ddZn4CFE/Ef9/z+DCzxM+5yhJ+K8DpGn5Ih7iM77T+UDaIqvEc8T6Rj3AEaDP8tfK7Ef41oUdMmdsSuGvJ2WBuOEPRuz3m6alwiId29EcOtrkos/HWLesKPSW2RF5lEoB+/smGyPd43i+i11MLwan97iK2m04fs6Y55duvgBHuyerLbSwwLnYfydrxd2zze6mVPgL0jbjc3iXBvXzivsUOzWrrBuojPuNIYpTSPglC9pBrKA5aT1MQBltj/lweWO8cc2QEoVSuqSYr84QppmdT8hjfVkOY1bVhHZDXMdz+Hs0wg4hPgxAcUGuF07T3SnnDvSL5oBw6HWi5uTP+g8QxH6AWsxGLW/cBKmjqtA548HjRXFLB+paZS+tPlr08EqTTvks2UKlYEycxShr5drW/dRljrpGMUI7+BwpYnaTarjGKhGJu7QTj4Xrnx2DZt2GeBAcFWj3lhAIK+vk1a2LvLFI4R1FE8MZFErOhwBypFq1gi2Ifwl66AF7BEQcji+s/AUmdIKnNHIlVPiUD1Rar/CCgfuJTyfI+PMPQ4MK/uigEUIlqdtFnMPD9+jEJ2N/t5/RpVsZ7Vq9lUJNiNi5fAfrGBzRvV3q7vnguwjuJTizEtIx4Vx0ZHaahRNf8LO7ISP61FHCbAjG5pZzuNrv01Hd/JOf1tbd8i9uroFIjmttYSP4VFI1vZpAYF7MAalLEfudu4b53tGVfL9gyvTb2FBIYCXRSIQKSPApFBCnuA+vRR3JnqKaKSdF6eQFDAfksE1SBcM0pFLQ239XukUH13YA33jqpbzyaNLXOKNO5QUzwKc41kfuGg5XcIAwPYRTx/6a5zyJadZA0YgO8TJ7AESofUTwKPwCRQecBSxFK6/I2IJwmzZoXeLR3fMgVi+STcfy7Jls6KkeNtBBRD67LYQ/P5tmios/6axl1NkGKhKB4MDep3xPgj2rp3HmLVytTAUwCbIuTGq8azv6cIw2kUFeixsWGOZlCkEqg++oEl2uGvwPKORTrNuv/yqAMVddP/DVQ+YAEmgUojIZ3B9Y+GfFHrPIPas74TIwIWNIOzxubz0mc9OLPTuqKEndC5uzUNLIHtYiVrWqYIKbIkIGtkSzEXkZlb1F0KbXRPEaQZ2knkMHzDDs20m2s62IahpNd+mW1Rj1LWPiAeq+wVbHRXvNkbT7HAZnNs4/gQm9k5pz17tA2Zz0UK+Yp2Y1NTm9m1KtQGkYUxjUD1XhQC3a1+LnBpfOSKcNKkF7E8YKm+ErDcMJv55O110xEdrmGT2zcEd00Gmi/5Ubyj++1Vt6p1qVPLqpYqbn/78hv7SkcuiTCJ06Qy3f8WMBZxhu5NeKyzCR08cqrFx34yfhLkM0QsPc6FBiB5j5xpHMiorZQKBSxdkZPCwQErU6YsqBtQkLIqNA77xwFN21gwLWf1EqUwUy1kuTE5q4iBWOmcgVYEjmrU6Ll2+95jukEOLpapyyX1EKtdqrpdxdZag9zYN6RAivOYmHc+asEBCoARrT6+1/MHsFzU+nSB9C/RSqDyA+v/Bi6NhLxHFybcaMMPLkUwd2nLzR19UStakQFtk66AvaNQ7lC7hvVrWNcWjOxNMFpqS/u0sjE1yljj/GmtSq7frSYTid5cOp07oJFd3TmWcdcigDHcjs6pZztGh9jsTgVtapuctn5gcdvdr7Rt6M8Wd9VO1gl+dMCQsbZnbEnrWDkT//2TdmRyJ+wmQ+zKynq2qE1FzOJ8F8BUoDvKQJorf3enYbiMTP4asdwAnL1HzSqdmBDh4J210+0WOvxYOesQuZyQEE29fk0TgM7VQvgaa9tkThsn4Ajm31EqJEzJhQlWxQSaH5MmtBbYUz19GeG22NfjRqMlih8SQSPgJKOIFRdY7gg5Eev3dBkcQJUKBawUqUibSRL59woRxMvnvVAhXJO5otWhel0rmiKDNUUek4OhpO65lMY3QYuVhRDx7dl32tau3WrlWBlvGFTfSWQGNmlp767wzsOi+qPr+p5ZDGASsFz6+wSquMASC/8fgaXaSt2eA1UcYMUFV9wi3iNSfZ/7Y+7oFfRi7yW/UTqM0VAaXZYh+tPAWqtjPRrXsw4hIbaFRRGLYHZ2cKHd2TgGp+gZlEoTWX3ryXp6aetQ+heb1aGUnVjR3VpVYVcyOyYfFUZY1aojrXfHXvbu4mw63OV2ZW1T2zi1qTVp2MZW9G9rA6pltPalM9nOWW1s07gqdnJ9Jzswt7GdndyWtErNpTMokLGKTJpRiovSR8ewO827r8ZyYyTxV6I7JBDUEFwSaLy+wtDe74YIfo53qtQWmgDI68sAmCiTegGFbUbnVnaOu0O506R0PNZvmdmgRk+VBB+GnzEKlrnxac6j4BLKith9K1G2so92oLHToxGPF60ELEUsFfKJiFbJkOJI5540GV4PCf2b0DnY1k2R4ncrxvpX/2YtiUABnDgrillHOcudFG9yeYCyqSvT+/JBdfELf2AdcIQLKVHZmmJuX6FgRS4hDIawhB1/9xwwca0hnBoqzFfA+6LUH9Hqg+sIVWMJWHSGcYlRr7byg0q0QlwQeXXWn7rD/+L3SjmhBQupJ6LQLSmSGeSqA5hS4Qs6Pu7oDOLkb6MyZWzvRuaa0TfwdZ9lJ5Zx4OnRcSTRZywyBhoj6iWSHkR0s1kK7VCCI6CjbMq4Qdazz1xrNe6MDZuDwuER38gn+5BrDeAA0yArmeQza5o7oeX86gdrkfU7rkkUtcc31rjtIl0Ye3HuMKPJnXZ0wWDSZWcHIkPmE6lxDAN0jXt8s0TfSMmx7n5geTWWEwzCl2nofWxyPzswtoeFscEdSafo1BWkxce7V1qlbDlt70Rk4HsWWHOsFKStErASk8oSpyEaYWMlkMycS71GnfX8TYS1xQRGhb26w/g0d64DBFwaTjvy1P/znxnlJAWsvmUKmPpECXyne3Pnzutz9AsuZX2aNLH8hLj2lWrjQpfRSrFBo7MbcpgLyMYSZRuUpZfvoI+vwrp4TWuA15POcVxEE/XxiU6CkPbeM5KJegaX5aur4gLLA9V/BiyRoZ+KdsAiUAlI/1Xx/glcXi3mB5jHaXnLFNJ1edIcnyxHkhPUE6RLe3PDpnbuwpsjt108ACv/kn87n3+6CX/VyW049tne1g6uDY1SF0/5/iybzreZbYpZ/+CE3OKpYMv7BNm4RjlsdO0Mtn1UaXuxvYNd3TTA+tfIZKV+/8UaFc5s45sWsW19CtnUBjltSv1Ctm1YNcz968LI17PNM9ra+BZBkLRj3YXVKA51iusSzeAuwnoLFFKTMi3waiyPbpAEOowxklQWr3G2nt+muj3E+fnd4VUWjXRHEesGx9er5sprt1bTkOyfazOUDhnDfEvK+ll1U2rqp5SYr9HRNWvZwx5wtDQS6nHqrLWOihCw9AhIilTeo4ildJiM8c3vaLx85ras4//ys8+7IU+u3JaGVrJi+UqAhMWHnHmhDkpjx5PFHawshbeTbHYK5StjU+bgQ7ponVvtasrguTK+4j2q1OAyLvUVnJEikNKhRajze+sDFlErbn31V3CJnvDptHSYUhQDh5Gk03oBhUCB7aXAPxQQPjmzTw1BfSUxoDdX1Ef/lo4XsT5t7Pg7SG/ZwmntGTuNZj+vQsFcdvscw2FpxPTnYfBvbZtjC7tgHbCoJpqvhnZySkXbQNRZ2DmXTWqWyzoUTWU10n1lXXP/ZNtH1LJh7bHSzvCb1UjzD8v+5f+2CplSsu3T3Rq2mmz9ug/nMHtfm1Ingw0smcwGVEpjgypmoZ6rY0+OAQC/GkFzTKe70iDar83yMfO+yKV5oRsnSScmObNUrcwr3zExiODvOTNnhG3o28rCMfaNPbAek7KddKxTrFPNkvhXIKeGmjgyf4wVyZvdvmSXMh6jvB/QUH2XKB51ViLLnb+kHee+IbpN23/kuGXNW5yBNeMfiFI3kMbVRh9VrP+WFotIAJUySwZLyQnlNJlIrf7TvU6PlTsXHgWgrUIwHuvps2KdUx69VUZcgItZQDp8QrkMoflgACZn2/acsI7t+yDFqGENy9SzELwFRjVrYU9wY9Ecz5feuNTAqEbRy6XCfwIsd59GdZUiFFJlpS+NalwKQ+Mt8GjLxkuD+rEDlEdD6GNcYDltklbA+CiG3lsFixO53DYPwBWwxnftgpVQbq750jEyKpJ2XilSLf8DbkoPr1rY+lTIbJtHlbHzyxuxOMqGzzn8wUZXtaGVfrddA2rb2YPjrUL1ERZSoZWVj/8Z20yVrXvNXDaoWhaG22Nt+LjVNnvARAtd1t22jW9h19bgC38Bnukh6Vmg0pzPr3JwwkQ/++4Noj2gOb7LDzCBSwoJkaCaWYbB/N/kouyUppVsC8qN6MNMAnDj2TFugG1lg5oxhBm82xMG4p1qBxNpUCWQBrVAES8JXu/Iab74PpFNnIzHPSz8XY6Xlq/WGG8H1u81jIb70iNQJaX7U12VinT6e0bckvlxyvQ+O26Zgri9wjy5WY/OmM4CS5XGpz2n1QrgSBLDZtk65ktexG3WyLG4VrXmtnf/GefTUC+oDgZfeGMWxbACDugtywf4HlG8MqZx+ivVUdAOUjX8E2Dp4JG7csqalpN9UF+IzFSqkszYK8J9nZ8vSv0VWFKkClyOUPWPd7zi3wOWp1oVM/8JWOF3bTSb3XKGMUCtDlL8l9vy4SCBIaG2Ozfs0OSutnVUA2fg9uTUdtswpo7tGhVo0+tnxOFvig3q3doqdTpoQ7s0sR4FE9iB+V2Q5XACrkxyW9iNVLdlKCqLxrZzfF17sXcGgCLlSlhI1yc5jyKVU11I107XKsrBHvh0ZFKMxlWU/hHR/Iy9FlmlcIUQlUbsypppNq8jXlntatod5DrnFk+y13tXuoG4KIkPGOfN7d7EMmf8zQn6EqNYEe2QAJPgz1kBq1GnOYYhL5wrY78hUxyoFKUS6TgAwPJAlYTfnzwDBiHZ8GwAP4pYnh23P2JlYzc/vQUFYrVTpqIVSpEV41ZdkChmBVOWcE7FAVz7HNhvvM2YvtTKYZRWH5qhEakwBGAtGzzQJxN5d9MBy41qwkUpKBX+84glKY0b5Wgsw4voyEi9qNAD7hvM4zZvNKpxWz2+iKXHRTGRp3GA9Yf8WRJoX2r0fp/n9fAJWBH3GFZ3tdZVyrv7NwKTK+5ZVFDK1NaPPb1lFzZheDazvx2ZPsBGNcrCJlNpm9c22FZ1rIb11mBMR1pwPLSvLe6S2WY2DLCD4xpyz6aRbRvbkToL76qAhHhFtGAy0YdGcDhuOYxsWDqNwNJAdZWildOL8XVLZ+VUCtJa6fXw7xLq5396/Fp4KTvUNbpIxnzQFPlQZFxYhbvMwFa2c0xXu88pvdeHuR8kz9Wjm+zIzGFWoVh+qIYMEJ9IYFKntKREn29//dUyUnPv3AfQSYcr1+y2VNBRKtYFrATUUL9CKSgFKhUKUEqF+pgaZao2oTWIdsDKmSMbJ8PSWPnyHCRiYSJ34oxQCBUxbs3PISRJYcpbSQzC5sxeae1adLMqcFaNMLJtgH9TlaJVbe2oYW6B0t7io8AtZXcBS1wVSoZYRa5/lgrVJerMrbaYJeTjBVJHpPCvUYrbQNG2jVvl8kWyT1SC2yn8o8BX1PIBzQcqXwT7j8By6/iqzRhWj+rVy4Z3a0fEVeFOtNTirLaFtMLvVqxEqh63K5vw/hzb2raMbkvXOBqfMNp9/p2P1/RlHa25jWlR3jaNCbYZTYrYss6QreVzWtM8P1qNzAmtX9V8NrBENpvXoQZ3bhrb29NLEfwxEXgAIPR1+iOVQCV1qKTHeqSScFMD/9fvfXSvifRXPB7wnNYdFt+NiNRZ8j2JuXbA7tFwnF440o5NHWLXF0/l+sZCe7hhuvVvVdN+TKt1Lu4RUrwnSge4sqSzBDAEQzA45loN18JuWUCZco5uSCyr7RTUV6nZLST9Jc9E0U7KS4K7jYDm1VifbIxy5cDSmsq+VCnuMKfNzn1iDntjIa3bLiWpr2Q8Wym4ns2ft8YqB9bAnL6ei1j1ygKswuh8xg5nceEPYKnjE7AM5+QPilz/BFguYuliqXRX8rsiYkWgf5JtknsHatMGLbdbkJCgzb3IvKhu6QLG3b/57HTzjsfyjXq8GsylRn9E8xY4XGGvuiz8vg2heF+/cBr/5ttIb/hvKQU+lnKVlMjO3vunRE8Zkjzh17R7+AKejiiGVJW/97SF4aFwdXEre/9gAzcJq9umnuVs19R6VitrQlvbr6JNapLDVvcNYoxT13oHZbdZjUtAlLZ2+n1XiHtFOl+30+X719acLFuvh7cH4J8q/HXo7lt3oy7kDaHlVenBFOliUFpIo2VIlRURw+kc72+abReXDLXQ2X0hdFtalUBEnrjTJKI4/1VmapnSMB/EhK92Y+4bQolwb7IxNxET6sYOwEqSlqF1BuyN+H3J5PlBrSWQpc6CKUg29lNV3BOxnLohB8awMicV854b7/QKeJUXTV/aciQr6LsZyKHGpk062dDhk7GdruRqq7rcz5P/uOaH67jt4rTkLJNGv1Iq9AMLr/eP6g7/WcRyBb+IUq2GEWUAjl4I7fJFsn0ciXZJ7z4V067+8KeHuN8At3wR54XX7PDThrRHtCqa+TeDXBRTZHt720Z174j6gQEuSxnaO3SLGNR6WqlyMmV4pxd8c8JIxe6bSGSI5Ini2pghA9bVr0tze9rpvRNsfusGdm3eALuwfaBNalXaDs9sbqG7e9isJoF2bN0Ylkl72pi6Qfbq7GrGTJCciiqSHTu5tU967SIVoHL6Mk0RNGD3v2m8OtNL/5/qRt5Q7uvVxEF/VkskAE3LJJo0SBTp1vIfQmdAyIYxpnq8Z4PtmzfRxg7DXhLdXbmqdaxQ2fKWU+KDivVs8XKUE3j1j58x31KQDh0RCqjSZOcuIcBKmg6ClKZPqTAtztsZ2f7xPEh9jn5IKbRwWLYs50UKMMbBeijv74XdfRfVV2VJg716DremzTtbtUC4q9IU7lhD14EsFbDWjBroA5Y/FfqUC4CLiPXfSoV+YOlyqTuZKyJT9QWFcgRyFK3CO9dj5mY+MRsvkApaP8A+DZn9USyussFXm2nf0JcWXSRT1wmwxG/p/vO0vsiob/JN1DY120Afkdzo73BKUEVKRS59Qx7JjAPQyVXwEd3YfaIqgsYISV/o0Na3L25bx7ayJ3vm2M1jE201EeHyooHIXZbZ8VmNbW7LSnb7yApbP7ubLYGRN1bSPrAbqYjlgCVQua+J/yaRSq+DazSgRfQodfsaFO/xDendrsAnBQgUisSP2jXQ36GIztjItOTK3x/1+BRAC7WLh47a6lXrbeLE8TZrzEjI3hm2cv1eW7xhpzWB/F66Zr8NGDzJLl69YftPnLd8xUtaUkY2v2OEnBb/MkUupUVxWCmoz+NGrE8LqxlBV9p0KUh3pLwSNZDKhFiuxHmtFGb+0rGXLVfPBlG41whG0FeuttXj9mDtMnWwMqQr5LLEcqx0nPsJqSzm+ROsG9Gyh1MzaaTzTlp3H+vu0qP/8cDnMe/ukLf/mLe9ZBBNKnIvODyN7trIkMyuELkAlht3KGLwY6VJb6FTha0zzOAb48Y1GkBrlYymwDHwfjcar6MUGfr65hlbPWOk60iVHlW0+7aMfanW5//g71TZFnKrVYoGSjEqtkUV8G9RutESyhvu9jzYNwMJ9AJbOriBXaJovn1kmkVcXmFbRjWik2xm+ya0tzldq/HnkT3f59H2kOaEbm3Ll+pdmpfWX52w1+369wFcB60JBYSybxmFSC8BpOpUfZScW79X12BdfckblX3JiId8j1DgHtmxw3ZuO2gv0V3uPxNq4+eusrV7DlroA4xCnjyx3sw3x05aZqs3cGB+4Ay7fOexVW/Y2NVWaXJQrGdFcZyZtIlGKznKGEWv9LmyWDaWcRIn4/jATz9aWmquz7JzniIthVtwECc3GCirYM+fjGPgMkjj/Ea1mq2sY9t+Vr1Mbatbro7VA2D1gutTvLOZg9ph0YBubntFX8yHl6IbGOlwqNtJkHn+CiwPVB77rpGOByxfrcWLpRdV27+SkDChf7pzkT1nmKqW+uNNvKLE5wBmpxn3dvD8USyGlPJHFKMec8DyUQxuKQOAeTXYq5un7DRb1m5FXx2nXGo8UxH/O94tz7pVfR+w9O9yK+8CvmoXWWgCLLslgB2xOzunWlToKuwKattTrold3gSrfms7zjZN7eKKEXZ4Tl97gz+XoWV/z9cjqYwHLFe0K63r3+qnV7yo5Fsy8UDll3ELTLwhY18p2sMfhks86VtSUUMkNW4M/GK0Ol7q3YfXr9p4NnPu3H/iDmk95djp+dtPbObSjbZk7R5u7TyzzbtOWZPW7DuMnWu9B060Fev3W48Bo0l7eGNlx2s0Z0aAxWwwuz6mdz9PSdGfhSOhqtUSJEhgmai5PtORJgGrbGkOenNVXRRDoZQY/HO3piIm+A0ad7E6NVpaDYDViCK+Ph/ro2zQKQ5dZZiGdWQEGyyusH2Fdj2ML1rPWyKUgOXVXH+JVlKP+qJUHGDphVKtJW27zDxUd+CVEAFrLLOztxxLMnYKRQpqKBvDAqkn4/201aKuStvCD+io/Lt3oixcFODd69bK/A41r2+d5J+taMsSLZ93APTXai4VKWpRq7gxkAMXEUWR0d+BCRQCeDha9mjtNjLPu7d7poWuGc4YqD4r+Juxk1wCMTqaMU53PB8gLakZRW6GMTz+yOjGRWD/KpcXrXw1lY9G8fRpesN5Klv3UW9CXr+Yt5QdaN/UBMWIR9TrjdFczDt+PfIFivDndin0gm3butuOHAu1VRt32qpt2+x5DPuETEaOXySKnbmHAdsWmzx7ky1ctdM27j7iTtBduv3Kdh+8ZotX7bGqdXE/xEAmS768lq1gTkvNlnW6XBwSyOkDV6rM6XwLFT//zE0dNO9Z2dRIkzYFbjNahgjGp7yIFU0rs7SKVhnD+3ror6oQoeQ73hRANeA+sX5cG2WDfNyHcxvvlVhdRygyL3RX35Eav+ELDPNJZP76OFB5wNJNZff4RH9aaNWYR5ZETl+FuZiWAgSqG+zlRexf5aKYajBpu70hre+jf0dPUUxr6WK0AafrlPzOM25e6C+K39OZRbHoqujgW1f3F8H+lX9PgqPZorf2r21jAUx/r6y9o6j9NDiWy56TDl/Zag92zbQHHNB0LsqcSglnMGzqcnWcgPleuI5DoUeXq414LK3QKw2KWnBdruPn/HSJ06jxmujRm9C/fOKL8oAJ3lCPGiVfF07XGqUxGm/syJe2fcde27xjnx0+c8VWb91vt3CZWbR+ux1l2fhlVIxt233O9h2+agtX7LBjLMg8fhdlT8Ki7eZjzEJO3rJFq/baotV7bNz0ZVaC6xfa7ElGJ5guNx6kBbNYxryZXUGfLnsWS4hg9EfuIKYT856Rij81nkrlcUAuhZgvb7IA5oNBrHSRBoMbWfVqLaxmcEPHXTWFZmjMIx2Wrn7qoKVOtd1nmUAXTpXj3ZoWwDJFLDc7/DOwPoEqLrCUPqV79z9uWxqAymBN/gsyzjC+EU85Dn517kiLYtVKIrdITNDc3ExmsURN3+7dIbc/6PFDTjzn371za/t+YAlEzvbI33U5jy2Kec9ny/nI83Pfr/uLaaf18rnZeBYAio6iQrzU7WwetWgBgF4d5HIacuawQwyFcf6LhvnWYyg7FYW1CBGtzR0tYVC7OXJW9EJcYPFm/QNUPmB5oJI8Sbxh9GteOxQl5DzXhce+B1yoVV88vmsrV7GpAyf1Mjra9pw6bfNWb7H1O07azPnr7ezFO057tevgSXsGcfWO4fMzhH7ygtcJusuoSR+8isIJO8auPXhlG3Ydse4DR1lxXJ3T4pqcJkcWy8TcUWkxAxfRtLTqS4Vo3tOl55QFHpuBxfA2x7k4f3KM76mdqgZyFaF8fatWvrHVr9iUUx31MQWpzY4hUQuQyfxfbsgd8CE9v2mBT+fk8UPv/MByTPwfwPoTqDxgabb4V2D5pTQqUtWhKfroHS7t0RX2BS/MG25v+IZ9vOCT4Eqj5Hb+nHkZSkyBy/OXUnHt2vg/F8YeoLzhtj76Uo+v04oRierk0f4uLI7eS5HU+czLKI5UqXbeeVQBMDc5ED2CeE814RscaR7gx3V7zVR7jmoifA+GuBwYDWdLJwo7JIFLdaOaAVcfitLwE79ObeEv1JX+nMQobsTSG1dRnh0DTT0sXHsGoIgFlo8fYuzE8aM2ey4Og9RTEZh5PkFxcuzCDVu0fDde/JNs9Zp9du/ZCwv7EGvv2E94QEW//9h1bkdHGg5H9jwyEqBF8fl3fIyxV5F8uZwN3LrvuDXn0Hl2THWTY4OVAqZdc0MV7wkS/GRqCAFWZuePFcAVqbypC1oRpUHc+KqVrWPluEFcpzyitUrN3dC5ETPChuU43VGBQ44lanG9qqw1LVqWGy+j+C/KatH3Lvd5M/CFqpD0R63/ACo/sNzQ2gOW/8VzqVG7hhSljtwUw0y6UW0lEds+jGK1kiUPUHfjWTJcVqD0jfzkjufZAukb7XzifRyRq7dUS7mrrBr5+CXQficcJzTkm6nBuB5vO9vT4HsckqKKLATkU+VTrF7wdaPqSu9oPEMEUvOh7pU6St6j9zlefnHxaLu+YqK9otONZnAsZxq9KUwb2Job6u9wPBydKv8+N6CPA65PUd0/PnM7mXotBaroCE6ZnCP97WHzZrMtJzotWLHZ1m3HsuhdmCvY7z57a7sOnLEt24+xlUPA43OPXr93RmzXub6q4v3Sraf2hsWKFxEATKnxNdGP9Kh1/JfvP7gF19sP39q0OSssICgE2oGLFXBZyVIx+kn8s2UWQZoeD+9ksK0ClqyzS2SiG2TrphqFemDp6u4YY9MKzXwRC+pB913ql2/A3T2oCYzW6uQtYSvH9HLsu/O2AljuxXhNyPYDy33h/9njhtYCnz8VCliEdRMo9edpBty7VmoEvaO19czC5pPtC5jgt7E7S1nHwpDDKSZJL06nhJxEDnkiVlWDRZMWHQMNXeCIT3936Pgs/d0ASzId142qhXedF+nH1TN/bGe7z8vqyN/2e5HMjaLoKMV/KYJJHaHXQf9e0SHOYMQ5xsi1BnqBOuwed6bPcePn5qKJ7riAoq7bkNZGtxMi8udF0IpvI4L+ASxRDL6Oz/e6KUq98AksWV0LvXDRZs1dhM32a3emdwkLL2du3rQVm7fbbk7K3X8RbicvXLcd+4/a29iPACfKTl+6b7sPXcZ87brd4Prq3Wev+dxVB6Tnbz9iGoIOHiA9YovnVQSfA2jaQXxLGARndujUNavfor2l57Z4EuzK4//0nWm7HmBRYyH0K52/OEeN8rpxTi0OCZUKqmEVuB7Rvnpba1KukRvlKFrVh25oWL4R52Tl0+AzAZnatqF9CNW1MApbyDy1ue6LVs3icVQuQsV5VB/o8X7d47FUQ/ifj7TQrm0WCIg0Mt91Yjem+GexBVrYubHdXzPd1S9yL3bXUv0OxNoUNs0cnaGHjydydRFpRtHG18b7OB8XjQQsfbP4b7rW3R9R9W+IfQng39OB6euCO/qorWysvvXIn8qRr3IgZPSjvUoRlI460LQAHbubAeoBZG5MRUMShW796ibkz1OH2V0u1tpN36JqFOlUrLvj1p6o0/b929y/SWlQflhEdL1ZI98RpSKeU1rxun54aTt2rbdFWEsp9UWR3u7cvmlrt+23s1ce2tlLj2zfkVDbvf+UvSKdySLy2Bku299+6CLSg+dv7eqdR/b4TSQRLMLuAaTnUpOyE6Z0+PQdaRFnGgFLoNPShfYQWUd0Jrk9BwxzF1fVFaZF3/eZwpaTJucNwIWvCEK/Sm5XsESpqlazQgsHLN12EbAc3fAnYHHHGZJ0UO0qeIkj7X3KO1T1B6I9cSvSN3lt8Z8AJBD9J8Byv/cvj3tB8dZyxrc42SkaKSVq9X0VorbFHTCn3YLWWyZoFMnumKUDF2tS2sPT5P+fAMtLe66OAUAClQOTWvZwIgS8XAyEo5qST9FMX8NLPv+CTlipk6bFV6Oh6YLddtFR62Y4zohEVUOhlOj5Y+m2j6YJr0+utONLcFFcNdrdrnZbQPwZ1xQIrMipox+TuongUeKr3GtKJBOo+XdFK+qyU6BOcOPG9TZ8zHw7cfG+hWFtEP4h3M5du2sbdhwGRLdtz6FQXGXe4+L3hkOlNwDJBwuL8p0B1PNKWzqAScB5ySdeIICPC6ynSJY9cAmcAtfLt/rvUP5eu4OqIStd4Y/U7CkgSLNnx8f7NyuYpxAHKEtbCBs5NZkDFi9ZhcNFXaxdtTZuPtiAmisusEJ0B4etneKcfWsVWNp5bMp7XFFLaUJr8sY7/BNQ4kamT1HszxHrPweWuqBHPkttDVrpEJ0XKBokpZRh1QLZjGlnb3cvs/cY5YcfZoFUdtjyVoCt/8+A5ZPZ+COW3+3G3hMN3CY2aVCA0hMmXoh5J5MDn4gRMEkh6+gRpW2+vghA+F7cHWSkwBfJ16R0ydzxI280e8mbgQ0d/VhymY+8RtLTy6NddpQiVz9ylOAq5mzHpg+1N4fosHEV1BQhUuMYjZWYY8a8xtterLpHx/DfY90aUNEgQe1EvnxuO7bvtRXrjthUtpl3nz4NVxWGO/Jb27DzkK3betSu331rV249cyB4Ex7tFifAFVEnBm0/fxXP2wiKdG1Fc9D0ZTjRyQMX0UrAUnTzAUxpEeDxqO7SMYIMnD/5/vvvuemIKUgO7qAkAVgF8hW0stAHNYrUsYpBNa0cO4Nd6/W2NlVa/QdgqSv0gFUyZxV30WoVBvxaV5LnpxsjKM280OjBz7/4uao/pca/pkIVpH+JWLGv/KlIABArLv8DqIVIea+ze7dtVF/rV6EIGvV+FoOv6FvuVUdhKeQWN3Fj8Vlb8w2NkwrjAsuX3nxb2A4sgMk9XtdKJ/XhLREBMtGt32ulzcmCeGjxnzy+j5z3oG3dst42r19nu7fCY11j3vjmEdgMtdMncSE8fcYO7Nlte3Zst3MnTtne7btt7ZKVtmH5KkY+HOrUTR38Q8MxFzk5fyTiQbpsz+pS3eobyag12xTfBmipqaKeAiy4qgikSg9uXLVjBw7Y1Wu3LfTWS5swd60t37rPdh5n1PQ2zHFYl2+9sovXX9qZy/dc1AnHIyECDXIMtVY0gNITweciiVwC2htA9Y6fvHwf46u3SIH6cx64nrzWj5UWY13NJctJD1haKfwsWxam0ql/s8KYglSAbddFz1Il2BUMaWw9AFbrypw5I2KpvmoUzIyQVChgVcJhRhGrTJ6qGK6VsmHcIH7FKTV8sn1rVk57TlflL4p9DLuPCPUKeScK/Esk89ppD2BKAapz3J9X2OebpdQWfQ1jDA5jhp3cZaPrBtv4OkF2j926qP3LnU22u/kswvL/Biz+bQIA5yt8kUqAgq2OIQ269j2a3cgoPkYAqGjqmQ8RFvb6hT159NRu3rhnx46ds5Vrd9jWnUfYXnpo50hBU6Yut7Fj5ti+vUdty6bNNmH6Krv/PMrkAbzj4An4o9VwR0eJHC/s7OW7tmrVJrbKt9r+7Vvt2PYNdmDVXNs0fQiHDma7VLl/9x5bOn++nT8G3aLXkqj18TmvQ9hrO3/6lC1dsd727jtgt+/esQjcfV5ERtuCtdts+4GLthQOa++x0/BSHBgPfWBHz92BOoiwF+8jLQxeKxw0RaPokylQFB8j+LNRmPa/J1q94fe8BVwClvcIYH+AK5Lo5XteRnzEffk1bslZXCrUDsVnmTkRliJVMisWUJwF1QooGOpbieKVrG0tLofW7sn9PByT/wIsjXQqcrlLJ2t1IECHLVuWDWYWNoUwL7abusLJewGX0oJ7QfjGCViiF7xW2b9q763bx50ZxgWYfqyazVEBup/DuEaXG2TFKD+rE3NHWbdS2W1Nj8YcT1ph7xhcO0eWOMByigh/8e6rhXz/LpGLPqBLq+/ThjkfL7osgSgCYGtHMoJ1tndvX9vWbTtszcYtdv7aTbv95KU9D4vgCXdtO3WsHcWefN7yDe7zl27fsrFTF9ilO3f5tRi7/oirsNevuY7sTUw0IKBgpv0/fv2eLeAe0dT5K+zw8Uu2fPEWG9Vvis0du9wGDuOu0aLdNmsqRrxzFlm0RmcyLGEuOIO7hYuZ5T1+F+H+2yran0e9tsPnQm0lKfHw0bt24MQlO335ke08esWuQhE8IJW9ohsM52JpJHkwJibOQ7TS5xS1FL3e0QUKVKq99OjHXuTyinxFLRX71+4+dudP5N2QmlWyz3S1KXmKpHhelbCqRarQCdaxsqTBXvW6Wrc6Pd1t4v8cWJUcsKQwLYENd4380A692/iIShfG4Y3U2gtctPSfwOWfDQpMf33+U2CptZbznzfyoTgWrxVxzedkrEJdF+ant6hmQ6sUtzOzRzG0XuaYenlJeRHrvwKWM4FTo6HaSUW7QBYbaa9evbLjJ+B7th2yeQtX2YKlq23voWO04lfsxsN7Fo7tHEZNFvVRtQoGsbxJBJ6bTx/zzV5vT8OpRcLf2ujxq+zgcRZD+KaLjNx3/BygI6O/CIPNfmjHr1yxmy9f2PFrV+3yU8R1AgdpaQMk5KZ9p2zWop34g75j5HLImrToYhs3rLHnD5H40AkumY3R75ItTqWw7/gZB9gw/hXXnjy1jTvPAK5DRMWntu/YDTtOV3iVMycPqLneAaZ31E7IrZxvCxh3qTCWyBVOjSXQvWcH7A3doNbu9XjAUtRSh/gEvkHgkn+pyNPLdx66ixVffv2VpedO4mdS/iXHD7xkkeKs1XN1lD3BkEr1rX/97ta9bi/uETf9C7B8Q2gtqjpg5eHyfAFqsqyFbWClkjiy0Jn518Uda+5Wqnxstmvp/eyxfLEELH1j4wLMAcjPLvssjjR/pCtUytI3XbWbiFiAqyXOj1d2uNvNJzG57RNcyBZ2bGw3189zTivivP4ZsFzEEqiIAK4DpeCNxcvryo3b+EbdtisPX9mu4xcsFBXA+Zt33dhDAHn88qVFfuQ7w88/8tx//MR1WHeevrP5y7fYzkMXHZfUvc8cW7buoB0PvW5Hzl+y2Uu54bP7pO0kje4+edJ2n+L3UUzvOHiM+uca36R3FsZfuP/caTt985rTRm0/esHmbNhug6bOsaGk2QljZtuutYxmFsy1HkOnMvdj1rdyi12999zeAO4HHI+ct4qbjIfO2KETHAc9csPOXH9uV3EIehpJeuMhGFkk7LpApXUvpUB9DI+i9uJzOmGjGssD1p/SIYDzgCX/UgHs4s177vyJHP00zXFd4W9suBZll7BS2epu86ZVldYsr/axbvW6WVP0V43L17Wm5esBMF9nqBpL9we1FiYVROm81VkVK2n18xay/RMHOv7I6a8pmH3DXVKPY7j9A1XxMNrOQQUhYPnA9cfzCVxEq1jqHtU7blFDZm3UQk64h/LAjVG4TCYHGDHYE5tUsgn1K3EEfJgDljw4jUUPDacl25Xhvifm0x6jvfZFTbcpRBp0W0XUGXdvPbQdOzl3wov8PirS7jx55oCx+dBJdEtPiVbgm3SiIvchbPVx0tfO3WxK7zhuW2CuV284bOs2HLUNm47b+i2nbOM27tysOmxLVhy2+Yv32bRZW23GvG0w11tsEjWYniEj59iQ0bNtLhFo7dZDAGWbLV27y1btvGBrd5yyrXsv2Jrdh2zXqZO2eMVuGzt+hS1dt5khMVvQp8/b/DWbbPHmA3aLAnsr4ryFi3fYuSvIYHaHAuJrdhS1wo3nGs3w7xZoiFiiGPQ1Ckh6BCrvUcTS73tFhCLTOv2Wuj8vYrloxYxHfNcdUuF5us106XGnwX8rPapSB6xk8A7FivqAVY2dwY41O1q/Zv3+r8CS+kHAKpsPcOX3AatKjsI2siFXUXG+U5rSyQ4nO3Hr7aREidKkgHCFss9w7Y9o9V8Ai9+jqBLjhq9+Bl8CN9huJ8EFOM7ljpHOgYl9bRT0w/ZhXG9n9VzDYLH1TvXgX6136/VsQKsRECXiWngKdosmNV29bEuXrYBkxBjt4mU3AlFUEoi27uOgJtccdh45xfjjjYsuh46ftsOHLtjlSw/s8XMKe9KJWGqx0uqeXtJJPX0rH/UI50wsxzxFtBusV915+obzbk8hKN/BhnPT+sQt27rnvM1csNlGTVxi/YbOsN6Dpli/nhOsb/9prLyPtenzNnC16wnNAkfgl2+0hxjcbT54zvaev2XLVmy1Wcu22fxVB2wEOqqjDJhXHb1v67efs4Pn7tlpDjLdAh1KYwKMHtELAtBfAaWfK/qKetDKvcDlUQu+NBgBqMIdsO48C7PrpPWzN55YmvQpLP73/rNyApaOjQegddbRcKlDu9fvagOa9cf6pouLWE0qIJnxR6zGDKYVsTxglcbbPThfFTxKS1swPFjtAoW5yjrE6ahkB+3SonTsGlNoadTNvgQs8T2+cY4PXD4lxB+RS1FKaUrFNQy8imqx4qqHlFIFDFh0BxopHPhvvWTAO75WoK3o2sQtcIqEdA7FDIUjGWS7BQVJfaUQVRQFVDr8BHJdp7d910G7/vCR3Xv1zK4/e2wPw0Qz8suap714gvwEYO05aydO37V7j6hVoiKcsyHfB/dOllf6iYs37Rz+FmdC79q1O69cjbPn8BV0UEds045zdvL8Ezt58SlF9S3GIXdsL6OUPUeuuWffsVv8/Caff4Bk5Z7tJY1tPHLFllAvTZ21wzp0GW8n7z+19YfP2IRJq+08gFq947Tt2R9qy5AVL2f+N3XBPuvRh0sYsOrbtx0hDR+145dJ4/dfusgSF1gCj4AV99Hn9PjSoK9490hR9wbh79Bzn3nObbir65QKlyFcT155xOIzt7S5nZ02M6kwW7ZsjiktlL+ohZSuao0qNMJErZcDVufanf8psEpylEmHmUpkCsKZpgJ3ikta3+rl3dk1u4wPuiTF8qTC2SWaRVR3lcKJ+ahnXvpnhH4pyJ/Vpf7i3g1gfcW7Zy3pzfA043PKAuZs0VAPxvm3DX2a42FA1FStR+1lt33OwgKWjhqJrnACvndQDW5Th9qPVbUzJy/bsVNXXXeHe4E95HN3X7+2NxHvHLjuMUc7ykjkGX7oAhOvuV1CWrJl22k7cfaB3bwXTrTZADBCOSUS6eiFp8hNHvGD+0QzzeT2kjIv3nxh919GE3neoXmCsLz7xn3uAMz41oMXXdpbsHq/LVhziJ8Dtv13SX8PbM+J69a11zjbfvKs7Tl53qZP2wqVsdxmEKG2qVA/cMFW7r4EyO5a50ELbfqyw/ydNxlC77djlx7buXtEyTjAUipURPKil1dTCVB69Guv3/u4K3W4iryKVO7recnYhym1QHWFuu48t3iOXLj7CVjpslC8Z2e7Ihk1VsH8RTBSq2atqrawAc37Wv+m/T4BS1HLi1hNKsDCE7GUApUKS+fDhQaBYPGMpZxNdzA/r5Itl20d3ZtaC7NVPJrc8FgCOZlxyDOBQj72mZQDPrdkJ/3wj3n+AJef6XZKB59cRJHNecQ77kvEKev5DGsjZFsti2si1OUl42xS/XLuYLeKd0VNt+njd1WWnl7XwNwyq8Y3jGzePn5k2zfutxfPo136uwcR+pg53Gu4nVfv39nhY2ct9CL/LcCkQv3Bw2e27+ApPn/F9h+8yoLnRSKWocS8QXf4EV6H9wzcjpurRYRTLJMWKZhvPH5qF2/ftbsvXtnDt2+JjK9c+/+AlHKfb9SdF1F2/WmEhd57Z0dDH9r6/edt/ODlNnfhHttNZzls0hqbzb9z5e6jtv3IY6vXaxjylbEAcaPtXLPMVo3pYpfmdbGFTblz1LqNnbr61lZuPGGHLzz4BCzVWA5UzAAFHg9EvrQnYjTaDZsd6w6XJTrh2Xsi1MtXFOlcC2PGeP76M7v9NNxuPH1rF+8+s1Po4vefvQndkNricyksjVv/YmFV/lhF8Z2U63FH+KuhLQc4cHkRS8BqVkHqhjqkRchStnQ8YAVxprccIHNX6PPAaTE7LJetmLUqXdKeaq2KNKUrrRLrSbQneYmTq/iVkb6hrg84zqbbszlSWtSjQbR+za3to5akO/QdHvDP7ZwlN6oCmZeJYuC+zpy2te3wNJoIWVdDpMp/Snt2nqbcDXb5u14/e2B3b1yxNctX23Gm/84y1Y04IuzW/UeQnvds/75zdukyIyBRCwDt1s3ndvHCQ3tDNIph0PuCF/3YuQsAChtIivwn796jW6I+IWLpEcD0Ln/2DqUAz8OX6JsQz+ldL0CJg7r97JXdYQh8hzpMBfZlIsElotmpW09s1uq91m/EQmq7qzZ90SEb3H+szRmGSRzy4jnD2tvSRoG2qEkuO9stm51uk8giFlawp9NqWvfAvBT8D2zHgWu29xTb3Aj1blMXCVgOVH5gqYZyTn6kPD0e0+7mhfxchKrS54NXr+0Re/eX77y2dUTpg2fv2E3qKwHrOFdadx2/ZmlZYo3/Y0IfsBSxkidPDo9VyhpWbmBd63TkmM8gB6wOtdq7VNisUoNPwGpasaEDlhZZFbHkn+XW8DER0ecELikeAjMXwPq6m328SGEtHRWdm6QjzlnPWQj57LZ9RwM8DXccxak3NsHITXWXrzPUVQuim5YGVHBLfguvJa93rfmHXdxrUecY84zoaRsGt+NyBNaJ8FwaAblTJ6x3RetyA6n4zhX036vW2OTpC4g+KE5Jbz6XZ7XdyEKwG9+6k/naNSIV3RNvXrsM23730TMkcz7eh10EukayLbeVnZwEqe99OKnXUagx8V19B3Ovd/2bSCQqjD5UvEsoJ95Hxa8EdA9foSLgvyVJ8C0ILoHr2pO3DlynbxMJOLM7fgIUxYFQOskt1qlQFrvWNa8Z5m0fNzWw6xOq2sTCX9qHhY0sZmIFmxnyq7Urm8EaYQs5bfIS23+cIfTecw5YNwmrXsRS1FJ0EphUnAtI3ujGUzCIu7r3TN1fmD1488YeUmOF3nxjC1cfsVVbT9IJvrBL91/Y0WsPbMuRSw5YP8bj2Liz484K847RaWDxIGtatRHHAjrhljLYBrboZ+1qtP2nwCrPrWdFrcJ4aQXlDrJyBatb0dw13Hm5qlwKk0mFW35AbSBlgjMXk76bPbkolhjiAsvRCZ6c2Q8sGbhpYcAtCWisEvGMhhK5x/E9tnfNItvE+tbKSQNsM2LDDTQNE5HwjG1c1Wa0q+EOJ2ltTDNDLT3onIkM1yKhK7ZsWG9XYLwPnb9HoXyeEQfOzsh53cEDALb34Bk7d5lIqhkaqe3arcd0QC98HBAzkEhAFKNWHZQpnWg4izWrG866zpC/imwCGQmoAJfvm+UDl0hF1StKLdJIPSYN6lEEe4Ba4OrjN3YFMlO1y+Hbj2z+jIO2bPMlm7/hjPWqUNCOd0hne9vksU0d89igSmmtVpqvbX613HamXWZbUyW+Te3XzoYt2G6dOk6mKbhlSzYecsW7RzcIVHo0bI4LJo9VV12lzyvyPnzJTUOmA3fYAL+LGPD24w9IlK/YUtbDDp695d4AR6AyNsHbpUELL2ClljQ5G+L4pKxGlyxeyppXbcgl1Z42rO1gG9xmALaRrax5pXqQpA2psRq4NKjo1YAOUVfo3axQYx2eoplKsTldzkUvKVD1UT/vWC2YjRTRARTXoSIsEd/hWRCLBMae0d2hk1cRHctZEze5dyMVdNzM76JFWgIkcp9LgQ/PHMQ3YY7tmoLf1LyxdhYN/EMWEyJYHH358L7dO3TcZrZoYlPr1rHpdWvazZ3TXHrUiZEPXE11Di9EzJessi9bzKFwN9F/b7v2nnEn8vYcPYUC4LWzpD59DvkPoHlDdJH7yju0IUofz4gyUgIoYolU1Ecx1R43pCig1KIUQ9Zx9YqUAnr36xum2ZqoB7XqTwCRahb9WGBT6hENcZ/04wPWS7rA57Z80xGbtWCX7Tx43Ro17ebcqieMnWFL1m23Xn25t5jzB5tdOqG1zf65zQ9Ja7FjS9v20c1YMh5nG+DQ5m4MtbNnXtmFWxxkUu3EG0CclEZRcUc0AvYTIqo4Kr1RJKF58OoNKf49O4cRpD6oElL1doSBG3Zdsm17r9n5h3S455/aht3nnZVRPJYpMmSlK8zKkSaJ4DUrbFGlgQ1u1seGtxvigNWxRuv/J2BJqiyQqYAXuAS8khmz2lRWxExX2dUl0rkpemj1Wx2aoS2KUTp7LhoBEhSNkW8vEUBxJuXdK9aX9u/gMPg0u7xxnrsaEXXjNBdgD9nVjStt24TBtrh7O5Y6aljj0qWo/TJZQO6MWImXseOL2ekjFUs9EHFLWicZfFyys8f2Od5H3Z6ep7TO+2HCB4+ehmPwTNu176SfMKRQf/zKpUV1go7zAY0CnDcC8VhrDW4FLl8B7APWO1KgotlrkPjHnC3ateuqXQQoLSrcpVaR3txjs2/DdSkdXnrw2kKptfSNnDgDNv/oHRs6doG1aIU0m7rmNkCfOXSI9c7+hZ3oVBQjuG+s8Pef2aLmhSx8SSNb1LGyLZ+30xZsPGiL1h2zc0wPbhEhIeaJvK/t5Rsf3yYg6b9/j1/TEXKlaf0b9WZ49AYw0cFee/SekdArB6w9x2+wInbZAevkbRSodK1rd5yxVBlIhRyAcsDKhoZGwCqC92grTpmMaD3QRrUbaoNa93fAahFS30WsZujcFbGah1BjUch7EUuRSWAKyFgSE5Eyn4BVPj9b1FrRxxy3cu4CdpArqHbddyYkFr902SFKYvNWG8oCFnqjKLwUfFr511iZ3rabu7fZ5ZWL2RA/bO/C7iOZuox57GLEfW2sVdlAK1W4gKUKKmLJQ0rYLw2r2Tct6tvPzevZvxQqbFlYDtk0dBAbMTjeodaMvIMXxA0A/eiOzVu0FHkuSxBczNA3X3M/tdOHjtOeQzJKxCZghDKSeUl9odJLRb0GtPoYSw0mRYA+esDy5mseuDxgeUTjHyknxn0jlQJdGiRqiTS9zbhF88OnRC2lnOsAS1Hr0oOXdgoGffXWC7Zx/02bs+KANWuPmRrs+uXwSFsydqgNyflvdmNokE2qnN4CU/xgxZN9afs65jNbUceuzhtqC7eesyX76GwfMTSH6nhFOn4W9oazywDHgfw9Uektnd47By79992/hdz+mGbkyr1XFoqWS8BUmj54hrqNiLVl/xU7wjhqK+l29eYTDljxudPjmPccGJ/qJFjhgkWsbc2mNrbDMBvdfpgDVmc/sFqGNPovgeWlQg9YilKKVgKWi1ocyCybPdAaFimM5cESIpfqLTTpV9Bu3SeKUciH0ylKyKZ0GEYEe6BotGUT5q9EGHRQ729dsEPzxlnfBiFWvGxBS9Yw2H7s39R+mtTF4o/qYz91amAJ4c6+LR1g8YoXsn/Jm8/+gVPhoJZN3Yq+LnfF3OMEyc1ztnH1etu6/yAD4DfY9IgmoM1/CnNO1Nq47SRM+FOXIk+dvW2XryOfAUAq7BWpBKSP/FiKAP0vJobP8UMvLYqxVlTzGGtfOvSRjSqSfZITnxpAEUvfQKUfRYmrFME3+aYpDT6iFrumOov65dQ1IgIc1rSle2zKov3Ug0+s++CZNhb5zVXS7rzRvWxawX+xYz1y2/0hxa12xl+tXupvrBNd4ZlhZc3WNbQ9+NVP3XzerXCJ2HVjGt5QvubBByT99/XfvAG4PJDp155Qh4lnO3fjlR1Dy3UR3urQ+fu2bgee9QDr8NU7tukAunpGWF7Ecv5Y2bPmcC4hhWDMO9RpwVHvUTamw3Ab3Kq/daLGakmn6AFLHWGLyo2sUUVmhfnpCuPUWH8FltKhIlYQitRKBWtbiTT5rG/tSi5ifeR6ljgu3YdxFx9eqUu8bu/OHrSHm9fa86vowz/QDT6+Z+emDbfhTepZsZqVLfngDpZo8VBLPm+YpejfxX7m4usXgcH2FVclvikSaP8oXt4+p/74O96ofyvM7LJqZbuFub4WRyX73UXBfoBtYC77uDC/nMHu9YePITRf2Q6UBLLCVDH+4HGE46a0a6eIFAEwFK30Px+wYvgokH10wPJSo6QmbhziT4kOWBqfuPHIBwcsX31FtAJAGofoeYZ2XKC6gHWQIhVUllssvUy0UpQ4feeFbTt+y0ZP22Rbd9+yOYv3W8c+E4ge723p6E62p/x3trJJBrPl9W04I62+Wb6ygRy/nNarjd2cUMGiVjXjnvYAO3EnDAUFGzfPqK3ocsVN6d+h//Y5mpPQ+7DoD984FYQ+p3/bU9pe8VanrkDinrvFcsYTgPXQ1mw7b9sOErGu3LPN+3zASk3xHj++/yZ0VrZ05B0pYHWu39qmdh3jgDW0zUAHrFZVGlqryo2pWRrRIf4ZWF60ipsKtXYvQHnACpReK0cljhBUdf7xiwd1dvySRj6iIDRmeXPvqJ3ePs8ucQLNabZePLUTK9EitWho2bvXtrSzO1imbaMsy+whlqRRc/u8eGX7V+zC/0+JMha/VCX7NjDI/lEuyL6oFGzf8vHfSle0/1UmxH4pW8YOTB+Mg5h0W3tt5+atdgny8S2CvSh4qXPXH9v2g4dd9Fi2Zpcz0Bfb/OotGfTKE1fcClRekS4eS0ASuGLhIP4Alq+I1+/zgOUx2/roBroU8iqUlXaUZpRylHpuIZATi61u8MyNh25J9A7/jsdsx1wDWJfuMeRmHevQdTitJXttyfJjtufgA2vXZZxt2XnWlgztaBerJbHltTJazNo2tqZbPRtVJKFNr5DExkyea3OaV7f3y5tZ5NYOdpl1uaMPI12EuvP8IxMBxjyARwBWNDp3G9nyXSgEajtFyxsATBHr9LVnduziExj/G3biKnPNcw9Y0z8Ht3bdDl68a5v23nDAkjPkn4CliFW0YID1aNKBM2zjHLCGtxvsUuH/FFjBBaAj8tMlFqhq5fPRNSJbPbF0kgOWCvpnu9dxKHKq3buGfovu79qubRyNbGNFW1e3dIv7WN6D0y03isrkjQEUIPo7BznjV6hqCStXt++ISF/UqGPfc/Tg6xpN7ZvqDeybypUAVhn7PG8x+5pbjGObVbeoY1sYVu+yA9u2OJ+C648f00pTXxGNLt97wjxtN1ssaKzolk4zf7vNO1cdkTo0RRzq8k/CNwFIqVFclx7VWtGkxk/AitMhxh2X6ACS/k6lQbXvSjfXmbHdQNKrj49YTLh47yXfuAd2kQglBv8WUeP89Rd2hqL5EIqLNdtP2uQZW23jrhs2Zf5u6zNojs3r19wu1v/dFldMaS/XADLcBXsVTWkbq8azAS0bWgfGc6vbVUDpMddiNnexPXv22W0A/uipWH7S7/+ftb+OzvNOurTR/s588840hc3MzLKYmWVbBklmZmZmZmZmZmZmZsbEAQcdMGafq36Plbj77Zl1/ji91t2SZVl29GwV7Nq1C2BdI70d5XjAGcB77t43uvwQEhji0z5uBO6ZG1/q0LknsP1EqKvMMZmVrt15XvtZbj0I475lvwHrtANW1qyoG8qbuoFUWAR/SRP6DWzdAx/wyQ5YY7uMdMBqD7f1fsRqm9acXcOmLhVapPr34t0i1vs1lr2fjONyLHbeBrKEcsFqFRviLH8urpuA7/koPWcYbPZHO0dNUO26aao4r48iTs1X8vLRKt2gnf7BlYT/ql5d2Zs0Uq7mjZWleUN90qaRPm7bQP/o0Eyfcc4jB11hqbgYxUR5q0X1OPVOYqyRHq3xTWrrkR09v499z/olGjB0pnYcO8+L91A/IMQ7C6DWbTvsaIC7fEMPHb2hb2i1f4UGhQEgeqFaAFwWdUxZaUW6PZngMmBZzWXRykWsd8DKBJX9OYtaFrGM57KC2Ia3Fg2sy7r9hb2IX+sxUes+M8aD528x0P38j27R1A8n7j8FWE+078xNzVm8V4s2ntP2E0/Utvsk9cfa++vBvpqXVFBfbR+ib7b2VPcqYdqSXlDr0rCnajlEY3sO0ldre1PPntCPG3rpJrqyJ0TIKxTzlnItSh26cFuniEanb3/p0t1FouTFe1A8bLWeBEx7T97XjqPXHGF7gOH4GuRA+07eZo55V5v23tbqzVxnJRV++umn2BihIPXz83O35ox5H9a+P0e6J3C0yIA1HPlMW4DV1IHLUqF1h1ZzGZdVFa93lwrRY9nb8LIxbEZXZe2eVBjEWCeYGsskNaFJSuQsig2q0/zSFMXv1ShVWQO4V7N2zGAoKricS6c1GIPYxmO7q/2VVWqJDXYANtk5qhCRatdWjpbNlLtzK2Xv2kp5erVX1i7NlKVbU2Xr2lTl68YqsVq0BjXM0PaJwzjQxRUszshdpnuc06CB+iQFaPv4rvoR2mH13LmaM3+T+o9erCHjF6NWuKBFq7bTujOg/fI1spULusOw1ort9+kDq5EypSVWR2UuH2S+zQSVq7EA1r/P3wxkv5mKwBGTkI7UWNceExEAltU1F+8zyKW+egLo9py6qiPnH+vm58/15a+/6cKjZ07ycoqB9x6K+NWMUybgDLPj2EPNWX5U/ZPL64d+lTU+Og9rcCP040GkQ62qaHhwFp1uX1TVw6to5JzjusrFsbc/4m7zxW59u66nW6O/+egr3SU129+/j474GMP0k4yrzgKu0+winr6Ntp+0feLaY+04ckvbDzMUJ3JZxFq947T2nnno6iwr5FcBdrsVnYWzdaUtYvli7mDn7ePRY43Ew31+v4keYHUd+gewOuD3/f8rsGI5Mfc+sBwAQ1m4IBVGhaKTt5orMFBtogN0a/82Xdm0Uk0apmnU3nna9fyy2s6foxw1GigLgPqkQwPl6dlKuXt2VIG+vfRZ3/b6cGALFevRVOmt63OupKG2ju6vx1xS/f7CPk62bdC2maM1uFFtNYoIVZqvnxIiwjSszxDNn7kYV5WzfBO/pD2+raFjl6hnn/HolfC0+vKVzlCQbtl9mvEKxbcb4XgiTeag9g/NEsD5s+byRCkr7DMjWWZX6CFKPY99jUzhnBXxlg6vQ3xe+fxbFy3O36WmJAXaLO/EtYfaSuNgdY0B6/xDCmfS03m2b/ZS46zfd5nu8IDmrDrKWOW6hlQP1tPulTU7IpeeHZjMwcFRrs7q5J1T19tXVJewohoxYYuODammJzPr69GIeF0fid/G0y91kqLcNPeXH7Lsinzn0NmHgOuxTqLEMDAdv07Nx7/RlAtbD17nuemilYFw5VaABa+24/B1V8iv23zRKUiNx3JWkU7oB7ASohM1pttgLeg/SVN7jNK4bsMcsDrAbb0PLKu5jMv694hl9t0WsWIqYzn5XsSqyvHM1EB2ELklHRNV280TmyGDnternabWRV/fpKqGX9miLTDxye1a66O46srZuKVyd2qqQv3aKsegLsoxuL0+HthSJfu2Vn1S4NKh3XRvJ4sFt07rm9ObtGfyQI2uU00dYyPVHAO5utVradjo8Uzcr2jI1OUaMWWNzlz/xpGOK1m9GjZtscaxTTNu8jI0VGjBHz53EuADx6870vKnd1EnEySZqTBTt2QgygSUgcqim3sMjO90TK4JeDcyMcI0k5m3Nt9mhZYGLUoZ0M8BoqOXkULz6+vIcywaHDp/X49JyVef/qiTRA97kffwgm4+dF0rt1/U6JlbNG/lcbq/WD3uXEorU/Lou4eoZq+v0YXpfdQ6ooS2p+bTWmaHE3r214k+4XrcJI8uVvu7joxsres/fqcjV564qHnl4Y/aeewmxfg9ouVDivNH7jnMuMvS4Qk+b9Pey9py4IYD1u7jd7Vq2xntO/XIfdw4tg1bL6uYHXzi4IDtUTg9lgHLZoUTeg3XwgGTNa3naE3oMULd6rX7F2AZ7WBp0SiHalxadTUWQLG3mcCKwgLpfWBVC83g9+G1AtJk78d6haLXytC8OnUVVT9adQ8s1tADa5SnelX9o1qGS3t5u7RUzgGd9Y9RXfUxXuVlOBTeuntLbRrRS18d3YpokEPnx3draR9SdEqkmlZP1PAh/TWfQ54nLt1Gx3RZY2es0llEdqMmb6DzYz4JVWCSGOvKjrFnN27GEi1fjx/6bVvD+obIdQG/zdtuSGxjGI8IjrroXVeXGXEyQfafZLyZ0hMD1b8PdDPVAzaQNtcW68bsRTvLge8zRI4jqAWszrnHqtha+LTtrG8ZGXkZvu3IFV5sVsuOEFUtYq3bc02zVhzWqKkbNb5pkm61LqwtDcuwP7mbDniBrq6doi4ZCRob8A8dr5VNo5Mr6EzfAD1rW1L70rNgsjtft+DTjpy9pwsPv3LA2g4nZbzUwTMPHKjt33MAjZgJ+I5feqLVW885UtSAte3QDa3efp6I9RhV7QVt3H0NE5LznJbDzjvTxsgDLM8QenLfUVo0cIqm9xqjSb1GIZtpzzHM5jwtXCrMBJYV8KmY3r4PrNDSUc5lORLvUgOW50lVdFgNpUGWVmNQbdEqHXnOxCb1ORESrZjD49Vg8iB9GB2q/1U9Q59wMjgr58/+PrinPhneX/mHdlc6wr0Fk4bqy2NQBvgWPDqySzOosRomhKpj06aaOmWmtu1nr44WfR8zvhMoMG/f/B5573JekMeaMXez27D5Fn3VK8RUTpnAM3cpgDt8QyfPf64FKxh7rDmoXYcvuYhlIxg3+afmeT9a/UuX9y46/ZniPH/GotP7a1JWrNuoxobOxmPZ6ro5uRgp6vb97n3u6icDzc7jVxw3tQ1F6Jqdp1yavIYB2kHI2oO80Idp89fvu+qAte3IfWQ0hzSdkyxnANWOJt6619tf51vnw1d1nIZ0GahGBf+iK/VzaEFiXl0dFqGHHUpqRaNi2rUDAvqH33XgPCkPHurS/R+ooe444Ow/dc/JbA6df0ANhdsf0cpS5KI1R6mlrhOlHmgDStg1O9hgOowkest5Nq1v8T0+/u/Awp/7HbCmDRirxYOmakbvsZrSZwzS5A4oHFr8C7AsLf4nYIWUinTAsqPj7wMrDnDVRulg3WEiVt/1Q6MAbA35LeiqoOEd9HGAvz5Jr6us0Amfte+k7P0GKQe+pn6D2ml8j356uHaRM+N4euuSFlJrNQmurHYcr5wzZwkS30c6ianFzuOXdJU65SgdyhY2U6zbWcpywR6WDzYifek1bI7Gz1mva5hemDLh4pXbmruARc+jtMp7LqvXoJmaPBugHbmMnv25UyRYLeTUCf8Wsd5n1e1zMn/tVqTek554ZnCQobx1Yj4ipdkFmbbJ1KVmcHYd8vP0XeoaRH3HkCub9OQcLf8BIsmCtQd0ns2aq8zodiEo3HHihg5Clew6+UArtl3QMl7QKfN3a1mTSKJQEe1v46/HTXNpe9xfNG54X61cuE0Jhf6qBXH/pf2NvPXrRIDVNrtWd6vJBtHnOv/Nb47R33/+js7iPbrzKN0dwNlDmtsPoA6cfcDfhWwaYnYfHeGcZQe1ee8Nly5Xbz+r9btN7XrDAWvzzpuaNZ8rFmXKKnfu3DKXSFJhJrASNHPwBC0ZPIXbeuM1rd84gNVOnRnzdIIjalOjuaMdLHq1S2/BwipzQJsFmi4LBj64ZITnSli5uH8BVlpIHcX6J6g6chpzWY4sVU4VGkXJu1sz5fIO0f+s0xg+qqlycUk+G2b+Bfp0V22kL3tGD9GPl7nLTC1wYPpEtQ32Yu0sXs0at0Mj9a2Onb+n/SyHnrz7RFuPndMpdFMnbvLThEXP+UdfaN/ZC1q6GcXC2WsaxbLn0Gmb1IH6cefBM+5S+zLY6807rrFOtUoz5u8ket1ywLLC+iuM8x1okL44quDd8kHmgDlTGGeRKTPFGagyt4T/HNt4BruPvn3unsffYRPEW5sHWpNg61pHr992tYwpBKzr2wOlYBr12ctZDrn4xAFrJ8ummyno95x+oG0oHJZvPU+ddUnLN53Tsrbh2t+0hK708NPDjuW0NP5j9evYQsdO3lKqTwn18P+7bvSMk8YG6XK7otrAkuvG/Y90/N53Oo0J21aWMY6zzLH7+EOKcM+Yxgp5e7Yfuw1HdZURGCOlJfsdsOz3TTKzad8NraBgX73lIuTyBU2YutXdCzBg+fj6/yuwZg2ZoKVcqfr/J7Di8NpKDkMQ+G60U8HfRzlicSWBkP2garo+qwsv1ayVPunTR/k6tVCdOlV0ZvUS54vw+PIRDawTD6ASmfHt1dxF29Rj9BxdxjFl/wU8nTAQu0zLvBvp8DnuKF64ztyKBdNLLDKYidiGPSyYnrujucvWa9OBs66Ib9hsiJq1Gqo5C/dh5noY+515WCXeJ+L97FxajGP68ofnboPlB+TGJpXJ1C9lCuMMTJk1lAHKtnG+dZIYZmvwYZ7VKGS8RL/Msc19FKL23PsKWTJRzIB1F3b7AFvLluIOnv8KTuieNvDvvPIQU7NlrO5TUJ9/8ANap2usfrGHeO6xNh28obVEiy2HcObbeFYrOkXqRNcwPesfqEfUUGsjs6hrtWQi9XW14fBWN5+sutjJV9fbFNWaNrGMrW5p6+7LDkzHLj3QetbWDhMJDVhu0G2qBTxJ7dlCqWDEp+mvZvD9soi2ed8V/t7j7mMLV53EVRlZzvLjGjV2HVe/yrsay9cvILN4L6YqCSmaPWw8HdcUzR04QTMHjlfvBh3pDFupc502cFeeGqtDWjMcaFooPRKVKKnNIpY9QUVDuRSWqpDi4R49FinQnqgIuC0IUjtEkBJRiwsG0fq0cpg+gT3/X/iX/p2L6TnadFFJ3m+SHqXL+yAz2S4+tmC+2vt7KZAmYfOuQ7KVhhGTV2rs7BVuVfzi7bvaywLBza++ZBxxU2e4+3Ll/kP8oE7CtdzTfeTLFx4/pJW/54zxd6LAXMJu3+S5O9S+22TNnndQPXsv1Pip61kkhb9BrHYekFqXZCMVZy4GqEy0Z0CyYt1+bdvBbq2e950RLNN/Vz/xcQOTAclkx/bYsoQx2zbYtQGv57FxyXeMcFioQDNu0Wo3RfAhujBLeRv2XNFh6j6rsVYSmc5RZ+08dUtrSNmWBu3FXrvnojYjWVm86bwWd07S1yPi9Gq4jw42qqj10f/U8Ko+qt1pHkrf6hrh94m6lv8v9a8WpPUHj0In4CW69aJj0Q8wTN5GM7AT4FrHuWrHZaLSNQr585ChVwHzPS1ceZaodFUzSXVbdt9w3d+qtWe0ftNFIv9xrWLENGHqbg2fukdlSxCxOFHn4+dtmncfdyi6RpXqmj9qspYNm6rZ/TlNO2Cc+jTs8AewWmMS4lJhenM8s1pyLDP9vwHLvEtDS0R4ivp3wKrJEYJ0BtI1SJfVQlLl6x+jTyv66ANu9+Rp00wfd+moQi3rsd1TTgdm4P3AncPVfTopI6iyJs9boE5waruPnNb3KDzHTFmpOSu2OWXCuZu33bbx7W9svsXe3B3SBosK2w9Yt3JTT3EMvo21z43Hn9NhneEn8jq6pjvUCvs1ZPRyNl7mqXVbLjMsPgCwnrrO6wReUpcgLg0IlhIt9Vlas506j8bKw2uZEsIKctOpO6WC1VA8lubsYzYDvAtNcP8rD6BsqGuzN3tMymvD5kzAGaB2Ei32UdPs4d+9bhfW2fw7TU68gLX6MxjNbkfvvpr9wN2n4LiO3HTA2kTkWQKw5jevoiutS+hW21waFp5L61Nya12DQKU1GKIgv1jHwC+IzaoBTevo4CVKhMtfah/Ft42F9py7gb0RQKLLO8i62fodRCTKg+1QCPtIg+u2I4deuB2Z0X5q0E3aduCm5q89AaAvas6ac5qx6pymzd+nIeM2aez03apQsqKbFVbmuKrjsYpxbKd6lapaOGaqlnPqYg6gmo1ov3+TzlAOrdUFPqtNLWqr94BVN7Y2kmQiEdHKliksYhmwwkpGOv/3TGBVJwWa51YqwKphTHxEqir4hip7+YrKQeGes1m6fPxLaDIbzOsGDNakRg2UhlBv/Y79OsUYY9i4xeR5LimgIR81YZmzjb6DFeKVR4+0h3Wsm1xTuI9s9gptswFr/0mKyr3wW+jNv/jVhq3fOQpi++GLjlVesfm4pszZrKatRiij3kAtIowfPAFnQ2ttHZKx3Pbi30fgZ7SD0Q9mVGaOd66movYyYFkx7qS6qAUekpqty3vEx+8yVL7N/M8Gu/aYnsqkJtf4mpm81RmWNOx949UO4QCz49gDIgg/KGwsG7BswLvv9B1NZ3xz4taX2sZe4qpdRBmAtY2toA372Y7ef9MBa+X0xVrYig1wJhCt6zfUyrqldaxpWU2ZtAKvh0laVaeyrrQrjKS5kjZuuavdV2gSSHPrtlzR0bO3tHHbNYrwS/zwXXfpbRMS6K2AzWpOS30Tp+3TpOl7NWPeIcqMu9yNPoK36SXNW3TcPQOGLNeEads0csoq/N2L6ZM8eDf4wGN5eXk5aXJyXJKLWCtHTtOCIZM0f/gUDWj2r8CyVGhpsEudVqqPx8P7wAosEuI8SSNKG1Ga4hZa7UmMrK340DSuXqDLAoR29d4K/3i/BEX5xGLp7KOYCoWgOXpoUq2qqlmW07aTZtOG/6RTl29pCGBauW2fW2sfyzdrzaYD1E9M3olU1p5f/5zF0l9+ciOSSw8o4AHRMj7HPvbNSwrqX9gsYdC859glhqlfuGi2ePU+9R40R+n1+mjGnP3asZ9RBS21cUUnbnxOZ/bU7ctZV5dZZNv2sg2PLd0ZwWmKCEt7xpXZLM1AZMC6/TVRifUwA5MNlW1kY0Nde87f/dIx7Maun+LvufEFq2W08zYq2cGMcg8F94bd19kpPOXGJlPn7XYpcsfxOw5YuwxYxymoSYcboBwWrzujlTvus5Z/BCe/HWrYebqW16uga61KaMq4WXS8X2sMo7OnA8tpfe08mjZmvfaef6qNUArGlu8k6q1hFLNh93mtwxrAxjbrd1zFDPeGA+4a1BOjxq7RiNGrsEs6rTUbsPFetN9RCzPm7tXYiVs0YNRuzZh9TB3ajlHZwpzvzVMIc9swD7BMQZqA4nLeSBA+aroD1oIRU9W/aad/iViZwLJUaBfArMayWaEBxoCVxDgnqmysYiolOm8HA1Yq1y3ibak1PN2dULGtaXtSfKs7KU01htMxASEc3W6upj4l1Zqub/XuK7rErpqx0RPmbNHCdVyiAlgTpq4kTJ9kBYl1caKUrZdfAzTfvDLtkgdYZrCxbD3jna+fIY+hPsJ7wdp8s6E+wZbyBaQyWw6c06xF29W83ShsqZfzU3uFtvqhixiHL/Ciw8ZfIgXZoNgUnqZEuMkM8TrjFXv7xQ9EMugC+/2jF6hTDl6mrrvjwHQH8FmUOo8ExmQoBi57a/M4m8EZoOy/yyLkZQpz+7WNSoygtILZBrqzlxykxb+r6Qv2uu7MaitLhTsBhKVF69ZWw74vXHXaRZ55q09r6KT93LwZoS2NAvWsUwW1rlVTk5efoJtP0ZWuFXS/oxfD6F50lBwMOMf4Cs5q875bWrH+NCw6N4XweNjAY3Xdht03HU+2cPNJDRixVv3ZbVy+9rxmL9inabPw/IKYHT1mhfr0maERI+epR9dhqhJfXYWLlVVODpmX4lKvA5YpSBNjElwqXD16BsCaoEWjp7K02sUBqysMfNs0oxya/hGx7GZhJrAsFRqwEhnnREM32GJFJrDqx9VzGzueoTRy5RCYeLweTKOVGsrvAbLq/rUUz728QEzoF68+hLHGNZ1lp+7Cdb65pINZHDj/gW3RCTNWs3VymZT3BcueiN8gNC/d/1zfvrVa5jtevEdM5h9qzdYjzv3EmPafsFOxEY0NXI9dRO8O030ckK3YfFR9hy9Q/YbD3Tds//F7cDhM620YC1lp8hADl61j2TKpAdIAYh+78uAZRTspkY+fukqrjiZ9B43EfnbrLrF3ePurn13UM43TBeZ89hg/dQaNl31dA9X+M2ibbhLtmMvZqMRmcQauTbvvaCIv3tYD1zST6GBkpAFrLeYgu2HFdyJVsQi2dONpD7A2ndYcADhg8Do1bDpaG1vE6s3ASupXxVfJTYerXYe+2tm8nH7u66d5bRIosg9BaN5xKXUXKXfFxguatfgURwUYNO+/o63bz2nThhM6yFb1cojj0W27a1r3vlo/dpw2jBquHWOH6MgUPFNnj9XleRN0adE4nV00XjtnjVC5spwAzv2ZYoLM0Q/mvWDRYi4VLhk/Q2vHztLCoRO1dNwMDW/b478By6KVpcKmWBlldoUGnExg2Ua0KR0ygVWL7rEqHWFqWDrgIloxjLa3Nlc0Hqx6SD1uJKax4p+i2s168JNCx8Pt6duPX+jKjeuoJY8Aro1Epd80ae56QEFkAFhPf/yBrRW8EG490ne//8wA92ddoCa7eB+uZ/85nbh4w41xzNSDBs8tBVy4bQrIh7rISpWNfWYt3anGzUaqS8/pSGfOOjLQ1tqtkLVUZCCwQvshbLylsbOQsAaQE1eQLaM6sAVUuzdjo5FdRy0CUBsRaS5jy3jx7jcOwMchcU0cdxpNkz1m0GEEqNVUxlPZ7xuwNsMXWUrcsOOORk7ayID5vItYyzacpJh/QKqCvDxH52iLDNRDCxhCWxSxQnrW3GNq12mhmradrcVd6+nl8LJa26AiJiL7NW0tGq46wXozOkAH21TW6IGLIYuPabv9INGBWkqcNve4Vq+7qX2k2x0r12jNlCnaNmOW1k+crMOzB+np/mV6fm4ztuFsWtnGuT3YdMpOzjzhxN7nx/UTC8kVETTkKlBAXj5Ik/3gHGxWmBKfrKUTZmrduNl/AGtYm+6w5G24eo7gL72VoxsMVPbYzUKrsSxaVSPtZQIrFubd5oaWBq2Ab5yIpylOgdWceUhNp8ky0CWQAt0TluEiWnAYdxC7TtBRwryLSl89BViPtZQwP2HOKszJvtGEBRt0DkL04r0naMW/c/bSRjP8SKJ8CvF0+REp7MEDN9o5dPKymLrAtCNVYcX5O+yJ7uDUYsC7hEmYTe+XYzc0bOQa1cjooamzNztWeT0cz54TOAwz7tiPaYcRrHe+/kXXqIdMLXmMP2dR5gg+D3dRWtoFB7NgPAbHdIDuztr1wwDg/G2LUGiX8EG3z7eVeUuxlmr3YoRmHJUx3Meu3Gf2dssBa9eRuwCcupK6Zi16J6ux5jET3IGm3IC1j7S76+wduKwrmrP0kFZvxJ1m6RlNmrJX9RoP5lrXUq6OtdfbSaE60ri0ls1apo1nnmp0s7b6bkyEHvT20dy2eJ+NPaTRU7ZqPf9ea4AWrTijaVOYvc5YhLKlqWa0SdWsZlW0vkdjXd3KTSD8McxYxXzqf398Qr+hxn3D5Q+7Rf3KTg+z4f7zjQPy8q6s3HnzqJIXspmQkCAVLVnC8VhLxnMGY8I0rRwzUcvGTGcjup961G2j7vU6Ok8Hmxd2gdPqVrsV7zfxKEIDqzhgGX9lN3jMJz6TyzLQNUxopBohNQFXDQcsW7KwJzmQ7R6eDEAVF95QfhG4CI6cq5O8KHZ80ZzxLt5B94OAbIw5qzziaOXyXUSQp7xoTynMEfXzop3GrudHHPh+4pqVWfycxcLRXqwt+7jKxWQwU+FpIDOvhOu46F37wuqfx2if+GleuEu1G/WhgxpJWjmv7RSuNuaxVLX3/F3qmZtElkd68O1bT23EgNa2VGxYa/TFF3BaRiMcPvfAfZ5RBhv2nQZEVtRDgCJ1sY/ZYuzJa3itM4MzQFk9ZcWyKQysGN9M6rFfr6EGGjJmI/5YF+HcthFVD8NyX+Nz8Lni77CNmHU7r2JAgkx57SkoGeqrIetUq2YPzVh+TJMHDNLzif661aW05k8ZpMXb7mlQp7E63J2tndmpOtmuuCb2ma0mg7aoQ+dpbIOf0tq58zR/SG8dXzVH353bqedsju9bNEWjakTpAOt197dgtouT86+A6c1TDlNx/8fsxe1m5Es778IS8s8sx1j2y5k7hypbVxgQ4OeAZUealk2coQ0Tp2vF6AmI9GegJB2knvXaqkf9Tmqf0dYBq3Pt1ihLW7volYrWyoBlEcfAZNGqCiv3wcXCHElqwGrAlTAzwrX37fMygWW/bwut6XiZRlFrJWd00tQFm3QaFtpqoXvo3i+x0r5x5zk4kg3O4W7+mr2uSDcvJgPWcdSWxy/e1Q+vf9MvrCw/oGC/cO8+tY2xyEcZneB4DKBMq/4Cobqd/biDHeOdr01C8zViNtpt3F16D56h2KRWGjR0ibbvYmSx4YxntEG9ZSnLOKXLD+DOkLdYV2k+ClaPGf+z+/hVt5hwDnNbK+ANXDZENk2Vgcu6vt3M+awxMHMOS3+uIAeUphKw4bK9NWLU6qy12y5r0Kj11JoI+mZt1rjp21xxbxqy/dRm247d1fxVxzR/xXFHlUyadVBtWk9Wi9ZjIFHvakr/CfpmWKi+GxCmqV1bqFffORo44TgOQq31dHSsno+P0O6ONTUBQ5EuTdppzXSWMg6uxUueW0Pfs4pn3vI/sY6HG8/JtdM1qUWGjs4erecXSIMYu/xM+rPzLMK95wVAe82+gp1U/vHaQVWqVImb0DkhSL30F39/X8djVU2s4iLWpskzHbDWTp6jKT2GqVf9dvg5dFYHFitst7BTRisHtg7pLamPjHX3AMv4q8gyGOTS6TlO690c0c7PpXEexdKiRbZMYNnbWK8Uai8K93jkz73H8ZN5RifQAx0xYJH6rmKYugMzsomzt2j93n3QDseQlVC/IDd5hmH+GSKTpSSLWC/YvDFPc+OyzrO2tXb7Yefxaf97SQFvtdaPmC18/uP3eoTNo1kU3SBy7SfVrd5+XDXrdVVcYmsUpofw7rwEuM66GZnVXKaPstR1/ckvDlS2RGDAsgLb5CRWwFuBf/j8bVdDHb1ISw/J6NGIf+Fqqm2HKe6JVJnAsq+7hT9vkdEGwMZd2a+t3R84kkOaAGs87jJT5u4jmnmAtZtZ4qZDNzWdNGiM+NxFJzRqxHrVqtoXNQcE5smnmjRghu72Dka+UV1Dq1dS27bjNWbeBTWo3VsT4nLp98V19OOoEJ3tx/bOPZaGOVCgn3h+uK7fDFh4x7+0XU93SOGuDswZo8V9uG29eb7nJAsGK3YA6/VtDmHZvel3wPqBO5IGLItY3r4U70FBAUylS7/jscZr67TZWjV2otZPm6PpvYc7YPVq2OUPYHUEUPaxTkSumvBRyQFwVoDG+Ctj3dPC6jpgOZIUGqIO9w3rQk1YzVUt1JMKLSXaUDquIv6lcFwNmw7Q0KlLHR1w6DRR6NptLA/xzPySCAG7PmMRtcbqzSxsnkMeY8BikfQ1C5Ts3B08dx1a4aWTwpj1zo0nT9h2+dylwtNXOciUCSzqLKu3nkGaWn32BQ7ID7+ly4No3XX8PCayOxUZxxk9SNOVay84fmvb7tvwX5Z6zmMVdBSG/iu0SdAVNpg1qS6RZuMueCd+7xQ11MNvXzufK1MG2LNx30VXTxmYDJgWxfZDa9hjac+AZB/fdeweywkX3de1r9d/+Bpqy/MaM3ktZO4BJ0/ZzdfZSve5ZMtZfNwPIvU578jLurV6qiU0w5rd57T74pfqy9rexS5+0pKqWtCwlJKqtOeCW10NZLtpct0InRkaI+3vqV/mpOn1ueX4T7zzXv2WH0LMUt7ip/HHcVL2EC5wjmVogypahMjyxR0OjxqQAJZd2bBbi6+5FCscqZ/fOKxKlZkB585OrYWCNBCZsE2ljW6YOWQkbeN8ji5N0obpszR7wJ/A6shihfk3dEgjvAIsY+PTImr+ASyjGQIKBysjor4DWKwXBiEAzqwnG3AuxUWsd8CqFgynBe0QVSGRWWJt9Rs6X5MXbyDdkE7O3NA51rYfcs3KUtaBUxi7rjqsyfNXOyPYh9jpWH30A+c8rqG+3H+G9TGLWKQ6Gxzfw+vqPMa0+5Gg7DqMiwzQMruhX4lWdl/mJxxdv2bT+mtMZJ8yPjIi9SRHiXYyH5swbY3CY1hx6zgRn9CD+FKdcAW1MdDWha3cfIaVMfRSjDYsWhmwtu6HC9p0FtPaI6TwpwD7Z2fxs/sY7TyAMbDsR8Nkj/0ZS7H2fiYwNzFc3n74LsC67NSY67ZfUR+4tSWMS4aPW0EBv58/hzsfbn9bYMMnLdjNWIpzcUtOOWa9aq3ubkC8GyJ1E8sO6ZE10LoH6vWKOjrRLRifrPY6s5+1Oi5gvDm5Qzuptb49OZ2TfEv0ZAYdJCYpr394pjdE+8yLbe7ci9lyml3544vo35rAM9bWV6e2euzW8Zg1YFkBb6Z2dtLlvwHLNO92xd62dCb1HaQ9zOc2Tp3igLVo+BgG0e1dxMoEVjtqK0uF1inWiYGTehex4hD4+eT3d8CylGgLrJYizYm5CYc0LWVa1LKu0JSkRjlE4gKYkNLCkaDLGBRb8X34LFwT8z0D1oNnFOikxRVwNWOmr9TRKzcBli0gPNGPRCk7hL37xAU37rENGugqyFBGJ/ceuE5t3Q6cZtigsahlb21dy8xqf/jVDhA9d49Fri+xhLwAsbqdSf8Mli2qpXXC7Xgeo4ztWDxeZB3/Ad7tJ6h3kFAjajtx6VtHMG7YfdGZx27fd5vfP6PxM7Y6odxVFJnG5O8++sB1iRshfPceR98ESO3XlmLt/e0HYdptbsdA2ZQFtpRgMpRe/enuSHWDRy9CzHcEcN5228aLNpymWN/HEYLj6tJ9ljLSewM0Go6j1HJ3f6ErnK3WSSl6ODhJv2/toC9HV9FTFLrkO27ukO6e3NLlWe11e2lL/f6cJeH1nfRgRU84GayaXv6ERMk8Yc2eHMNfLKbeYnlgfq2Hl0zSwl4tdXz5JHf/+6Udv3p3eNQBi5rrh2v7YdwrKEfenPL2o3jPXKaIDInQiM49tG/BIm2dOUMbZ86kgJ+kvo06qnejrg5YVmO1hSS1TrFHw45qQJrLBFaCV7K88vgoPbweKS5Rpii1mioDF+YWHNO0AXQmsKoArCT4rFj08B16IdNhfXwP/uePn8H9IBu+/Dk+oNw1ti7u7A3GDHzTx0xfzdbIbT1Cn3Xj6RP9RM10l9HJzhNnHUBsUdn2/340Fh5gXrj5pauzvsMtJdN7wXPeg+VRrjLYXqE57f2IHdGXPwEyFhdu8ud2Hj5DlFiv+s37qWO3Kdgx7sD84p427cCYY95eTZi5A8tHajPM+Y0isA7SRkLb9txxBfXoKRsdYM5c/9YtGlh0szrMwGVgMlmKgdI+x37ParFNe+kkmc85YNGZ9uy3BGCdVl+uyJtKdNdRfkiImgaqmfOOuGlBtWR+4LtNdB3hoAHTANooDe8+RA85WPUV289vz0/UD4tb68GmcYDmB+ct9uq7R9zq2aprwyMxpCP6nJ2jR2NYw3+I8yKu0eYH6w412O0gDPHctVysNJ8c364BNaO1eUIfZ3AnLpo5z7F3J2XsJuOfwMruAZalwkLFiivYL0j9W7fV3vkLtXPuLG2aBVk6eZobRBuwOtXt4FJhJrB6NuqkRhzGzASWse4Vc1VWrdA6joEPKhEOs45tJNLkVjWQ2dhxAn6dwqZOCtxVio13Iutp/uqjWrjhOOThPTaEISCvIy1m5f3LN8+didnFO6QThqPjZ23QBS49PP7pe/zKv0BG89bd1tvNSY9vX+DNbpp2s5Vmx/kend+Vu985Cc3dh0/cCrxz6wNYtsn8kqVAK+S/t+iFPh1HH/c1LPKZD9SZa4xQNp9AXjNJ9ZsN1pRZu9AxQVJuQRgIeTkLRcSBU49dF7cFbdRmBsfbEb7t2HdPs4kmwyds1JptOCpfppZCN7UOOcryjWdctPKkVv4M7xvANu696gp2e4ysXL7utLr3WYTG6aR6DJjuRiwGKlucmDRrvzp1nafgwMauk06r0lxjuvfRziWTdXLHBj2/xCHNs8v0zYL6FJyH9evB+bq9diT/wcwgaFp+/w3v10f3dXFEql7tHIxZ3VbdHZ2qBwdWE7VY/zbTYHz1f313D1HPnnjMf7+4pgUIM7dO6qfn+Jy9hBy1czKWDu3ou0Wsn/BAq8CV+6x5sqqSt61/VQ5UcS5j2op9i9pNtWMe5vTzZ8G80iHOmqbBsOH9GnfzWBpVbwG4mql7gy48nbha0cTNCh35yeHx8lkryGQyqejbg4qGu3FNTVKeqSLqxFCPmcVRcB1VCa+DFr6WWmH5bZyQeZQbDXD/2x8cD2Xg+YrL7BadbExjpq/jZ61xw+TPf0R58M1XAIvITmd34PRZPWUn3or3F6CGbSxXxF+5z4ji+BlYcQxHzC0Gvftbindbi3d+DPAQBqxvKeYNZEaiuvEPj80Xn3zLetbdO5oKoBu06AvHNp+V9rtaueKSRo/dpsVrYMQZ4RhA1uPmYlyTqSo372HIvfKkRozaoKVLT1NwW/2GtwHLBivWnSB1XnEd4np8qzZTqK/fxriGaGgacmPgpy3cr76DVmjKjL14Xy1B1PeIdHdU3fotorPr6dwUJ3bvoZPr5mKashMw4Kn6imsdL6mHsHd6yU7mL4szMBLmGPrxWXq2eLCTIr19QWGOh+tv1JdP1kzW49FhenVyop5NjNWNNdgQvPyZA+U/OLt0YXrnvF7tyKfdL8IUeN145oztGuvapjkQpniO3d7j7lm7eoubPz/ij+HFwfHsbOk4PZa/T7CKliiosLAINcEfa8ucOUSt6dpBxNo6d6aGt+6FlqebI0kNWC2ol7rV70wq7Cyrt6zzywRWhRwVsC2qqjRSnQErBdvIWrxvFt71OFNn79sIJzk8Q/ExdbQI17ljEIab9x1ytc6jb38kQj1w739rshfeWqG+CyHaFDTrt+CwnrIUYd2cuRs//fEniEp814lwBh6LRAasn+Ct7n75zJ0C2X6A4wHvgGVnJDL9FgxYz9/Y8STToHueTIC5URCP3Uq2QfZZoumAUVPUqddEx1IvWn4Rn6odSIMZ4ZCmth9kkXTrBac4MHnvdoa7q9af0eRpWzUOBYCRnjbwtTpsoc3lNpEGmcutQlWwAcfj1axSbcANZiugHD52LeLDnUim96hHvw1sO89Sw7TO6kP5sXPCOH13HLsArnLoR04G/0YHhxHvazvSaWfw7BTLobX6eU4NfuqwIt8/Vt9gUyAubbyEl7IrH+RFPcdy4Hofb71d11pfj0vS/ont+eZhHWW+Gb99wYk6u79IlwiozOlauAFtmTpA0zo01sXl07nRDUH6EL9Xs0F354m5u8h97kqc782WixqLme9fAnxDVIzrX1FRMWpQvQFRapYOLJql3XNnY784S2M7DtCg5j0cl2XAsqOYXep25ORcJ0R/Ld2qvW05V/GvKu+83opG3VA3uoEjSRN9PTNC89Nqyslfi15V4bniKOCbNe/JkBlvdXTmh86SzgjX5iZ87eHnHMV+ru8hPa1ru/oYQpGxw3SKapP12sHsz+liTO3w1XMUmOcuOVNZZ6JGqjNwGctuRqymdDDTf4tgtqFjwDLC1NbjLboZM2+Ryuoti1zfmcMxjwHsFz7f/o5ffn/J1yYSUqkdPXOJdTLW9Icv1NgJ6zWG0ctSItfeI1aY33cpztahrKjfytDYPKOWLTmjYcNW0BTsduBajD586qKjjqcyOmML/JV9nhmXrdp8SS3aTlf7tlOVntpW6dw0GsMuwAFei+d4q9roRM/OOVCZR70oss1B+u2vXOv4zdyln+nZ4bX6cmocVlGL9cPOnnqwrAffF1xz3A1Gu6+I0cnjWzrdNZAFizitblRO55eP5Zv3o17gC2sWnu7YpnnDcoDT7ia+/P60TnDgfWzDmtoyd7SnE7xhp5E99yAzI5YV738AKzggXCXLFFV0TJxqJNTUyimTdWjpXO2ZP1u7l3hI0oHNuro6q3Uq1+yTm6hjBtxW486oS1u7mzpV/OGyAFZAkUDHYTVKaOoI0+iKCRTpaQ5YljZrEMFSAhlAR6Vz7mOda8237j8Nw36fYhyfKkR5tz7/iuNGP6NmQDtOt3YDQ/+9J6+TIjY7PboV6l9xUs1e9Ge//EzXyP7dEy5XWFTKZNl5a7NB+1obd3MUgAsQVoNZtLLbN1bNOwDSAPyCJdFPXGu3x6KWAcy+rvFd9hi5+spqFKD1CorDQHaLeeT69ds1acwM9RkyW1PnbnHudpmFuQHMpTr04et3nXEpcCKzuX5Dlrh9QJMFWcqbu5Dh76Y7nEi55X6/FWdmqkSlqmP9+lo4rDdWYmtx5jHfVsDEWeDXMOIGEHOWtjvQr3+2lEW16W5D44BIBP/15DY9gwDVgUH6bUk93Vvdj/9cM0X9Rr/Z8U/4Qf6wjg7J0NYmZXRpNedh7KAm6U9mHGw3IXGifsXh0d84/PDK/u6vj+nYpD7cKWqp/RxL15PTfx7JIhXaJTZLhRUqlXep0EWskKBwla1Q0gErJiRRc0YM15GVC7R7wUztXU5XMmCkE/z1oc7KBFbbmq3Uuwl1Vn24rHCKcT+c/Ki1QkqHy7uQnxokNnW+70aa2nq9HSg3YGWQAhMhRJsA1FNXTBv1NQqFC65I/4UX7j5jFvOrshfUSE/r1Gz0su/UDRQOm53s14pse+ylNgCcvnaL/bwHDlgWiTwsO/p0opel1t3YbB+/gHufAc/sj/kcC17uc0l1FrkMXNYpPn9JQW/dIj/V9m+wiPj19885T4sDMn/n95zI/YkXxWKYfb1vcQ1Zg3FsF1b1O/QYj+DukEt7RnK6Tg/R3nqWGlZT4JuefBG/P2LEAg0cOFdjJ2/VqOkHUcUeUYc2E9Webah5A7pxJ3qe58gn6UX44r/mmr273vrLU+prDx1gIHiLY/RL/FlfY6dpqdAszV8BrO9P7dKlLl7Sxm76elpN3dvG2j22kO5ukPm5Qin8wud/eXiFnuxfSgQj0r3gZB6HNd9+RRcIsN4+ueCsPO084GvzL3twQA/nTlAfPDKOYdTy+30Kd25c2wW292uschVYsScVWq31l6CAUJWvVFoxCYkKC4jROLZlTqxdor1YC+1dOlNLRk7QwOZd1LdJd8/twpTm0A7NXcTq2RAuK7r2O2ClKLxclCoX9FVGdH0nU7b5oQNWQh1Xj6WxYh/PM23eSmeUeoyzHEdhzi0KGVQMWPcw2TfT/edEsG9/Y7D8zTNnnj9z6VbObJAiuXnzIxIaA9b3mGmaFOY8+nc7O+L4KlKbRSPr9J5hpWhqze2HYIkzI5Z9ngdfLj1aTWaf/yugy6QhDFzfANovfmD8g9H/fayoL3/+ue7D2FvDcIE1s9nLt7NONk09Udp2GzhZdbELmjF/DxLeA277Z8kaUtvWq2y5ICvmrQFrNYLC7dASE0atUS3GWO0boB5p2leLx07QF0Y+PjIjOoph82blNIxd8XjJgYM3v2JDDgvuLMhff+9uFXqOKHyD0+BX7nP0M0X2a9QWXGzd07wo0aqRHoyJxG5zledmNDWT3V4U54VfG8B+sTPDP/BHcDC0u9Z2YY0o5bzwTbFgrPrVffr9MiDCefHaggWqVKiQVo7tCvhIf1eP6lc4LTvmnpkKS5ctpSzcK7Ra6y/+vkEuYsUlVVGAb4R6tWql4+uX6sDSOdqzFJ3S5FmcP+nKNbAe7tpqiyqeOstqrN6NO6BewH+BiJXkn6zw8tGqVMDnHc1Q2zPaoUs0GXN7GPtasXXVvEUv1Ad3WTD4FsH+Rfci2RD5p7e0+t98jY78Oy5CUGACLAPGHUjSA2duae7Knc6r6UfqBSu6DSg/4pNtxb2NbsyJz8BiLLtFoZ+JWHYC7ibWiJv3HSHywCzz+x4vd495mnuX/zNw2WORLrM7NI7LItbn2IFfhwa5C4i/YDPn4JGz6tN7tLr2Jw1O3sTO4hr1HrVQtbjtOHT0WqcNnzp7P0a5m5G/rNPoSWs0ZuJGTZl+gHR3UI2ajOZ6bWttmjpR31Nof0FN9Oau+bFex036irunLaLTy+8BCzZLL17hgf/i3TWO5wCEGvN3vO/1Cw8HOz1W5d97DnlyCvm7I2t0slso/FRVXezjp58ecLCBiGSO1K8dGB+REu0aCDSMeec/Iw1+S/r7HGaeE8e/MZp5hZXnK45c/X5xl3O7/u3cHhYq1iu6eTetmTcVIDEnxEP2JQPp/yOwfL393NWmqPgkeVUIVIu0NB3C8vrQ8nnau4zOkBGP6bIGterl7kO3rNpSTRksG0FqwGqawvkTgJXol/QHsJKQLNeLaeiAZfd10sNrOsqhAcX/lFmr9JANl3N3H1H0nnNLC1a5PCcZPoIgffId92tIZ3azz2moANbBs7fZWNmjb8y5xc7nvuXELKCwuujq4y+4anrV3TjOBNYvaN1/NpMOPoe5MeqE47oDn2W/b9HK3rEi3v3awPjusa9pnWAmx2WR8xm1zJcvcd4DZIu4CjZ6IGdG6NCmAKjRC3egEdulOq2Gq3XXGRoycj0XUTdoJKAaM2mTRkxch2Z/m9tiad0OOwGOik7tM0AP93Pi2Nr0O/t4QbEI57CBuPfs7jkCnN9wiv4dT/tXLwGXGT3w3/3WuDo6N0uB7qgVddZLowTwbHXXO7i08SNR9uXP37kLtD8zwnlOsW+p8xWAe/ULxb4V+j9wZYNI/NYug3wFFfPNJb25Tx13E9+HK1wQOb9Hb7ju8du5Hdh6AqyLW/R4/0ZNwldiE03lqIVYb14jSt05oV/vc8X2XY31E+f9ypTD551U6CKWtxfAKknxHh+nyv7BTMqratuCyWhzZlGozabOmoXZ7SAsg/rj2W73oVupUXJzdUUA2L8JBT3OM0nIZ+LKJ7mhcqlCvgouF66mcQ0UWjJM0b6cm4OBb1WtlTp1HKgTEKD3KMLPXLVtWzzXqRFs6PIbYHryA/t2EHmWloxJt1T4iBUuO1C0dPMefc3FB4tENr4xXspOy96GpbfO0Pb6XJ1l5v5EPCvEjeuytTE7FGkHkt7ZiIKml9RZlOGZqAKo9j83/qG2e8HzK/+mF8wVDZzHUY72HTZdy0aO1osDS7Wwc7oG9ST1rTmrTkMXq0mjHhrQsjckcjv1odYayein75jV0AXz1LdVX43sgrR32iQ9Or7NCeZ+/wL35i+4bP8dp1rcyTwYbzucYEcTfiPVYejrHsYsdtzcaqo/L6N5jlf9cY3WzsVY0f3eSWQ7D+MeQOhO9/1xr4io5qzPb9MQXObsHzXUPVId947eAKrfLm3n/W1Eq6369RK26WehFM5T227mxB0Eb69Lv0IA70LUt9LdKNJN1A44YNtQ+gcT+pWvoKxsQpdF7u4c/YoX45ZOXKwiE1NUv3YdrZoyUmc3LtauRdO0f6WpHLDnBli90GW1qNpajZnvdUQ+Y8CydfsqyGfiK6AG9aqi8sX85V8qWE0TG7F9E0tBH6pajG+aEv7nLlmju2ZIz4rUIa6WHrt806U1e30NWAYqoxjc5QfAYxs2pm03YC3fuk/fvXrhUp5j0gGWHaK8y/rX0Qs2DrLbop7O7yWiP6uTvrfaCdjefMIK1YFTzlHPQPz7W2OpPNbadnrCWHn7R9ibn1znaBT+C33D76/eul1DegzSMUjjt/txfT64TrcWTlDnWqkaP2a+utSsrpaB3hoSH8jhgupaM6SPNk2ZpM2QywcWw3yf2IlvL6nuGZfHnpGWuPvjXlxO776habHIY4ByAPqNItsKbTvICbAcG/4OVB5g/Suo/ts12vcv07573xQLdsrPnfOzw1R2nfaLSx6hHlc7XlziFM25XQ5Yv1j6O79bby8CLizMdQXt1dkten5gvVpz9CmyZprOryZiXdjA5xPNMLN7Y13rw6P69vIOlS9VXJ/lzI5EGWBVrOilEsW5sAqwAjkiEB8bp7G9uujcpmXaj2n/oTXztHgEM6kWfSBKezD3a8nKu7n7NXfEqakcqiGfMZFfYuWqqlwiSJWL+6se9VQ17kUHFw2G68pgPWgAHk9X9Lkd2GbHbvv+U45KMH7I/vcbEcYIUaMarNbJBJZFsYOoMFfvPOQGz8ZRGbDMN8aKbRtUnyAV3kSWnEkpvAKs1tmZcZnREt/yxbYfPOVu3tjf9oaaznFa9nX4YvYxS4Pv8OW+zl0MO6ZPmatNE8fomx3LMTTjkgXAen5okd4c38opm8bqi+PNyDox2jiomW6tHKEXp9jitktjpqp8itbpSwDFJQwTyOkZ6Q7K4Pcf6WCJIEYX2IEEBx57SLcQSR5wMYC3eZ2b2f1xedYDqsyzxpkR6/2PZUYni1BvODpqj9Vsrm77jtEMB+DfoAR9TZSxQ+yW6l5dPaSXgOd3i1Ym5jtnkch+b7vOLMDzv3GqhmfUUn/ECKMHTdZaasO3F4hueJr9dANLKbs4cu+Qvr20Vb7ly+jjrB/h845VZIUKFbgJXUiR0VEq5+On8IgoDezY0XWGR1fP0aG1c7Qeq6BhhPohLfuoZWoL1ArNKeKbOWD1pNaqiXzGFigsYvmWCJZXCX+lkB7rIfDzzx+gJOZaMxeu0wO6mUfwLSZ32bTrODzVT+7FtP/9+q5YNqLUXmQDlkuFjHWsxtq47zid42tXZDvvdV5+owncbI8D4BducWTz3dd6w0aPFfZfsEBhdZKB68zN+0ieufDl0mWmnbbnD9i/4Zd3ALc3m/Yc0xi64etrFuvFydV6c2KTXp3YqBdnNnJgc5Pe4J96eEJXrrlGwRMRyc7v4BvMTzgW41aIv7qPtIT65vU3AOobxiJfQRkQLd48p/v6hQ6PLu/3F3R2r78lK5NsMwH2K4W5AerdQVCTrvynKOUp1N89746wuwtqHLtytZPdeISzsr/Trtva4c83X/DfzlFSGxy/JBq9vswhB45YvT4PqBgNPb+wyeNmDbCuzp+qgdUY8YUW1fw2SVrWrYWalUnSygnUj32n6tSCSXp9hHuUHMUSs0Nd3wdvu0VeKJE/y2oepCWIWLClRQoVViTMe+WQUIVGxapVvUbauWC2jgOqg2tmauf8eU7/Pqw1x8fZiDZgNU1qygyxi3tsK9rcZkzzHlgiRD4Y2AZXilALukevXL6qhwzl1PUH+krc6KPIPHYBvfeB047VdmCwlPWuxbd0ZxHL/Dy/pwi3uaEBaytX3Z2G3TKVSWSAg9Vitl9ocmTrDD2Vko1tYNThpAxYdg6NOOBuyGw/dIyhs6XBd5wWb5kc/nH56zkgnLFwhWaNHoft4mb9TgH7ilvTL/gG/oxC0l6Qt9eYz93YqTtbZmlKCzRKG+Zitcw9H14ox+lwe9puI9qpYKuh3tolV8d4G/f0nV7bPI4RixsMU5BbUf77r5CcfPwtXZ7r+Oy8np3Se3cgNDM6/QEmuCgnxuOxqGQXay3VGZjsXrYdeH9LyrNbjnrqAZQx5DaCsQjz6tIOvbmwnWerfrkOzXEd+uDsAZ3hikW/+gmqV8lfLSuF6dwc5sbr12j6oNHq691IJ7ov0MQa2Etl1NRofOSX92mjy0hqXl/Yy72kvfLGSchdpjAPUgNWSbZ0jCD1DQ9Ted8ANmfiCXlTdWbjPIA1XfuXLXQMvAGrA4sUTau1AFhwWfU7aGDTLoxrGim4dKSHFC0TKX/vSFWuEKJWyU3lXzxUo0bO1lO7gPUGYP30LYNVRHHIY4DJHxTAS4Bg0eX7157rWr8grvqWjz1haGrA2nGU+zaWvt51dAYs6+AeIDO+9gTzsivXXATzUOtGepphh/mpf8ffDeHKR49c4kwI0mVHM9invQOi1Vm/UPxPYatl9sRJen6Sru3CFv3KN0zXiT7UI2+fUpt8fUe/MM1/wXT/uyNbtImNlscUtuKSq7HPv9KG/4rozY6av6GF//05LzQE5CvOD780UhMQifrP6jfhIS8mC1ZLZYIqM+29f2z9X6LTOzC5M3zuHB/SlvcA9fs3lu74d8KDGR9l3aEpD36/92fqe3Fum94QYa1gF2CwQ+0XoZbMXbp/zUgtwIF6UQpS5CUntWz7SSXP2K0pLJjcRqC4tuU4nRrEUHvfDj3YON05Ko5Kj9e4hsm4bTdX6QJF2CvMq5KlSIXlK5cDWKXcrLByWIhKch01xCdSs4YM02l+Gg+unaojaxa5JdbhbfqrW6N2nPeFckhsSZfYWkObdaPeaqmwinEKLxWluApx8qscIR+fCDWAaU9n//AAGidLNd/zk2rD4YWbdrGKRTFKysrklgxYxh39RCXtUYNyjs2iDid0DVh7sNDOrMfcdQhLhRTwJvy79eVXdH7X9B0vVCawjFU35t6uL9g6/lMi4T2K5XPou6xGczwW/+cB2FvH08xil/LnE6S0i5v1AhnI2weX9Oor5nJWD31LiiGtvb53Ta9v0W5f26X9o7vpmz0U9FfsuiuSXbosq2PcvWlTCaDEePPL9576yQBFV+veh+RFj+LpAg1wf9zCfq84f5fqXMf3XoTKTHceQNEEfAt4+fssQtlJYru/LY6w/86FM1N4vrVj66Sr15d3cYCdaOvARDo8t1tf7l2jmR3qaVDVCO0c3F1fUUu+3rlWpzsP1D1Uq7MfvdCSi+ZFwayV7988Rlgvr3m6Rt2AjqCu+ungBt1ZPwszmfYqx37qZ9mzMdox7wa/SipetIRiY+PlFYqEppKPyhbzUe+mLXRu8zwdWjdNxzcs0gq+6AgK8N7NO6s5fEzTROgD0uKw5t3VKb2don2SHdOe5BWvypVC5R8Yq+reyXiDTtVXGI69AgjfwZyb2de8TTuFU6Hlo38BlqMIAISlNOv+HLD4iTZg7WM0kwksC0oGLKMEHsOKG3AMWF8BMkuD9rvGqluNZryYLU3c4YD4d3zMxj8/4Kpn/3NnS/hiJ7BiHDlwjL49zk8xhamuHeVFAVSkmdcIDu0Ip8l2X35FNPiKEccNRi5XDtEpjkNBssKlGJPnvmGu9uaHa/BL9z1HOn8iCVOIv/84OgEG/fVLz5N5OdZz5DPzsdENzcj/BVRvUXgauZmZ9jLrqN9JxU4yTGS1q2evr9thLIp0Up8AF+c/9OORjdo6qpd6JIdqFZbmzzfS6R1coR9OruH3OdJ+eD3N7xZ1x+RtMd5ZK5BL77/AHieduW5Rm7Gw+ustUj77hbpCjUVn+D0RvmJJgJUji8pVKA3dwMCwOF1hdHS0vIMiVMo3TOW8g1UvtZb2L16kU2vnswY0X1tmT9PYTgPVr0lf5n6t3DDaqIchLbqrGyLA+IAqiPsiVaVSivzKhig4PEk+pMNN27m8BRDs4ujTn37GI+A8ywvwJwafd+nIEuLPHJi0Ls/VV2DDHkuHNrM7cJ6dOs6+eaKbhyZwpCa0gElnLGqdv3uXixOeYbRLdfy/yZAfMfG/8wwnGkYyD2Dfre56CkFoXJUDIP8/e95yZnTL+CZt5iIrtdRjCl5qnjeQisYvuQLaZCSkntcw5C9ILcZIP1g3WT8dW81Z4KN6aTeniWhW51iRbmMXVy/9C7CooYxa+A8UguOm3ivK/+jwjPx0qc/IUqImEcp0Ur/bsPhd2nMpDymNpWN70XWHW9g0E0YJiO7u1/Ob3DHStzeO6sisMRpaI05zm6Tr0bLZen1oqd7sXwwRukc/3z3LXUe62ps7dGbHWnWZvFwDYEjaLzmmoeNn69vbZA3I1NcPqdN4++st1A2A6ncA9v35barAAYEcOXLIy46N+wcGcBOas3IREaocFKoy/swOffBhCIvRCqTJZzctpEOco/1L5mpyT076ct3eZobNUhqrcVITivdOGtC4O51huvyKhagaUhmvYgEKj6yihJgaus1ihL3Y3/3GzI29vyUbD7qlU8edvwcsx5b/H4B18AKmqyxN/CdgmazYgGW2Rreffu6ZCb4Dls0NbVnC6rArtr2DaPDhM27XwKV5CHiMPW7jGbVovl6e309NRaqwS/eQsm+ZCwoWOxNYv/MCO07oG1QGHDf//eZ+Pdk6Wz+dXOtOEr/+6qornO3Ffx9YmbRBZtr7V1Blzvz+pBFcd/eO1DTawApzeyztueKctGegsrRnUcqY+7ekYNtKtiOjb28fcOeKjYd6eZF0hepAyIjvbV6gKU1TNaFuoi7MHaPf8MT/GeXo96fWu3N/vwNGO2/sDsM/5mtx23HN8tWKGz5PdTHh27NvLw0JM0w4q7f3iFL3aFTuQvZatKbm/P7idgesnDkZQhuwzIjU3YTmiKRvWKjKsnJfwS9QAV4BGt9roC5wfPL4uhk6tnoBhmyjNardcHVktNO8ShM3JzTDkKFNe8nMP7yQzVTF1c+vWBCHNatqyJBxLlpZvfQV3Z0NjBeu3Y0E2KNwygSWkZ2ZwLLCPTNi2VjG6q5D+DAcOu9Z5Xo/Yr2h6P76Z44eMRi+xX2cG08euU7Rw4x5AGZdplEStvFj45/r+JMaW/8NdpAW+Y5zjeJLVpxen92mF/dPkl6oj/g7heZLUB2ZPJF1aK5gthf2c2oYflqf7VumX6Ae3JwNwDm1JZ/z9mcAgYbc0QWZR9PfHVH/7wy6pwP8g5+invLUUX92e5nkZmbac6CiOH/N6vubu9RRDIJf3z6iF9f2/pH6bCSjW0fYyNmpVQM6UGTH6sjoHnqxb5V+O7hSPx1Z5WolO8L+4gF/1hQLj467r2XbzvqOK2nXDqvP6BGaMX0SM2tqTVe/8T16wno9IHzFvPAtFIv48wascuVLKZsNoQ1YlRnpFCtWQhFRdHLBAfIKDlJEQpKCfOnq6jbXCSSwx9dPp85aoOVjJkM7DEVN2sUBy5Yp2kOQjmjOijozQ5+SwW7F3qiHkIA47Tt83LPvR7f3xQ9IWI6ecwy4mXRYtMgksTKBZV3dvwPL5MOHL91kEZSf0nfAyhwcG7DsirwByy24PmHdnnHO+8AyNamBz5oFWy8zQ5Er+D8cPXXBneDdtMGK2FXomNYgG6E1h2N6ZSkMWsRSk83gXOtvdZZLR6QiZmxix+6nExsYfZBuIEFffwcgiWhuN48/9wew/iA4LaX+yUv9SXT+SS28n/IsQlkd5eGj7jrgvvnaohRUBuK71xTn7oA6L6yRnS9QcJoa4edz1FKcKxaD5BNzR2lk7USt6d1G321DIgMX9+Puhfr1OFH2hkUyM/dAWwVhajWiGy4jl7GVsF+/4Ndfc8D9Piv1D+x9ygOkMvb3vmYF7AUUhoHSgPX7fbrkC9tUlqNYWa14r2BHmrx9VRRgBcBhGbD8o8KUlMrF1Ig4VYuvhTx5ok7SUp/eNE9bZ9OWdhqi/s16u1RoUapZajONRBPeoVYrRjmoGWDfba8wPrYGF9BZOwIMds3zc/bWlqzbgb0Q6cqIKCcx8EQWA9avHKaxaGPAsghnUcsiViawTl6D7Ps3YBlJ+v1vUBIA6wFrX9eR5trsMRNY9umWGu1zTOdl6tQr2B5d45LWroP4K5y7yZhpHd3gBMdAW83yFhbc1AIGqLc2uDUwWBq0Aa7N3FBX6hv4Ib6pv57dDsdFWngGo/2DrUp5Org/gGVjG/tz70Yx/zLj+2Pk4uGrPKD9s45yfJTVbN9Crtq/i7TnJC0shzqik9T38jazPFLyr0QLA5MpEgxQX+1Zrnkd62hK82p6vGSq3pL2fj2wQt/uW6IXzP7eMOf7nVRmYx13he0J9etjHkD1+5cX9ZJLtq9Ie78/PUHKpUhnFOXMPxgF2WMAkykybh37F2CVgRjNki2rB1hm5FCseEmKbSyyg0NVwd9P3mzuVPIGZP6Rmjt0qM5sXapTdA4Hl82Hzxri+CxbqmiU2FB14+u5cU93POGDSlObVUxRRLl49eo1xCk0LRV+jubHnPfmLd/mTPYtWnm6t/87sJ4TUjKBdeYmNcZ/AJZ9jlubt+2dr586dekfEYu/w/4Wx8ITMW8DLjMaucKK/vnrjzRn0Tr1GT7TmYKY1p+L5dRHUAEss77ma775hRfaRap3wOKtrUXZi20t/a+oANylWJQJr9E5eUjNd8CyYtwB653kxUlW3tVS79VR/x6lHH0AH5VJcP5OdDQKIRNQLlUZ0UmUekXUMRrh1SVqQwP45X3aN76vRqRFaseITvr5IF3egbX6bddSLs2u4d8LVUAtZY4xtsX8hh8OPQUcCPt+pQvOpCpe30NT/wUZgpRvW85vH9PxPjbh3wUXsWwjWrYBzSFTV2MxxvoOIrlsmRLKli2bKlU0GyMGhgasoPBoeQXCmgcFqRIXwSr5BsrbPwKlaDsd27BUJzfOdHXW4qFjNar9AKfNaprcQo3iG7ktnv6teirOi0XVIpHuNuEqXPiMADWm+wna7L2kno27YIAdlqy+cvByv/JsKnvSoEWtzIhloMmssc7h454JLHtr4rzMeaENrh9DpFrUMj18pr7doqJ9bQY4Tm16jQLftncu28FJTNRsQbX/yEXq0m2shvYeQmQi/TEM/v17otRP1Fd28DwTWIDGIpcDls3eiCC/IoJ7YWkEeuH1c2qjd2y5i1jvgPV+/ZRZmGeCKbPT+/fCPDNC2ZFQe3HtRTWtlLHnxku9gZDN7PoMWJaWH+3AgojifHqzGvp803zpNKw6DtS/7CVKHVtLc4KygrRly6Y/08kZJfE75Ombx0fRwPO62N9lEcuiGD80YgPaqUcfEiFNwQCgXt5nlxANlq1/WSf8C1dr396kK2QU9C3zxvKlS3jMbe10b2AgQ2hMQYJJfeW9guQDuMxAqzSqh9KshtVj4XTPUigHgHVqw0JtnDJD45DRdKnTCe8rTo/ENcQgpLUGtOuFiS2Wkbn8VR8a4tDJi+6FN4Hd14jSlm3dBV/0yCMRfg1RmFlnvQPWb7CW/wlYxsZb8W6uyP8JWFaXmSDviaVbKIJH38I3Zabad5HRgGYp0gbWpnQwYF28/bnu4Xl1AtvEaaMn69r1OxCn37HUacI4ogxyFusI3VjFUtX3ngLbBsiuzqIz+wVi9CU1irhlbcBy0ckA+H8D1jvq4P1uz2Z6lvb+hZMi7bn5HmknE1TWsRkvlQkqm/UJhcKeyX01qFak9oztzcrXNv1CpHqxf7Ubmv98er0novF5b0ldzszDiFMK9TcsqprE+JVNC4hKAjiibntBgf78kUUyAxLgs+1nAPXqLkqI2/s5qslbUrBRDUa+GtC/5VhWOdQN2bNmQz5DKjRTkGIliis8OkYVffy5kuktL5ZXfQKpudBnBYXG4P8+WhepsU5tnKuti6dqUrfxGti4LwV7I9XHMtLmh8Pb9FUrgFYxh59qw8pv2XLAo2NHsXDnm+8w9ljt3IbtRXfzuXdKO+et4DaUPVdMrbayiPUcbZTt+Jm/qDkhXwVYFntcNjTmHQ7Ling3U0Qc9yU10WNe3MdEFZMue0Do4bMsTP742rwaPmeN/0sOMz3WPZz69jOzXDpllL69Q+1gm8DW3gMKI0YzNU6uEzQ9uQEN4BggHLCe4XKDdY9j5r+nvmJ16i3SXyNS7fFooKyYfzfz+960UIDSxHzvhsQeeuI+X4MayjgpCmRXx1jEMPbcXlRaet2nULZhLy+gzfkMWEYrWJRYwl2h6U1SdXflFCbtm/TzvkX67Qhd32Gi1fH1br5p9IO9+PZnjKeyYtuet+6BDIamyHysGH//MRGg3dN+c2ufG1K/AdjuQX/1CnGfKR2MIP38+GqVr8yF1WwfK4ClCmdjVJRbOsHhESpdwUsly1VyadCA5R0QwhOmTg1b6izXSU9tQkaz3miHqRrRahhq0oYym6JGSYwFWBHrktZelXP7c4+wpsbiZWrp50tUnocuXNbSdYjHwIUnFXrUBZkvfOYleFM0ZFINmcD6mkXKvccvOzB46EzP/6wjtD9nNZxFI1uwsLWxLyFh7bjSOzLLAdjBkc/7lsL8Osuut57+5iwax42dpKdXKULfdXOvTSdljPc7YHkUAx5g2Z6dS4UGLKMVANYvqChfGxjs144m8IDLkzIz53kegvOPwvw9UBmwXpq+/ds7jpd68zkdH7IWVxzzvKWdFzWVG34Dil851G4gMbLzATTQuMZVtBaLoe/3INch9f12cLleHFqhX4+s1qszW/TyzFb3+RblDFhvblnEARx0g5mPi4LvPS7VAhS71/0S1YLptH6Hxvj9CiC67Hlr9dxrhICO0kC/ZXPHH89uVdHyxZUlZ1YXuRywLBWGREQ6YJWuUNlFKr/gcPkGhcknGN/2kFhtnz2DznAKHetCBPUzNa7jWHexonGKx5q7D1s7g5r3Ugj7hMHsFjbGkWbfQZSF4Gf1Ns53HDjmQOCpqzyLo++Cyh+X4A1Yzt6Rt5nA+urFc2diexmvURvjZP7P0qwBy3Tt38Ha2/KDCQNtK/oHXPbsqyP5+0MSY9o9g+V9FAR3uBoxHOvxK9vRWZk/AVHjjSkCXGfn4Y88jwdYFo1eoxN34DJgGfsNGF4/hEcy/soimPFXpjJwf8YjX/E89nVMxvKO4HxHclrae8MGzmuUnKaE+M1SHrWUcWJWoNvjvBGubtNrRki/IW2xtfbXdH3HuJE9NiNOJycO0q+Hka+c2a7n+5dDeK5A3rPe0Qk2aDYQmJrhzygDUKw+u/nfH/dxS7P/9rykIXjLGMioDOs6X9uD699rgGyqjlcXUEpAcTxHr1acLZ3sufOoohXvBqzi6GjCoqLZvfdDpOXjUqGBygDmxXqYv1ewRnXurYs7ZqF4WICMBvlE13FuBaxpMlLl+AbOQnJIy15KqIRKAnFfMrVZe7aoj19kEWLZWl3H08pDMjCfo1uzSOJZ8/P4Kdhg2KTD/x6xniIpMbPaS5j7WzPw78AyrdWPpE3b9LENnm+os0wX/yu7zMgCPVAkuhkQDWwmNV6z+wAGZWwI4/UkNn2NGzLd0u8saxpBaoSkJ21BH9gYxeQp33mAY8Pl358BQNNZ0ZY7ma8Bi3ToiMx3QLJfu/EOv/eHNsqGxUQ61/HBSRlbb3p3R7hSOMuKdPP1JGJ4IgdRw4a+14kKdGAviA4bh3TUtKbVWZNnvneCKHV0HYBapdekPQPVb2zpvKZQf3WBoTNRxSKOsfD2GMicbOa9J/Nj7uNOp+XpMjOfN0SpFwDoOXqrX6A1XhI1X8BZ/UYaNunNzwzsbQb5y6GN2GGVUZYsNoQGWMHBgS5iRcXFyx//hoo+AX+kQkuJ5WDiAwKiVDcpQ0fWzWQwvcgtW8zCknBImz4QpW3UBBlyG/iswa17qw7LqOXzVHIHAwJYB2vQoisGYrPdbt6fNMCfTNP7wMpMhe/XWF+gWNi0+wzHKhmVuEjngZYBxWosS6+2WWOAMs8sc6E5cfm6O+LtGTVb3iSJ8nvGabG7of79BuvGAYatT2CSEeQZ4WiS4bffwEdZBHIRiQgDgJyC4I+Iw/usn7vayB5kNG5u59QMptT0gMjVXJmqA2Pq3wOU/R1GIRgnlSm+sw7NVKc2ODZQWfvuhse80C+Mc4Ll/xbaYGnHxtratx3d3iq9OAqDfswToV4eX+fS34uT65kgbKUDpCMHEC9JUZkAceqG//DY79vH30D0vr1MyuWx9+1xagjb1CEiGVhfmpSIuaM9L1iysOfteSKXbfIc36iKlcoqb05mheVKeYBVCke/2MQkhSBNtihVwdvfvTWQ2XjHBsoRAfFaMHqYLsLgHls/V6smUsR3Gs7mDps61FnNkhppcKv+bOO0VqksJZ1znx9p0YeTcktXgu53cHABJBMdwOP/BCy3vgUgnrDXZ0uh57DA/k/AcksV71SntvHTve9YxcY3VJMGPbV17VHdvMNFCW7aPKYbXL/joLrT0e6ZO8N1OMY627q4zf5MmWAvuL5FfgJPZWnKEZQAKPPxAA7wZJKXFrXcQJgaycDz7nFA4+Nvv7avgceCAfYda+7RSVFHveOHnF7KurR3DLrVQAaqFwgHjfx8y8jmwqrpmt0qXWenDNar/Wv1+ijc1AmAdYbHIhRF+2tGSxZBTJhowHp7dY9+5X0Dx//teWPAYqZo6gd7PALAP5+fz25w0el3Up5Mx2XMfqaWizHYa6Lmgx3ztW32AJXi5EnuXDkUYHSDl1dFbqCUYksnQYFhjHUAlHWGlhLtKV/ZF0Y+Rn5+Uepcv5VObkLxwLbuTjalZ3bDmK1Rd7c40TCuPvcNu7ES1lMVcpRz5muxGKsFQkEcxC3PAs1rxHdOqvJHwPrvwMrksGzh1PRWTxgyL123n0uovNgOlO+CkKU33n9B12gff8JNm9Zthyg8qDZuNukAvqm2TscGaM4yrV66XNNHjFaXhk11dt1KagI4neuEcIpTe1GNz3nL1u9bFAKWFj0DZdIcdZRLXTyOFCXteX5tHydtErE8ZKbn4x5Aejo8DxcFqIzctOcdoEzW4tFK8Xe+IzsNVFYwGydkW9Amc3HkI0WzjWXmtqujW8un6Pfjm/SSXUSLUi+QSP96BjUGRfoL3v5Gu++4Kjq130l/9v5bp8Gii3z3vOVt5vM7gLInE1j2OfZ7TlrDn3dvLZJZwW8dJRHwzVlSIrXUI1yUD80ZqVVDO2twx7pq2yIBkjlUJUoUU07suMvjEPmXMmVK/QGsgFAEenSDBijrDq2QL+9VWSWRqparFKg4nyRtmz9Rp7ejLGU9bFk/dulg4VtVbabGCY0hTTtqaNuhCkU16pPPxw2kQ8Nq6jSrV2693UrpP7Ogp9Z6r8Z6vyu0eaJHb/UTRq57dOQUNcl7fzizKzSa9EuubrVqM1AR4Y3w3GqgVlXSdXzhGL4xK/X7qS3up/rh9pWaUb+mbi8eAafDT7LVHzeP6gVpxg1xiVpupdx28VzNha4KWa8BxsDiajAek/tmgsv8DQxY9jEHKH7/9bvayUD1GqVEZspzEQoVgm0ZuwhlBbq54r2rp1zrbsC6xIvKmMVAdWBGf63t0Uw/MKKxdPfq9EYiBwpQ+8G4xOefY0XLAGEgMBUDlIRTNAAqA9frS0QU3s+MQPa5BqY/wMPn2J+1xwBmn2eLFT9BqH69b6meEImuL5uqE9OHaW2/dprYrKZ6ZsSqSWoIdyUj1ag1CpbGcYpsFqX4DjEqUrS4subNr7LU6n+pwPFCG0KbNDkQYHmR+qx4N3CVruCjchUDVLpiRZcW/StFqU/rjrq0ByNaqAe7YDC+y2C1Z7XLWHiT0YxoP4h1rxSVzloGP6yaCqwUrVkz+cZ45E+u7TdZsWcIbe95KAjjt8x81jo3+1QryK9xaWL2hqPqMZymgaONnmhl5KoJjaER+MPXHv2gZq0HqkpEXdXCe6txdBrT/C5OBWo1yq+QiD+dYl2JEL4fR7oprap7ao93xawRfe6FtNEE8he392eF9JdWAxFpbaTyf3j+iEYGxHfPv6Q6wOTYbQMSX9tAZanXo0agOOfvfEVk+s1aeWZ9z02Z+ZAa59ZWbeXI+ububfR202z9uBmfqy2L9WjlVKwdh7LuPkRnJvfXqfEddWB0S+0d21+bh3XUhgEttbpXNy3r3VpLutbSyrZNNa9Tc01vk67FHWpoeed6fG86aW3fZtrVj72GId20bXAnbR7QVkswVpvZuZlGNKym6S2qq3u8j7pViVKjQD+V4Lhltn98po/+x9+Ut2AheUdGqSi7gynN0xVQJYi1sFjFpibAhxZVjuxZVb4i0mSfypyVA1i2nRNA8W7MeyY5ajxWxcr+6LMgTEPCFBIcrTrJtbVryXSd344R2ZwZmtZrBBZHXRlKc7iJYwEDoByMOC2dtZTiUDpEVIhRatX6WrJ8g55SUNv/DEw2uvEEIMpwUqT7H7++xwHudRv2qnO3kaqK+Uha9dbqiKLiEofDrRjPfB5/9zMmZ6eVnt5Rwd4JqhYFpxbdWOOaNdcT2m4j/mzU8RJiz0L5GyLUM3wMRjaIp2bBKAOyz+oQSz0e8tB8EzwAcDUXbLQNZI0KeB9ATl1ghfe7x6VPHgfCzNopc77GsNizgo7UhG7Pli0coGykYh2f7e7RxsuKZVN4ItT7AU3YqqFdNatVA23r00OL2tbXGLzWu1VP0Oi6yepDtOjRpBkjqMka0Yt9z/4TNaT3DPmW81Kujz9Uqyb9NIZrXX5e/iqdPae6duqtkcPns8E9R4O6DlfFYmW4wFZRaYHlVY6DShVyc60rdz4V/TSb8n2SQ/k+/EgJAMMX9+MAnB6jihfUB//1/yrrh1n18f/+p/IUyK+iBJoSlSsopDpeHeEBKor3R2XUx/kKFVR2ivdyVmP5+UCQoscKxXgtMDTMdYbGYVmt5YBFWPPyj+VyRKSCI8PRw0drdI9eurSTqLVqPudRJpMOB7AOBp/FWn23up3Uj/3Dirn5i6mzUirjCeHF/LBmPXXq2V8r1+Fz9cVXDiDmGWog+5brXOfOXtX08fPUvHZ7zvzWUlh5zHAD6zvtV7vaHTVu2GwtXbEdd+LNWCYuV/ee45RapS1XxXBpLpeCx2lddahWRycXkAK/QCtExLHU88b5DDDrQuctxhnbJ/bRpHZphDqARQfkIpdxNzbUtbRkEcUii4n5KOhfwyv9nx5zZLHazED42uZttg3D+MM97xyFjdG2UYl9bVNais7PbtK4B1D/7Hgqapt7B/XtCU4Tp1dXUOFiCsFwuHyeHCqRNbs++SiLsv79Y6VVKqWaXiVVt3Zn9Rt/VP3G7NbAsQc1bsoxWvwQ/fXv/6XGbcZq0qKrKuObrE8/+Lvqtx7Ksu8TjZ9+TEWw7/wb4IiuWIIypZyyfZJVWT7Iqzyf5Ff2j/Los49zK8cHn3FX0k+hxTDjo6lL8i6rj//5D336UTZ98L//oWKliyskPlI+EUSywBKQohVUKSiQDa9g5S1c0KPH8sLRz5sa6n1g+QWHASwPh+WoB1QO3ujXvQGeT3iwfCqHq3YC88PFc3SFOyvrJszSmI6DKJY7qUFME7Vmg2d4u4EKQ0JjfFZ1olaoV6wiEmsoomp1JVXPUK1aDTWU88AD+45T9x6j1L0L4sEWvdWAWq0VEaoBbjWmRE0oi0qirjkHtlGN6LpKjsTfNLw2n9eOeq6nGkRxQzq2oULLpqkO51PWjugGIJjef03n9fSqXtpoBI2VS20PeegCf0ajPZI7MZdWErVsqcAtbZJ+bEQB22zpyTo1A4Z7HFj+8+Mi23sgssGsRcrMMYnRB/b13NoV4H111TTnFMG2RWwFMhHTVtzfMGY5vmKK6ocHqsA/Ptan/+tjffRPUs9nAOqj3Prw09zK82ku1fGpoEZBXqpfq51GTTuhwRP3adyEA9zB2aPK5b300f/6i3p0Gc1dwWuKiqyuD/+fv6gdFklz5+5HeRCkjz/8BBB9oLqBZdQpIVCFP/tMeT7OQ6TKpXyf2d+RW9n/91+VFlBJCWUKKqBgLqWH+inLx5/ow39k0af//Fh5i+RRfK0kRVaLUjLfxwhkznm4MVmsYll37Ct//oK4J9v1r0oMoUtAkIZHyi8I4JAKrYgP4Bi4pUQfFA4mWa5MKqyA8sEAF1w5WmO69tcVJup7cVk2yXKfJn3gsxhKx9Zz6bAGF7+8C/tzWZWrFQArMraqolJrKiK+iot6dSBV7TKFga9eQkNNJrT3a4r/QUYHNavSVLU4DWz6rlbVW6ozUbA+XhD1Yhoz6K6thtFN1blmJ7Ul/VYnSlbDfXl04yb68tgqOjMc6ExezGN1zxtsDl2NZLpwWG47OHSCudpM6g2xK2gcjhW8RhAaX+QGq6QrK6wzGXDXOb73ZH7c8/bPWZvr7hiXuLEJqc7DcHukwrI5nY1m3nFG5ojnxIL7Nmhxj45KKIe3FNEk60efKXeW3Mr7SV7l/Sif8n6cU3kBWL6//1N1/b3VOIzJSJFyatBwgHNonjv/GGtre8gm1VWoUBkNHDyHA+DnNWzMIg3n/elTNsu7YqiyffhP5c6ZT/XTG6tFfLi6p0SoXO6CKpStkApmyatCOQorX44iLmLVjg6jtIlReay1WyaEKQfpMesHOZSDyPnPz/6h2Az8+WvFKakFpwG71FB0/TgVr1xaBQsWVt4ceVTOq6z+UqkC+RJghUcCJsR+Fq2C0GaF4Pvuj0W3b2AMEcsfrVaYKuKlVYliLpDUmBFXmxX8GTq3caXzg7fu0Lyz6rP93L1eZ7Ws3lyVMWGL962ixIBkRYQmKLpKNcWkVFNydCq2kTXVHI+oKCJgnFeEhrTtixwH1QRpz6yS0qMaKARdV3VWyDpDYzTDIbhuFJEsoJaLUu1Y4GgGpVAdW8o+tWvq8oZZHhb9HW/kWTSgM2OWZxpx69JMoPfK5LyMT+b2bKwbq2fwghNViB4vjLshmlhnZjMyV3MZUIg2/20wa96b7x77vD8fwGNT/3fjEft6bubmGgXToFNHuVrulEt7O6cOVe/UqgrKX1jZ//6Z8mYvqKyf8QJ+ll25iSL5sxRS3k8LKX9W0hXFczUK5haxASqfK7uy/g3b6/L+at1hrGYsO6yluCsv5uCSXV1dhdHbvrNfa/6i0ypfzkcf//3vyp8jvyZO3aD+AzD4aNZQKwZTm5ah689fUhULlFCFwmVVpgjUU56iGLhU0eQ+XVQhXy6Na1VHxdBYFchSAJBnZ4X+Q8WlJysuo4qKhlZSaONwVWtXQ75RXJErXFg5UTeUpeZywCpWrJiTJpvCIZRtneCIaAcui1q+IXBYXAjzJWqZXsuky0EhnI7zjtH43n0cYbqVIn4MB52sHrKI1ZYo07V+FwWWDFUQxXtNrtdH+0a5rxmcFK/EpGqALUntqrdVsG+kAtnmaYnN0STqpv6NezHM7qgm8c1ZJQOI5RPVhTs3HTLaIyxsDPGa7m4eNsQ7vjWOgr3Sm2jnjKEU07DXZtHzJSZsXwAoCE5nDeR8CzyPgcwoARujXNu2UOsZjzh2mTbdgGUstAODi15EHTe4tUL7Pz8WjSyFGhjtrf3ZzBGJ0QXGk7mBrkUss63GI/3ZsY3ayVWuce0aqmqlEoAmm7J+nEW5sufTJ//IqoLZDUj5lDNbXsYjeXihiunTLAVJU3mVWrmS2iT4yytfTpcuc330gXJ8mke+PnHq1m2cDnBn5zq7gBce/KbZC3eqfPEg5aCgL164iBZyku/A2e81aPhSTezQWkemD4I+QnCQr7j8CpdSpYKlVa5AWUCbX40iA7Vt2kiFFc2jCW3TVaFgPuX7OK8KfpJbn336gfIWz8+oL1AFK3oK+MiaTG1igpW/aEHlAPQVvCnevfnHWo0VFhHuXP2iExMdA+95iFqAwdbuLZqZstSKeL+gaAWy7WxjnuNrp+nI6iWaOWiMS2WNIEobIVnu2biHYr0TFVSZqIOzciIAiklKUmiNZIVCxsaHc/iSqxVVqKciuSFtNw7HdRlLfTaE45vMIFGo1mTeGFw4TO1Z6zbfU/PiyohooGo+3N+JbKQeGV20c0BXfJrQgP9o28coH7+xcYqtaj3At4zxic3rjB13czvA9cyIS1IiI5ytY3roDrTJ7+jFjQeylOi2W6iBLPL8izLAQPbu+ddBLRHqmuexQa1Fv0xFgCNgSa8WsW5vm6MNwzuqf3q0GoVVVJPoQJX5mPT0QS6X+rJnzaG8gKkwEarQ3wuo2CeFVCQL3RofN9AVzJZHHRPCNbtrA9Wtmqr6eMKWLlFeOf/2dxWg6C6erZj8yvljnTRGwyev5vf8VfjDv6lkwTJasWqnDl74XKuOPtKgMcs1pUMnneQiamIoIs/cpVWpiJfKF/JShaKQ4nmKscJXTocWTVcSRX7HVD8FlC2uHH/PrkIAKx/A+fDjD1SmbCW3zeWF67YpjxNw38lXsqA+y/WZKvlQvFfgsI5FrPDwcEXGA6ToSIWxsRMZB8DCY5wDTWgU2810iga0oFAiWTB8F1/QPyhS0/sMhahdrtXjx2lsh0GueK8X1YjtnU7wStRZ3uHuEmsa4AoPi1NoHCZtacmq0bwWDHlVtYH/CuYnLsgrSi2ISDP6THL0RWciVG3kOAlFMc6lYO/BzNF8TOvENVVc5TTVJmouG9OVyQmRirnemx8e6TkHhjyzPXNbYXhMBDPFgg2CTZNu7xupac4rpiF/wpR+97iemO4ztLXBK8W1DVl/Q/Nkq+dGoppVzyu2h01V8JJO0jgnS5UGOqMqzBDkra2NWTFuUeo29MGd/fqJUciNrdO1YVp/jWhWl9QfTEdXyRXO5Wntm8UGqzTLnXk+yqkCn+V1T+FsBVQyZxGVzl3MpagKBYgkBcqoctFSKpOvtAbQMe6YPgIZeBrjqZPawe3EDv0HqWzpMsr5949IWQVVLEdRFSft5fkku4oULKVl6w5zhfZb7vFwgezQHY0ft06Tu3XS4ZmjOergq7L5isqrcAXqtoqqVLQM0amYKuUurFk9eqp9ZICiiuXW0EbNFI1QIUe2nC4tZ6NLLBMQrNCEGAWEhalsQEXFQOOULFGOs3K5Va4kEcuAZTVWVFSUi1hBuM6ExydyrCgexUOswjhCHs4Bp+AIQBYWBZhQO/D44rbsFxiBCVu6DiJZPrFmIbeDh6t73R5uyaKNkaaMeipXCFWUN+ZrACs2lIsVkfGqVreGmnRpqQZpjdUSr60ELL1jApMUXQkP1O6jiVqD3XZ1k6oc2/SqqUjOqdg2UBdO2zVMbuNcbSZ07sqmCJ3eDzZquY+0BSvEF+bAgrAOYL20uR5mHH94QyEpdpIYc32xNGn2iGihzi7mtrF1iNRaNtawMYmNRX5jmGu6I3NisTUp84wyZxZZncSv35zdCIMNAC3NuRHKTn2+b62OcUByYX9ceDI49xLgK+8iuVScbiznXz9UcIFCahrrq4ooANqnRMIhZVPRHIVUOl8JlSMVVS5SXr7FK/7LE1CKYp1NdS9qoKF83/bMHsXwv5HzvT9w/St3cfbg2ZsaMGiiCucopmK88KVzFVC5wiVVJHcBJUVVUz9uE67deArb88eaPmO7A9bttfPULD7YAcuvhLd8ilVU2ULFVKpgEeWnlqqCirhvA+rhCoW0YGB/ftBr6rNPsujjv9EZ0kzY/qlZMlQODFcB1r4i6kSDo1JcWM0B0Fn/slNglgojSXm2Zh8KqxoWl+DSnwdYUPZEr0huRruaCzmNAcuill9gmAK9QriO3htt01ItGzqOO9IjVC+xDgDAtpuaK6BijKKCSIe4KttF1eAwvmZitCKrUAAmVuVIZk0Y+0ZsUicrqGKEWkKKZkatjmltVZuzKH5FI9WSTrEP6bVhMjuNKfV1adtq59Wpn+5iBY0YDtOO319DwJqTHQ55TkL8zuXuz00bz9JppgTYwGVbNjsn99PjnYudr4FN8t+yffPbSayLiGS/MIN7ewUA2fyOwbAsmhGhXmBt9PnW+To0f4wWDeygXnU4nBDoq0AK2JKktjzUS1n+5yf67MNPlfMfOZTlnzk5XFVRcwe1VxRc0IoRvdloKkfRXEbeJSry4laSf0kv99j7vqQ5n+Ll6Iz5PdQnlQHKBLaXDzE7nNG3C1zeeu08zy3ES1xyvf2cS2ELVDxvUX3w//kv5adOK0DkKgKFUODjXHR8BeRdNkg1ajRU53ZDtWHSCOZ9SznAVYPUV8QB2or3kgUKq0AeGgUaiDz//Kd6wawvGdlDLZNw1MZO9JMPPtRH8GlZ/vEhpKifytDIFWU6Uz4iSFU491ucFfvseT/j0qoPzLuPjwpxxd6AVTW+qqKjSIOJyQ5ckaRAox4MZOZRasDKjFzBYRT4pMXKILdGbDXtnj9Fx5Yu0DQOWrZO50ZeTG036omCII0KYZUskG98EKdOIhIVHBPt6IuAmBiF+8SoPSYjSYEpiomohgdEvEZ3HqlRHYepB4rUxtzvCS0Vrxp+VdQLxULrmt3VsWZ93dyzim0a3PDw4Hx8eIu+uw4p+YJFCpMCm44Kh5dXuAE7X3Pz5TS5sK3J2/WFH0idzPZefoma4avLur59kbaP66Gbq6foR1tAOLxGPx9Zpx8Prkauslr3AdDlFczMcPJbOxImu0V9tUiIUhLCtor588MHUXzzzc7+j4/4pn+sz+CgssFi58hK8f1ZfpXIXUZF8pXilF6w80lP9a+sY8umKxleyrtoeVlU8itZwYHJ3vqXqKDAUpUUUBJQ8etMYI1rVEsXV83knuRw9YVJX3+IU3WHv1arDiNUOF8R5fzkIzbak7R+61mtWXWImV5TaqKS+uSfnyo3zHm+LHSeAG16t6b6+uB6fDjqqVLhEi5aFc9VmAiXT7mIpoVz0iz88wP14b9z2aj+Ci9RRMFF8tJc/MND1vJ7BcuWVQHvYioT7K2kJtWV0DIJJXIRrCI/YaTDENrHp7IKQMXHAJ661TgTF8P6VgIOyMhoIiOsaA+nW4xTNB+zbjEilnTJRo9REQYyf1xqTFIzvF0XosgKLRo5VoNaj3DLrK25+5Iagnuybwhy5STV4dxJhK/HOdBSom8sHUVYoupTxFshHx8NJxKQ6M7QTes/Wf2hLdrWbUUnmKGIIiHqmt5Jnev1V5uqELQLRntM7397pC+PEj1OkbLwSzAn4EwtuYtU74DlwMVChN3ic6pQq7uIWDbbM27rCWK5m1g2nZs3Qkcm9daBcd21f3xP7RrcXruGd+MAd301ifBXeMniKvhpVv39//07pOGngCiLPvm75212UkjOT3MqD4CyNFSyQFHqlnIKKEpbX6QMPvfBKHEHqy5jkBMrZqtOJJ12kdIuKtkTQG0SWKrCv7wNKFFZgWXKE7FKa2Td6rq6bj6yn1kaOXKpu7TaoG4vFc1ZlMhE0Vw+gGtl2zkidUQTuLg6acpqjZ26QiPGTFX1lBrKzTLp3/8HgKmfwgWL9RrUtg5NAX5WBUqqGA1CiTz5VKYg/2b4MG+AOrVHF/WpV0dlGQ1ZxMpOF5ozO3PDD/+h0n7lVa1VFcU34vVMZ8m5SZQKwGNly53VcxPa9uxtxpMQnUjL31i14iAxAU9EEtwT88NQQBAZm4BeC8Dx1iKXAcrIUwNYSEKcgoNjlRpVU2tnjsNpeYEmsGxhVpJNktg7jG6EuB5SNYAuMqKeu70TEEpXGen5s3GJqYAuwR0fSuJSWHJMuiL94jWs4xDa4qHqVIcZZFILhRTB1zS2ibo26K9O8Fdz+3fRb5+T/rho9ez4Ft2nvjEjfVvfMtnLc9OL2wIpv3am+zgHm4m+AcsjIWaJwcR5aM3dpq+x9HeYLzKg/u3kRj0naj3dvkDP7SjRmZ1a2rOdQgvlU/6PPuYn9yN99CH1xifZlO2DTx1xmPfTHCrCi1OK2VsFCm9vujE/Uow39VFAgdKOK2ocE6lDS8aoIUvB59YsgFCOpwYr5cAUVLqiextYupx7gjExCypZFpB5KaisFdflNKpRBt3lMp1dsxR3nJmqVbuLitA15gdUft5hmj5vN6ObPejfjlGsX9FhLqDde8a54p9e6d6Tn7j1c4L5a2e1qJ6kI7OHsxCTACjzqiL1nW+xcqpME+dfCnAX5+8sVFb9GjRQx6rVVDJrFlX1LgMIaTZyMfb55B+McoopphHLzS0oneoHKbxhmAoXKuGu2FdA8OeAVagY3g1EELPMblSlHoe3qyqGbeg4CniLVlZrmQ98AuSmAcsKe+sSrZgPpNj3D4Gf8o9T12YtdXTdCi0fNR7j2+6OLbe9w0jfaFeb1QivAbgaKCySFf7oCEXEkbv5mhERCZz3rUf6ZGwDsMJCkrjK2lDTu49RH7wvLbXGVYpXMidUOtRhaYNbPr3q1NHjM7T3L7/QV+i+7+1Ev449kFttZ+X9yamN+gmrnd9/ZR3MpMVOr+5ZePAsTDzC/twkxkhdbBGT5c1f4LOMvzKG3OQlpsZ8i/T3zNyxSvctp9yMO7J/+JmyfJRVubLmVJYPP9Rnf/+HclJH5c+SQ4Wz53bgKpmroMrlL0bRXYY6qZSCisEX8UI1jo7V6TUz1DAiTFc3LlXrlEQHrCAiUuYTDIhCy1RQBCOa8HIVFFaWugu9XGXS4hhS17OTW3Vi+Qz4wSDHlH/2v/+m1Orp2s3J47P3f2OtjTMxd3/Qzc85jv6U62mPnuna42cs6D7TnjNfcMeH4+39hmrzWC7cD+vi/n1+xcvzd1aSF7W2V/HS1Hhe8spfSokQsq0SKMohRWv4leKHJhvAysuw+yPlYtzjU9VLYfVCFNsc79qW8SqQrzDc26fYcRuPBclVCIFWGNV9q2qN1CK1kRKq1FRcjRpKIv3F8FjESmLOl1orwxXyFrkMKJVoOUPoJkP5dRAugPEhHCwfM4ojT9M1scsItqXbOT18LCpS30iWMoKTVD+0gdLSGqlOs3pKSq7i2PjoFG5Lh1ZV84QmiuX0bEJKbcV4x2pkGy5OdR6uNrDstSFew4uGqH5CM2oDFmarpmPCPxiPkG/0CL3S/Z3YEHGZ4YXbiLnm1pEeHqUQx1HPfD/1sycNujqLCGbFva15OfEe1MNL2/Zl7vcL+vKXmKpZh4h+WV/sXa2mUf7K89f/rQ//N8Uro41sn+UiSn2qwvwkG6Odi1/bKCbrJ58qFyvm+fA6z8sAOT/MdelCEJDFKqtiUS/VoS7dN2+8mtAgnSMVdq5ZxUU0A5UByt6GlOZ9HPFCSpd1b0PtLaax5YuV1LBmtagnV2nntEHKx9+f5e9/U+NGXXSQs72HH36jQ7fu6fQtLnXcZXeS9barDx/qwuMf2Uh6oMMn7mn6gr2kxmOagEnt5Y0btHXhLPkWKSF/0rU30aYijYdfeQBWsrIKZac25L9jaNMMlcj2V9UKKEpUg8YAWHkYXufKl1/eVdiPqOKniIaUQ40iVJiOMhfg83g3VKxE8V5QfpGkGuZtPTm81ICrU5FxKYpOZr6XTK1FGkysytV5Ill4bKzzdrCIVaFyqAIDvBUAa+9N0W/gapJam1Ova7R27CwUpdADrOBXYaxjDH5AeLwaR3JiLqaWOvZrq74juiMWa6Y4QBsdX1O12fapg1FuQnw1lascptooF+b2mah+uAa24tJYZOVExaBk6JHRTb0ymmpw07qsi3NW7sgK3d6x1Hmkyxz0uMz+E5HmmvmDskzq9gFt58+WIMxe8WdPFHM+DM+IXHz8F5MSs2quG8zzcAQ2Hst8SFtXq+kkJVn+Rn1BVPrwn9bpkRLonApRnxTmG21Fr73ND8+Ti5bcQJeLNJkvK7+fI5uKI0/Jny+Pwr1KcEVrqhoGlePyxxRN7dIQ0BVRWLlyyIuITrwNK2vRA0a7JO/TtnuXqehA51WolJrS7Czv1lydEsMgVfOofY+R2nuda68cOj9y9alOXnuK0e9XunTvGc463+kUK3NHAd1ujpSv4sb0rLn71LrTeFytK2rZ4LaUGg1d2raO07dEaQUSJX2JXMVyFoJTy69C1IpDEUeGlSsExVNU9cI5Jp6NHxiG19ngySJ9CqtyBK9/rTBFcci8MJajn+b81Pm9O9dkm/HEJcera9eu6tIcK8iaDZGk1FJMYhVHmsZXqaKkajUccx5fJZGbyagUAJejHvyxPKKoD01g5hUeq6rRycz9uuLzsFaTujM/ZKHVzslZHRYVn8xRp3Tqrgy1bddSHXq3VRJfK7ZKKpGRy2BEK5s1xkOcejMCiuXihY14JvYcjp98K9UIq+N8IepGNlQ/7iV2YKZ1ccsi56p3Df8nu+bginSGzj8ewfJwwXjWtu65TtEtkjLusbMiYrHVLaUasNi+sX3CVyZDtn0+2HVbZnjM8sKA2qkqmyufctPx5SL9ZQdg2aml8pLy8mbJzjc4uwpQzBbKmUdF8/ATnr+QK9iL5inIx/Mo96fZletDG71kVzY+v1LhPFoxqKc6JERw/ria9s4Zq1J58pBiKJrzFlB52n0jKB1JWdAzw6tE11gpPymqSEk2oMqpb3UyS1youncdrDO3ftaBC0SjCw919PIDnbnxRBfvfsUx0S908OI9lx734h26YMMpzV/Oebvhs/XBP5jl5c3nRjVT2zdzoPIpCqiIlv5lK8LAU8gDLJsZFmK01CEllqwDGVoyD2VJNf67s0Jf5HQROqpiIXmFQVWk+CikTrBKlGH9K192lBQsU3hjAlK8eHFFY2xbK72mqtWsoTo1M9QkvSEzvapK5MWLSkhQXEqKatZJU5vOrbmXzCimVhWiF90hxiFWjFt0M87L6IrqRLulmLZtmDwVrqSj6sPEh6KIMF19WrV6eMDXV8va+D7glR4UF8OfJSXy56PDq7DlU181uGwfTto0pt7Eg5MQE5oVeHPUDHE+RFII004ZdIjwMssGddODXYt1ZT1F9hsMQbCzfg2F8CuWPUcY8v6CFba7IWOXH9jKeX4dLbnJiy0V2s0/1rmsiLfhtXlMWQF/ecsCDqrXUMXsORyFkJMIZSDJmyWnCuZG6AaICubITVtug+IcKpA1N6kjr4pCTJakmypraQVBXSVql4p0fUWohQpQ1Bf89CO1i4vQgr49FVuuuJYAslIMoO1r5PssJ9GNyAfnVCJ3Ecdv2VMZ5t2fr1G+cHGiWXGNRt3Zvjr1bPdhLAJ/y73Hqzpw8paOXLinQ+fuaN9J/FqPc8ica7AbOBA1ltMr89ZyRH3OdiiPfMrGv6EYXNXsPq20uAsOQeY0VIp0W66iq69K5S3iQFW+EO/nKqqMsECNb9uQmiubhrauA71CZM7CfzczzqQKcGBhpeRfN0TRLWJUukw5jo0zHPdFNlOeMUNxisMYZoCxACWJn6RadWqqJZbc1ZOqOzbeCvdYnpikBLXrSgob2kt1m9R1wAqLSpYPtZZ/SIAiGTBb9AqA22pas7Z2z1ugyd2HwvnAU+FRanaUrdp3UrPqbVyHmARBGgLLb+k2KoUuNDpFyUS3hrHNlEDNFUNHkhhWlU6ws+b2m4DnaSv3+2EAq3p4Gj9BPZHLNNSRmSN0dQ3qhjdmJsstP65AmJHa4Qn99cMTFA/mB2qn10ibz1lX+u4SoxfsHF8aWWoAI1q9QoNlW8cPdq9E/5Wo4phbGMmZk6iUw9SVpLXieQqpRN6CKkInVZCfWnsMUDbHs8cAZk/BbMz4chXi84s44HgVZX8AcBSGZ2oY7Ks2SQgnC+ZUl2pxACkPHWU2vk5ulaHgt4hhoxVf6Ad7Qkt5ubToX8ZLkSyCLoVgHdg03Q2f0/m+LFl3nOObl7gwdlHLNp7VnKVHNHr8Jg3i/O/A/su0++DnWrH2oErmLU7N9AnXuXKrd++h2rVgotb1b6+gUiVcPefPOMYajrIFirt/gzH9RpwmYBCzbdwQ+RJtuzeoolQGzDmJwEWoJauXY8YcV0HJnasqvm2iSvN1cuXJTtkDQWpCv7zFCjuryJo1qqr3mD7qNbq3BvfvowapnNhFiZBSLd09iaSspFQiV92aLpJVT69DfZSqagwgU6oR1arR7cHeRyVS6MdV04iOPbVtznLqtm7KYO0+BC19fE2Ai/6qaWxzd/QxkmhlwIqpkqLgqARFBCa7VFeNWssK+7jYZKXH1NfUniM0ol1POsfGiglIVTSURKtqXdQ/o6FmdWiiy6tmOOb9FQcK3lBjvTkDsEb3Yv2PhQiOG/1uhyKhFF6wEnV7+0LqMFKkjYFg6W1R1ax9zO9qds+2Kp0nJ9wUY5gPcrpawngpS28GkhJ5Cqgo277FSCeFiFgWZQxU9lNsUcdoB5vT5fyQtGnc1gf/dJKYT//3ByqR/WP1TEuRf76saNFKqFGot4pjrVgWktVafaMZQogcmY+nQzTqwYDmpVSmHWuGdtMsDGnzwCV9wAC6ZEm0cRPWauf+h9qyhyPp265p2YbT2n/8ju48fq4t286qTPGyKpWN/45PP9acFdtQQVzUrsWTtWF8P8ZogJao5QV3VY7RkqeTtQf+rZS3KhQppr1TxyoZX4YmydgtVIuBaIWnA1iNEQSGx1RSSqdqCmsSwWC6vHLlz8lwmq7Ql4hViFlhJKdOqlaDy+rRVG0G4R4zoq8a1aqttPR6KD7rqwogS6tNh5fMEBlQpabVBlj1FV01QV37dNWIscNUlflYOL8flZyq2OiqqhpVVXM5lzJn4BQ1R18V6R3hjN1C4a2aEMXSYzOouwBWUoqLiEHQGha17DZPnbi6qCCrKYGjUfGcVGlTs7HmDBqLs01nJcDixwWhkAggajFDHMjfe4nzLHbpwUz67Y6xrYAfHdMTnw0kxq9+xAn7W4/hBvO9c0vHw9Qj0vuV+8fu9jFzQyTMt0inTRG55fjAFJOf8g3M6/kmQnYWIwUWB1Sl8pGqiFr2fom8AO3d+/b7RanHLB1aZCtFXWQpsQLFeYWCJVwqS0WNuZhoH1Eqn+omBKkeuvMAvvdWuNsTCpvtCngeez+SItg6QnvfAQvp0t7xAzSnUyNEenSf2T5jjIOkBYojiZvbixbv0IVrz+CtWET6imMIqzepIum4ELt+RpMsWLxG36AJ37/zuG7AvB/dtIQDpj7UcIXdsNu7aAUHKv/SpR2vZhyaRbBF/XuqdwYZBG+GEc1rEr1zQKjmUufYEOTOuegK4xQFQWr+7p5UyIVVX5h3s+MOCuNoJT9NGchNW/Sop879O6o69Vb1Guk8GapZq47S6zZQcrVUB6waGXWdzDixVlVlNG6glu3bKjyBjrEmQEhFsgrJGhWVola1G2nl+FkaUK+74r3grWgAzDIpObSWs5uMj6O2ovCPTQBgcGSx1Xg/Il61o+rwOQCPFFkDniYNd0HbABrJBbE6MWmK8Wc0hCqiiR0y4HjQSbujR/FuneEL2zQmFZ6CQf/iMu4pHC7/zY4+mtgPBcJ57hufY+uF27Tc2IaOsIVSivbLK6YrBkOLv//XP9g2QVXJUxxOqgjpyjgqexHLFTHAFHMft1rIopd9vATtt731gItfAzgz1K+II3VIeR9HPDZKidP5jcuVULkkQ/WqqhvA+KZkKYUCIHuCynhAZE8I7xvAghzQeNFLlnZa9OPs860d1lU14RIrwrRn+cf/Yij8iQrnzkkNVUhJjOWmTl2oYSNnqGjpQEeg5uSc7vxlG3CgRiLGnb3D+89yM+ooztybVIWvWYm6yq9wZUDuQ3dYVoGsygezG2gjJSNP2/N6zu3aGtVDVk3oUl/F8+fhv72QeleNcidOysf4KKFpoory35ItbzYFk5n+YmdWyxTExgiWvVUftOS9G6tTH+SrzJOq109Xem0uz9eoReQCSNQ8qbVqKjW9lgNWagZHMJl6J9SoST2Uiq4dlWgS3RyyVgNXfGqa6jF+GdCyvZYNmQuV0IC/J0ZxqcyWkNI2JyWmsgMYRdqMjaXz5OtHUd/EMqdMYTaYHsZtaWq89vxHtWnS3kmf53J+w04Gx/jxuZC6oZyz62QjnomjAMp3MO0/6hd8pWyYfHpyH31xEQ38659ZxcdUyXzaIUEvL5vIHcaR1F3Ia34kRWL6b1dCTy2YwMF0ZmIfZld20lspil3ryEqS7orlIh0CopL5C7jCvGKRsshaSrtfG6CsIM4EmIHMfm21WBH+TDnqm/L85NeJi9Ka8cPZfsmrDvVRwuKxH0D6M2bdurJAAGUvaAgrefY2iC4rCN2TgSwI6XK1wAq6uHKCtk0dpnacU96255pGsGQS6BvjxkkFs2ZVaZhvW9cqyGipIHouawYWEbl+ZAPKXKtP3/1GO/ecx1Fym7aO78OdycryQV4TyNW2gBKog4315+5gIFHLJgGVqbXiESqs6teRXVEUpd3qsQZoLHw+dYwPYGunsHKVLqhI7goV578he4Hc8q3g6xH6mR4rCla4KvVPRv00de3dkY6toapQcw0a1ZXtmpZKTk2kqE+jM6yj6hmkRWZIVfj8lFrpiq9WXYnVOdREIZ6QCsHJkwQYk4kkfQf1VsO0dI3s3F/9ua4aE8I11qrMJCFFU4lWDZEnJxDZjIW3GWUYA/DwZMDFzDIthL8DDwgbiodXTVRyUAqD6N6aNmCq6obBq1HYh4ZUVUKFYC0dximOV/BVL7D/vs/mMaz8KVQLX5yG6OQKhLiC8fYLWHacWw5N7q6VA9q5i+3OVM1UpaxmHebucTF+8j/9KBcMegmiUHGiTgWXxkpTlBbN8alj1r2K4yHG/M9Sh836rC6xdFc6d1E6KfRU1Cr2lODXlhqL0WUVzZof/qqCxnVoiqzlM1h3fFp9vV3Keb+mMkAFAzCLXvbWjXbKMi/kBU/090dFslEXFo7VkKYNtHTLZR09+0Q7D9/RuKnrFY91Z46sAJ20XKlwAUCRh+iaT42QJ43hAMTGvae149Dn2rrpvMZ27qQNgzlsmhLq1sB8S0J02t/DLNSfJsEP6iEEbiuYCGZRa8WgrqrlU1LtwEDTpAhVyvWx2qSEqQAsfc48sPXFAHRpCNIC2VSO5u0vPt5ejseyZYpYIk4ii4cNW2Ja264xnV8dde7VSXUa13FAqlqrlmrWrufqq+Tq1eGz0nhbjbc1+b0arv4yfst+34bWVWqkKb1xhqpUS0FtWkvTuo1Ww8T6io/3cFex0QlqFNtYqbFpTkwYBLgCkUebejUGPiwenZZxYNZ5msIiFJK1BksWk7uOVR/ohxgK+KhYaAm8JkZ0aOMx6fiResk8yJG3nJ/TX7dPswnzhhvSeIu+/vwWHlO7tXtsN83u2NBdmjBLxzekQrH3twNboDL4O2WBYS+dHeqAo44GjjL5S6gMac3RDLxo1sn5FC6qeFjqYPb5AiAyLYUYwCoh87Xo5LTkvCDWYZXm/TKkm/YJIZrYuYWKffYB80KiAy+iN8Np68gy54VWsGdGLANZFGf/LKr5UYulYJJ3Y89Gfbl7CZqqdlqy6Yx2nrirvac/19GLX6lP3/Gk4KL651/+H5VBtZCTaFWU+qpEzgKuwSjGvy0FiVLfHmPUnMnKgqEdOACR4f5b/EvCRaGksC7RH0c+Xzq8SP4t/kRnG1LP6dVBg1BXVA32V99G6YorW0htOZXyGb9XtKQ3d8BZcsY1OR+jHu+QSLPjLv9uSwflApxSUq1kVaufrFYcIBo1HaoA3qpD787qNqC7mndsoVZdWgO2zqpVN93VVVa4N2yBfjuNWqtBHcDlkTdHxsNn0TU2btdMKXVQLXCQoBPCvb51OnoEfgj1DHx22d5uRdv80IbS/ix1+PoFKwLVgxGudkQzkQ4xIjpJvtAV0dRfJseZNng6Wq2aRFrmmfxQJIaGa3qPbrq2bpG+R0v1A2v1J2cO0pWTCPN+x7zITrbBY9lCw9Ot87SW7d+vzUqbsyPO/OzWUQrj/ggLSyocIzqTxCRVLqUM37K02BUVzotrHaFdSstDVLN0Z+MQizahACwMbzF7DBi+zN9sBuieYgYu5L9EvwFpiRwzaq+K1CEdq0ZC9pJOHfNNcc4Q2GZ2JpexKGZPMCx4YMmSCmVB1FJTJEsK22eP1Q3O0Ezo2kbrtp3UsVs/6eC5h2rWsoeK5WfFHb1UTHic9mD9NHLKMqYYaSoAi577gw/crK8o//ZCbOsUypJFs0f10IYpw1hmqcTAnNqOOjCEmi6wPIJDgBWEcM/+HUZV9K7HhvmYQSg1CqgLyxSt+fe3ZfXrb/zg5YPEbcw2jx0QyIfQzzbpiVgVuUxRxGmv0uvXVUvqmW5DO6nXSM8zAtH9+HnDNX7uEE7S9tWwSb00nuWFTr0AFSlz2rzJ6o7SILlGklp2aKlmbVq4CGaRK6V6LbUHeKmN6kKOJkEb1FBbVAyNU5kX0m2a9t3kyTW4ahEHbxVH4R5dLVmBISx0MB7yCg1WXAD0hH8atAPr+knUZylJpM6qGoY23k7dxbKUEZvIgmtIvFIqhas9FEZ9pD6dSOOtwoK4mMZ4xjrCbyBDMUozAd/rY2zIjO6ju9gBvUYs6FIh5OiBiX01vmktLWFFfyNr6wfmjtQl1AhmdDa/d3tuW2PrxFJmIUDlIheLB5Up5l1kYaM82tvHvbUoY6OZIApu/5Ke1t2HVGlfe/GgztwcKqj+FO8xzGkr5ieVAixv1Av21ocXyY+RS6YmK4yUZF/DivjQsiVd+hmQEYPpXU1qrDPazAJFLVQppYmmeT/5DCl4KEsT99xhpVuPf9LFx79p8+5j6tF1AJHIV7mgHJwi42//RJIU7aSmFriLAAD/9ElEQVRO7Wm4fKiVLO0GInN2tR7gCizB+/BnxfMWU02OSxxbsUARJQshaKzAhZK6jOAi9BE/EDlI9WlsV5v3qM1IbcnZActSofljNWnbSs07N+cqe1d1G9GBp52GT++lMXOxeJ7eTf3GtiGKsfvXmyhUK17poLhDj7Zq0gbeKZ0uB9K0Rm1GQRCpafU8KTMRjstSpHV8idRVaUiZbRaZTIQyDszmgpbeakbVUgo0RSRFfxAdZSCdoykgggKRMlcGpGz6RCQhmWbEEAm3Vov2eg6WRS3jWyoqoqoiE1IVXjlGdZgvxiEu9Cvqp+qslW1YNJQi3dxhOLr0iOsLdyFHIUO3zBigQ6vZmn7JgBqZjfk57BzZWZcXTaRzxOTV9v7oIO22jm3X2GLE2lHdFYfldGU0SzaGsSLZxiPeLGpaV2egikXSa6RiPG9jqF8dwEwSQ+Sah1/oskFdFFI0nwbhkRDF6MMA5VuMKMdj7xuw7H0Dl7X7gcXpGMuZJouUSDpsFO6jTsnhakPdunTJFsVHpLoOLfc//skPXJwOI1O++vVrXXqCwuHJ1zr7Ff73X6N0uPaNNmy7oFkLmX+yUFwUQPuVyaOTXNCdO7CbwooXdj8IVssFsIVt6diG4oHMKssyAbDIfHnbBpaEAxVWJKcm9GytEH8fZSnvpzw0f3VDWMgAlHnzoHrgoCqpsCKLjoVgz/1dLdWiaxMNnzJA/Vky6DWym5p3wVStZ1NWubuzfTtIY2eMUL+hfSniMyBGM6AcktRrIJek+vcgmtjoJ0kp5G+rvxKoo+Kor2pSxNv7/qTHJKu7Emsqg5orCqWEsevViTgZ1FlOZAinFUiK9CW9mS9qYChjoiB4M6TNVtCHAdqYFIbhjI7apzfTtC7jAR08GMLE2ASuYvilKIlBdzC3E2MqRKthiLfmd+ugQ7PGoSiYrJ1cvVpEeu/C/GsHJ0DstqA5CZuX1J7xPTjTywWHix7/dLEaZoeNnMn+A659LRirasiMgpESm4DPKIUSpBWLFl5FGLmwSheDZUEMqtxYb2/GT5XdE4kDdTRRbAt/9+rh3RVJFzWhfQNSLSnoXfqzFGhRylp8e5v5voErtHRlJ1kOgMhsT+Hct06qqvODF+ofrYoQtzn/mVUZlBcXrj3i7MsPDKAZQj/hki2ymZtffK+Tl+9r3a5TOnj5oa4+eyVkWtq1/44a1GmrBYO76vDiKcrg++SLbMZqRmPiLQX7M+qxCFaGAbhNEQ4umYf3bAOV/vi/NImUXpS6MlvFIA5QlFarpBDXBOaFiqhI6nY3oQvDrtpIJr1hTdVtUUu9hnVSf74JdZrVJgJBOdSv7dh2A17T1s3VoVsXKId0RznUqlvbPVa8ByONMUKzas10N7SOY/4Xl0pEAliWCsNSGA3RQSbHwYMlVFeVqhT8tegoq1RVNeiGVFJl1ZQM1xlWCMD1BkMSWz/zYxYZ44t0h3PACUQmm10a3xUVlcTWdR93QzEGbZh1oqExVRXhn8L4Ix7+CHudQF4EtPbGLOdDR1ScdJH/rx+rCAsOs7qzVwgxauYgdhPnMedAzB5IzBPNpdgcgT/HSOTM4onaMrafhjapTxojXfEi+5b1U3mkxCXzFHacVik4JNM2hbh6y+qu8rytQPQCVKTIFP57js4ZpXWAuZp/eS0f1p0fFvgtCvfMeiqztvpD9OfUpBWdJsuHwjoYnmhMq3ooaZNpCAqzg5gf6cyn+IL1xK6cW4z3vuOsy1e6baB68LWuYTd+5uITbd95SWcB1a2vv9bFL7/T2Xs/adqsrQr3w86zWqQb4A9rUdcBy/g2J9Xh77KhtHFqtphRmMG0KUqXDumtaFbqh3ZsplxE05woXMoS1dpz6rcQJiJ5ChXwyGZKgrr8bI8YsNp1a6mezKJaI+do27UFZlq1Vad+E9Wu11gZ9VApZMC2Z6Q5dUMNCvKMhhTedIn2VCUSJQOmGhTs1UmBVaivDEwxVas4gNk4KBF5jCkmbGE1BsVqWq26SgG4iekYgJAW0xJIkShRbY2/nJ+vIiNZsED6bKv9fgG41vjXUiLRy2aS0agvg/j7asama2ib/ixwZNAMeKQ+VrdFl0f+TNQKr4TkGoFhIIVocMXCMPgJfH5TnJ87Yt1TTz+c4xayHQhHLmPn2L7E7OQ0kWlB35YawmGjjOBKSixL201h7MNCp4ngAvAOsyI3lBlrRWqMsvxE2/DWXmzbqDH+yVKj0QWBZYq7+iiZYf/JBeNcOq0bw0Lo1CFELIBjA2AKfnssDWUK/jK7RAOZvdD2IodDXM5knNOaDR9be8/3aRZ1pBw4fftrHb7yRGeQy5y78xQf+6/04KsX3Ib8nCPrZ3Xl+q968Oilbj58pr0nb6oZW+eF2c7J80EWVLFZdGntLG2aNNhFWZNImyFJGP8Nvsh3QvlvN7qlIGtpdcDIBOiSHg1qqhUrfLnKBCg3J369KvmqdTK+E0SsrPlyY9LHrLA49YHt3Ach9O/cs70GMwZp262xutAJ1m/SXBl1G6lew2aqXZ9FyYYN+FgDaqfq1Few8RlIYBgCWy1ladHSX5NWzfiHU4PVYK7IC9+FkFm3cX1SoYEKIjSJugoPhyjer16bzeaMOkpJz3AfS6lCxKLmigpiSMtqmS9kanQM3SGpLyA+RXHMEWsgbU6OrY4pRSoRkNRJKk1Pqq1ejbuqKtRDRCIpAtDFUvg3Z4N7WO14jULjPaROFY1tWVeTaffH8wxr3UitU+O0qndzXV8+QZcWDNfKrvU1k8sO46BI2lXl3iJNTe4cBSFBS8mrIGw4dU84USSE0YWjBWDUw/lp9aX7M5mLDXHdvI1ayZYgbIXdAOgHJ5VIt3kWQ9qZfTuiqwrU5snDlOBt1IIRosZdeR5Hir6vKOXvMiWpLV2ks9iyCAO0GBxg8hb20ohxK3T25vc6dvVLHbvxhY5jAHwBwZ95hp2+9LkOHbmtG/e+1vn7z3T28Q8aN3uJQnxD2d7J6SyLCtPt1cIWYem49oglV2LAkgL1UNzNJu3f4k0aDODf7o11UZmC5R3AUnxLaky3hrwW2CaVi1WBsog9A31UOy5IhagdbcvHj2WRv5Sm4zBgBYcGqUuvduo7DGqhPw7IY/qqNS9AWp26RKB0GHfIUSJWZkSqSRq0KGb8Vo3azBQZ91g32BtCdATscv1myF8o5IejMOgzpCddIuBgudFGOilp0A/IcuMtTdatr8Sa8CO1GWijdoiDVkiJY8gMj2VW4DZHDOeJRGmRgB4/IZgaCnlNYgoCNNJuUiyKCJqCxmktnbS5Bn+2cZU4V4u0S4pUkj+GJ5WZ1TEWKUqhWZgN7uLBiSrH1yiNn0QkStRqzEBTLLKyB5gR5KNh9Wrq4NQRjHhmaHbvDqpJtKnMi1C5EEU1MmMrpo1iCGf1KZzoZbSAT9GyjsMyVYCBqwIRzm3a8NPviyq0eoCXLm5chDNPM3WoHotLz1AISVLnO2BZsfzn4xH32eNfjggIE+6NtKkTC6tTOtZTVIWSatK4szauP86FtWs6d/Vznb/9lJrqe136HAnyuRvad+62A9TFhz9o297zqpPWnGVY0icq1xwffsBcuKbWbNuv+Ut2MSZrinfYGk3t2swB27pQp2Cly7MOsWKBYm58Zak+tGg2je/WCKkV/JVPggqWCyGlllc01Ez+IuwEoCurzA8Mjn5eyoPYLIgB6aARfQBBd17sZNVuglylX0vqpSqw7ryYRIYEujZbfkhCBGizvVoZ9V3EMibewJVCi29arZ4DOY7J3py936FHa0dDeIbX1VwtFp+azMCaTWj0X7FmFGIFfL36gAiNF5tBxlUlJ9VwNVQMgLSUGoHKIZxoF8mBTdv4SeQeYhBFflQyXSj1mtVtzauk4UKXgiOLD6RiCYrJCipB0V8iqIa84prIN6WdfKq0lz+qiKBaPRRVf4CC0XWFIr8Jxh8iGj/V5IadFMGYqRo/ONYlb583XRc3LEdVgGgxhk3w0l7M/3jRy0EvsCdoKS+8onVtnlUtH/5Oi1hGHZhQz4a6XtRRKfgk3N7NUagmiBxRCMznBrM/nVhmpPpXYBnIPODyZ5XKj3TkjQJlQpcWmt6lAdooog3b0sXYjg6sHIU5HWraQVM0d8FmrVh/SAdO30fw91wHzjxR/8HjOanLD9QnbEmzaW019cQ583T36+fo4L/WlqNotnpibLd8Ojr8xSiAEx3Za4oHm1Faqi5jG9l0fuVRYdT0K6G2GQnKXZqdwkoRrIEFKpHtbp/iBVSI/55C0BZuS6cMxVohCq4w1qnbduaIOMV5GmmufvMMok1f1W9qaa4qdRSRKY2IwJNWp75SiDbhMREKiw1jtFNdrTu2d1Eqo1ENpTeqqhYd8X7v24aCnr1+6quM+k2dlt5qLKMZqtdBsmx0BKOg+OoU8aS2YCQ3tsZfiRuKUeFEE1Sn8YA1mVRoQ+0Q6qcIgB3NLcQYaIiImCooVyNcE5BEGg1FlOZfnm8EdUleNrCLB9dQUTy1SqJKrZzUVP7sLwbhtRWMVVJgnc4KbNBDMfV7M53vrRBOuPg17i1/7JjCOw5W9RFTlTh8vCLptlrgErh34VTd4grajF7tVT0kkHqnvCNNrUB3xTrkaCa4bJvZIpix6pbCKgC0YGwUb+/dhDqjKjPPcBe5fIoXepf6PDPC//QEEWVtgTWhUiU3I+xTN0HFsyINxggtf04G4xiEFM6JrwLaMNPXVy7rrcToaqpbq6kiQ5OdfVEp1Bk5/5ZFNas10Ancp2kKde+rtzp84LaeYX63fc0prRo5gM74iObgheENQRzOIoURpFZzlYHgLU1NVjLLR2jJuJ7r56UCvvEqwvZVoTI+So+spApsehUkqubh76rk64BVVjlzZcWnwU8NmzVwXV2mJLkeXWGr9i3djLBx82Zq0KSp6jSoj3VOKw0Z1Q/RH2RnazZxWmIROWwQKXCEhrL9MQydjz1N2FsLQSZj6lPTyxtorG6rkp4GqDJU1fRcdHcGNBtMByPdMXCZk2Ay0SkVuXJ0fJyTRkcmp+CvhTaetGdkaHRoIpN85pI14LagNOKYT5bm9mIODHnzwmcVxperQGSaKkVkyC+pmfxS2cpO66YgtnwsOoVzsSysYQfFNuvI2zaKat5RMS07K6xxe0VwySyNc3NpExaqxkjMMfBZDa9B9G3ZWPsWT9CuaQPULjlC0dQgkRVMhVBGEbzwBq6wij5utmd7gBbdLHpVIooFQqyeXL3Q+U51ZEoxoGkdKIqC/wImT33lef6IZMbAs47VGDfFI/PHql1qvAZhZTCw/xSlpKS7jqwQcuhCTAVMo14S0rYMvldFkEKXZQZYjkhXpoDJnovSzOBXhmlebWiaZi26uOscS1ds1LzZuzQG79KH8FSbx/WjhuPfzH2lsNKk+JKIFKgdbZs6FP6qazrALuenQnTphSuHqDQZr1EC0QuQ5yZaZcWB0PljGbDy5s2twGCOKzXgxSZV2UzQaiGLRMbGZzSop4bNm6p2w/qOdrBZ4ii6iFGTB2gAosCO1CE16iEGTKOzY47UFlPWoRMGMbZpoZYdcfnjrf251IxUDR41SG26tUWiQ+QCEFZnWdHfrHU7F7382Te0hVbrHFOITsm2yEEKtXW0JAbeNmM0QWBkDIrU4DgWa6E5EAoaR1a4DA4uFaNVinXyImV9VMI/XOUw2vVhecMvvg5GrA0VTK0RWqeVIhq3Uzgn8wKadlYw3+QQgBXWuK2imnZRFO6CqX0nq864pUoeNVXR/ScptvcEhbCK5s+GzZBurbV//gRNasu6GtvMYfibewDm2Ql0ox3qLl/mbFZn2Qq9L5LeyUw1QksUwj+slrryvfChPf9zAP2fI1ZomWIKgA4aQUNxauFo1t/qatGCo1q15qoW4Ys1d+lJbd11Q1NxmAnkB+qj//pYH//XB/rwv/7qljryYIGU/YOs+G19zFLrxypEN1kEyiXvZyx85MTQDcoie1ZSMrqvkQ3T1Yf6L8EfQBFBjT+zH4xyTA3yfJZNrbh635wMUhCTY6tVC1Rm9EZdWg9tWX7UFPmxuMyN+LECwKQrLKUC0A0hUPY9+3XX6MlD1HtwFzVqVZ/aCQ08L3rdxo1Vp1EDxjWt1KBZI8ewN2/X3OnfB7Mt3LFPG6ViWGE1U836UBAN4L14W7tJQ5cSR04cQjMwkDRZCxqjlQYT1ezzTTVqeiubLaZnsM8IiCxqGddlUdM6wjge+3gokcxUDha5IlCd2u8HY0wShH9EHN1gKT/MKSpgwMumdTx2S1XYWq6D4WpGUGXVxG2uFk99bBZb4hvRskZ1J2JsVJd1s0ZEqXodAA3AYhcyHP/UkCbdlNJzpOqOna3qY+Yqud8kJfQYq8iOIxTUrJd8WE+rVjVFk/p11tKR/aiZME0pVgDuB8Gkm+vZKAQ+yNKjDZCpvWIYx4wwrojU1a5GFbe0aqtfmUW65+374LKoRfRCXOddqIhj7HdPhrRu3UHTZuLiN+O41m2+gP/9U1dbVcF0uDBLGB+R+j5iY7lW3bpauXmLNq0/oDl43fcbNFgNGzdSNOMyS80WgXKhtc8GuZr17/8Te6ggda6GZVQyO6J0hcabmVbMRlFmhVQS+6JBLWrLzzdYRfE3LcQWVT4s2htUiUAMUN65AhamuC9CB1kZYP6lLDk0PwsAvpw26U4rPHhsF3Uf2Ey9kFQ0b99ELdq1o85q6iJXm04dHI1gzLrNAavx4nTo00Q9sHQ2oFhBXqNeXd6mu3SXAgVRpwmd4bhhblBtGz7J+GPVa97IFe0J1WDkeZFNvRqC7DYEbwjrAmMAVgiarAjUD9VYO6tdh8UOIpUtXcTXpDMkohonFsXvh7KrF0xarID/QVJkEDaU+YkSOfDR9GHBtQL/obb2/ncWIT6AyMwC010Ary6sFuND1L95bS3EknrF9LEaNmyYUpu0UQSXYv3qd1IYlkw1R89WxvA5Su0zQYlc4YhnMzu8dX+FAL7g2q1VPro6w+RoraHDG9WxFbolRiAoFgwQYaRGa9Wtu7JiOJHt4NGUDZUZBJt3QwJnQfwgWzM3nz0Uw/u1lgdYFjmCK/jr5PLZ2joBU9suXbVk5UUdPPq11m09qiZ1Wjt5j0mkjdsykd3a9bu5gf1S19nNvf3suW59+6Me/vQS8vRH7Tl8n+NZj7Rp20WNmbiEOjaeJWV/zURc0Lc+W+8oFGyDO4KFWN8SBTHa5aIXXl3pNES9GtVUiYphZIJkFfWLUQ7GTN0aVkEty2IJg+6CCCALogfzggD+i+XofBB7AYHBRI06TshXlRe7BtGqdkM6oxYtoRnqqhoq0iha+xgUitVg1o0tb87A2bgs++lo27mjK/qr1PJo4q1TNIVpAnxQk1YtHFNvYDBARjLzi0pGnty2hZp3aO9MQsw+yR6LSjXrNXDEqK3hV6XzTKYeMyBGE91sDmkRzmQ0pt8KZIs6lNN34TDdJTAy82J6HwHz68scLn/2LCrE/l9ejGGzo7H65IPcmMZm1z/Rn3/wP/8LTfrfkYRkV/PUWGaHo3Rl5wotmzVG1VHEBjbrorhBc1Vt+FRV6Tda1fqMUCxD7+i2/TxRDV+JiIY95ZXSVoGY/45s20irmLG2SuW/oxTCOXb0AijqbZhrM7iqAeU5dNVU5bJ+zIY4xX/5woDQCEkjUf9cWM1cXs2MZH44uKRSGnx/+YKWjxytUcPma+22q+rRbQiREMEhhbut/dvibFe6u1PXnsC4/6JLj77X6Ttf6ALzm7M3nmEd+UirDl7W6n3nOaG8A35xuKJQ5jZGBboCb4qRrZAnlS+BUhVyly7WJgxeNHalEDOWRc8/oU0dxeBRWzCwhoqhKilKtPIJrKyOzDzzYh5nK3HFSxZh/Ssb0mTnNuPnzBy8sJ5JpFZJ4MVLJEWZNstkNPY22QpsvBzsQpj9uib8lNEQ1dOhCdJqOTa+QbMmGNdGOA1XV/wrLbJVp3u0TR7bTTQZTeaYxwCSWKMaMmbI0uqMaPh7wyjSA1l8NWDZLLACETQY8aEpU42KsEhoqdM+JyLBs0Rr9EQi0c67FLt4eT6ByeYQArxPCVxVirCtWxQfz0K02MUR3xWDwzFHlaIQnlbkmhlGbiwa8/zjE/RL/0PZ2HROpttZPX609q5aplGjRqlJtx6KHDBLqYNnKqWrAWuA4joPVii3GcMadlNE/e74F3TFEKOzSoTG4k4YqSVE7wkdaiuyVGHWtgANlISNShomhGLg215lc3ymJtXYw2QsYoRrpnrU2np7Mtn3TGBVLExN1rKFXty9osk92qt9804K4YxMsZyslX1WFOVoAVVHjrRy3SHOEv8Cd/Wrjl//TntOP9DGfRc1Z/FmTZi2RL37j1aLtp2VynguOCVEBcvnUMGSn2hme6wMuHkY70/6w17J1sAM6NaA+BSp5ISNtSN8GJ01UllMictFpqtkQIryEEVbEERSMdvN/l+fsLGElLtIfuUskBO6AUc/OzZeBO8GY96TeeGsCzOlg1v7opuLioNXwrkthtqkaavGascuWj24GKMhjJ4wBt5mhSb4a0U6aN2pFdqsKp6USbFtDYBptAxYNtpx4AKoRpJa8W7AioWcTCRKuprLCFGUqGXp8CoFBDk7JQNd3WZN1Yzo5maEzBwNcH44DoYjjSlLfRNQFqsddvXsp7c4JrFlcsEhFcQzobivfDAW8y1cDta8kiJMsckT5hXg/BC8mftVxtHFnPDy/PUTFfjrX1WflLp20nAdX78Y7fgk1eg6ShHdxyu6wwDFN4fvaom1T4u+Cm7QRoGNO6kyNVoYTtF+zDl9vSqwuZ3hdFe18FIvg7y5JJs4LTgAMBklSIUsf1P7NKJtRbaP4ZcsYtljoHp/1T4zRZZjCXbq4P46uHASy6O4WBfO67RVJjsOCKyi3gPmaeOOS9p3+o5W7D6kCUsWqw3aueqUIEm1IaFZf0/EYiihBVE+I0S+6cEqX9VbRSrkUc8W9bjWMQB/1ySVLlYIq0n7dzC+4pZSxeKV2B6icMcIZFqvRoqhji0Z1ViVQmqoVACdYeUgjUHVUomNo4JYIxmwCqJazZIrm0fd4I2C1E5VmAdpNV5ki0wREIFmBmJSF5v5WRRLq1tL46eO1tTZ4wFXCwbRbTR28kikx30cMWrgGj9tvNp2aeNUqJZGjasyFYTJmU1xarSBEanWCRq4LGJZPWagso+ZZt5kzUY/lPf1d8Cylf6QWACEfaXNHSP5GsbEB3GiJYwxj/3alBmFIHmLsX3ssVm0VSaPQ54/PgQmR4mED7L2OQjCMqL8O0kwZ11CqIX8mImFVwx00hTjcCpAQOb561/UmAi8Z+oErZw6Bp1aZ8UyY4vtMFJR+CXENOlEuuymQOqx+OY9cVvpquAmPeWT0ZY5ZwSXMkI0oTv3hUizJanxWhLhR3dpJ6/s/1C32oysGH8EYZNtEcKiVmaEclKVdzND+5jVYX2bNtSEVsxvoYS6MOtMZAO5ZL4cqtGC/Uz4w4yOLVWjUwPFt6rGfl+SavaooQb96qjNcGiFca1Vsx9eGG2JqO2TcIdhTFYTzpJzvydXzNeaiQOYo8Kqo8UKqcREge+FP5Jrv9LeyomLTacqkRoBbVQUN8ZyCZ1UAbl4kYBoVScL9alHMChfUoXYEs/9CQJCfNZyF8TTgaDgrn8ZsCKpb6ry4iYQDWxj2YBldUxyVeoliMwMQmjbTq3htVo4XXwGixZNWlLUo8my2spSoSNWIUlNVtOQLefaTbBFov4yMFnNZVSGAc2AlEIKNVBVTa/tVAlWQ1mKs6iVGb382M4ODA91xiMGLuO6YgGoF2aqJWG7LR2aNquCDX3RSXVGgz+qBaYh/Du6k67T2UAJLorRBV2VWQIZWx6K0D+kfGVXKNsCaBw0QbSPl6KxHI/0rgyRWRyvCW+lI5POiolrBXxCB9dO0c6JQzWwDxvMLHVEte+tyBY9FA7BmlCvrSJJhQEsj4Y07KOIpgMU1qCLAuCLyjP66QbvYxvEHTP43pIiyudBPVofCREGG8HUXiY7zoxYmVHq/WF0MAqKoJJFFQ4P1pOZ6gSEAjN7NSXqYV7nw8Z1LCOlmrDfrRNUq3ctNRzVSE3HM94a1lhV+vB9b8NuAT7sDRskqlntOPzFkjSqWZp2sSX+3dld6snrVQlVrKkybGRjhGhgaR8Vp2MM44jAxuE9Wb+LVLmUZqoU1VIVo1uqENF+eLsMhIplnLV3Cdbu3cIuJVWuAvlUnvT/l3JwL3YIM4aUF0dUCEUabLWURS2Tp9gYx4Bls8IkIobVWzaMtsfY+DoNmRPyQhp4LGpZpGoB+IyeMGDVboDpv1vASHPbPTZPtPoqmSbBli0sQhl/ZcCytwYsA139Fs3lCwVimiwbcjtJDCnSCFR/tFqVOSYVx6/tp706xiRrhnfVVTZYruKYd2rBKB2bO1qH0I4tYU7ZBfWEzeWcs4ttvcCWO1Cx1ZvMRL9acAjiQG+n6EzgwkIinM6kvr0URTQrieYqL27BkUiD5/VsrplD2qsavlEh1FYxuN6Ekwrd06iji2SR2JCH1emu0NqMiWr2UGU2aFIQx81BTTG4YRqnjfOoPhvQ5dDARXC84Y8NHSew+7PGssjl0qMtjtKM2PqX+Syk8rVmcIRp++h+zn8hIiNIdTrAN7bC9RDP9XqNozibHK1e7ckgbDovQKi5f+Uk7Zk/XgsGddeE1o01tHoVrerbQ5unjlIDTI19CSy+KCcscvsyOC/NQN0LlcLOicNpSlpRV9WSV2ILuMImMO7U1DRuA5olQMJm0aZpUDHMBrP87SOV4N9oEcsLoxlMQdjSYaAYSRdm4IokMsRTTFt3aIRoDWiDtDqAB2LOukMbQtdrxOUIQJVCBGnaqokDTTw+Vxn1G7mhtMlqLDJlNMLluCEW2rwQBrT6TRt7ljKgJZLYWTSwWB2WWrvuHykwMy1a7VWB4a//u/MrIezR2Wa0e2uzQza3bcOoOgTlkmG9tQX+bUqXpviXttNsxhJT2Wiex8rSBja7t09lF2/8UAg+pDZFCimaI0LRgMgUnukYtFYDpEkcNYo3QR6bwUG02YuHD9bkLh3djCyElFmcxYrCH/1VHauEaQX2iV2o9yLwmA9oajNGGHzqrRDuORofFlm/lwOWL644lWr0ViXkP/5QByPpotegq2+dFufqJFuGtWhl6dCIUotUNgB2K1jvbI1Mh16xDKI7op/b86OetP3CrSOH4UA4Vesn4m5c1Y+US83DgHoBO4e7l0zDknKuNs2cpNmoIbrWQqIUgNKC5Vk/6qCgwvk4RVNarROC1SEu3PlIVOTj9nd4FSvvDjWN79FJV7evR4VSh/+GjvJOaCHv+MYqzwLLlL7dVSvItquz6sLmtRoJN5mdcygFaTSymYKU8uov5fgJLsxSgJ2Vs5lcHFRADJHL1uYbk+pSGT+ksTiRQWdmC6s10apnarOq8OLHJHoimxXmRiVUgWcycaBJk21sY3Ia470MpCapcStjFO7V2Fc0UJlsxgp2i1xuIG0dKZHROkVLf3Yz0Z20YxnDrLyDSdER0BBBpK4gNm57ENqHsFHUmpQ7lM5n1uy1Wrh4kyaMm6xayXFqEFBKIxulat3wHto3bZSLGhEUqvGkvTR8vZqEBSC882bTxxdLcB/UngyUGYMMbtOEU8WL1ateNbaL8J6AqKxcoKCTm/gAznl0f2tHt1eVei2ZPbZQaNPuioA8DbGU2LijewJrt5VPjZ7yZvmjchzby2XCVZM6acOU/lqCj6gftIRpz0vgVuMUBVZvvZPMeCTCJtWhuEdlEMTgO5aCOoSUXwmGuwk/XBe5G/lg104N4XvbgA2elrERSHK4JRjMybdKxeDKCtAlF0PoCFnM5bYaXAGJrwQ/hTq0IutsDeiCTS0xF5lxOs2bzQTzYw9uw/a7B/dqSP/e8saK0i+tuyqnwpeF1VbzBs01qy9Rm1liJTaaVo8bocNr56t53XrutrilQn/TY5XnJ6Mo/1BbWDVuyoBl0crxU7asmp7qOC17vwY53lKiOdLYzmFCFU/36PlzrHsBKlMxWAQzcDlNFp9rtVQDWuY6TZu49zMLdXtrj+OoTG1qQ2pzDQRolipts9oXDVI4SopyAQEKTYIMZagdj7Y71LZoAoqpVkNOyU1ZpYMnbusyB80vwd1cefCMYesj9YCHaoFRbucuPXATJLLR3ZzjQOYY/ERtFFOP8YypOC0NxsOYG2kZQwQPoLiPZ4fv2s6V2jNnorrx3x9M/WHjGT8MOsoXLKiieES15fuxf+YQ0g7eXTUbKLhue0UjZ4kkejk2vy4KhrQ+8qveSeWSWqoch9lteFue+dqQ1k10atkM7j22VRkuZmXD1aY4WvqKHJO0AXcYzi8RgMn8E/yR5ljH5jFko+aifIlk1DMWh7/FTElSqXUSERymeYWrAcx6E2iPlswyW6LqbJwazYJJjFoExSiNlF8riPRfoQT/raUVUyKv5vbuqR0zRnJ+ZTj1Jn8fpO6pFXM4eDpTUc16KrnvdMZdA1UptSf2CHFai2y9Ht4M3RF6erOcavxdl3px6tS0PsN/LMBZ8K1IafKXihRtBWlp/enAbH3eyFHjsayWsjTYrHVTj7jPaiL3+x6rIwOb1Vcmp8kEnEUmm+sZsAxUVk+ZrCa9vo2HMtxbe6zmMldAq51q1keBymC7Vv2GLoIZyCxiWZ1lXaKt/ls3aZxWOT/SFe/H05EURcLRBH3Y8nX7dOz8DZ3jGPmZq1/o/M3PHcAWrNnB2tpE3br7SN89f6kxYydxkCBey4f30oVl05jzNXH1VAx0S4SpKWixY6kzoqivLD2ZU/EyGHVLqcHwM1ZoR3mhnrCtGeqtytRIRdE2BcNXLaKOWzS6r1uJ86/dRgGNBkKg9qLW4s9yvsWvamsFctmsMrYB5fFRLRrK+IXBchyr9jPhpnbNnIDfZ5rbwjZCtygG/t4ICi19mibKSNJgGHHbiLYX3qtoESJPGQ1phDMPJLEfzHsSZ2PS0MDXh4Kpg7auAT+AjeIi8dLiQc7djh/6jBg/eCe8Gsrn4/YN3vKB+RX7/yXsrwPrurNtTbQeNL3uvufUrTpVSSpkZluWQbJkkC2ZGWWSLMmyJJPMzBxmZmaGSlJhZmZ24jhO4jCn4Mz3fb+t5dJJ1+3+Y3lvydLW3muNNXHMMQvaJH7VSqS5l2Asrty0Ip656boYiczUEDLg8h3nxeBlp+EK62Lr2lWxC1ZGX0RTrqLn27/dEbENZcbZI3ozef3foh2JkkuaOvV0dS8nsQVd8H5kWsZSshgsemYVeDO/Shigfk+qjN/Xevm9hoVzARnj901kQF2i4NJaGcgvW7MqxVo5OjOMBj6c/58GXmGMGpMZh00lEZg+u5JCqBQaXPE4+O2A1yyxAIpyX2pVZqgqBspEHTh0cBJ9O+usm+LRp/fE068BrDffT1TcZ1/fHY+/+FZsPfYcxqBejR/Qbdj96bfob+5hj98tjJmVxomk7o+dRxN5RX30ByT9yRStaynCMYh4RoquNJAGep9nspG0F0U/WZxaKwuekt8M7F0U2ZniaxtWtS2aVBq3nsGgyYrF0Z+R/5Lq5VECuPqzYaMEDdXi8XOjF/uBurOsszv6X10Yd2tDYN+JBrNx3fmM0r10zUWo/C0k3Ye5+rvf57hNTOaknmFTBmn2VkRa34gYiy56KDsFR2LhZlEumgGnrrIMGgvKe5OZmrEUMKJXS1pfvWHaskp5Vt8YMW0QxVxuklnMYs4dGXkDWvKZjowqNmXsxO0/xTifIjDtJ8yPsvptMXr9CTFs+ZmwWubC7DiLxU1HpBj1nnNOJnvuiuWaCFujLNr87t/gv7VJOxA7uMVeYKkdWczSHbM+wZUCdyyJMZQFUutYWqnMmmnR/FmDfK1Y5g61JrZutFQyIhZR+/G5wDJoH4jUoeCSbSqoHLowpppcOQMmxLxoxNdPrGT8i4U/Mky1UqrQWG7oTENXEd3hYyYxMDE6VtJmefCJD+PJl/YApg8SsJ594514Y8++uOLG++Ka2x5Ar+Cn+Oibz+Kld/cwf/d61K4+mYb4ZdBONsRxi+rjrTsuizMY/ByARehHLGfqP5gpnAFUoB1xl5N0JQOdZd1lepKlMfHcH6KcMUoRR65ZiyILtOUj4Ef1ZZefpYCrT9gQ07HQ/cobok/N5iggPuk3cR7N6/nRFRXprgzpdmbKu13JlGiJcmE7WAKHM042BZnuh9m5/dZtVxLo11HUBbQUQgWvBMJi5gIV8JhMNnkCFnfGcKg6nQ6CMTsAMeB+ULTpjw7rig5GZ9SBUOEbSlllap+YuZ75hOVjo24TlJnNKALNHBj9obpULR9P7MTSS+YEFw/rG7eQBFVNq4pOTKt3n0w1niRkKLskR9ZvihsuPpuRtenxh//p32IqIL7jlGOQR+jLGhp2Ss4aRfmEYV6GWd0J1IbyCNTkTgCrVVorJ6C0TIJmLCnpwCGDUiU+s1QCzecCywDfDFJXmB2J/rJgQWpYCyitlso0s+eyqYtCnu7R/9Oi5QDHAAQAmjBzUtQtmc1k0JrYyCaElWR1y9avSr3B7gyfFjN4IZVGgKkeWD4T9/HgK/E82ptPvPQOlmoPwHo33t//KaNOVKBvuS/2fv1tAtbb+/fHIy+/ESeee3Ws33V+3PPE7riC/z+HfdYXMnHy/GUnE9A7bNEG15OXgveBMBFKmertAef9rJ1ro2Y8HDFmA1K7o8k9JcYnDWbVhvvSAFfSUUFYNzrUIoxy1UkwOpbUkIRUxACWsPecvDx64BLzGXHvht5XXllFdIYl0LHfqGhVNCJa0tQ9jAKuWqXLq6bFK7dczVQ3rITqOVGQxszQYSC269uyRazi2iyfPTG6FBwa/Uagt141NNr1bhHDK8pi2jLCj/VMoB9VH6N4PmLOoJhY3T/WzJ0Qi2aUxsx5iOXVDI1eEyjlzOLo1ymmAsCjIGiOoefacUhldJvUGP0mL4xiYkPrc6vXbY17Lj8ThcM/Ic3dguXyI+L0VYtInCB0jh8eO+dSh6TJ3pnBkcMRQelKOPEbF/z4RV/WxWmRssB8NBPJo2gg6+qMoQSbgMoF8VNTwD5O5ifzfJYdPLRWc+bPT6UFQaWVGsFqE9s9E6fpIimKkm1OmjEpTfgsWLaASv3C2LRrfSIG7jhhXaxnCnvjzjXwtrYlAOYRcHZCm6FrIaIVDErIiDj3otviZRqrTzzPXr6nX0zW6p1PPo49X34dN/3lMWKs3fHV379FtufneO2DfXHPUy/Hii0nx023P8FY+sPx/Ad747Pvf4jzzzw3Loby47aJtYi4OmmsxZqB0K8cK/lSC6aOjh1LF6SYKmVtBM7FuJ+cMgxTLGRzrrgt4TxasVZE5LdMvyjIcc6K2XER8VcF4nA9R9VGPml7D1xit8HTo2v/crhiEPV6Q/lBIbo98VHLPgMhKfaLf1dfi7+9ZdH8eP32a+Pui85kyJfdO/RDqxhYXTxlKIwOlP8m9IjhjWOjcvOc6D6xKKaumRkVm5CbWjclKrdS9lkxiSWm7KOk2zADMeITULhZPYcuRzVLTsfkw01vHzVFXaHwdIueULm7DCiPDiPZMzlqfhSNWRQ9y5fF9NrF8dit13FO+kYrVtuVtOsUm2un0raaGdtgh8xEI+tEZiSXUGLqTNniIJaN56vz3o0KtKLwdqR1bZMAQBUtBEE1EpqLLR0DdoN5M8HUG7RUAJCU6BZg9hb9Wgtk8D4SrpLWSVDZhLZ6XkkCsP3Y7bFk9eJYBjFw6zEb4gR24u06EcbpCZtii9Zq1/I0JeQghz9TNrIMOs4kskkKkiNo3NIRWIFG+SvvsJzotT1x32MvIjX9anz49dfJQj316tvx6AuvxNf/+DG+/cdP8c7Hn8QLb30UJ519TZx81rWMmj+BDvq78fG3X8Z3//jP2Pf5t7FjLZtKly6Mayk4rqLC7jDpcWhUjCOz6U4ZJrESiJv6ogjsVLOcKfWjLLLqOgtgUQzEJZbREnFGsBiCoZPMrWhxHEacNIse69mblsZKZjKLS8dFjzFaLbSm2BHUtR8XA7ZAxwLaPgUlMDLRs4JX1pblo4eiffXvh8M26NSG97g87r/uithSRezbjRpUSXsoRZ2iEGs1GmBNXwP7Y3ZZ1NK6qaOVUz4f/tpEuhMo7nXFQg6avTMGoN86rl9pXL5rQ1RNIBPuc0SsRg91TD5rS2CytmCMq9uIObnZgNELogeKi32HT48bzjgjztm8LClEH/bbI6KOJQgbmD+dP200Oxdnx7QhA4gL5yAJujw6dmkbf0KEpIfBe6cOHZmsOCIFyZYaFJzdvANxMyroAmksQbauTmumzJGWTIvlOFhGn0l7DrnolhpymWFO+NbYSuD1pzVjEnDiacdTGjgmjqU9cgIthR0ULwXUJmS5tx+/luer0nOJhg51qHW6lYLf+m3Lom7RvFiwYmP85fHn0TBH1/zZ1+KeR96M99n09clP38erH+4HVK/Fhyj0ffP3n+OTb36Mt/Z+EFff9STLH8+Nv9z9Qrz6/qex5ztc5N9/jB/+9kvs+fTTWL3zophJJnoKbuuiDfNi2cSyuPOcE+MCCpDWdQZRLD12GW5ctgUBtIH0AIJXMzYDeZmXcqYKiH9shfSlwNgXgPWmFaPKzKFkS/06HBlbWbC0jXM7jOmgbuiv5g2vj66lU6MT4ietWGJ1JFr4rXCHrXpCpIOS0p5+Y+uCwQlgf2Ac3n03DayZ2Tp9TJy8vjquuWhHzBzPvOVErlvN4JiyaHxMms8E+bjCaMkwQ3tWxwxlb/Yo6DUlbL/tV0O7iTbTBljCJ69cFMvRLHPf5JEwQw7ugeYq2mX5sG2LKIK2GzY3sW431dfHwyfvjOIj/yP+2/9+KPJN+XHsXFQdu7SO+vJhcTokhHIa9jcdt5GdO7uiC7SbP9K07kky8puu3IVHIH/Yj6HQibRaJkziDqAP2LhsYeKyS7AzQPfQHQo2Sw0egkzrpKWSveAQ6+jJ1FFoWtbMrU6shsFDoRIzzTx77iys01qC5zVYKMb1T97C3uLNKabazELKLcdjsY5ZGesA0uI1DbGO7adb4Ddt2rUoVmxojFWbN8XVN9/DlO8PaSDgz488Hq9/vCe+//t/xnsffxrPkBm+s29PfPnXr+Orv34f7zFe/iQqLJtPujKuuOO+JKb/6Tffxc//+Vd+55v49NtvCP7fgsy4M0678NY47czzYgvgOh+pzIsJ6N+8586oQeikK7Ul3eQy6kF9aVCrg+4YerJePJfD1I92kb3IgV2oOeEO+zNgIFe8G8MU43t2ZgcPQwf/8/87xhV1Y/Ms7FU8Qy9qTp1ZApo/aAKTRBMB1Zg4EpJeW/YaHsF0ccteZFoFrBHJHxUtGOA9iIGK3x5J8ZZE4o3rj4k9953Msso1sXQoiwlmDImCIe1iwvDOsWP6iLiImtIKh1+g+YxccWyUoN1vR6CIxe3lFLSv2rkhbrjp/pQ91yzdEh0Y7G3NOuYOaL8WskmkO4PBlbBcHzh+dRpbm9qnd2wkLLmGcGVr48IUZ82fPDTOZg1MJQs972Kp5k0n7oxO1NgOZc9QF7d/dUE89UhqQkUUBJXjrpiFj7b3B3BkfKr/LgdLl+gkjBPPxlojEOeYXjWJaWlE1GCFGjvZfDY+WrNlOQOvy5OYmttY1buSxnz8GTuwSMviqJM3ArLNuLxNsQ3y/ubjWAiwizW8OxtzwfuWZVgtwHb0+lixeVEsXrskLrjq6niDbQtPo2d+50NPI3jxcaB4Raz0I5boA+pXb8XnP30X3/3nz7H3qy/j9d1Qdq+8NS696cF45cO98en3X2Ol/hY/IsD2w99+irf4/bMuvAWreFa8wut+/uMP8dD9d8YFx2xJJv6OM4+Lp266NGV/1UwiHQ9fvRfBfGIAMI41gDqXE9Fp6rlJO7SY1pigS2Ng6rPTc7uSVtLJuLJWv/1fYCocFEWtfsey9AG4knIq1D3jSKaN2iIo12HAqGhNCeXInvD1WXfctveQOBJhkdYFrDZBC6Id9aw/wZ0fSalg73OXxTOX1SGcNipeufncuOHSXewIZIcg8khDkKacR4b30I0XRSX08KJZi2iKM+JGD7MPOyCHMsR71c71cQrynft/Yk3Q87tj2Iy5WDimbvrOiDalxMTs7L5250a0zIrpm7aMrazMuxJ28VENtNlYdNnxkHYUh8dADWL4dtTQRJC8cuemxG44DHJlFwiOv8mD4diSbMP1cuOIo9QdNYDXOjlkKoAEl+PzDomOQ/7RjHHRirlYnjVw4yvS/KAEvzWbV8cCFlzOoRo7lB13Ul60ZrZzZsPlOu60XcRW62Iz4DGO2oEewk4sl2DadOyKZLVWbSUeAVhrti9P318FF+ni66+Pl9/5IB5+5uW495Fn4qPPv4pv//bX+OavP+ECP2Mbw5uxe/+++BKX+CUB+/uffBF3PvwkoLqT38OK/fRjfP/XH+PHv/4S3//y9/T7T730Lu/h0rj13ifjzU8I5n/5NtB9jYcefCzOPGY7E8uL4nbe2zFLG6Jfy4PjQuJDGQ82bEu7Ik7GDF1fmq1FWCnBNYjajUXMQupifcju1GafiQDZ3sfvjWNXLY4Wv/tf41jEVSYVdo4W/5//VwwmC60eURgzmdoZgKBcm7wydv8NjY4MRHRkL1Eb5Ig6ArLWbKhtgbBIKwZDf4tO6I7l09GbuC8+uGFhPHfZ2tj/3CXxl0tWxrBerdPa3cP/f/9HdD30f40rztgQZyP40Z/ywcBqWk3TABYlj14kQtfQ61zRsChuu//lwLjH9tMvjCNLRkcbSiBy4s9sXBqLJ5cR97UhGz44FpdPYBXdwrjtlDVxOeHJJOp8W+GcnQOhc2PFVNitj1ITXMIWOaSUDv5D9KRd9hu3qx5B0csNExOUeYTBaUxlbJSq3CjIWMfKZYC5wdXBI8rgwtcw7kW1maKmdOQhtFuGjqGfR69qJBykGbMZwmAPyyImdo6igt3AzP9a5AaPRjUvC9S3HoulahIg2cRQwnooGrrC5ZsZ2oDusXLrApYKXUOh8+W4kwv+5IuvxFff/xTf/vxzipE+/YLR8bfZxvD+7vjiZ2IngLaXgPyZV9+Lq2/7C2zK9+ObHwjkf0KXlELpz3//G7//13iVqeEb7ngC5ZwbUpX+M9akfIM4215e24niOZz005GePG/TKiah2dQxpE+S+jkd4f8e8Lsd93KC2TjLYD1J/lC7sfZVDCVZem8xfcVzUbn54J7rYuc84imYo1fp+qmwt//twdHxIIY7mZrp3+7gWMkNvKGyNgb2HxxHdC/GFRJfMQXTmvXIh5IptqX9dHgnlnujq/7kn0+Pv751a7xz40xkU6+IDx9YjfbCylhZMTTpQyybMgy+FmCYPioeufLStBOpePoaKv+LozeZaXuYnxcCuM3z56E1e3p89dVPlGBeiR6jZ0ZBYd/Ygdeqp+dYOLRj9IW3NYDVf3XzVkZddUMctbQWcV2Egdny+gCifBfCxTtzwex44JzjYzmVgLbEa+4S6kJH4zedaIT+E1i4uzG5upRZoFmdi5lGMBljPCWLdC7TORWzqUOxmUJ9UZkL/dhm1ZtGZynirSOZWJm3dA7ubjPV75UpTnLw1XJCc1DtJN7afAwT08cvi7U7lmOhWHe7Y0lsOKYR4beGmA1ldtfJp8TVtz8Ydz/6XLxCa+abn5B8xFJpeQTXmwDnWSzZe59/ngLyr3/5Od6ivHD7fY/Hi+/sTkH9L3/9IScV+cv36XffdxPWa5/E6effFNfd+UTs/vyz+A7Aff7t16lccfrltzEgwvpdG9m7juHkLY8TG9F0WF4bT1xxHg3rorSwUk67VfsiQCagkoQ27AApvYVU0ytKiuJpWkcPXcomNHqkJdTBbqG2deZaCrLEIm3/1Bk9BGb2ICceAWti3IAuiAAzFsagcA+mXA7mZ47MK4k/ULhu1QmAtSyM+kk9WVZ2Z3z55jXx3B1L4q/vsQ/77dPioTOrsK6L4pbTlsazV3BNCv4UQ9EDffK6q2IWY3n9pjNZNGIeXKpKNs8PYAtuFQXiuSRZDfH063vitb2fQfwjacI9TyzBjVN4HdLABt1xFH9hf6w85pJ44MU9sWHDhpSAPHPJGfHVE3eg7HRn2v6xZfKI2LxxS+RRAzyI3YbtaTclYB15JEuaCvthseBLcZgdOlY/dgqkO9yflmrsJGQdURnZtGNNIvuVDitL5Ql12ofy/2nAASlHefKNzN1t2LmE2cKlsWJTXQKQ4NpBRXojxP0VG9GRP3p5HIU64JZjWV2yHkntnYtj20mA6yi0q7Ys4v9PiiuvezIeefaVZIV+QfVXYPz8j18A2A/x7t59NJzfi5cB17f/+XeC9p9j92f7ib8eiZeoa33zy9/i+3/8NQHrH//4G8D6MT796ot47d198Req8Ceeey3SPx/G57jAH/+G4N/+7+KhJ5/nb58cZ175IEXUJ+KWex+Ov1x9SVzDqtuLoOM8dsEpccHmjUmjwa0RpZQdBuYzbUO8JU9cWktiqGK97mB340V8jktP2RirGc6wD3kHi8IXT+pP7acfYriuNemalAEF5Qj0GLod8r+RfbZk48bIpNMwEOvVUkvVoW8cClHgwtXj4x+7H2Af0GPx4VtqtR8bz1+zMk6bUxCXLxuEsvFAZgPpd7b8P6KMPt4DyC/ZIC8YAyUaZkIe9bMje1AuYPbzLDRFu+QNiGtve5EM+ss477gzYiILl4ZMHRQ9qNaPms/ubzZ79RpUGItRtHmJfYf3PvsWw8rb6dESg156SXz2/GNxzxnHxmpc5bW33BNdoSL9/vd/iHY9AZYxlnOFhQWwEJlWHutYFkF7Hd13h01lLQi0wdSRjLUsOegercJbghgxFjozzAQnqC03uMuwiHk+M8Ntxy/F3NYmy5UrJxjYWwBdlR4XrWpIwb5gayQTtKWzZvtGAvzj2a7wF+Kj/fHdL78kQP3yN9wfFuhbguzPKBkYvLtC7bOvP08W55PvfmDL1RMsKnqDjO+r+Ot//iN+xrL9wu///Ms/kkt89+O98eJbe+KCK+5O1ff3v/yUDPLb+Ozb7+OdD79kO+n1bCQ7J6687dG4/bEX4p39X2LJ6DPec09ceMIudj8vjY+4S3cuWYz4RxtKC/RYAZEaof3hbKlOMxDK8aVbVsS1zE4Ooa5zB1arkeRmCtLb9115Nnyo37JZtRD+fRuWAByUXOoWMuZVTHQXH8GicLnnJfQiqaQ3DmKkrS/b7Dsdxlq59vHQBevj29chM96zlsUHL8Qve6+IW46bEdduGhO3bimDnzU3jl9YxsJNFAURn72C837Gtg2UDtjyxe7tjiWT47BupYB7XFxLktKSkfxTzr0nviRD3nHcKTECkuDU5TOieGIxTFmo2tMHRX6/Lkz0HM20z9546q1PUXa8LWZAD7rk4htj15Ztcdy6LXHu6WfHI0+/F926d46DDz44utBHTQzSw1jZWlw0ILlBWZnGUHPmQ/JDHGQIRUo5V9aqXISZhkehm9jqkbOVU0qmeMrQhHwsm8Tqj1bMQaBjc0OsP4qaFMDZhrXaevwGgnPcHhnf0PGsBYYNaRzn8qcy9stMq2qIo0+8PK6+8VFc1OfxLSoDurDkyn7+Llmfb374Pl6njiWoVKz74W/fJLd41yNPxcPEYF/+42eC8L8mC/XLT1qsv8ePv7Dt5FMWQr7/Xtzz2PNx6rk3xRPEYZ//nSTg79+hY7A3/vLYS0x0nxEXXfNw3P/MS/Hu5/twpd/GR5jKFxEyu+32O+K6U3bEg4inffT4/XHi+tWI07aPEvQK3MzVDXbqpNK+cQNx5zV0D8bA37Lu9fDl58RiZhgXoXxz95UXJZnsYqr4w6nW13GjnrAEUFWOQNML/VJ6o0UkPaNpv/QcT8W8FAImdbQ+R/x/o6qgRXz49Onx/Z7b46XbzopvPrw4fnz3nHj5yrp47y/rEXWbTtDdO7bNHRPXMovQ5d/+pziOzsZVJx0XfQbPoBA7KtXK2qAQU8mw7LXHb4tDIS9uOPHK+JCb55jzropxS0fH+MV4IDROS9nm1Y9GdfeBPWP+anYVcQ6eeuU9ZhrvpXS0JgmPbD/tMnhvl6LN9V488Mj7qCa3Q7vhoMjvDm2mK/FCSwQfehYWR2UDGyZYHFC/VBVk/gBg0kJpmays+7VceB+ttusKk4itA6xNlBkne3zeD4an/zenkZlD9La0WDuPXxc7oJdMoaXTHQ5UPqm0o2FO24yaWhsbGRD9y2OvxOfQXP4Rf8fafMUeHGKqH3/Eav09lQRs3by4+1128r0Vn/4AqP6BqMUDaLQ/8TTB+T/ib//4O6ACXForLN0PZIFmi7pM9/idf+UDceWNj8SHn3+Z6lkffflVvIG12nLsZehHXRcPv/wywrDvx+c/kAz88J/x9vv744W9u+N9yhRPvvJWnEmqfjfivu/fe2s8c9tViT5ybGNlbK8bQ1DcGJtnowBNJV4e+ZDiPvHUbVfE1BL4V2TPD6H3aVbZDcH+zlBkFswYGbtms2qmX+9YvHhtzF6+PnqiPjxhwfgUOA/kAg+ZPIgx+N9E44i28dGft8d124fEa3evjr99fGV8/MIZ8eht6+ODh46Ob58+JnZVF8X9l58R83F1v/1f/udYOHNE3IzKckF/BkwHTIQLxrZU1GnG0wO+gRi3B7t9tqL/vvuL72LtccfFhIUkaYuZd5g1MoqmsOcZinOXMqbHl24jDvsEi/VW3HbHU6hl74gb7n4uHn7qBSRCT+bxnbjz3hcI2junGMudOr/pDk3kCLQb+jNirYtaurGO1H9Z6tstXd0Ysxtqc9soIPiZKWqt5MTnRsRGJMZCbo/huAOaD8ZbukYHKSw79KTINnzcsJgK50cR3PzCnghHFEQfSPqtWLA9nl7aaRdeHs+/tZsA/D+JeTh+/in++stP8Q8uqEDRJX74+ReA4z02iL4b7332SXwH/O5+5Ml48Mln4ruf/xbgCnf5Y/yMBRNgPv8Gc/X2RwiSvf1+3EtB9Gz0oO5/8tXYj+X7gvUo7yH+esOdj1DWODVZrXf2fRqf/0zZgr///sef83uv4mb3Y9kiHnic/X+AeDVTMVspHl9/1GrSbAYbmIaezGcayKba3gw9FNNn7ItGwwyWi79w301sPuscJ65aGA+wy7kbI+juKFyJWuIJaM3PRAu1lk1rV9/0UAwhdukxehCNZLjxU2HNwlAYTOtkyAQeS1qyno9Mc/WE+Oqla+JaiqPllb2ifnzHeOSS5ayVaYw1s0fFny86BZ79gPj94R1jwsCiuOHc4+gXjoj2LFpojUpPK5SlJ5SWJMlKXfWp519NHe/TmL95XZQvhxjAJq8BMxnUGM9idVgQ3aDczGnclID1LOf93gdeRkftpLgGgL3w1jtx3KmXxyVX3w0p4OXoyEynoiBtkUD6TRfuoFYtD48i75rVc2P+quokuX3S2Tvj+NO2o0BTkwJ5YyobzoMQ+HfQQmtl4VQA2R8UTFqrtFQJkGVWbMiIieh+o0oCLaUrUyoW+g4jayqG1VhQMhi2w/y47ta7Y//Xuar4z/T4fqZsoAv76ed/xPc/sgcHy/Ph/s+wVp+k0sIL72FRfvolHnz62bj7gYeJu35JoBKMBuq/AMjvsW5/Jfb67Kvv4oU33qJHuJcSBAshr7kHAdiPUnniY7LA5yhXbDzqlLjl7kcowH4MoP4aX2ElBfFz3KHvf/UhpYof48PdX/K3XolXPvouZi9cFTNw+fNQLz5l4YzYRDV9LGtBVMNLy7ppSBt7NcCZeuH+2+F5tYlLj9sZt190Iap/h0VjxcQ4bS16+WynGIem12XXQgNm43xP1HP6oUY9ZREhB43iogkoFM9kOBdayviGMUw+jYTWMiAmQ6wbPAL6Du2bQe3+eyweBSer05HsiNzOHsjp0a1/Rfy+4wB6mp2QD9gV3QroPyqSBkVHIY/RWNLjGJd3Fe91dz4W99Meq1m9IKavQpNiCXsnKwdB9elHDayIPTm9aKdtjjc498+++048+NibsQWWyIU33h+v0Oy/6Y7H8UbnxZ33vxgd2Kdo8O60zm+6USXWFfaC8221Xb12C55al7GQ8I1/nMJxTF72p+UFe4DGVJYjVKbxezIbbOvIt5I+oxUTaIPYKlE8gHYBdN92iLT27DcIncrWAKwAF7khHoOM982PrCOJ/wRI36bjZ+IqgfUd6dr3ZHv7vv4i3qWvJ6ief3d3fARYHnv+Fe6Sx3F1WDTA8BOliL9j3b777pv4GzUu3eC3338Xb+zeE8+/8W488eKHcd4V98dtDzwTn/zwOdng16ntcwkM1LMvu4aiKgXW77+Nr3/4JfZ9Se9x94fx0gfvxSdU7M1In+V9vkhcdiWtkMaVx8dV194XGzduRN+8J5rtE+MSqtCr0EsfCL/NfYPuV96A1un7zzxKLNYal3RSXHH80bEWVscZWxbH0lnj4V+xFBNQnXP1A7Hm6ItoANPrG0/WuAox4FmDotcYxtdmDI7BbJsfDqgmLKHltojZzAWIzK2ZzXZTuPAt/hATu/4pLiXxkQbUr/+46DWS7fa4vPasHzkTleYC+O7teqIQU8RKuN59U9dgKQ1oda6ef/ezOP+GP8eM5cwyAKzxi+Dgsd+5eNKAKJqMxDbAWsD09zvEvM/ufi8eRsP0xDOviXOvvTvdeM9Srth18vlxxfX3RmcWHPz+P/6YhnN+k9elMI5ABrAbF115bGtYaoYuhm9j2UCl5Brc4fwlC1MFPUc1rmg6ZqTgfUZ1dXJ7GYPU2Mqqu/+n6/T7xXDq89g40Yb6T1cKf9uPPy1ef+/j1Gb5Kxfu++8B008/J9f344/fx/dYn29//jHFOrs/Qwl43z6EW9+Ntz7ZT6zzBuIWT8YX3/Lz/yD7w/VppX744bv4K0DUcn3Ha32ESvDzb76dMsHbWEx0/uV/SbwtKTV7v92fGtlnXnQjQT1F0u9gPPzyA8XUv8V7e7+ANPhWfPjN5wT+/xlffPPXeOSZ5ylvvE3n4MzYevTl8ecH3sRy7o8Fi9eklXCrCc5vZMTrHBYrzBoFw7Vtyzhn6+bY+8wTMRp6yl2XnBQPwsA8jc7EshkwQvr2i3MvvpkOwatxxsW3UxQ+KfJK2AhfxeazlQztzh4WfYmvzMyGMBc4up5ZhKX0bFdOjHHLoCHNGx35RS2jGgryTgZELqQW6Khc0YQFlBcaGfgdS0floDgbd92bYZSOtIhaFJTF4QjRqiIzl1Bm3boN8NV+jmW7jorpK2jnrWVMbymaZDAlirBYfScztTOyIJas2Qmw9sfLH38IY/dtzuOdceHN98cL77yT2CNX33pvHH3SRdGVnYZ/JMbKo+wAH6t72kzubmhbOk7kWGo4+exj4uRztyW+lEOoDqDKCs0O5we1ZLo+LZlWSheoldJyZet+h7FNYiDKf/LYuzB63Rd99nMuvjJRVr7/6e+0WMj2KCX8jNX5K3HSz1ipH37AlXGRv/qRGAhLorWS0fDGx/vSBf/LQ4/Gl7AXdH/fffcdFooeIGAUXMlS/fhTqtC/hqm21vXMy3vi8usfiBvvejg+/PLz+ILXNpi/4uY74qkX34wv+HvfkXlqsT795vtUB3v53ffSz/2dJvcetNIffe7luJ9j/vrj4qwr70F84+O479HXowpe+PmX3xILaqqJszrG6fMnx72nbIrbTyPAp53z6p23saS7d9zIZM75G9F2rUcSk8TlqBPOidsgHd5y1zNx+jnXc+NugCZcGKPnsHxhJXqrjMRrvQYQgJfOhGxZT8zaCDVp4bioXMWqv4VjuejuN+wENZk62uCSGM92+gLmHQvH12PNqlPWdwJlnCGsg+nEMoU/wYtvkd8n2rEXqK68EgHcd+Kmh5+K8kU1Ub1pWlRvZunDEuSlaqEoTUX7ipnFYgAmsN7gOryxf2889sxbcdlND8QlMHRf/egDiJZvx9Ovvk+f+HQ8EqrJLCPvTliQqMkHQXUoYI/vZEz5FEazlq9ZGuezeu3MS7bHlqM2pz6fQPLQWmnR5FdJ1tM6eWRgsvEsuJKKHxbLWEzmZx4to6moL99270NYGkoBuDprTLotLc0PP/yQvs7FVn+NryHi7SOuElSv7N4dr320l0CaXccPPkzc9G0C1U/UpgSVv2fm6KOgsh9ok/mld2lOE2De8+hrcSmu68lXXmMRJJI+n39NSeGVuOvxJ1J9y8TAfqJZ5+sfwEYFvPu+th9p7ezbeO3tD7gzqX9ddxdLFS6AWfE8lf0P49Kr7o6Va09FrXhfPL1nD19fHPPGDolt0HUfu/CE+OT5u1iGfh0KyUfFBchmnoh4rMIb23eeyqrdJ+Pup96N6+54lrv9UsTslkcnlIgnNU6OcoA1EQD1I3jvP2UILFAGVBYy2b0YVu5c2CeNMHFlh0KT6dSzFQJr/1t0gYk6etNZMQAZgLxxTCyXVrOH+kgoMozwcf7VCv0TI/0uVSpEOfmG2++HVvRTLN52dIyfPyHqd6LhvwO1Ia3iPFQdq0pi8Ez0xyZTKlm1FQWbPfHm5ygzP/9OWkZw8e0PxFuffpwy5Zfe2RvnXHIjhdwW/wRWB7YKtKKvVVTEQAGqxuPRplKPQW7UrtNWJvqLFXjnAbVQDkcIrJk1lclNpokbwFQA7cYSg03npatXp7lCLZh1LRcA1C9exVLsl+J7qtw/kfUJpn9Ql9JCJWv1d8BBreqbH7/Gjf0Y+wHP7j2fpFjHTO2l3R/gNh6N9z/9jEJEznX+HZdnbJUBK2WEIG7PfrJHQPXMW++mOOBWUuNrbn0Ed7oHYH2VAvnbHngu9mLtBI5/7yuSAff5yT59/QN6jyQN32EBvyVDFETPc/J2nHBhnHn2TfH8S6/zGm/FjtMvj3NQcnn1vT3xzO734y1KF08993qcvJVmO8Iptxy3InY/eTcs0Oviyi2rY0xhl9QeO/mSP8eNd78YTzz1elx4/ePU+C6LcTMboguc93GN9F6XYp24wAOxFgPKUZquZuUfhL6JS6AoLaXNthgDsIxZzVWc40VjKCF0iv/zf2ejPGtjSurWRdcJK5kImgyfrGUcPXc62zEK4qDWefH7Tn2gNVXF9bfdE29CbVh/7CUxZnZdTGwkroYL33B0ZcxYy4jfImK8KgRZyktSArGQPTyv7/soAevJF9+Jux59OS6946FUYH6Bm046+INPvhZtOjNiD/shHyHf1IR2/GsA2kcjkbGeVjcpZi0i42HLav2SXIlBdyfdWHqx0zQz2NCgYp/PK3ljDkf0Z8l4UUlJsmobjlpLTWpVzOWDqxCz9Vi0p7jAf6carmX6mdhJ1+VjsjIU6BI4uLhakC++/SF2f/JZvL3343iNNs2LcKnufvSxeO/DPUAqByrrVMZSWi1jMy2WcdXnuDKtzrOULp6F2fDYM3Dgb3yQEsPLNJm/ife++Iy61+Px/r7PUmP6R9gQ3//8C1QbVoXs3RtPvvMWxdFPU3z3C8enVPS1lA898wbLqM6IG+98PJU8HqSIuvkYYq177Ut+GC9DzXmJbNOU3JjthpvuiTUrtsUVW9bFracczbphBD3W7oyGVcfEqRfcFHc+8Gw8/Py7cQpucNcpV7DmZQKU4MIop0A5fj5LQJfBcWM7vEH04EoEPeaNjRkrWBezfHJUrC6P2RsrCPKZ/1xLslQLZ4uK/X87lN3O4+ooLbDrEQ2OhejJ92bJQXFe/+g7ZnocRUHzgRc/iEde3RcbEJYbMG5IjKRmNm7R2JizjamrnVUxeyvJ2TLE8CoHIuzbN0omFbMUdQthCCRJWmKydB965tW4/q5H4106E6/RzXgcq/XY869Ftx75cTDykyaCVN7pnDMhMqA/ExdQROqRe569bBrAIoBfU5fU9gwKbetI6tNiKQFZNZelAjwa0FfWSpMZDQV5EP3Cspgst3rrGqru63Gpl8e7uAlbLNajBJYgyMDl17qz76greYG/4mtB9Q7x1FsffxyvYq3ueerpeB3Olf+f+92fk6USWD/j+nyealaA7EOsjtZKYD315u64+6FX4vrbH0o1si8A731PPUVs8UZyl8Z33xNfffkdmxsSgMk6qc5/9DXFU15bYH2wXyv2UVx18wPww85LS5BMAG4FULtOuSq5ghfeY0fNR/vYw/wpbAv6lwD68adfQ1nvnjj/mJNicVV1XHTuhVipJ2NW47a46Oq/xH2PvJTu8l0nXkJP9bLoVcZSqkmM4BGYT6bcUL6EJQtVA1Mty+DdoqnAmspFnw6XvWbDzKhG9GPymtFQk6fFwCmD42BUcooZXt2KoN3Fu3bGLGqM67acmcRrb3/sI9oun8RZF90RMyoWxBDLIoOlNtOaA8wCq35HddRsYdSPvzGYrHTwNEoOE/pEvRaLOtZHtM+efu2dlPTcwGyBidS7DKs89To33tMvRWdKSX886HfRnUmmBKyWrJ8tZrvAfCZlyklta+H8LFo7F+YmrQmlsBlpH1Bq09lhipz7Uz7SbFD36LCEzWddoY1ox7Zm1tbFRVddE7sBh65LEAiKv/+VQJv46a8JJN8noGmxvoOwJ3thD9mH7ZzXuPt90w89+3xih379Axkg2eMPLLTUSgmuDGQ+CqzP4L4LQC+8wHrs5bfj1nueJYN7khLFN8mt3n7PQ2R+sEh5PwmM/E2r7/69597D2ljjItZKoKXZ/RbFVaerjzvtyjjz4uuTdXrqlXfjPFgQboTXQr1ADPj+F1+m5OKpV9+MZ1+zvPFWXHfb/QjPPhvPvcBYGrToK6n5CKxrb3o4Hn785bj74Rdi+4mXwkM7HxYplfZppQk4U5cSZwGsEXNgrU4m1sFiTViApPlySjtkbzNWwvCE525Zom4r8gcbkTKgqFo0qFMswH1umo7sQde2MR5jsHLzubFr84Vcz3Po6y6KLt3KoistqGkFaEQMZS9jAhYS4VvxUE3AMs7KWSyC97EUSJdtBFgfx95vqO1xbqWA3wyPzc/70Xdfp/G6+594PjoxrS2wuqk205EhgLYozvXrX4hKTEXMJkBctaMxaqGt2AsUWENReClxCRLDEzOYB5RNavxkYdSiqRmgoOrFpM8ANCBmMrJ0IbWhvQyKWqT0IiX3pXUBFM3dlwD5GspwckdffpEshIXQdygVPEp75eGnn0ugMqBPAT7uTnBl7i+zVl/xvff2IY1IsP78W++lwdUHn34VK/F0PPn6W8kKCaoP97H4kqr8d5QxvsXNmRG+x9966UMCfayVpQ3fi3/LjPONPe+TEb6LtbogboOOYwX/oaffYmfj1Yl//zStpVf3fhT7+Hld8NOvvJnAZ+H12rseihvuezWee53Y5OV34xKEZufhCm+4+aF46tl34vLr7omTzrk1Vm4/Ee4V6svTBjYDFkusKCnoCgdOL4sxDcxfYskM2gVWxWrWzXA0bEZsZQMqP1gwRdY692gBRfhw1BXZ8TwCGg8T3k4SHd46Pw5rXxRHoIScB2+qfhgFXejMoxZSG6M+lnOFNVG7bXayWKUVJVFa3hdg9YzapRsSsBxC8fM/jsW/nR09JlSfEiu7vu7Bp15MFutQNCF69KRX2I26Ugt0wPsU5UflnIlQJBAL24B4x/QcqU8FmlFoKYwlCM8NVuTEaOVglcF4kK48eISshpHRG2UYlwJceNlVsf9LygiYquSysChaKAGltRJgAs2Ll0oLHLIIPiAL9CJrsWQp3PP4kymI/4VCl7GQF7o5OH8iJvvB7wO2j6Ejv0JF/jnrVlxY0+C7H34ubnvo+QTSx55/Jl5gvvA/sXpfkvHZpP6G7HTfN99y5wHIPR/EK3t2J6tnvOd78+feAHC33P0M8uNXpvqZU9c33fVUnHvZ7SQHrBX58B1qQZ/QBvo5UaQFlu7C+O72x56NG+9/PlmvN97fF2dfcjNMgRPjjr8A9mfejjOYzD7vigexCOujfV8WEkwvSTGUgbuWa8pi5gXKB9HeGUQdi0EVGszjyQQnLBibADaLca+6zbOjbgs93u1MzKylT1k7Lloi6N9rfGH0n5gftWyYrxtSwO5m6FFsUzsU2nBvlkOtLscaDkGySf0s/p7AqttujFUTk3kPZZWlyWL1HdcrvT+Bte87Eh94bk+8/CYB/ItQvkmGCGHe/+zrRG/qyPKGw4/8UxJK/k0XtAjSyhMs1oyaCbFwDZaKJmSf0sI0eaNmlpu5nC00kLdPqIKfqn1lowCXS5QGDYnejBYNHjUpzr7oCmpUX2EV/jO1VVKxExB9/20OFB6Z60ruD8rKl/zfR7BBbaO8j/uzvHAPFJjd+HAMXgKVFzoDqb+fO35O5YUvANy7WKtUCX5bi7UbS/ca9a7n48k3GL1//fV45KknUinjZ2tn/F3fm1ZuNzGZ7u/Fj3an9PlrqvXeBIL9YwBuPcuY6MIrYaRiCS1ZXHLtPSQAz8fz771Ndf6d+IDOwH5uGsmIVvmfIeZ4kbjMutedDz0Xz77warzK98+99CYmuE+OO+59Nu568Lk48bzr4sKrHo3JtXOZ2GFYlvRewEzmQmuVBM5gBDf6kxmOqqPhT5F0TAOasBwTsTS6y5mbKmPO9pqo2TyTWKs8ytdMjX6VA/idoujFRHTj6P6xnJXBhzLg0YIK/J/g7Bf16hO72PA6bCAKNg0kC7jC6k1QzDdgBRl2tZaVAas/o2J1yzckt2cX4uX3mD4nrpR1aidEYH381Y/cPK9Fe+pphx4Brx8dkOQK/3To4QCrD7HTuGggeJ9cA6EeScIh0FL7lw6gN5hrOhuY21RuREtzMeJfMxsmoV2KEh4T0coLrdq8K9796HNIKyyUBxE/sIf5J+IUD12XoDKe8qLKVvDCenzy5ZcJWJYS3vuEYJ0JnLd3fwQQyADJEH+mF5gYDilI/z4F+sZHAvMrAu9EiaEc8UwC1nspc3ngiZfjAZgSfn33o49DY/4yBeNazJ9+hPHA6+77en+a8HmV5OIlRsV2f/5J7r0BEhMBmRRaoDMvujn+zI5l44sHnn6eEf4HKAoSy737FknG3gSqvcRwz73+Toqxnnkd5RtH1F58KcVRz77wejwvM+LSmxkOOS3uf+y1uPjqP7MO+Zo459KHYjQiwHlDuqE5PzgF6NNXA5i1CH6sq0rA6kPKP6IWPQuAZXboYTBv9jh2ybiYsZ4Mcd2MqFrH9rWNqPzUDyYLRLV5RAF9zAksZq+J/+hUwlBGaRzuyFqfkjiFvYelxSjb1IyA1Dcq/b2pKykprWKOlLaOwNIVDmC8LAOWbJJX3t+Tzu+9DAF7E+/nRvz025+IK99OwPoTAx0JWJ0RwmjFFvMS1rBNnMZU7dypUTm/PO0unAwzUHKfE8kG6AKrH5z2BmSlZXw6WbOYdbQKxvdGVGTttuPi1r+wW/nRp2M38cZPP36bmsI5qwWgjLNwGVqDzwiYvwYsPjrfZ2yzh4v/ABngy2gwEOPHD/DTBdUPgCeVE4iLbEobs9kHTC6U5vVbH36U2gt+UGtXj734egLW48++HXc8/HC8jAUDx2yy/zp+hNT2/Xd/o+n9PYXSj+J94gNjBdsVe77an7OmgN0Cra5RJZvTL7g+HiMAf/aN9xhAeJQiL26VVob0Ha2aAxx7vvgqDXyoH6G7fJPSxfNvv51oQM/CV3rhzQ/jWEoLFljveuAlkoEL47xrbo2Tz7k7htNn7TakM65uVFSuq0jWwws9YzUS2LBJba/oCsc05KzWKNT0BJeFzYkLDfYRr0PVz9hIN1a5uiL6T+pHkTQvts+GQr6gJg7qnBsnawspsYjh2FNX1lG3bIdY3NAYOQ/NWK3dClwwwNJiKRoisDKL9ea+T+KznyjJcMNnwHrqjTcTsPZ//0u89PZuXCFEP4HVF1foiH07tlMUsvZ+KOnu0PJ+UbGItSWb5sZiRrcb18+mbLA0HeOmDaHTXRnLNzVGxTx6Sxyrd82LclxoKWNAs+rnxqadZ8X6nVfHqp2Xxq4Lroj7H38p9doS4Y5A73v8tLGStapPAMVeXN+H+/Yn+vHzxjDPsxBcC4dV+smgHkBaTNXSeMF1qcm1Ylm+gUn6DvGNzWJrS1oUP7Tzco+wWu22B5+Ke2A/ZE1q/74uVXdnbPXep/vjbaaldYVvAawvHRHjZ7RYWtEXafuYUV5y3Z+pxn/E676L2Mh98SjB69OA5tW9H/LZoN/wWT7Aapo4CG55S9Z3Xtq7Jx7CZTz1Eg1siInHnX4Fmz+uilMvvD5OOv/6OBcK9Amn3xj9WIHnyLvtHGtUMwjKp69k1QxZ31B6h7rCydQUx5EZqoA8hknn8Y0TYtxCpqqWAAYyxKlrp6XiZgWucRplCLO6XhAFd6FuvX5RXRyO6FsLWA4tulPNZ+jiTKTBB/Vvw8whUpZzx6VEwDLGtNVTc/3CyrIYBCdMNukips+lKe2nDvg2U1FPEQ7cQ7H74VfeThn051wrS0pdmVr63R8Pio4M8P6mF8olLY6EZgt3aB4qvzVLEU2jL1W9DILeBvZBr2VtCZ1vJ2amVhNATh8ec5dTliBInLO0MtW7Vm1fCtjQIGdQYPMxx8FlvzZ2nXF7rD7+krQB9ISzLos3SEkNtLVYAmL/N9/EXu7yD7/Yx93+eby9Z288+tSzXCguru4uBer2DQVDDlgeWdDvazil8wYVYWMdg/anX8MVYlWsszyAqb78xrviI1zrz/Dfsxjta4JzYzopMyYK71Ins1723mfEV1hY/5Z/Y+9nXyR6zrW335d6jC8yvXMPfK07Hnw61W2eJ/Z6/8v9yZVbBxNYto8ElqCzt2a1+jEKq8+88npyFceedjnMgOuw9qyAu+YvcfrFdzNCd2n0Gd4/eo/uHmPqsFjESJXr0HZdQwuNiz2Fm7x4MkpAXPwJtHsEUwasaSuZhKJxXLerIeqObkgZ3SwCeYFlHap4eF4C1obF9XFY10HQZkoZ0BgQ/Zh6d8tXWQkqO2ScWj/LFza/tVjjAK2JhMDqO6kvwy3HpaGTDFhPv/o6mhmEGi++kSzWl5wvy0qSN/+DLWQdGIdLajMCaxDDEUs3zU/AGk1BrnwudRP+YBUfpm45IIOm0bi2LsawznbYxEExawH+fFllzF8zKzYwEGHQv3TjPKjH6ykcXhY7Tr2JebWbY9fZN2L+z2MC51SYhi+lGpL04k9oBu9lFnD3F6Sx1EceePKJ2EMA/uPPxFTwsQzqv8PEJtdk9qi10lI1WavPv/4mfZiXP3w/xVbpouKGrLE4/nX5DXekot3faCIbixnbZZneF1irD7BW9iHfxcQb+H/8Fdx52je+vuUPhzWeZgj2ItzVfU+wUxmppFvueQxL+HqyjCYYn2BNM2BZ1M2A9SzAepvX1pra6JXiY23rxLOuZI/jubEdJsDF16F4c8V9sXrLKdETTateo1Dag4WaYqvkCmn4U/ictmImGltk21iryViSKcu0aAwVa2EAw6z1dDeOnpuANWd7bdTunBPVZIjD5rDZY0R3gDUtNi2dG4fDdW/VZ0gcweRPXwRW3AE0bBDNa2pnZpvTlnO9sVjGalosE4mUFQKsTSecnqruAutdQgfrig8+91rch06G8wcC60OC+5687sFsWLXswCJMRuwPb8X2036xEODUrWQ0G4s1dd6kKMefz19HNXYJ7ZuG8VGHhVpKM3VmPf2sCuQaxxZFPSifQ+GuFj8/B0rzWHQdFq3bxcb7G2L7KdfHljNujs2nXR+bT74cy3ZaPErM8jkX+sNPPsL97cUlfR2PUgR9DGv117/9AxAw4/ftFylQ/x5uVAYsL7hWzNjKi7nviy/irT3UiwigZZQ+/WYuBjJj+Qsd+8uuvZn6FxV9QcXvfIOF9PgK8RCzSGteJgpW+Hd/SrmA8S/dqz+7n/bO6+8TfD/3Em7w9uRarYndfN9jqZQggN6mdrUfC6f1s40kQLWaliCeI96zxPHBF/sB+Tuk4i8lsJ90zhVw0HbFlbc+HOdcfkdcesMjtM3WMuiQB7DyU63KWMfqd+V6mvwAawrndSDyRMZQU1eg7coxe+vsqNyAhj7F0qoNaLvuqo/ZAMrscOGJC6Lx1CVYNrZ4AKztEPq2sCenRfdhTDqPgN1QFn0KihDZRRqylBW9M3ltGt5W/GdAyTErFFhaLGMsgbXrjPMTsD4jRt1NHfDZ198gHHgrAUuLlbolxKm9UFw8AoZsvgOrWqyW7LJzsmbqHJqf9aNjBp30Gtxf7fJpPFLVrR4R5XVU3XF/MxqMrXIBfuVCrBYWrnrR5FT7Gjl1aPRhfHxCRXVsPeECBkJvi40n3xjbzrwlNp10DRYMjSr4TG9D+fUNCSyzpfMuvCo+/5yqPAG7meMPxDrf0D74AYsgmDwyYHkhrTW9DxhegXhmiUGX9cRrbzIgAcC4gJY8TO9/hFul6xOc31rWIHPTWn361VcJTB/I8wIgxnm6Vv/O1wT3n3xBNZlg9C8kIbrBx154M2594Ik0ZKFVtARhMfcr3KZA1a3b19QNerxAvKdW10f8jFnlUy+/lar1244/k4mkM+IWqvFn0oi+7MaHY1INSsRcYIE1Di+hxardDk1p02wusu4QwToYncZWPi+nDDETV6m1MqaavbkmWav6Y+bCUKiNRSc3xpIzlqemddGwbrENTfnNiNq17DkqLQFo2XNYFFDPuunU4xOwiinKWi8TVLPW+tpsysXdSpvRYtkEP+H8yw4Aaw81q+cI2o0z73/x5VR/NAkTWCoWHX7kETlgabFasY7s18CaA0V5CVvAKqiVVC6eSisCq7SE/XyI0E+ZPT5q0BEXWNMZtRZkizdyx+AylzNQ0EBGOXf5WrZ+XRW7CE63nnJdbMc17uD5+mMvwppdksbgDfwepRVQPXsxGqH00ujH7d7zGVxSa1eMeuEidWFamgQwrI8u0LbPGx9RMyK2Mht8kjvoaazV02/shnR2D5SQuwnY/970e2SBWDsBoHu14CqQUuuIupVu8DMAkF4f0AncD2BHWAuz0n7nQ8/gCl/EWj2SKvjywbSUiW0KCH1dgf4WJ1bLaVvoJdykxV6pNwLf7r+V95Wbj44rb74bbthD1MXuS1SeMlbl9hiKpinAmjCfm3YdixkAVu22WvhR1QCnls0XlBrmjYlZG2cBJjSpuPhalpot1VG7ZXayVoKrbsfsWMAmisWno6QI07TPcEbLWCAusNoUjI22AyegRDMKQZKiuPm0E2LEIGS/cXm2hlKpAm2tyg2oDDXFWAKrDP776ZddSzvnq2SxPmbw4gWscg5YL6bP7pTUB9ygPeBhHXTIwYyBuf2LrLA182UCa1od7NGFE6NudU00rEWjnVpJ5dLymAdoqpbSm+KDT69HPwuet7Wu8jqWCTATN6EaCjOBZ/ViskkC/mXb6mIBHOo1W4+FJXlHnHHRXXHs2bclcO068yaGQk9hOuQM3NHn6Y1t3HE8tJotBP8nxJwlW+Ksi69JRL6fCN4N2AWXFsfYRxdo7chM8Jl3YHECrMcIjp9/56O4+4kX4pzLro8PPoa5QCkil4V+k6zWFwTr1q7kchmYZ8BKmg8AxDKEwNKivU18ZZHTmOoeuFd3mF0yzJoq7cRPHxI7fYWF+5o2kcDSAr5BFToD1isffkixd3/6bMZiulILpdtPPD3+8shzgOoelHOeiDMuvCkKGV4tGMkO6dFo1i8kqwNY1VuwRLg7gVW7Bb0H0v8xTNBk37M67iGw/F7VNqzWMXVRfzTnHWAtPWtZKrIWj+weW5He3Ip6ToeiSUgVTUF/C3lIRHpvPo1VeWUUSLluc/w7gKpuS442Mwbq80C49TIbZLSec/VNKZ50sHUf5+9luO+PvvxaAtY+3L1MEIHVHXbDfzBi39UYK4/U8Eg46L37FgIYKq8AaxosSMFVjbWaxwebu4G7ZxnapDXs1mEn8eQafDJuc0zFsPR8PD0qXeUkaibTIKLNWTEu5nNnCa5NsBovu/r+uPT6J+KkC+6OzSdeh8++lkTgKBgQx5IRfpQazbOXbY2NJyGNSKd/KqL8coDefm9f/I0qaXJRxkaAw5qXbZYX3sftEF8pCGLt6pk3P4hzWUPrOL4cesH0AyfiO2KnLLb6FBf36ZffpM6Ar/MRKfSHX3ya3OAPZqOASov4Cq0ZXdctf3k0AcuSQ7KIBPMvv/9uunO/8WgClqUJC7TGVlqsl6H5OPwh4F6nVWTgf85lN8FvvxFWxGMMzN4Lc/TlNITQfRB1pbHEWE3A0hVWbGCLLRdbC1WDS5yA9tXQuqEAqTmguD70CT0E1ryT5sf84+fF3OPnRuNpixJnq3hkXuysmhjbVzVGRxQEOw6eGu1YvN4b1cBb2SgxblivGDpneNQDTkE1ZzP7j5ahKcv3EoO0vH8Mrx4Z5193a3yGB3H2QGC9Bvfs8VffiAdeeikBSz7bbpr1WiqBlaMmg66WlhtoINeurIL4VZbirJlzKbQRONaunxqNmGUZDwbs4ysp0FFyGIiG5YgKVGiYIvFrY69R0wazdmMUdF2CSo759B1nI/U8b+VStBzO4g59ILaeTFB/9nmxfCuLvIdXpGWMrwKgcy+7GlnCRkbfb47jzrkDYJ4c5eyr8f8UAPniW1o+cKi0Ji/uxgW+byZIsP7Gq4Dq/bjrYfbwXXFzmsr5khPwLRx2YzStnLGVAbkXWhB8TOosqDz202MUeN9i6h3E0E3atniIJOPGux+nFvZ4PPTCy6noKblP96mF+5ppa8Hr6ybLZJ8STr61r9c+3I01/ogY7BuKt3u5cV6OY848P4mbOJFz/c3PpDhr4bqNKb4qQpS2H7296UuIW1chW04ZYRbAqsQizeKCmyEOqGCiaQXPKUPM2liZygIzCeD9OcsMC49DNO70pTHv+AUxe3t9jG2YgCpfr9g2e1Icv25hEtTtMqgagE2JPARHHPefMLwwRtUPS6CavSVXlDVJGMQAR8HYgtyOnjlj48o/35tqVZZ3BJZhyGMA65FXXkku3y7IPmYSFAP53UG/j66IpfxG85UBy0xwMlXY6fMM0skKqeyW42+Ns2YtmREjGaCcAk1W12eAP3Mxk88E9pOpsUycwzgYmcRUfreCYH4SJtbfq2Z3Xw0LfWYRh63bcTLV5zti3UmXR9Wi41j7eyWLAipjydpNccdDT8BaPTfmLTspzr/qMUofJ0VXJHXql65MgbZxkFXuV+lPWWIQUGZnqY2DNbnoqlvTxI81pcRcwFJ9bXW/CVhW+JsDS3BJff6cOCgDlo8fcILkc93z5Iu4wifirseeSa7W2OpV2A+WJSywfgEgvwSkAkv3rMUSVAbunnjd5T6s4V6s5JW33BmXwa/XnapLf+Otz6XGdjnUowLGuPqx4VRgyWmfnnqFk6ICazULd1fLsiUzxNLq4RRNyRbXMdBCfGUh08KoP1e3Y07MP6YhZYQLmC+sR/9ixOzR0ZaWzVEN0+JkhjzyymYiBT4nugykyo+azZ/P2BWTRhbF+AWjk6WyCV25HjdI8VU2haNlBWPZBFs7Jq5CuE5geQ0E1lsfU31/gzgLmU6BZTa9l05DZxZe/Z6lVso2pBF7geW+QoFVuXJKIvoZT83kccoCmqGUGUZXjoxJgGoa4lvDmBwxW5wFB2jy4rHRuAtNrPWwSql7lc+FbdpI9ZaSxZhqhG9nMjpv4W/u0Ji/Aj2l464gZjs7Vh5Nlnj2DTFwbP/owRj3GEbPFm/YGdPnrEGI7bwYMXUamgNFzMgVxGU3XJ/mDt8EULoiXZLW4bm33ki9QEF58TU3p0EIrUlyU5YXvsoF7bpQgaW18tB8f0IM5B1oQTYBCxcoWBxutYN/24NPEls9Gw8+T6mA3t9L/D21H1LQbknC3wVQvm4GeIN2waX72wMLVRGSPbAsz7zkqmStbqEddB2lhlvufC6u+/NDMWji6CgciQz4mMLoM7onkzfjYJAi/ks1vXITO7gpfDYcU8+KOIiU3LhTSY4M5g2wPewRarEWHDs/Fp1AmeGkhTH3uPl8bzba8qUE6q3j2Hkz4gyUfPKGVET+8AaEdWdGV9QEbz99Z0wd1TcBS2ZE9SZCHdynQxyyKXqOoteIVLfAuuaO+1OtSmDpEd79lKEWzvsTr72eWnH2bjNgabHEFIp+XQ5YrNkrQD9mdiEuzMB8BqWEaYtYGbdsVkwksC8HeDMAzcQ6Yil6VPXramLFSSjuHT0/xWFT6lHpLc2PoZPRx5oLP6gcKwbtY0Q5g5m0CKrnu93+ilh7zKVx3Pl3RR3rY3uPas92eXblsWjIQLZ0AttWxw9NDdSBE/KR1EEUn5nGd2BovkXv7oV33iAbzPHZn3njtcS7uuDKG1Lb5GvigK+Iqwyqjcm+JQHQDX5Ohd8mdA5UXxwA1eeWDACWLk1wfcrdpy7Ec++8HzfC3ZLObMZpfUqLpJtMQTvg9XcFrK/ra+oKBZUNbcsgxlhmS4+g6nz5TX+mFPI2F+jeuBn3qpT4WZdfHwWI9vcaiZ4WskE9CbQdSnVYVYtljDXv2AUJWJYehtdDY0LToWoD43dYK4PsacSxs7drreYlYFlqqGVH4SQa2X0ZgujQnz1CWKyzdq5OwOo5cl50HVqBUnNp3MYU0bTRyINSw5qzmesLn34YxEKzzzLaPPkjkB6fVJRc4Q13P5yA5WcWWJZ6PEeeG6eoBNbHFKu1WL/9w3+Pzsg7oUHaFXHbVsliWWKYi19ftKU+Vd4ncAdNoaYxg4KZQ5J++LLpbC2fPiTGzR4bCzYtiMXbWfBDsD9kEruQEf7vjJ/NQ/GtN5vkC9HTHDubOKwWkhrV3QqAtXrruUhG3hrHnnkzv4eCMJoEfSeh5wl3qHgs0ou4hEEU5ezOD5jA0gA2KhRQG1OfwWzwmbdfS4JqmuIX4Kff+zgX7oZbU9Hz82+oR1FcNVb6CkB9+UXOWiVQQckRABmwPsNiZcD6ithLcNn+EUC+tsCS02W5QBnKd8h6dJsCUcvm6wrYT0gEPsYq6SZtSjsS9RpZ4UdoQ2hlL73mJoqrr8AGeCGuuwtG6f1Pw7Z8k27FCdF5IPTgCcVMQLMJFgXksVj2yY3jsRwTUq2q4eh5yRUKrNHzGSQl7JiFWxRUHsZY/kwDBdJ5R9fH4lMWpRirchMWjmwub3B+Ata5yI3nD5sVPVFrzhs+i8nosrjllG0xgxW+Nr5lpU5mtN4SxSiKtFq7XqPZ3Qj1ZgxG5Jb7H09Nea30Jywu10qlYRUSJ8s1FpUzi3UAWJqtFoe2jBKUjXWFFSsoJ2Cppi+ApA+whleVMnY0MWqp8E5uHBezVrP/ZgHpL26uZgXbJaiTlLEQqBfLjgqK+7KebgTLt8uiHRPW+RTiymygLmQIYyW68YjeV6MDcOLpt7ON9ZYonTg8fQBNbp9xgIoByX6TCGS5U/pOgG/NXF2/KYXRa2hxbD72+HiXtokx1eOvAy6KlA45XHr9n5PS39cEyl8xYPolrSJLE19w0QXAfi6woMqAlXtOKYBDVyaZT2B9CVB2w+uWvvww1u/m++HJw+USWA6qGuibPfqzvqbA2gegzDSl7ZippmY4h8O1H5N9vgCF5sobbkvjURZYTQTsNaodUbt8WXQqZSlUBcK0oxFIoeY0unZEmhucBLimUltqwBVWbUVmk8x8ynKmoWYNSzGWZQYDeK1V/VHUDI9qSDGWFmvRKUti/nGLYjzXUmCdOL8iLkDVuMeomug1bmFaYJDPRPSNaMDOYonTyDkjcqxVRs6m8GhPshgNr+7Du6dpbOcZLbcILM/ZJ/u/TnGVCY5xp8DyvOzBUv+XGMtB1dZH0OUGWLZyxrNQcUzVkJiACZTzM4sWz6g5w6KCTMVG5SzMryAbR9Guhg78pEq2OtDALh5QEv3QYigqGhS94fv0QsitE3tfOrJpatRMpkZWobBMnDWBjVX1qKrMXbEl+oy0e24/qn8Mhb4xdBb8L+4STXDheBqgTAIPqkDMfwrKNSzatARglf3pd15Dxuh1Wi6vUL2+PTWU91OpNxP8EuB8paUCNF8QaH9GsTMDVma5krWS7oJrFCgZWN4lg5NHdTftpVsfRMCN6vvzb7+ZCqLGY7pAf0fQ7mc2MQPWHgiJb/IzGbCkVjsFdPtfHiChgLeEu779oafiTir5dz9q+eKpGDFjcnQf0YULR4UcgTOBNQrlmQPAWlFOJb0+Waz6HXMJrJGSBIRmbVWbGL+jSGp8JbiMsRYci+4G5QaD93nHNqassAsF0NMW1yRg9Rw9OwomLAJccyK/77C4Dg3Y2nLkJaHiSHke2TCcQqwSSizEwhjkDcvD6hHCEBLd9fAzOYtFKLDvM0o1nL/XWMLgja0X8bwILLPCP7ATWkyxuped0Cx77M94dw0x1lREISbI9yGrmEpxdDpZnannwBn9CfRGMhnCpDRZxEKqvDOcb0NTU5pyX5RjyoYyUl86AhGQfomf1YXSfkcU7goGIlQP63H6OjRN55aQFJTH0BkTiK9y5nasbaQV03ldFmwumRRF5YyBl/eJATNohNYwTECq3Z/NXSedfwVshs/jqbdfBFivUmx8Nu5/Ck480z+WI77CWn1D1vI1tOgEli/3/V+AJbiywLs5sATgm3DIBNafH30ibn/4sQSsF999O5UYLEsI1q/4fYH12f6vErA8ckRDMkJKILrCNF2ExsQ1gN6m7b2Pv5CyzDvQ8HrgqVdgTNzPDGA/tBny0mpd3aGuUIulK/RCOzdo9d0Ya+6u+Qw7zEvAMrjWWpkZCixd4dKTl0Tj8axVPm7uAWCNwUjkI9V9Brqh5yMdpcXqPQkd0gn1CVhXH7025s4cBbkQPhaGYwRlB4FlX7KALNXgXf34sXPGHQDWZ/Q/BZakzDc/NHt+P7XEBJausCv67v/BDsMUvPdEN7MVO5NlitYuodgmu6EGjSYs10QCuUnUpabWI2gLimcuxk3SGK1ck2s92FkfjXBIMSepzyDW36LsJ025J+qAdrp7w/tpg9y3KjMFg6B+TKewis6mZYr+kwsxuexilkkBmHzNBgp9Mij7T0Uglw87sRGAzx8GuY2tqtTQRqP79OSb0FDI0l559yMU+C6NOxlD+oAPadX8p1TopHVDNvgpJ+AzLNfnVNn3A5oPubNkVGQZoaCyHPEVrkzA6OoM3F/+4KPUvrkHq2Ul/XVqZrIwUnkBa/glMdXnuMJ9DH2YDX4C0A3qX4OblWKsD95PlOqb77wvMRsUMbn/2efS1PXdTzzHDN47sZNtD/noTvWBKjMR/nrpDOSChnaPUTXcfJQbUkOYZnS91uh4xHXNDnfOY5PrSDa3Douq9XNSxX0WS5casFaCax4MBy2WMdbcY+anaea8Yflx/ubGOHvHxigaVYXIB1tS2ZNTUDotrkAcbhns1GF4CZmrw+uGJZZDCRmhe6YNUWRIjKmbAhP3JZIbEqAvPyGe/IohGZi+LMN69YN3E7CMNfdw7johJveHg/4Y+ZBHf1PYo0+0hkHajw0D02AtzF7JOpNaxLkwyyPRDBiOUPwIlHj9vzmrZsUc0lzpr5OXjKRiy/7B2dOjcFBRYpe6Ks51bz1Q3zXe6lFQiJg8WuWsBmkPJbZTz+7RiVVk3WkleEc4CSIdRJKZr1ULSc1gUl0mhwpms8KjkR7YshMWRQ1LLPtOLI1Fm9eGbMZH4FwpgVSzaFUsXL2eFSkbaB9dHC+88nIqXv6Itugn+z+MfZ98DshoeicwfJbiBIN2s8D9nKAcUD6nEr8vWZ0XYTVYFrjvmWeTvsO7TOl8Qj0qBeyAyZ8XqB8zhyiwPvv0ywSsl957J4HLUsPz9BRvIgN888NPU4X63qefSUB1789jsB0WbdqYgNVvfC/KC7B06VwIrOHEUCkrpIRjzDO7KTNM2SHAGlk/LgFrOoVs4685Oxh+2AkjhedZyWH+CQsT0HRp3Yfmx+VMtF/JRpA+Y6qjeAqr7SYujJ5sHbt8+7JYUYUiEGHPiNqhORDhFh1B09L1HtMb64hxmT8DhZlXU13wM1QOP0JPTGC9/xE3IudGV/gvgdUDlRnHvwoGFqYCaDUuac6qCirso6N7YV60ZqNT/6Fs6mysg5mAhuhxi9FSIthrHBGzsVqL1ixJPHhH7IvY1NWHZUC6xV5FWDGmq90435YNDl3yCxFbK0x7nruyWrZwbDF34PCUAVVT5BNYDmEOmM4qXe5imZR+b+OZa2LHBSwbOH8TXYCaKEF/fMtJx6c2yTEnX0qDfD1toAsgo51FUXcdBVe0TFdsivsQDjHGcnRMd6Xr+oTg/1N4WForzbrg+sL/A2wfwm9PmR01rFsfgHf1/Iupgr4HGclPv/wsF7MBrPTzANWTmywWr6eqjUVRLZYshzsI/B8n/nuLhvojLyEmgsW6D7Wah+GK3ffsCzGOBaL5BNYlkwrTqhJDAa2LgbzA0mLJHp2ztTYHGsHC4yR6sSU0hccQmM/ZVp/oNRW0dGpwmZYcFp+4kCJpY7JYAkvLc8Vx6+Lmi85iP04V3CuEbtnqld9/Uly8YWGsnMW+pBqmsOqGozDDhl1CIC1WN278HiN7JLBNmDf9ALD2f/EJfVY6F9xUu/fSWmMARYuVWm1NFuv3f/gPVhRTee/JdoV2HQAPW5xmLa5IzWbZCoNHMHyKSklvANK7GIAgQz2UFWLTsVxjK4fGdGoq0+dOSRsplHsUWIJJcBX0HYC6W34SOe2C1cpDhjKvBxu80KbsxkbTvBIWM1KykLRvG2HOtmpAhBQSmgVlrDqbsXxSWji0kv7Xrou2xjGXbovtF6yJoy/dTO+yPo2GL9m4Hd7VKzBcd8AX2x4n0ofcctLNFGCvjLKxiLkWlbIZtgER25sSy8DmspZGi6NLMxDdz7i9bs361W6qya/Q57NNdOfDjyf6rcOq+xiw+BymqFbNw9dIYKI04QneB1glHL69b29aq2Ln/+a77qHWsz833PnyK/HAcy9itZ6jW/A2u33uij4jSqLHkPzE0BRYE+cTD1GBt5STYixiV5vI1RurUtYnWBYetzCqqRUOqSEuomhZAU/OWGs6HsRYy8wwV8taHAux8NKNBdZVaL/ectm5MFRnRfHUhiicSgA/sDzOWdkQq6rI+rGSWiqBpXRS/yklaWJIYPm9KchgPvLUa8kVfvLZ3tiDB/gY1q0WS2B5jgTW3j0fJVf433//u5CKxfYviH6QswZQK6paUJmsVv/hxYlbM3IYsoFoMpjhWTroSKk+rzeiqz06ETdRvCTgzy/sTamB4iY1KwHVvTexFUBUy0GgdelNGYFh1nzWd3h0YLdMIcOU+vNyq/z0qARWA3edGaAuUGAtJmjdfsG6OPqibXH0xZtix4WrY9v5K2PH+RtiLhNC/VEQXLxhRxJfW4L46rINZ8Tpl94Le+IyCq24lgH5yAJ1ThuwZjKl8uhzTyfazT5OSgIXVutT5wEB1sfUZd6Hn67Fshh672NPJxVA+3374VV9Li1XIKaDWhhg8uRqtQSZbSDrXzJS7yKbfBSr5OYxC4gPvfACY2Avxj1PvwApcXccc86ZkccG1AJV+abxeZcSqNPKMUEqmYJan3UsBUAcyQJY86ikeyw8bkHUb5sXI6grDcaFTYDKVEHpYRpBfBVV+nlYNAP4xZQbGk9cfABYN561M269/Dw8xKzoMwW1m/LG6I0st0up1taWJ+EPqcnGWE4C9Z04IGWTvh+/p8V6kKltG+66wo9x/elmQrBFVyiwmrvC3/3H76NLJwqkshsOR2i1D0L1g4aT3qPwWzIYYAwg0ysujb4lkPIBVlG/sujRG11MhlI98lmB1hMOdSECYmo29C9jggcACa4+/P9AxsE6MsMvGLuzsqM3Y2KjprKFnk2gBozWTmawV2/2lhnED7WJdps/qjvB6+SYt706Np+F0vK562LnBezduRCN+AvXxooTabRygtedTEZDY3XghBHRuHgDGgmPMX2NjPeuc2IGRddOVJwLx7KPb3QXzHoPtjyw94Z9OBdfc2UaO/uIRnYGFLPBj6gev0N8JLAUanvomeeStpZx136C+s/SQXzGYbyWAUur5WuZFb7JHeswhdbKLkHiiZFoPPDC8/EAbaGHmLtzyKIOQbs8LIIVd2WCErBwf/2nINxBdujzSRQq1QOds1UaDG2aY+clV1e/vSEBa6CxL49TKQVpsWQ9LCCuElharEVYLNmoPZmEvuvCk+IWtqMWT6jBWs2JXlMB1tAZLBCojjVsDilGa9Sb3GxTYBWMKYp2fTskYOkKJxljNQOWWWEGrMwVeg53UwbqiABJYjc4TJHn9CrAKkAUrV8/lE3YRzcQ8VOXfBcg0e1jMe6tCInHPv3gSwO0IpZTmvl1Z9dLAdZJq1aMBFJWbVe4thODkQbs3dm1nA8VdugkhiznsDaWPqOaBI4aqRew4Bj05KnXDJhWEr3HYSUJJJdRkzn2UraDnb85jruYfYK4wtUnLY4VJ7AFjKUEa09ekY5Vxy6Ggz8jsSLWbjslSkdPQfC+DzuXc4xML163od2iO+PknQfmR0/kss9G+P5HZsuMtQzeBYpc+7etmFsyABxPwGZw6uRjssHPDoDL+OzTdFIPWCys0h50uASWFurPDzyUlP+cVXz2zTfj4dcQ/njxuXiQ13uCmcN7nnkmhjFil7Iu3t9Q2lyqy2ilhlRi4Xm/E5h0Hsecn1QZmQxaK8FlcD7/qAUxli7HIFglQ+h8aLWsvgus+bpMGA5arKUnM1FFVth7VEHczSrgG849LfpNmM2SprrozX7qXgDrZHYhbV48OwHLkbKhtcOQLqKVM5wqQWEbbsqCKKtmznFpDQInr8fX9D0//mRPfPARY3p85vfJxF3bZ4zlOXyfgnUHJCgPxFiuWW3bln4dSrtlA4dFGSvgbO/0LipG1ThnkQSUVkpQufi7b3/qLrAFu6MLYAwmuAzUdYdarc78X0s0ztshONK1KzUR6lojp09MZrbf9L7JBao3YBa4+IQGKLes+RjVO3XkLcaaeWqpjrtoewKW7m/TGSxwOmlZrDyRiaDjWRt70gKAVh/LiT/KF06JUrLXkjH9cINd6L11it7wvfOHkixQhLSKnD+8gA5/H8DVP+68774cVZkYKbkyTo59SHWxXJRp39G4yWzwc6yZ4BJUn1D41AVmh9bK56lij5u78c/3pLrVyzRo7RA8+MoL8dBLOYul8s11LCLoNZyYlfpdAS0rA+fJjex/BFgOUtjaGY9ew1gYJmMXUOqB4OfUjRZr7lF1sZB1MBOZ2iklsRoM0XK0nRISH11hww7+nxty6Wmco9NXpnnDQjRM77v41Lj2rJPpx1YnYPWavjB6D6uM87etjOM3IS/J/OGIWupX0J/LKgdTT+udWBGF1LIE1viGqWi4v0B7jHNFjKUrTJ8ZV6iuha4ws1jtO3aI3/7uv4c7MH/Ts1dedOrUIWk0qCpTWoaIPRbJ6WY13h2plySf9BqwXj2wPoIpn1iqW4/eKUj3sMru0Z6YTYXkDozu+5iP5bK2VYQKTW/crNO708kqdYFzd81JYLH4WjihV/qAc2iAV6yAJLgNq3Xhzlh98rKYt435RvbrrDx+caw7hcWYp65M4Fp6LAOzpOKLjoaDBPfbqvQEEgLpti7R7jmhMDqN7I3CXR+OwuhKgNyppFtMY1OZd90Xn30Dx4u7kMOTlEoFVNqfe/2VFH99QqYooAzu99F41YLpNs0gPT4gYN9Dhd0U/J4HH02y4I7sp1E0+otOQtseeuhlYjaYD8efewHxFcS+MezbGVNAdTzXTtH1KQDSCwEOWyyeIzUaLJROp8thrcqA3LLDNARoy6qGpzhrZF15TIG/ZSxWA0PBOMzzsuikJTGMuKl0XP94/toL48qzz4jeE6vT8vPiGfMib+TMuOSEE9lasSIGooFlNmiNrHTm0Og9kjh4QMdUbug9ka271eMTsKz57aNQvOeTL7kR+exY5Tc/fj+1smyRvfXm65HPWpc//uH3XHuAlZ+fF4qvDRs+ElUZTCKHelhur3e1nGoyAkprZdvGRQOCSoAVEk91ye+VNNt1d26ab4OySXdWl2mlfOzC96xt9WLZT+lUCIEUQNUI0A0uJcisgW4zFOlpT6JuQGA17pgflYBrxdGLU5lh2XEMCMAxykC1BjCuPXVFAt1Ce2VQoeu316XOvxQTM6aJkOZG0escghUcxEnrxeBlT+7CzqXd2bZQECefeTpcLfpfxAfvkio7TW0ALj3mLUCwxykcXOVnFDv34+p0nXuxUHvIhvZ+zPNPGMhg4ZN3rlTo626+PSk0v0avUfqyK4U9HqKP+fgbL6VW1KINEvvyEkXG/qDAmoLSi8CyxFLoSl0yM4El0NKQA6CxfKA7NHby8w2fw8KsGoRa5qFFyvn0c1dTXDYO82YzeBdYgyFjvnjj5XHpWadFwaQaCs9zE7C6j6qIi48/IU7dvBQvUpCA5Ws6zq+YbTd0s4bD/5KbNbWxOu5BXuBzrPvefR8mi7UXt/8O4nJvM+TrmNz7xJdW3vNYWHXIIQclinJa0mQda8RI7oBRAGk4mqHETAqCpNVyaGKp657fm9k3LJdWqj0FTwE2gkq71fbBI0anLFBwte7AVitdZLFBPLweFJJt7xQMZZk5FfyqddxhCKnOpxu/lhrVaHpUtnuWHLMQ17YkZsOWnG/QSp1m9tqqdAdqodaezOqUk1iXAqhW8XNrTlkeS6lKL2QS23qPd62d/ynLpxK/ORuH2O485asZmVqJTgEnqitF2e7QcboiNtufVS4PomhsRuNM3GsE2+/tYU6R2Ogdyg5mgp9gkfZj/j/79CNcwSdQcOTS50h+n1LP+YST/NkX38ef734w7rjnAUTfvkhERAP3R15+AWv1fGJZPkMTW+7S+KoKygw9onAU+wyxouPnyWag6cyolkF7v8nFtK9KU/Nflyg3SwWZWtyc7nARMWYdAXzSCG0C1gSYuhWcs2oq8fUUkxcdRb+Q8zLcTG9Sabxy29VxwWmnRO8pc9BtXxBF09hHPWZWXExT/yQ21zrPaFtH5sTA6YOj62CK2AM7w3VnT2XdCG7w+fEXZDVtl32GuO2HDBZ/xOT4R2wMe4Ob6L0PYOHSQnuH9k637vQKWYRZUFiUo820QdDfPS4eA0qQYiaecrWJe3MElrsKbdG0ZuF26/adABi0lpLStJJ3FLJGQ0aOwd0hQU0sJrjasRLtCMT0W3foglkkcKZnOGhSWcxM1oppnyZrNY8emAXRWmIEgXLMxdtj9YnLogGaiMCaC6mtGjbFauIqrdVqirMCS0u14gSyH+7khccsiDpcpXReO/9aqnGk78rz9CcgHguzYgbDtKMAmdLWnahwC648FiXNWlzHShNYoZQb3mRAwOdvQj/+gHjrE8CUAPXlX7kb0WVAxO2Gm/8cF0OhvuDiq+IueFVvvsuw6+5P46rr2R/IOrvX4IlJsZEn9vhrLEL3wK3KxLiNgq08s0IsgkF6v8n9EqA8JhJPCSIHGAYgcWBdaxwdCGMvXZ3tm7kpOKddw+MkWmLWs0bBfxuzgPYPY2GyTeuOqk+ky/nUvLTWYxnHe/WuG+KME46L3uV1CViF0+ZhuSvjwmOOjpOYXHd1nOWGobTu+lF171zaLbqUdk0Wy4B+8oJa1AdfSTfZ3o/RvSfO/ICb50O2Wdi60nLfeuc9sRrN+3ZdOsShhx+WE17L4x9bOiUE6mVsixg4iLIBrk+rVcLK3QlTytM2Cufx2xCU6QKHYKEEnj8zgsVNrpXrCdiMtQSW8dXhrdpFq/adWYtGDFfYHUYpBT8a2FUbp8a8o2pjJa5Mkz9s9iDipHnJKh11HlkgAfsGMr7Z3KlzYUIKssUAcN2Jy9ORskHAZVzloQsUWIKqnGHOkQxzeLKHwhoYDOuyehNTLlgvT3QJQOs8jEBexuYEtmWU9mCl3bpkqRyw0K3txe19DufI4ucbWJorb7qLIdN1MZxdQkUsN+ozhEIwmedAln6WI/K7buOuuIveooJuBvAC66nXXqF180I8+graWK+/xEqRfXHqxdbXKNeQbRm8CyALoQJrwnwYBoBIa1VEXKjFElj2EbXAZn0CKmWG3EyK2g6HfTK8FjkpbpjpbOyqZAxMkp+hQQasyTSZX7v7ljiBReAFM9mTOLMx+kyfTyO6Ks4/alectI7+I9QYRURGIGdUCMukbb8OyWINZo/OMIYqypc0kOw8lwvePyFEIFv+BAu/Fy38N7Fex596apSwsKsj9c2DWx7G+Ncf/wmsVmyjkt1QNoQ9OaXGU2wlIIDvR2vGJePKRNr3cybfmMks0UzQIL6MpQPjpzCtC9AM3i2Q2rpp36V7ApjqJmoTVBF0OmI0Z1tFLGNp4xKoHfYK5VkvI37Ycvaa2HXehjjq3A1xzAVbU6Bet4nCKcCay0jZ+pNY7Xv6WtwgOxBxhYKqYQfsSlyg08BSdkcTEzjONH7JtBgORXoKLnAOScBoLQBWzMVD+QTNPcYKLNTqUMsrGFLK0s1FiH38GT34N+MReOl30dI59rSzY2ZdA6WLXtG2Dy2vkTAqubt7jWBt79iutEi6sliyYyxftTFVod+En2Tty2HOJ19F6ea1lxO4nnrrhbRzesmmrdGDVklfSipF44rTpLGdhgxYgmgEWWJvssVxMEkFlu7QkXo/3zwskbUqLbSTOwLK+NH+YTmCIQb5NXDfF+xsAhYDrtPJHl+59/bYtWtHFNcsYS/0siieuRAAsVR9x444hULziNlDDgCrD6zTToO68h4KU01LYE1YUJ1c4aeWFSg37Mb9mdC8Tutr6ebN0a0fyVr/fOYTesURHVsnV2gJ6ze9aLEYY1lCKBuCkBonuh/8KssMgsv4KpUeKCcILmOstgTonbBOBu8CSncowPJoOBvMd6RN1AmlQMHVIq8THPkRUYM8j72/Rmotq0mHbTxbz1rAPNyGs1akYqig2nn2ugQwyw2rqF01rK+OurWzYvlRC2PjKew5JM4SWIuJybRUZoOWK6bjDrRKgkgxMd3gSFiXWjHn5BTU6AtrojsA6VjWKdVsbHuMn8eua2pCY9GRGkWNqf9wuEjsFWrTuyt7ZzqTeneOI9BS71rG1PAEYkcYCcVYlR7D2bCKhsVd9z6Q5hRfo8TwCssKHD9/6jVdobWrVxgHQzwDYZCJ1bXUj1hRMp4d0gjWGtfYE8zcYSoz0DPsAUt3FPQZgeVhyUFX501kraqR4LyOMEHZ7mFYrZHQYyZCypyyBn4W7nA+2bNWzdpURdXYeOm+O9CV3xH9mXgqZYtqMcvHBdZZLPQ8aU19ApZ/YxjljmIYLMZYarsPh/lbjLjtWDjztyPK+zVtsA92v5NYI2/i2tds2xGt+9CFKWkbXYfkpcTsyE6tUvCe74bVHvTzWrOxasDAviwaHx9VNRVRzv6cgYPh5cBQ8BBklh0Emi7Q2MpHXWXpMPRH+bqYmMuKu+0cLVYeqnHJauEGZzTCzYZi4yTIEjIb3aBBu8oqy09pTMDacf66OIZ61dFnr4+tp6Mxf+Gm2Mmx6dTVsWQHVWdEyFYftyQ2n8lWMqxdlgnO5IS6A0aXkbm8blSN+6JJMHlFRWJT2voYgSJe+0EdohsKLKbSXrxZayrJoFjUefHqOOYSNqFy0WYRow3Cskk2VCNqBKl9KdZlINu4ZNOWlNPugqOeX9abKvrCeIdM8g0mcwTWSxRXn34VURJkLh9h5s5a1ksfvh5X3/JglIwcG8XMDqrp2RdmrAnLpKW5wN0AXmDpAvPhZWm5/NrDEso0GCe6fC3WYgJzY9P0WaGPCyzZohOJMWdCAPS8zOPnzPRm0Qt8/p7bY+v2bTFw/room7M6AauA0sNp69fGCavmpGVQZn8Oawis9rhBgaUeVwm1rbH15XEb1KRPKTF8Tnvr7ff2xrajj448qOeuwBtaw8+ShHhzHtb+yDgUop97C3+T36Nrsli6wuGsR5uFC/EYNYl+G9asN/tvbNNolVxbUgbhzqaz2u9u+HJxpmyGHlTt87BstncEoNarIyKn/csLABX9LLLBBdBnV7K3WDWVEXPKUmy16TRAdQ49wQvoBwKszWetjo1nrIxNZ66KreesjWOxXDtxk8sMXjH1609fkQJ9hyyd4JVeMhW25Qyq1OMXlUcPhjKKGLY0mF9OBVpm5ai5lFIQ4c+jaNplcKcoYZWH9F8FNxbjUmVPaDHtSVrlF7jKB01HTcdyyBhioGG0PcYxzjZlJeembmAMGF1C0I4kAJV4LZX05Wep5TzxykvJUhm0P/XWm2i+f8lW0tMSGIsnITTLe+tHo1cQTVoIcHCBFkknLoSiQhBfOM6fYX0J12BskySkn0/WaCqSYvEFzizKMg5XjGL+c+R8RvX47FbhBeC87XNjCBaooXZaPP/nGxFy2RJDF26NkvqV0b96efQqr4pz2D5y3Ir6KK0qS9bc4rTtHC2Wc4VqRbj6ZOK8WtSf74j9dCe+2PdNnHI2G8wGExbRKhtSnWtJKVk5jpJJmzat4o+H/JaBVVo61rGsvBu8T5w6nt10xEJoMkyrnpIAU4j+e0E/AEMdy4VLIxGmVyVZ1WR3FU6fUZFrMmPVCgj6+wwgPmORgArKXckkpToLLNkLi+hlLT9lMbUbhb7Kk6vbcsaqBKyd565PoNoAcASWMZfA2g7AjrmQfiHuMdfWWZyoNCsoAlYz/iTlZjq7ZaZB9dE9qJ4yhdG0ZbR+VgFahwyk5pTCjNQFdi7rmIiDSl5r6eoYPNhwxmpAtQUwr0h/fwNV/llrqpIlUAZbAJbCmRoxl/SbmHAqrnXpxqW4hI/jrfdhNRC027R+Fi7+M28AKFo5j7/GWpTdb8arCJXNWY6VoG6VdhBOKMJKjAQISm5TXYfjPgUB/wxYBu/+zARiKF2h9HDZpLP4rIp++HkM5E1KJqCnMRrxu7G4wsmLOFYi4kJcOh8LbzAusJ659TpWIm+IwY1boxR3KLB6A6yzVy6OHYtnpeq6wPI9SWXKgKVehL3CyWzadVjFmYAbyH5Lx46OzlB+etDlGAnwhtdYsS8lDBkTHTt2jIMP/Y9cHcuGoeWGAVBkJk6dEJVUc2c1cIewTMi4aRiN3uHsgLaG1YuC57jxk3Nb7ssh6xdTWWe9hQyHgaz3HcFOQ5vRkv76spipaGhJYpzWwM9eSCq8AnmdOqR2RjcMjYUQ1NacsjSBR2shqNbytYfP/Z7/t8v/P2tNHHW+zehNsY41LBL/GrlrDdwr4OBrUYbg2hyR8oRaIF1M/WsJIJyIu/Hu64t7E1i6mpSNYbGs/+TqZ5xkrOX289iogVLLZkDdsKU2VwEnBtNyDaLdUcYdavZWuWgW64Wvhbn6UbzKGNrrjEI9x6T0M1BtnnvjdfSjkOBm5tFK/tV33MHqEsbZxveFKeq6NtygcVEamshx3DNg6Ra1aFJWBJYWy/fgOJjAchrHkoMUGuMsVf60WAJrCiWIVJogiZm/Y0E6F431FfH4DVcC7FUxZNG2GDxvbQJWweRZcc6KRbGO6yywUvkCJm+fcX0TsLwJrWFp6SczmHz+lTfFs4iAVMypj7ZFEDW5SYrgxQ2rHgiwyhLjdxCEwf8CLCkObVp3iL5Ux0vKCNzLWHPBfN8QgGL2J8nPvYSyHYpwixZSXTw+s25GTK2bnJgQPfvT+4JF2ocVZ50g0ssU7VjQNYZOYxkBfT8px2Z+685YkQJWRb6WH08wjmXafh57e7iQ60+j+Al3e92pyxKQtGAeWrPtZ69Nj/6cFXfrV7Ubq5OlKie28u7qQ/o+GNaroDITbGAAYQHzjvYlbfPofjoN7pw49la7vbBeBBOBFcRh/l2BLLD8O7pbVVhUgPFIjVr2+E2Cg7Zq6/Z4hbH+DxigeAOd9xdff5mJHgTZANfjKCRLm3599740SDumil1C3N1DWAJQiotxLEsQSA+avAj6dTNXKDcrxybtRmY4DgCOSBZLV6M2qcBq5LxZgffzuRhc0t8YanbJYq1CLcZJacoRxdBh5tWUx8MsjprZuDSGLt0RQ4mzBsxeBn2GXuFKYl3k1+0RCixnCXuP7kOo0C0lNs4X2gg3/ttx2rmx7qiTonM/Mmp6unnIWhZPgXVazZALJEEnp3swpqeB+gMLBLrSI/5NT7K4DFi2cgZQqykdTiN6YI7J0IvYqWQwBDACdPUdXBM3jgyggXHvuQS/85fVxRwmQeqX1cckVp30YdqncCABPHyoyfh+gbUI7aY1NEelGY+ZOyxZK92aF1DLpPsRVMlakTEKrMw9CiqtVfq501bRhF4S86hEmwl6J4+n2SpbshCdAe8aQbWUzHERxVSzRtd5CLx8Jo5b9WudJk/szwkaU/hlgGopcZZ1NOM8weX70TIugONkxjWcYqSWo3TmAEbkKpEKODFpi76BpXodRoRDGG4bVY5brdH7n3omTjjnHKa7pwMqsm0q2rIXdDfTkeB0NW8qNWCxfg0sM8Ou6K+PZEOIFiu5QmYN/LwOV+TqWQvSe7fTMB6L4syh73M8r6sCoOWHPhOLYn51edxz0XkxsWF+DAZYw+eti5La5YBiVlyyZlkshXpTUjEw3ZwC3jJDd2LBkXPISJknNYSYxNxB7cqVUcaC056sGe4OqARW33Iq81grs8pSWK359GINqQ4AqweC8i1aoOjXt38uy6O8kMsAUeolWC+ld5j4VUPxxTPhp9OfmruqCt42YGIid8l6yGUb5sLoXBCT+SAlw6l2T+di0yR1idBcUmCt1SroHFqqSWyrWnniohScCx6DcWOtVXxPq7X1zNXpyMAlqPxaEG45Z33qhVVg8h1Dl7M0CqVBG6h9ydysYalzMP/ohcRYy1O9R0XgYdRkelKY7FTWNcUtDmga+M+n/WFVX2BtPo34juLrsl1U8um9OT9p/FWFBqvNcXuZjqeNQSFvNEs/ZzfynrdtipPPu4h1wDfE+dfeANHwMtR0jkFxpzJKxqO1PrZvDJ5RlkBlljVz5YzEsRLU8tp1gWnciyB+PEMjBu/jKfA6elVGrJiVICaxlsSSg1pYddxUvm/rWQ1bKf5CV7a7MJkJ9fG0smYg3el71p0tb5gZfz77dEoHtVG6dGcMq1+TgNV/SlVcvZ793/Mm0kOkZ0nMOGhmaaJHS5exDCOoJBtOWkzpA5c6rApdUvj2ZtU2y7VYZVgs4yxXspgwtWMX9B8P/n3kdWf7lzFWuzZtYxAbUN2wOoCN8rZrbELXL2BDBe0cJY6GTRqCekx90suaiWtR7W8hbmfRunrowfSpVlbHaBZj9+xHc5rF5aNpEdTvrKCftyBWSpclxnJ9mUH8WtyO8ZLgEVTyrLRgWooMWNvlup+Vi688tpy1LnGxBISNbANaTXUaMJhJ/EOKPp2NZTZpnRxeSmsoiZYRcMutz+NOdKzJi6XF0uotxfotJ2ZJrAmq+pY0ZruxjIyrljm+Ohav16INJtNAjYNhvM5o7nKlfaS5KD8waznaYcsbKImsiYVbKKPUTKSAyi5nTvQo7uZU1iCxWHQ0jXRiOdmyZsi+B3uFAmvCfGMpNnwR09jOcdBEiUZvAgVvtVpKRHqjmPUJrEas1nx4bK7cNWmZjJznRP6O7atqpA8E8yoAftOpJxIfVsfAxdtjcO3KGFizDKZqdVy/cXUsA5COfAlarVRP3JycdxMWb9xxaHJNXIJKM+5WMqBLpKTVWK4ZMH0koQcMGEsNlHL0GC3ZBf0fB/2WfT0USB3Vad8W9Vw460NYW1I6ZCQWi54hFfiR48iCqmbEwOF9kwZDFZZibMOwqF1H0LsZacLliH9xx8zlLlHxbzQxlRarZOTgJMkz/5iqBCqPWchFmw0aW+nyjrlwc6ynHODXWjC/Z8yVAUlQWSxN1gs3qKuaL4NBRWGyH92gnKUyTLjxxBBWq5kpOWQgsBYfvyTFG1qsEu7GtgM6pNFxg2+3PnhRlttz5O8bY1krW7CZMfVtC6Me2csahOemobCjWzH79O7VpcpFn7ycOGnFcMAxjv+bGKtP4TMR+5nyDyLeGKkoHeUKJ4tsP204c30sN5Y7ZRnWFCCyVElgmRnqCs2cM2BNoh3lhXP8yhgrVeFdGMDNLAC8WXSDAsubQ+tkjGWGOAFGqQ33Cup3DgBvXjonrj/hWDJlLCjBe2nN8iipXhoD2Vl4w6Y1sVxApsSgKoGjB+GCCn4u4/TGFVij5iNd5UKBGqbc+b9+Y+HkMaU+bPYEFnGaeOjSJxNj9QJYLeOQw/7QBCwGHNq0YRKaAunosWNiIOvNxk9mtnAS9BnGgHSLw1lvUrusClGQMTGVDGwRF3DhGtJdUDsa8ftKRu4rFLOvQiKH+cGS6QMo1EGLwcVokSSgjW3EgmGtNnIxBcxGXKHk/0Ta43vGT1vPsLxAsN7ssMxgnLUON1lHz8wsMPl+7ijptMVkWkmgleBV6q6VZ4uEZoUJfNxp/ZE8bEtxtIygVH30StycQiar0TpYCXlOa7XyGAJiPlcVd30l1qGai2iv0jhLEDoBnsaympIPB3vl5rvHZj5SjRUkCcoTuDRpJRY43STcEFuI1azVmQEvh84iN90Sie5QGnbW0rFfKI1GdyhHqtvgrjEBN5/AlQqlTO9QzzLOkh4jsc/XquWc6AZllnqBDdwnMh42DLd1Ivunz9+ygRuP6aZ5Vt5XRHHl8pTZX7pzZTSizz+RJKIaK++wrD1MOwIWZT13k0hyPH+GAdJ5jMNK0Pp3Ql1SoNx8V7R4LUoYgjns0BZx8J+ovPdM1OR8BlbtFZJVSUsegiYlm1NXb6bRi5tbsm5xNNKs1CrNIEOYwwmvJ3AfS5umhC0VXfv0YvaQKWrQXzZ+GAzJklQnmr+rOjESPKGyRRWdkK+eMj6ApTtccpJUY9yQGRmWKbVziKOywxaPwDK+Enw1FADNBD3JAmRoNZRogCUlRuu0kPhIGo3H3J0NKXYw6O7NoqGuFEet16RYhYxSYOkGjasaiXsce6uhyLqI+T3bRlpIDzNQgTVb/U910AFWGs9C+U5guZBSi+znTFkuN4EJgCWTdGDJNp5Kxsv/W3uzep5qb8R5ZqdmXYJJYCVXyPPBM0uiMyvirPpnrR35WsaUMh1ywXtDOnStU7GsBvGyRl2gOYavh00bGqevWRinE0v1wUL1q1+RrFVRxRI2uk1MwGqYxd/FcnruhtAAl8EqV94Wz3jfVwremYzHctkpsM1TSNnEHqtAGzsPPVqpPRSj9Qxq2dor7NINop/yfi3wjTIaymdOSatOXBAwG/FaZSHVeG+g+13F3VVHbNCIQIXaWcMnIlAxBxM7YhDbVgES5nfQGCg3YwalGKgRPcw1AEswjZvPZnYme1PdCgB5ov2+da0NXIxUFOV73t3bKFZmbtCLtOV0SgxwsZYQrOZc4JR0R5kNmhYXMoQwAnehVuc8lOxswq4gIJejpevyjusqXRlCm6Cqofe4CNKgQNX9ruNir6ZNItfLdpGHgDJLNaGQ8zWXiWSpPbnYiEozGZ2gElxarLWnA8Smwq6fYwMuLyvy+rWHN48xokBNcSLu2HpaGv8CTILKeEWAjaC21LGkQwyair67cVaT1UpuC1DqCo2zBGk9UgczkUaQsuw5cf3JSCzY8KmD45z1S+KYFYvpDTJTOHt5DKhcnIA1dvSEuOroVTGbReZTsJwCy7/VY3h+colmiR4pjgXQcvB9r55L63BqOySmK5ILaRMZwHLRk1q2v/3dv8N9b4vFovzemvqDNasR40dQNmCz6sZa9K3GxQBS5cm4m1rEQGZTKZ9DnFTtrjxc39iZnIiZY6KuEUosgbvH2BmjaUYOTRdiOepypvL2COVwS+fYRNy08fTVsZyWySIBQDC7DnBZ8d5xjpaMQB2gbeUi7eBuP+r89bH93I2JgzUP9+bd4d1k3cUTUIT4qjTkcu5S2xgyJlYBwjUAw7qPRT7vrM5DOqXp6grqPLM30HMEVFvpSeZqZFgVShwbTwHguGO59b5HM1Tfm8VY20fGWfY2M4s1E7cnsHTvumlvDrsIuj2B5O/7PV/b7/m1f9es1lE3BVbS6rgmYOkGBZePY3nfWiyndpQ2chWKE+JaEC22jXctsnW6ebR5DNYnJavF5BPlhtHEeiPKB8d5AGs921btDfadBVt05vwomtEY4yF0XnPsmqjEXaoKmCS/iVNdFGWxUyKhwLKw7JCLoY3n0Ru535SB6ZBW42JO3bSAV3xXi/Xv//3fmC9sr8Wii4/FstQwcoIx0+AErOVcKDM92QXzpPsStE6nHzSVF6jDZbhYoA5NTK3bkrVw0lfVIn5LkElcsITKsEMOCwFPTvpoOnf0qnQYUxmEG3+thQKTnXwbz9mRWS0v/OYz16YLYuxkjCGwHMvXx1ursZQgNVdrtR5QbD5nQwqU/bmRnBjTaC2WJ6YKjtdCLogA2oZl2nEWbSSsjRdel5i5P7PEpcQxK2xBGRcRzxhjNXeFWizjqnk7apNb1/ppqUxIBFZ6TYDlYwYsLa+ffwFMBZOQcuKbjOiXAWs0s3zjuZm9yBICjX0ElkOlLgXQinjTWKNLTAZaPGauk5fOTMCSmzWKG38ElfEL1vDeqypRmWEaZ+aiNLDaaxK1Ofh0Vx9FsZpsWvE2W1sOVcjY0CLJqbdp70YMWaWKuJXw3CJzIQ30buxAzONnre9psczOBVZ7FtfLx0oxVo8e3eOII1tSeWf0ayQDEyyorkYzVFU/g/R5G0lxScONQWbzBma57BqQzaImVc/Oltz+aAC4ojqGU1mWHqPKny0X+euesMXEPFoIKcW6AgNi60ebsBIpJsE9Gots54LvBByWGrzTvVD28QSWr+feGPlJurh+KPp6GGuZykujWY+lWQYodIdmUSO4QLZyuqMebNynC/K1dFObT12VkgStTHJfAMvYyhirDqtmw1tgGBf5t1N8x0oQLZbZrc1X21XKLAosXV1mrTL35/vPAJc+iyRFzwFuzJhtGtY/A1bmBjNgGUinOItKvMBKuwphIRgoex509daxHEip39JAr3RWOhdW4IdSghkJLfmi1YujYurkKJxYByV5YRpY7T6uBonIcXHlzmUxiaTHxrUWqw8ctYLRhakmNYhJd5Vt+jOZbbDehyzQupjV+X5ISnVHZbGLFGukptJiToBlE7ozpM7DjzwsejHMnOpYshuKGVjNVd4Hw4xkfclyxE4J3OY424bF8qiidlVJ/DQTy2FWlJrJuIRaUlxF20ZVDeYi18WSEzHR3OXToXYYoHqnGivpAk2TFwIun68BEKuOpTBKzWkr/3/UWRD9OLzgFix1T140K/b2yrzDdQUGlqUVbGuAGqL00VoAuY5D0Ohi3DoqsIbhUnqx09ghBTMb31OKhQCSwNp5BsnCuZvSe1i0jbufIF5iYS6Ax/rgUldigbwZBILAMr7yc+sGZ1EgtgC8mnjMmExrtRYLZ9yWWS8Blz03jtNKGy/qXs1wM1dobCW4MmBpQdr1axtlKNEcABZWy/jSKvwcC9T0M+29Nmydi1RBDXOGNs0pGEsARFTtohWNMWHCuKQyUzRlPkH8bCrn1PpgqlyxbTEF79I0PiYtx8DdcTHX2A0EQNYGPVx2rjtMQ63EVTIf3FOtFdNjGNR7PQRWp46s7j38T4wGIm5r5b1VS0bsB1DHwkQWl1CHojg6Z2lV1DJUWsUJrMbs1xPgKWZrGq5ktAG6NZ0pi0enFH1kpcT7qbHiZGR12C3sB9eMewJ1PSsYtpRuLEDMirQKi7Boc3GptdRflPvWSq4/bmlsP4P+IWxRWaNW7S2uVm2kRqOkIX/T0W+3W8mnWkocp5WyXmRw7IXS5dnrGo5ls1JsjOC20kZ6baldw4UXyNtPg44Dt2kB4FzIFo65m2lPITyykhrYdgCXWkiAxfjQGCsDVpIZanKFGbC0TMliaRGbXKFAyxKTBDpAtYbXdurITLOGhGAqFigL3sdQrBwFo0BRO3Uc2vZFdBhemOfRVo9WS6tkSGCsKLDSLmeANWsD7hBrbpVeYI0ePyjOg1Y8EppTn0n1uEMOYq2uI/EyqAJdgsznGECriK7Akn1hfcpJHYVHSmlK9yWg1yvk5CQnQYWGYTwDvTLiK9+LUlN6AoE1ltKD6wkPlBu6QyO1eWgTOg1FQE8eMm4oG1QZ60aT1PJCFW+4xrUYXNhqajwJYLhALdXspeiDW2qYMSCdrEXEV97dDk5MoD2xDmuk+XcRQQVZnd+vAESKj/j7c9yCsQ6XS1VfDdRKgtBa163sIoU/eU2q3Jt5GTiborsv2TlEP9icTXVpgNUkwCxzNRfUguZYepRW5O3cdx7SJRUYbdHY/7MEYua39oQVSZC3bj2Z5FbEeQFVLdnvYmphKZDHbXlobXVdukJrTzaPtcI+VuOSnHlMGWbTFJFWSQulKxfAWl7jOUHqefDw/Tr00ECLxuzQepBBsNmfh9Pgo6hqt+vfMk0zj0T+XNlzwaXrMc4yrqzFwip1ZC3LoVWnk6bMnxol9BlnjhkYp7OncBB8uR4T6mCtNlDEnMtE+IRYWj4uTlxdF8NIaGbxOoJRRcERbFvV5Sm+phtUPdkYNqsbGqdaZLY3aJvLbFGlmlRTpDPRpm3HOOiwg6OgT8/cLp3WrSk3MKJlP1CajP3A+WtqWIJZkxiVlaT4NaBai+TUzGyyq2qyD8FhgD+GUSFFcHUZioVppex615MEeCItNJodejIdhtASLd5KDYYTMYuMTiE2N180YM7rqXhX06aYuZSgkte3KGrgnIFqOG2SIeqiAu65uK/lWCsb02n8ngsqsIbVwsDgQthglYps4GlrZQHBrn/fSaA58K1UgK7fgKjZxvrUxtHda1EEgzdEFhP5vgWWIEiZHMDysQr2qomITAiB5e9olbROxo0pcMflJoDyfZMCY0vfr3U0f1eKdjawKqg8b06Dj4Fv3qWsPXJH6mZBYaEfmnOJOQvh+L3apHUud2gClpy0BCwAMmt8WZyysJZyELtzxtcRQ9XSKG6IzgPGxJIpY2M7C02tl8mu1X0qXOxkjlmhQbsBvFLcgkz6jImDwJLJYKyVtrwCLK2WMdYog3emsg454k8ZsLICaXGMpDY1qXpsWi1nL7CB4LSC7Epx2+kEqzIdDVpnUm2tIB3NwDUYH1zfVKUWVDm6yZgUDC9GXqfaLVWQ/ZYRYHuSt3DhduDqtp1MlgiX3WEJlQRnMQSRenXsRpxFxjmJjr1+3e6+pQYPXaAfxka02Z8ljQxYBtrWcbyjBtD8tXZVxNDEaGi3M7CwyourXW+FXSs5f2MDWl9YSQBu43kFzWtBlQFLoAgGLZZ1LIGlxcyApS5rPam/FiizWP6OliplhQDd2NLvObomqPw5bzbjLDNUXWzqG3K+mgNLd+jMX9eBXdDNAmjcLAJLC+FFNpOzvaM71KUmbhphRTmJ10AC8LpJI+LY+dSvho5O8pC9R1YxSFIXHYqHx4qp42JVLatNoMzYWzXjdOTf/qdFUNkidjKk99itUIDN9lkWY2XAGkMfNouxBFaHjl2TxerZG9pMfp5Ska1iAIp+Dcsg43MnzyNGqQcMxlezcF8TsybpPNRHoFEoZDGTGMP/m8SbMj1udHA0LfupSkMSnjQD9ERLBqCJVkwtx+xvM/HQNlzSVk5yyv4A4DICZgXfplMdn07/cSZWazoptPUqMzsDSBkC8tDlUlkrk9ossIxZ7Dl6ga08e1dZxOs8vEv0garsnViHvKKWqRpmRiVF3+pVfFYWdwosBXwb4TdpXXSDyZ2ZJWK9BIGvn90wGbB8nEEl3CxY6+PPaZXSQQCfBfKCNIut0kwk4MpeU0uoRfZGtMItTSazWALLKeWOjGOVTuFmwgLLhVd9TxBaZ7LHZ6ylTlYVFjXtOOScOSq/cMqY2FY/M3oNQRMCQduewysh6M2J9j1LYgPs4EWzIEWif2Vf1Q5GIVso7EvaFpJ642GGOZZWnaASzFopg3czx5SlAizfS/q/JmApbpsrN9Ar1BWWDOkby1lyuYi4I1kr4o1ZNEln2jeiwDkNgXmptFJoJ8yDSUAWYNlBc+r0sgXMWj7kNCi/yh9KHzb+SCk58tFWt1PfDLexyVKDBxdjAwG3h6WHdVwUg2gti0Q3R5DkqvthHNfqwjSIbs05OOtL1sqWk9F59+sKBZZ3mbGBNZeOZR1SgTFtfEA4RPc6Zx01qRVcDI6a1bg/hNzMAnWPKQvldZM7a8rgBIG1J4Gs2xJQHkmGqQlYAsRGdhqoBYxarAMZIq+VrFXT//lzHqlIjCUUsKkPSdZqlT0DlkXSQUzJdOjbPvpCGba9I7B0k7miZG4CejbW3rnDVMAF5PK95H+tgA2s/lX+kPHQiGezV6cCzv/saJfXJ3bBephXofYDCo4AS2qxSUIOWFhkYmqPiQvpJQougJVZLL2BPUPjVoFlYO//jQEPXRj30xU2ZYXoLdCE7g/VZVo1jUeQPJ6q+gxoq/VI2BhDVVDJne4fJNMqp5aSDgJzlzkNmTUwAUju0hx6cN51mQWpdzMVLmspF05LtYM60zZSeEG1sQlUZlHrrMBzCC5HvJbikiqxIgaIZiW5GUCWE6Ap0HssPHruIjNBg3WBpYtNnC4AKqXXn/V3kt4WrtwsTwCpTz+TZENQVdHv1N3qFnOySLgoEg8BkRIOXnftCbAfJAI2Vcu1LL8GlgG81tmfS6AyNsMFCq41VO2V1vSGydyhgPLwPVvfy2JIgSWlR2AZvI9WVogYsVN/BDqQFlJ5z+wwxV9O+PC5BFYtdUalIo0BU52PUGBIeVlsqmRQhM1f3YZMQauhOnoOqYRBWxUdOveIk5AvqoasqVKyjJCBqFMPYgpbLphhh9ZQ4Aoyi65Svz10hbpBCYuWH5y0Elj+32gSEIH1pyMPzbnC3myRsI6ldFGZzFHUkwv6IYUNk3T0BJCI0nHZODKFsSUxkn3QlQtgF1SPi36o/vUsyU9pqHezMZYZn6q/3uHy3JXtzk7sJhgEW07MuUGBtZ4ANrkMHnWFnvzVXEzZBsY1ZphaCKeDpZF0JNZQ56pshnrwZCLQS1JGyIXzIsko0GKpm27hrhdsSMsMtWS1O85GBunUtYkOU7GMsgUUE91tNfytWSQlDsHqolaQfKSaE+9HYDlulig1jvE3uaxfA8uugkG471lLJ4Aya6WVXgvY/HxJd4LnWi6BZedBYNne0dqoHC2FxjhL8JgV2jPsPAD1RD576TTcIRZL0KWAWcoyAJi9DotnCMLAqhZLCzN8SlnsqqVcNJXW0NDp0W3ELAZvZ0S7ATOia5f8OB0O2fQJTOJAiTEuM9RwxM2s06TI3p+ZpzGtXQ6TBQ9docDSYvlci6f1TNaMrNDg/eDDD8mA1TNat22TRusnlrOm16lm+FgDkR4q7osuFhM3+cUMohbCLixh1m7csOg5oAAJyO5U6oemXpknRmvlCXF0ao7TybjABYjfbzudYudJTN2cSA+Qx03HN1ko7mhrPxZH13MBN2IdfO6Jt4/ofhf1SeUsSdMVVN2G9GSuDyarc3TQcf2bWiOBZQtGS2kAKrCkInuHLaXKn1wcr79kO+9tnSUGRvJNzdnNKLBUshFYWpjMFeYszJIEGC1WFmMlHlUzV1hJwVaLLVjSTcEhoDx8PW8Wb5oMVD76s/5ND28g41LpJ3LFdIcZsARX9zIkCrBaA7HCAiu5Sg5ZG1qtSko2aacOWbdxlhbGPuHx9bUxnVpWAtawmdGNrV+t+06NHkyyn716bkwZx8wgVKZKMn8zQVUWdYWJNo2L97Dp7+tZTvAwyM+AZYylxcqANYIMsW27Tv8M3rvnM9XciZ15fYtjWmV5NDTWphH7MeOYd5vK3Y/KseNf3RlcVRqyd6/B0asXaXzf3myZQL2Xi5sq3QRvdsANZHV/DaSxVrZ3nkb2x9CpwElW62RdIR1/vvZuXsdJ1mrpChPrAZAYs5htWWKQbDaaGK/vlD7phJoZGYzr8pwgMT7SdVp2sF+om+iNTKSH1lNL4cUWXHW4DssmZn8CR7rMXAJeEwcta/PD95YBXeuSlQbMCLNDkFnpt25nvKSVEzge/g3/rqqDcr1W0GXw8Lnu2/e8hKKxbnQu7RmLulot3WEGrLGk97rB9sVMUU3oH+OIOcdaN3IekTjW5vs0XLsx5/T1WGEs8OgFzAKM6xenzmeTPcpBXQjauyFm273vzGhTRAG8R16ctXYxmhs0uLEyEgX7IrKrBUrb7AFWttRccPl35L9LQTKRshEtZysBq6k8YqtpFMDqwLKIXIEUV2iv0IqpKjNDRynykRNYG03Zf1Y14hOjmBmbNDyKmN5x+ZJKMy4G6DeqT8r4HJNSKUWzmHhL3DkzaKes5MTtgjkpsCwtZGASWJupY/l1zlp5R3tRcRu2O7yLZYpSIxKoZhwWRNV5qGLUfvFRBL27GH+iRiZTUkWaBC4AKsAFVs/ReWSG/ZJiTfOLPJ9A1Quesr0UQ+XcrxZFIPk8A1f2XAsq2AWAQXaWFaYiKV19gWV8k+IsXjvnQqFb8zz3dQ5YllWyIwOVYic2pAVWNaxcrZZlGoE1sobqNtmauwwN4PuMYmklF3WMbtD2jz06MrjyxXZBXNqk2C0xLsAqR3DtVOTTJW12GsoaOXTd84pnROsCEiGKl2esboyhY9EeBViWZ4on5+Qida8CKwveZS142B4TWCZTVt2tZ2m9BJYxtcCzCW2v0JZOTwSNf+Pek1asPNH1GWMVIwXpyPzwUfCsZ86IKkh/8xaxLKi+ignoIQjVIvxRnJf6gjUbp6RM0Lggy5DG8bwBKyBoBM9RtGfs/wkmXV4GsA3H5y5mBioviHe4btAT7evJMzf76DOxMN1N9gUzHS2B5J1vmcAL5URzDRfHC1PAwie3leV0SnNWxMcl/GzOLRJP8TsCYJWui//z0ePXlsvfyzI4ASSwklw2h+0Y40BDAW8G20M5K6WFylmszFoJKgc1lu5EgJYbITsWYmX9vJ5H22Ry4FMAD7A8x4PJcC05KN89NNGeARwtrWQxqDfJHhUMM9Hcr+Jmm7ywIioQXDuJa1bUfygDJNMR7ZgEIbM8WuRjMNDlOGXlPCbaC5M3MBEqmqQ3yE0E5VxhLnjPESqNr3JWS168FssQQ2BZ+siAZUunS+fuqQndu5At9oqCtENuyAb0VMa3RqDlrlCtWlcuIB88nBYD08/jJiHdjF6D8tq9BqEtRUZlbOCJcATIivxEzHgVb0oLIIjsxW0/BWYoLlHXZ9PZ72dHc+vgRTB7nIcFNBDVzUjJsNxgcCmXqnGnZQXiHlxniqsAk6DysNyh5fSiODs4B3AbVy3H3fjagstHQeWFT4Dh/5YLBi1LE7B89GuPBLhmwNIa+74SsDjhllUsmkqBsT0jcDOrlcVbmQtsDixvhuxYoNZCU1YtZdrsMLV1ANBwxt9ldhpjpQCeEsqwWaXp+5YeHOyQNTqd8tDMtG2VPZMkV3MmD46jqLrnFw1GkmhKtO83LjoWTowjOveN6YzvHUNWOJBpHEFjbbBfed+UgWfAku2gO0xxVcoIEU1pcoVeD4ElsO2CeL79/8xiHXbEobAbaOnkdWdgtV1bCqT9Y9Hq+lQkHTsNkh+qK30Rg03Be5PeqEsEiofw4aAl12+am2oouhzbOdPdhwPKtVQCyrjKw4BdV5gBay1uwSMxG5pfTJ57kr149hTNSASWqbDVYNPqBdtzLk8L4hCE1GLjFK2YWamB7+DKgSmbyuKZDEAZuJJrA0zZ97P3IIgyy5WByhsksz5aUt9b1isUWDa8/Vp3aMKyCNcrWDM3mIDbzAU2t1gL6Ul6+JnnQ3/x/Wdxlp/Dm1UAuZKkSyl69f064hb7xnCnlP2+I/80m83aLGZq7cqJtaYyyb6IoZbVsHs7Fw5Dc3Uy8tqjo0PB+DisQ0HU087ZhGDtQBQFJ+DOPbeSIAWK5YVk/WgXCaxsYEVQeQhCgZXFWMa8qa8J780Yq2OHrk3sBmgzitu2atMaVkMfdBsoZhK31NJHmonKSDVb7afOYSCBRUxjJmJ6J4NUNMatDWm6RzJ57BCn7R1bP16QrdShjKMEle5u8wm5gD25vmag8vkBN9TkBj3BVbAQUpEVoOrDpb1MXjSJyj3zi6boHArdGovZLsriKy+MZllr5R5rrdVK4rGUpQEmH73QWQyU0n6tmbGQ329ygzn3nMtWfZ79XgYsXbQuMAOWFkx3KOgW0rvTaml5Ba+PmaUSVL8GljGgv+PnNladjQCJrEzLDsZZAsjMUMpwu6J20cut87hDOVoell10UwqxzfD36Ldah1zPCNq8isnRiWC9U7/xBO0jo13v0XFEu56xuGJKLK0Yhcp0vwQsCZNW3jNrJbC0WKlAmgL3nLVKATyuVyAaY6Vyg7FgE7DkvBu8/+mwQyiQAixjrJZs/3JUXjGQBtLwOeyArpzv9A0xhJLQVK3nLqaEwHj5BJqj9v6cMFEnyixmEqbQLFAwWavacCylBC6qgFp/DAVCAliBlD36XAvWvHblBWmgyJoWbTb1BQdWStEoS20L2ahy1Q14rf94oY1PBJmZqPUkKScu0nQ8TetjtufFzeK3zFVlVXVBI6gyYGUBeyoPCLwmN6kFEshapV8Dy5hLYNnaWUAiITvCv5OzVrmYytGyxVKnecxiLK1V0lpVa0HCHocZduYOdTFKDDmbKAlPYHVjY0QZa5AN4m3xDKOeZAPYUfvUrUD3fRwLtXbOJTYup3dXPJ7NHGOjVZ+h0abn8GjZNj9WskGtYWJJqlvJU7dVJlC0VrrUtEqQPqSljMQMbeYKBZYBvK5QYLk17NfAOuTQg3NZYb4tnTYdcYUlWCh47TRpaxikmL2Y+T24z1PpC1ZAQ6mohT1ZPSamg1yrzcMw0SW8QYHl/sF0lwMi61SCy+e6O782phJUPq7GNazkZGcWy4vqxTdjqwWcFllzghnj05Suz2Ul2IsUWF4QwWWMorUSVJYnjHecyi3FNafA3NioyeVlgMqslNYkC7Qzi5UBzEdBpbU68D0nq5O7pa8HF8q/JfOznPcosKzIe04yYGVgFtACSVA1bqV1BBtDcPm+/RxSifzcxpUCK3OH3ljGWcoBjABc/Sb2peTQPm3cGMjQ6Eh6dbIdRtXk6MoWRadS7xvtAOqYAXHMPFwZsXLrQmKrPmOiReGQaN1jWALWOrZRVCFX5FaMcVg7OxuZUrOgUidCi2XwnmIwyYd0XHR3SeXPoV3cpsmUMVYGLAeDpSYfKDf0ZHmhJHhH6ytoWs5kn2AtWgxV89hKXw2K4bBP45hC7846itVqY6oC5vftZ03DTAoUQZRqVQIJUHlotfzaOEuwmRH6c/58FiQv3YnIBSfck2uxUQqJoBpM8FoAQ9EgXJchmLIL4oXygulavFBeJFWHiyb2zrVwmmI434Ox1q/dUeaS0mvgYj2WmxhQxkjus+nw6yz4N66T/qPLmYqbTgVNF1YCApkW1dShEvuUz+Lr+rtL0JHwvfo9D597+HkEVe6AYiwbVL1VnvtoKGCcpcUaBk1Y92cA3wVgmR0Oo3dqQdM4S4sygYs+lbnCUkoN4xDPPZ01JQOGjIv2heOjHdaqY/eRcUjvsmjfvn2cMJeQgWnmIWzFcNRLLS5DGsFiyCG4LF/46E1tVi6IzAK1Ugb5mcXy0cwwI/11AFh/PPSgtG/pNz0RXnPmPmlfYUYHU4grh1JRDeWici5UE8S9ZjDjX44Q2FRco7N3RUy9lk7n50D8QvVBsUSZq9sIA3Td0WgzNAHMr6XHGGtptVYBBi2BlkKL4rJyXUI9bkA3k/QLKBkUoZw3FH9eD62jObC0VJlbye5+KS/GJMZXXlyBpGX0Pf2rdN/fy46lJASCSjAlIPG8OdAEltZN9yuwtKhmnwIqA5YVal24N4Fg8f35er5OZqkyUPmYucGkr5oEfFE8bjoEVkpeAG1yhwBLIHUpYdMHq0jyBnaNIZDtEj/L3iFcKblbDrGUzqNcMbooTmTBeK9+w6Jt77HRmoJ2h7wRcUhPJDChoR87F/YJK1f0OKnBj5K0XDWBY5/QGEuX6HOTJyv8GajS0CrxWG4rq6Bip48yAgDOQN5turZ08gvJCgtozagSMgjm6HR23WihqhuZv2uE30P24HZVrdV4ahhypUyD84Z2Sut9HbQQLAbmKcsDNKmibnzVFGtpNQSWP+P/a60ElOAyBnIDhSdYwOZouuhqAhKHTM12LIAKrMz1pcdmFsCvbcvIYDXYTVVtLYbgbbJqzQPnA4DK/o+LL6BWcTMIBoGVWa/0vaYyiO7UWEhadtrQ1eSuk8g/Vkww+Bm8EWRoZNawuaUSZOloKjf4uQRV7mBoBVBZNjGI9zUFllmh4FIRsHWvlkgJdWQJO7se1auAWqzFGEM3IgELgzCdJVhH1VG76j0IYI2Olr2wVN2Gx5+6s7eb0tL2upkMJucnK6X8t8DS8ml1BJOgSkVSnus5BFZqOPP/AklQCbAcqMwQc3sOTbQ6w3lP7AaGmBOwpCZbHJ0Fc7RS3fAGZH7mMsjIMX0uWSHd7EmYzRn48nxm9FyHZmlBd6a1EjDZYSFUkOn+tFwegkzrsQJLkQFLcC3lBHuHe6ebWWoJrIsNItMcwN+YsykHqpQ94e6yC+LFyiyBsck0qD1qg06lQmylWxeUXp+L2NxtZoF0FkQnF/krV9jcHQos46QsJjNZkPMvsCzECi4ti60jAac79LNk4MreY/Z+5dano+nz+Jm01AeA5dAKwNJ6aQGNs4yFXOY0ALZG64JW0YnNXFbhdY82pssor4yrI86id1qG/Hb1OPhW6GK1oRjatteIaNGT4df84XFwR9Yk9y2K9XCxBjqYitaFCwsElio6Asf4KgvgdYsC61+5QkHlkbNeeLpU18oBK7EbinqzupdKegcWKim0JqCm41Mnw1achqjadEoN0/Ddo0lrK2gd9BtfyD6cbmk39CLcl9ZK4KzgQmaux0zQ51k8pfXKrJXAyiyVoDKD8qR6pxtX5JYVIZtEpV0ukOzIXK0nB67syO58L5h3uRdAYGlBBYvA8vV9jz7PXJuPKe6BFp1+BjfoY/bcrz2yn0+Wqym7MyEwA/W9ZsDKqfHZ2qGW1QQsExBdc7YEQeuVASp77v9lh8DyEJDy2gSln8lyTqb9bpG0DOJim8LW0SGVHXrGCFgGY5nrs243GvVka0xDGPlawLKqBUh+Ht5tYLTtMSSO7IFEZv7Q+GPrzjGhbGAsq0CdB0ly+63FZNAucs/FW0xANwHLR8+/rjCzVrk4KldqyI4hdAb+FbB6FRdQee+Zn0jwiq1VoGc5y53EAGsKaiIeY2ZRw8JiudU+D6lF+1eO2WuV1uBCBJaPlhgEkK5QYDW3ZCnW0T01AStddN0bFz7RPVTmw1rJB3LxdjELlhSVdW6uOaCMxTwOuBQskj02a2nSbFMxEjAk8PD6S8wgm4EoA5Lfy77vYwamXwMvfc1r6LK1Wr5nL77vVZctsHxuMK8rtAan1RJcAieLB32/gspHQSZ4BF8CkU18QOTXGSgFmcDydd0kX4bVUmfL1o5xVreSLjFo8sB0Xfx/ZZVK6eE58rVuFkVOer5/ymPKB1Ad2r0s2uUPiUNatIsa+sD1CKYNQiJJ/S3lxQWW1KS0mNSMkMDdR8sPabxeQl+zwF1XmFksnwssv9ZiGWPpChOwevemRsI3HKSYOocKOuWDcZDKtFhVC6G5QosdNQspRrSThsDenMPIlcARTKsJaDN3J7AM1LNYK8v+VnKhV5tlNQXF2cVNmaAktcR6dCKYIBFrpQy2waTuQDcnkLIqtc91ndlF8tFCqkG77lA3llkdgaVFzEC0SKYoR/b1/xOwMsCl1xGkTTeDF92/1RxYWi2Deq2WLiyBC2DMx3VmWWEGqvm49xygcnHVXK0br5lirCbACV5BNoNww6TEZQMCK491JO1ZZqDVKhzeG3cIaYDgeRjXx6GHceMHxg7KCUPQ7D8U99euR2kclj84WmO9Dm/RNhbPhOg4tn8apzcbbA4sYykBpThcFmPp6psH71lclWWGWYyVK5gOD7NCg/ecxepVkIDVd1AJAvqDYzLmbnItcj21UFbQZhg8lX4V3++OGp7DE6sJxhOwqCmt4sKtBjAZuFJ63xRHGXN5p6/grs+A5UU/cKF1Y0xYSwg0aFeeWkpMMVu6FCrzwlg3SkBqiq+yNF1AZW7FDySwBJ2WSvAk9+bv8L0DQOb7jYx4eWQg+/VjBrbMXabXEpwAS2slUL34XvAMWLorbwrjrDTahuXKAJZuDrLmbG5RUHkzZSBKWaQgA0QZ2Pye7lYLZjznxdWiGKz3HMraPoDVpnerlB1a05IaPpSZzoHESeOpYe2iANqHAuWhvUZGm+4DWX5AYbTLAIrg7WJNDeJswxAinjYw7X6WU+8yJmMsXZ8lhgxYxlharMxaZVlgFrzntBys2lMSwXL9X4BVwAbUpI8F591tUWP4AJW6RKjJw1CO0bd3LekYE6j0StYTRKvMpIyrtEbUodbs0i3SOuH5KhR7V1JC8NGv1YAQbGuPsj9Ixga4vHsFjNmPFOQkQIaSXX9U4XSFmVsQLGaF/qy/44URUKliTbyjddAF2vbIsr0FdPgFyDJBBu1WIDW3Wv8KXP5/Zs0yi3fAwtnTk5rTBEy1LCwIG7xbFskAZpyVAcv1LlodDz+LYPJYqK4Yh0O6btvwtTIrJaCyOEtgZb/rhfbCG8D3h0LTtrAl1fT2CWD94F0N4qa3X9ufDsWsYSWxjlZOa3Rl23YZGi0J4I/MK4k/5bNAvHWX2IC0dpn6puz9dp+QPHfjK0sP7qXOCqQG8ALLIw3KcsObRdr49jF7bjYp28FHgdUF2ozBu0rav+nNEnGb0KXsTB5bPiLKEeOqosA2AbJ936F9CBRZbTKCVgAgsmzQHFgrAYkA+leH4FrBcmyBZXa2nJ/VeiWrgrUSMAJjKmvRJsPk9M0Xobxbzgf0pPr/WalBIPk7CVSAK/u+KbkiZQqlZRXurDDZCMCSQBxHBpoMHBm4sgv9axeZAS1ZvmZJgD+nBfLvJYlH7ugMWMZDWi0PM1xLIB5Z3OTvzWd20UNgGVJosf3/7PBzCyotlYdfC6x0AbFaAyciIAewMnfYG3c4EI9i2cFZwJpRBOcE7i3YaSSwWmCxBNYheSyW6pgfa9EkLR3aNUagx9ANhm1/skLjN4HlNZjGDKnuMFccNXjPJVNpnrEZuNK0UBPIrIWlIQ+AlWWFPaxj5fekPgI1ecgwgsAxw9hC0Su6FHSOfBbv9BzUIzr2bRvTkSLU2ljkXG9tJwGKjVwsqtQqZSDy0a89BNVSpBe1VksAxBIuytImy6Br8GR6EbRU8teNIwZgsRxx96Rm1irXTwMcTZVrnwsu3YnV6SHw2pu3TQRWAo6Wi0ctWOb+fMzAlD16oZt/r/nPJGunG2zmZgWIgNEFJrJdk9XKssPmwNJy+Vm0RFonAeXRwB5GgeWRWbYMXM2B5e9KF/LiCh65WR2K20Tbglx22HVAlxgwiQl2vIzliIZxQ6J27Ig4vEvPBKwj8wbEkd0GxSGde0cZBmRpzWRKDVDKEfboMqQ7mTRcd143s1gZsATXgfpVE6iMewWQIE/MiiZw2eJpDqxDWxzGJjjqWHm9UJtp1TJt/VLgtlOXztGqYyv4O50wuSwzIshbcxSTu0jlaK02EqQvwQoIrMxSZcDK3F8GtmWooCyzP9YELMHlhfYka610H2mFGlxrV304qiWwPMm6DkGUXKFuxNfAgmTxlRekDFbpRNJg2za6yuRmAcM8XsNH/5ag+bWFav4935OHIPTQhXr4XIu3AADrCrP4TSBmtay0oYtM1s/gHa9L9+I4FCun3nnFzC1qnQSUh891hY70/xpYfp1ZLB+NN31dgWXtqgthiTGWwOpQ1B4h3f4E9vRtSa4WlUNZZgfSnwBS266D/wmsDnkxEY5d/TTEi9FoKGE3d0cWshvECyxdm3/DoV6FXJoDK3OFgkcAZsBKlXtdNBbL71nU1mIJrF7Wsbr1zKM5yfgXCwK65zOwwLqKgoHI1BR3TdtAFbH1RAuk1RxarKWcdL/2gmSg0kL5vPnh9xZrbbAw2QX0YntSDXC9u7VWmmOBpaaDW1VTgAv4tEyCK4tRMleSmz2k0IcbVFBE1yV4LDVkrkbwNLdGGbiag8znmSXN3p8u+0B8JjABVXNg+f61NBZj0yKlJmD5OQ6AC/euuK+Mg6wi72cWUPVIbmbA0jr9+hBMgjE7jEEFqTGWBdEezFZagU/usKAt84IFUGCoRQ3tFStnUFxmedKfuhSz6L0sAeuIrqVxKEMO1aOGxowJ6DFQtVdVpuOgzun1BJbWyJBEUCWrBci8WSxBeNPrBjNrJaAyUKWkoinGsgPQST5WBqy8fFST2T4+iK0UrYi1WndsG50KOqU3XYH8oBndEsQ3BNJK3MIK3IKucDkKJ6twO1oln2dHslLNvqcbyYErF+94sb0rjY/SLB0XRlAJLhvcCnUkd9cUi6hk7PfmIY89l1Gn+aiq+PU4Zxr5YBmosljK39Ni6XIEjl9n7jAL4jNrliwa/691yoDlo27U7/tozU6rlVkwX09gWXLQDXrivQi69ObAmsaFSiP9bpXFdfo7gitzgT7PQPXr2Ko5uASVaj62bZRzVBWmZa8WB4DVZRA7EMcwujWkV6ypmBA92Lx2WB7FUQCVA9ZgeFgdYj5cugkjGesjGXNJQKdSOii4VukzvnZmbbOY1+uitdINZ3GWli0DlUG/FistzARsAss6lsF7sli93PFM17t0GGvksFSt8/DfgGrEtLLkAo2TknXiJAuqJaTHyy0w4hozYGVg8mcFYXb4tTGKF8eL5EVJbpATbUzi6JBvyuWP3vECaz6/r4U6ABBA1LC+CVAAa+EmipT0LAXVJC6mCUEWS+lmMkAKLMEmyJqDK4uhDlg/3lNmtYwBfZ6yyaYYLVks4qoEsqbPICj+R8DyjtdaeegSvYHMIrVAgkr35/F/Z60yYOUSANxhU+bsLh7lIwVWJ10h16ld307RewjtrCGFsXompL7O+ako2qbLoGjRtX8ClgZj6VQyOzyQEkWdKR25/cIyksDyJpV2I6gEmNfCG0ZAac08skzwgAvUDXKkqR1dJPU061gWSFOMVdijT24nNIMS4yvGR+eiDlFIk3Lt0chHY4mWeaI5+csBh4dWS1eom/MiZKDyMQOWoMsOQeXFyYDiyfVEm1UJLJcSWWmv4M4UWIIoC3IFjNapHo1NLZZqNAsQ9a9ksqSMWbhawON7yNQHmwNLQOl2sr/bHGAZqDKLJZCyI7NMGZAyYPn/CXQc3hzSczKLpbXKLJYXR2tlduuj7t5YMmWIxlQE4zVkelkc5fczt+dzM87s0fNUs1J5cOI1rJZLAQZM7p96hl1pRncqbActplN0H0gYMbQoVs0YG0e070ZRdGi07jwgAevwzkOiDV5oBXTlYaVML8Hlaj+wU5KiFFjGbuOdJ2xy31np53/kAo2n/pUrzICVBlYFVg8EHDI+1ujJw6JLnxZppcka9KmW0LNayoX0WIalyI7lm3F3fO2jYBKAWRYooLKLku56jgVciBS48mhslNiO3CUT6W/1HGVDVNE2JqeZcatns0JdAhjPiUmSBcJipLikqQc3Gd9fygBAKh8w3eyhixSAAlOrtggBkAUMpwq6BYDMQ93U5offy1xe8587AKomtyoos5/NWUT46bA2tZh+DnXAfJ6ByUHYydz1mTtMsRbxo5/RIrNgaX5ogT38P4/a1awi5mtvoEwhx9/3NQfAUbOu2I4AvivW6siibtG1uGMsQbZo3tghAKtLHAqYDs8bEq1Y9P67rgXRv0uvaJjEbCYiKQqnte7XPi1kKqNIagjiTZFZK+tZqcxAGycVRZFEsq9oIbX5IchtC7l8yr3SSh51aN82Djr0CIAFH6sbq3Vd0uRq3iLKCxP4heUIka3cTjMXYK3YQvwEgDIwZeDKAJe5veZW6kBGZXbGMQ/XkdVuvAs98d4l3i19qF1lbtATWreaVJy7Mwt2/b0U9DbVfIxHZFeM50Mnt8ZUswDSmql5JTi98H5vPqtY/hWosu9lli5zfX6dHf7MPBOJpngtA2SuXKBs5j+B5WcRXF54wZUBS/eSWYIsU/w1qPzaz+3R/P98fYGlfliWYQqyYcg75uPK2vRsQYJFhkg83KsIi8Rcwrzy8ZHfh73OXQfGIe0K46BOfeKgNl1iVAFlHIzGQBRl+sF1b0m5opBiaynsUd2ZsWFzYAm0TBpSUGXActuFgMqOXAPbxQLww2iEC6yDDzuS90OB1A2rWqyeLK0sHdk3lnDna4UWYQWMrdbsoJq+DZYlViADk4/+3GLck8ASVKrUeKTnTTFK7gJyoXF/XhAFco09vMs91GQyK/FuFBSeWIGlxdJtpOo0F9evBZb1IF1QX7haZoMpKOd9zkMkbg7irtkF8vlc5IkyYP0rS5VZoOZgOhCwNwXvCVxNwHKBgofuVWBpWQSSn0NgZeDScvn9DGSZFcuslvFSZrUyC5VZrOwxA5X/3xxcBvFaeblZR3Y/PDr1aR/terEHiUr8KpYmrZ9TEReeclyctg5Z8IVzY9rUSdG7S17MZCPb2CEFZIR9EuWmTW+q9miLqmZjtpclHVornwssXWFijDazWAJKMGmpcqDya7UcXC8HDbpDu38Cq5Alli2ObMPe5+KYzUzaCouYCSQo1ZH1rT8K7jrgElgJdE2u0ccMWAIxBeqAaiHu6L+6GDI0LoYg0Vp5oq1XSa1VbtrMw5OdzD8TQrrCDEyCK1kigJK5ubGwShV6S9khlqk5sLIL8z8CVrJAzY4McNn3/PrX4BJYvh8/Q4MAbwKWN4GfRUvlIbCSe7em1QQsH7VezcGl5UpSmVikDEDZc1/Tz6CV8tD6VqBQKLj8vRr+tjdmXxR3WuQfQa2xXQLX6JJusYP4eHJPOPF5bWMRZYejl9THyRuWx67GebGlblaU8jMG/nkDu0WHXu2Q32ZRPK0gWajpPWJdBZbeI8sIc0F7Dly5nmLOYmWgyrlDZY3+CawDrrB3757Rks63+wmXrXc9nFmffcBchT0DVmalBJdHBjQtVgYsAbmAk+GFElypwMijFkdr5V3rHS2YHBDwg2qCPdECKwGoCVheQMGoBVOr1JPszxhjTGHII/dzgBiXl1ms7ML4O1osj+ZAyqxO88cs9moOLgF24Pf+B8ASALo6gZSBKou3MkAl62W81QSuzDVmcVNyj4BGYAkkH5tbKW8m5Tj9PwFmjc+b0P6t1ff2fdpF2z5tYsbwAbGBecHG8SOjdctWcXC7PGKddtG9dac4sbE+VldMoqPSPi0R71LcObr375KeS6ZMpYamRCMrNWitvEa5ansOVL+Or3J0G62Xa+WoheEKtVgCqwcL5tNOaF2hUzoCy5KCmaAxlpX0tTtpLm9nng+3lyxUkwtsDiwB1UjQLKiaA8u734uo23IdnfGGb1rz63aroWiJZy5CV5hZpxRjWdMyvkLHKrlHXlu1v2LmDJPLA2yCSvA0kGxo7bwwmTvNvq+V+VdHBq4slmoOtv/y803V8sxipcQCQAssrYfAElBa4eaBfBZnZcDysbn1ygqomVtMsVRTTJVZKT+L2qwZsHSF3oSS/ORmte7VKrrAKJXY18Ca5GPRa5g2cWL8gUp7izZ5qPYheDKZBVvjEK5jdMwdOK26Hxn5WC+BJXvU9yywsvKI4Mq6IQIrs1Raq+z5f3WHzEkALIP3zBXmFyDH7VyhO1AE1lLU7lagI2Amt2wLCiwyFgCVMdYi3I7A8rGRE6sF87kWS1ApMekhsJrHNF6Q2WRDsk69g62NyAUqZCOnPG3vWu9CgZMA5Oi+rpEjZZKARuukNRvBcKWTwJYe/NoYSgDNQfoxu7O9GP6fv5d+l4vR/Pg1yDLA+P0MXNnPZDFVApNuUDqP75X3mQErWWCLiNz5WeyoaxRwHrqW7Pi15fJiZlYqA08GKkHmc3VZK5kXVADYc+XvyByVm3Vk9yPQZ+gS69i6NmMwnDSO847aEmMQ0aubzKjesL4xqaRXTOKxDxJQReNpYlO1L2DwVSlNKVFJ7bDJYqW6G17F95kZAAGVHQIrywaNs/y+JEOzQqeyM2Ali5WXR4sAYJUgtLZMaWpUXlLQTrnB2tTKrbRqOARRBqoFnFhBJsAyYGXWyhiruSvxeQ5YuaDd9oCgGlA+gPZBrqdm7CCwtDoCywtYw52ZgnYslkDxzu07DvYDIhZJXdmyhCtXANZsJCA9+V4kL7jWzN/TRf4aSP8joAki3V8CUxMY/V2tp4ffU+XZz+LrC2AvslYo7btRi70JYD5mAX1zUP0rYCXwNMVUPvdIosF8Fs+Zn8vD73vRtfqTWFZewAjXEXmHx0As1onEU+OGFUdxYY+4/vTT48YzToxJpX3j//jv/x6VWKupExilG9wzaYwJrEKYDf1o57ghzBsjs6SZizbWEli59k3ODWaZodbKQq2PuslRWKo0/9gErEMOb5G5wp5pl47aDY0Ivi62xUENaNkmrBTxRRakCyIBJYAETwKQViqLR3BPc7mo6Wi6SBkwtCbTGYYdOwflN3hdFue8EJ64muV0/83ovFg8F1w+T3FVsmCWH9huRTbUf0KfnGUDUK5Zmc/3kwvk9bMA10dfR2DV83NaNS2Xv5NA6/d1r82eZ9bNxxSXAcgEyiarl/2uj7520rfn73rBvdu9YUbR7tBqZS0QYxSPzHo1zxazC5lcEO49WSMOh1W0UEn/ns/m38oF+sZi/gzVcXTBHCiWoXBQtz/F2P5d4/j10LHZL3n+pg2xhjW7G+bNiHmTx8Uhhxway6ZPZGVgfhSNI3CnQNqy2+HRb2QRhVZqWLhUR/qyw/flkcVausKs3JDFVH6ttRJcDmR4Ta2+j4OeLMX9kIP/mET5iLFywOrHAkuBZVa4ZBNN3bXUiAzCubgLsQ4HDgCl6/MQXNldntSWAVcDd3J2x3t3e3JcMDBlLpwr1vlaObbf5V3tXdj8QmXPM2D52MB70kINxsLpCrVU6eJz+J78nebxiXd6AqVAciVeE6h0lxmYfPTr7HvNgdMccBkIs5/1MQO/wBIEWckhc4VZX83HJPjfVOM64BqbyhEZuH4NLMGqdfZm8bxpFXMWTasFS5XvuY5mdOXIOLzHkTGTVs5pq+bE0QjWjmZ390GHtokj2Y1Ux8Kt8WR/i5De7l3YkTH9IpgRXaJV3hEwHPomYA1hSMZESC8guLJsNis75Nwhq4+bMkEtl2AyU9QNCjYNhQwHgaWi358OOei/AqvvwGLUZmYnBoOlhnkrsVC2RLhzBJcWywuZWawUSwGmzDplX2fAUited+aJ8i6bQNag8q87W+yqT0YHILNYXiQvWHOLlX1dj+a7z4vYkzyDEfIs49Ma+TfTBW5aQuDrNQdWQzPr1BxEvwZVcyvWHGT+nMD0sRbt0uzw/aSg+l8BSy12B0CbgJUF9c0B1tx6CSwtlY/TXAvHZ/R1PRQVTq4QK2xWLbDSzch+wvG149LUzryZ01LQPqx7hzj8iNZxcPvi+N1hHSIPxsoC9kc2QKXJ790u7al2TL9tj5YxAGE2gSVQMmvl3xZYqXTSxNhIDAc0XQVXlh1qrfw9JTnVzxdYTghJX1IO64DF6s7G8cwVuh5uJRSZRqrZ81dhkbBYza2VINMqZUdye01ZmRbEw3ZQZiU8+Z4oZxIFloASWFouP0gCAndmBqLmj/6uh2tQ3HxhcS+VI4y5tDZcaEEskDzZ6aJwgfydzGL5symAb3J9zQGSxWeZhWr+c5lFE0hZcmAcdwBYLPbOLr4lBEGT1r8JKN1hk0tMewabssWskNrcNQowL6zv3cPnnq8UL1pmEFwoPQu6FH/xt5LL54Y1zuo5oGusmU88XDE91lCrWrl0UVSydnlAL0pIB/0xpg0jgIf814PWj8BqRRvIXvAAKM0D2fHtjT6NJQ0ejuhPYuLdGUUBI6DGM/3ukdWyMnDlYitqkVwXX0PxtilM87hAQGB1pOj+m549e0er1lRvhw5MWeHy1HS2+Ik7tLdm9iWgcC/pAFiZ26snyMwugm5HK5KOpovvCfKECSw3K6iaUjy+KJ0UQeD/e/Kau8MMUNljFbrlfUb2iHF8mMyy1HBh/buutMvudP+Or5clABkIfg0sAeLxa2Bl77m5ZUrA0pXy2bLf89G/X43qso9+jvT5ZFr+Clx+nWWKv67QZ65Ry52BK7lFXJ2WKrlBmLtus9WS+HeqCNy1zlKHx5EZDoE6fvpylmIN6hOj+3SNRuKrUzauiFNXzY31ddNiRUVFDCsrjMLBPdhMURhHUFRNpQZ0toyRzC7LEQr2MFQxS8+ApUVSaz9ZJVyfR+YGBVRWcpC9qsVyMr5jJ4h+fzo4OqBr+5uCAtgNjNiXDhuUFlouo/+2VHIfwbuuUL2s5kcGLK3FHD6kViDdzYrzcyG8CKlkwHNPkCdtAqKo1qzyh3VPW60ElicugYqLk13oBJamC59dYD9wPouWEmj4P4Hr3zG4rjE1trpNnOCdnhY/8X9ZLJQsXlMslT1mwPAxc3WZRWv+tw+4xCbr6OfL3quP2XPBIDhMLlLWK81EkY2mxwxY/8pypeY1oPT9H3BJTDQLqGk8GkJUzifzxGppGWsAc3K/DDk4UTWVYZczlqJ7MaRfdGxxaPzxyHZxeMsu0aNduxjZq2NsqJoQfSBs9h3RJ7pDmTm8G7RhQGa8lWpY3KwZqLwm41lslQFLq5QBSpBlrs/vZ4G8/+/4f1qTwryprlBgJYvl+JfA0mItXsNmVam6BO8uGp9Hit1APNEcWAJKF6i1qsUseyHTRfKCGoc0uQxPvODxpHuScxs8YTIgZjG5gTuwyeRnF6m5m8ncjv+XZuBY0evF97Uzy6glyoCV4jX+lq9x4KJzQwisDAAZaJpbG38+A1BzN/lfwMjPZGCe3QSo5q+hOzf4FVjqWwgqZbN99MhKEJmLbB5z6UL9Pd9/dqiToQCLwPJwOn0y58obqHoertAmN9nhaNbnLpk+gQHVmbFpwZyYNb08jujQK37bsmccdlibGNqzK/tyJiPQ0TGKIPh1ZlzM8kRvmKY2oK0ljiXD88YVXF4TQZUydwHT1MLJwJUBLQNYVn7weqpNqsJzlhV2dl+hW+zdCS2wDN61WAtM0ZcTK5HVCazsqOdC1RHTCKrsyFxCApR3NXdV1SJcnCL93HlaK0+0maCu0DevP09BKj/j7/vo7/jcIwOB3+s+NC/JJ6X0vwlcXmh/xs1kBpheIC1aqsA3WZaULbr0Kfu6CRTN/4YAOvD+m4Lz5pbN/0uZZVPpIgOW38/erzGebtjPOYbBggxUzS1X8+cCrLn1yoCl1UoZGqDKDkGmrNRUPpvxWEUdgAOIZm2jUQXaUIVb7M8OpCkj4qwdq6JiDIrXqOlVoTM6n9WAdRVjoltB+6QE2B7+Vov8Ixl0LYD/RozFbOEkYl0tleDyUVAZsjQHlhlhVsfKSg+ZW/RrYyxdoTuVtFgHH/SH6JSt7hVpAximWLiSJnIqMdA4ZhWvgJrnsQwLRaxTxwKgzN35aD2lxloUx2yCyzpdkb0vSWPcYR6pzoEf7ja4a6LCGsQLOA9dpaCqRDEwA5jPdWkG6qP4UAXs0TvgMnWbAoQLq7WZwR3sRfJu97Wax0cCyu9lQMosWQbczLplr+ejN0b2dfobfJ2BSCBlr+HzLGObiWrxDGp0k70wxCyOvZucJJkhHj08B9lFy77W7XjoCn3/WdovqCYTOHsIrMp6+WuTcdsTozIJ/uI20defiDLy5uljox8a/KPZKnLhMTviXKrua1G3Hs2FnULFvQ4ufIc+nam0F0ZrGA2t6S/2QUbd3TxW3cdT3JyCpZqkSG7T4feSWqAujol4e4FSY5rTZzLrlVk1wTiJ69ASDRClIrsyR0FLp1uaki3mzc1dSlZHmWAu6azb7LVQc90jyCau5sDKLkAVGqXKSFZzor0g2SFYNOOeHE+wDWfdoD0uP0Ay8Vn2w+8KpuzwdxMgrLSz6mQwI0opkDdYbjrS3+fwpBjDZK4wA0Hm/gSoIGgOCv8vi8MSuJoAlN0wzcHl58msb3YDZNY1q4gLqulkVc2BlVPb+yfAPPFpLVwT0Hwu0JJKTJMrFFgJZE2AEmACawZr4qq06MRyJivT+DyT6zi3w/vF2sljY8uccXH+GmTGsU7bUfLbinhezz/+WyL2jR/ePzoRY/VmOXirXm0oT7SJIvSzDN5ljwqiCRwTudmbA8v3LqiMi4ewScylT474+7VHBrr0HJfpZ5nMdWjTEZIhOu8JWF27dmbZOEhmJ3Qdorb1pLICqQ4dUi1Q7iAW0Vq5/bTprhZMFQuwOIDCi+NF8HseXgzBY8zhmxBUUj28mzW5GbBSAM9JS2AiQM0umsDyxOaXdU7LoARRAkcGLADh154UXYsXxNfKQJS5t+bWJrNcmQs7ECc1vfcsRsziRP9W9nky956BP3t9X0tQeSSQ09ZIFgttUO96L5CuIgNac8AJMgHmOfL9p5IM7nQiWVgWZ/moDOQMdK+moqUxZfZ4rCZzhoyB1Y4eHEsmAIhBxdG3c5fIb9cl2h9xZCyrrgBs1bGMcfo+fbpFl355BOy9omXP1knHNAOWug/NgaUnySxu9r5zQBpGmSg3ISS4skMv5P9rybS8XieBpcVy8us3nTt3pLDWKgGrfjFZYDOLlVwb/r0WCaMMVAesVbI0Tdag6YJ7Z1UCEC+AGY2xkZMl6j4MopvuSS/Hn2euMLnDpp/P3GGyEMRGVtq1WO6KTiBoApZ/I7lBLJ4pt/yszGIlYDXFa5ml+fWjf+eA1WmythmAsr+RuUNvGl8v+//msWD2upnFctm6LiUD1yiq2oLKOz+thHNjKWDLAJcBy5/3onp4obUevo5A1Qq6r2YWEpDTmU6farxFVjaG6XQtU83I0vg/f3tYHNyiZ/yxXf/47WFdohtbRuRgLUbDoV2XFtFtQH50H5QfR+a3TBqmxWOKEW7rh0ogew8za9X0t5vfFL5vjYIWy7nFDFBm9R6CKn0mAn3LFFOJdVt3yGmQdkV+9DddunT6L8AyYG/uCjNgCa4D1qop4BZYB1yE7gyQKISrtOQkUlTVfYvRCOg5tHuSO/ROFlhZxjNT0Vx/p+nQEiSrAJh7D8tLhVGBlYL8JnebXC8/p0XzDvOONyvTYqXf1fL9CjwZmLL3mrnGA0DUavo7TUcGsGSpmv1fet4UE2avaZ1JDTGBJRCaWy3B5QVqfmQAaw4sfycDmMDK3JMAm9xAuwQ3M4m4yq1lYxmLryChacSK7FwxJ8bSiutMVn94i45x8CGHR8t//29RzXqacaVFkAA7R9f+3ZmYhgkBsFRdzoA1fOaw/wKsDNy+D9+jFikHppw7TAqCACpzidnnMN4SWNN/Daw8lo0f2SLHIJ3TSG2K2lDO9RlXUUawKQqosvjJk+5JFQye1ANurOmiCJbMWil7lD+4G+a3ACkkNkVZkDO9BRSCL7tI/s50tE59XZ8Lyp6MJ2nRUlGwyXJ4oTOLqMtIul1YRf9esibNQNA8bmtuFZu73OSGm6xW5mYzcPl5zT5/Da508zS5bV10AlYDzdumINjP6A2UHdmdn8Ul/wpYfg5vEi+uYBrPxfVI1otlCE4zGQPZahnM7uZVLB8/G3mDLYQMO4nxls4iFhvLnuzRA2NicbeYP5ZRPpikLQo6Rue+3dJEu8ByAFlX6MKnERVcD/6GN0MCc9Ph+8hZKqjHCVxZnMWScdxhZqmyGMyeoa5QYGWu0On6tKTJ4F1XWIse1mwuZAISGV/OWhGYM7iaYqemu9WLLzAyYGVxkiddgAgcU++Bk1nsxCh3CemtEtJ+AO9ufya72D76Wn4vA9hApIwUuE8BMgXW5oDxwvs7460EA1b/TnNg5QLdnEv+tUXM3nfzv+1n8/N6M5mg6PJryPT8npa7ecyV/jaf3dfWalqa0Gorp1lOKcDPp6zm/xOwmoMri2uS9W1yTVosgeXjVAJ8P6MtEwXxSkf2jv59aS5jVc5jyOWCE1bFKQy/rOH8zaHBXz24IIZ2OjJaH/n7aAfzwaywfZ8O0aJHK7jyvQ8AS80z/6bAEswCS6B5TpOgbtORc4PInDfFWJlrzyyYP+fvTmuKsQ499JDonlSTUfRr1RoNAOohWiyBlYBExldNHFNjUNx0Z2cXSyBkwMq5Q2tRZCzcuWpr+WZ9gwbsjoRLpdUVelcbk/i7WpQMULnXsn2BtQP93ZnS1WqllF6lZi5i0prn8OL6u8ZWgjWzWMmdNl30zOr807L+0+X6N7L6ma5QMGUxpEBKYDJJaQJbVpA1DPDzqyLt3/lnpgl7A6ulCHAGLD/7/53Fah5z+XOZxUrusClTy8A1HvWfSdVklFS2yyuxaqgA5Q3oHD3b/HusZsfQNjTnN9UPjmXTesbG2tJYj5WZ1rdrdGrzx2jHmFc7rFbbgnYJWIW0dSw3qN2QAUsAZ+WGDFiZlU3BO0F+7mDNCqWH5N6lI1M6Ur3ZnxVYU6kltm4Pu4HKewJWL7gzbqZwR6HDFALLOzYHLNee5I7MWmkdvOgCIF2kprtYLXjvXMHjiRJMBu26QZcLjeEEZkGpP2dG6TG9Hp109Lj83iwuaClBfl/isurFZoLEV1nc43tYQGaIJfVCZpbBC2A9y+/NnAu4eC3bIALe72eAPBD/6XIBiOAx+81AlJYn8L15KykM832BNQvrmlmw7Pdn6sKbMmEBL/AE8BRSboHlhRLwllY8vKG8EM0Pv5+BLy0DaAJiAljTkVksG9lTZo9NorV1SDxOYFnTgE4tY2ifvGgYMzC2UytsHMs2ti7/HgPb/z6G5OHyWv2OhvAhLBBgBw/iLq3zWyEx2TZpl3o99CCjKgA0MqD+nZQENdXgBJxu0hjMx0x4z2Df7wkyv+eGDB+1WFbuVdtuQ/CuxcpDwSiNfwkshyl0hTX0pHJgom6UAJaLQzJrZQrsSRRYKdZo+j9dmRZL8HiylNXRDWq1RLdvPgOWPyeQPKbV5VSatXj+f+EIhFu5EKbVgit7fS/yLAAzC3D5+wruerf7ur5OAlcTsARXAq3f5335oX0UFBkwMouUc/vEbpycDFx+XUUJYSY3icBKz/ndZKmw3lm8mT330fMhsHw/AsXD8/BrUPm1wMoAlT1mv+PnElwZsJJ+AtZi4cwRsUyaMOP1c0YNjnXzqmJmSc+YDEW5sMW/xfj+edHusN/FEUf8LjoDrg7dW0en3rhCLFar7i3/C7BShi6oanI3QvO4MAOWQMqslQDKAOb30gQ1wPIQWMZ/5WCiXSfaRkccFt1hV/zGDauyG6y8C6xq2gWeSK1DslQ8zzI9rZLWKqkq8zy76Nn/G2f4RjWb0l+1WALMu1bLojXz0G0IjvQIsPw9rdMQANiDYF+QCDTXrjQHlkqDWiN/3guQYizAJYCaW6wMWJnFykB1ID7CBQqY7BBIAtfPK9C8ofzcGdj8v5Q0NLnbzApmIBVY3lhTKFY2B5YA+lfA+jW4mgNxFGBsDq7Ub+T8LWax0ipqRmMKW7Erpzo2sAigYVRJDKI2ddSmlXHBqSdD9GO6uSgvOnc9Mtr0aE21vWO0790hWua1IIDvkLa1mqXrTcZW4XZnE1txXQTyP903RD6kJwWWAMpApBZtZqUyoPmou9TaTaJm15Y61mGH/Sm6dLfyDrDsFQqsmvmYf0zrAevQdEI9gQKpnEDS/pLA0gokK2bgndzgP0+sd4SxlYOVPveu1BrlMkJfKwcqD61MZsF0gSV03gWV36+m6pxdTC+ywPL7k2bTdmhyNV6EA65VS9X0M5mrTaD/ldVKrgzwZBY53Ty8Lz+33/PRr7PvZcDytdIKGKxTdvi150CLJeBT0bYpK/w1qNKqkqYjA1cGqszCCawMXOl1iK3GQnFZy+feZABf1CaObqiOrY1z4oy1jQyobo0Lzj0tzjjxaPqG3eJU2m+l+ZQduh4ShxfhAnu1T8BSpE2evBtbBZYM1HHsRtIQNE84xhDPNQdWZpmaPwqyBCqtFzGdLnw8sVbLth3iD3/4PQDr8E9XaIxVxcKA5sDyYmbA8cQJqImyE3jMrIAnVjMo6AzcvdC6vyy+8kNkwMqKfhmoMmAJgtHUSgpQmRs3a0QCh4dWM61c0Y1h6QSWMZk/MwyrqGX072UxVm7xAQG2j8ZcHiYaTa+RAUyACKDM5WVuz88riPxbHgJLK+Zjc1eaWa/stT0HU5Qwx2JlAbwnOwt0BVEGKN+zRxZ7ZbGY5yi5xV8d1vJ0hVv//8W9BXRVVxr+HVwDCSHuJCEkRLAgUSAJCSEkJCECgeCFGnU3SqlQd2+pd9pO3d0LLXV3t2nH6jYz7//57Xt3uKTQmf/3fWt9LPY613Luufs8+3n93fsstmPYFEoWIcA648iD7OLjDrPLTjvBLrvgLNtTmQzLanPtrANabFrOcMsuSLIMmoYIWOmFaXKSstBVRBEEFjoWrAWo/EJAtegpCncELM9cocCaJ5GYlpltUVGREom5AWClpQc87wQ8uxRFD4iBwCpmQgENelWzsgZpcstjd5OI+7FSiRVpYpvlX6mRpQBTASz/I5gwVrKzPqSHAEBWN8OBSwCAqaZpjxcn1gQO3B1L1gQY0ek3jlEUg5TobFCYYbZWvgeW17F4D+Bx9CwYylY9geWcvkEdC0AFVICAbuXFoBeJ/jq8rhXqTAWogTmA0QOMxeB3h7KUB5UH1g4ZLISxnLjHEFD04hABfKPSk+dPy7TzD9nfzj72SLvw5KPtsssutVM2HGH1igWeomD1vssqLTsnyjImjraUCTk2elK2pRUowa9yvFPeEYXovDAWOpZnR8+cKOw99SsYir7yoaLQi0mX6IeuK2DBWHHKbqB5nwNWqpLvcZB6YDmm0qrvlNvAMxUikMQwgIVvhZu0QCBhQnkOk3HDp0unwimKt509X/gRHljeamLynVsiCLCmpXMcW83uqAxYcgL1conBxQq2en3GA4te9PXyqwAs580PikLA5frUB4HlQcu1+WsMFV8B0RpgqFBRyHMWDODidScG+WxQ7HMOL/488wEyXuf3tGirN88CiOtQtuJ6ezJWT3HJ3/ibzW9rELOwcdauAtgF2tpunkThSQrZXHreGXbVJWfZSScfZ3NL8+wQicvz1AahXJ3+UnLiFRsUUynZL0sAA1gk+AEsb0zBWIhCz5CeMb3l54GDyPPA8iIwVJkHWM75LWBhFeJumDA52MaoJ7CY1IWsegHHmdECDaAiMaxJjjluFp/pEAu1CnA853WatZXInIWtUN5R3N1OVfpiF0EPmuNMPuBiAIBqVehOmJHXbSli+cGYnSsD+otnx06BBp9OrfK1YUZuEswAGEMtTG8QIJoAAdfnAeH0QfQi9xvFuLomFhAjoFsGgOWfIwoBVqg49ezlzgUI0UGDwOI3ec85Ny0UOB5YoXqWd014ALJgsIq79SwBYI6yC1rkGD1XvfVXqM3jklkz7NyzTrZ16w60ZlUdr6kttEuOXWYtjYoZjhppYyZkW64UeEbmhCxLzU9R6sxkp2O5DZ40d3O0Uy6s5cRg0IINGBsBl0Ko4t5TvwrVsQjxOH+igIXynqAqHcdYY8eKLhVrmlVbaV2r5OXGRFckfcEu0HvAReBWoNiosUsAWaqwjCpEuHkwhPM4Cyiwzsz55cpPL7Jx6m8JwGAvbj7AQhRiMfE5Pt+6XMASSHDKjZdbYmaTNsIWcGBK2AoQLYCBAHjQJYF4Q7/CeqyW7sYEcV0wBX/L3wQWhK5L1+iv04nG4Dn8Z/gcj/3gb3jsAB08Dy4X2BOdzf1WndMf+T6MDJ7jZ3JDQOZaUAmapL+0SNSgCHOzvHjh6H1C/nWOTrTr96A7AizHdnoNdm4mrCLG2UPb8p551N5WXZBi1eOSbWZ+gu09v9DO1CYMreqGPC4/ydKz4y09L0XbnKi3g5yiGYXpUt5TXfXzFKkoDlhIEQGrUcACXH54/5X3VQEgfJAYYDN0bznynIHuzPxT9Fqnyh2YlTajCYnJgYJV8rHYrxBgLV4p3QJrTXvotOsxwHLOsyCwuIkAy08u4GAiAQvKN0CarMg7LgOARV9yH3zmHJwLUDHxgIqbwcUBLFYl53WbF6BLBUEFAHjdsxDX4BqGaSBmmXjO6fSr4OgJLP7en8MDz58/oEvCUgGg8dgDy1+HP1/3dQQBhi7I4HW3UIIszO+bJz8RoyewuGkeXKFH9zpKfXAAKkaFQFfZocfScUolBvcX0x6nZMq9WovtWMUQj9KekTUl2qlCIJupVkWZ8mElj01yYEoX+EaJtejX4IClgd7rgQUYABhikcHjUMZC5AGm0BEKLOZ/9kIZHaovnLdY+07n51hScmqgP9aUKdrFIAgsGIv01/blTJRWn8ImUKXzBoutuKmAgdXK6gUcTCLv1SgHu4wQjkAFuHAdwGBMDueA2jkPIIB1ACh/j8jk826bFd0gWALWatf3eNbyTMFnAFIosBC/XIO76cHRoWvzLOKZq5vBABnAgHVDPs9zwBXQLbdnP/85bxxwLoDEEb8a88H3+flgoTk20I0KZYFt4ZFAmARxE+ov8u970cP7FXKMlqiXO9ubTJmufqNFaVY7Pceqi5KsbnKyFRbEW6Gqb+htVt0yy5LFUHHyuifLKqRtN2Jw9CQlGSgl2YtCmBEQOVB1yhLVqNOYrR0rarW5wKx2deoLDq9fobwHGGzbcA5SMRbAalK4aUwBKVjpAWBNm8ZeOrlWW1dtS1dLUQ0y1vxlYiK2shAgnJUTFIV+1XpR5tkKUVasXuOwD+IQYBGeCQUWspzPAwQGynqh+mFWNpd1i0GAxY1s043jhnnG4nsBJczGeT1jASzO6cAXHICyWzyFPA79jP8s38PwwAoVkTsCnxd9nnHdNWp41mpWSISF44HlRWC3FRV0OoY6GblB/oYBILIPyJniOF31gMWK8RWpqUfp3BLXHjJbmQq5YqaC8aNtkkI8pXq/vEm9XOepS7JANHJ0jCXlJzrWgr3GqGB1G7DKHKhhKMDEdcJcDBYC4PKgqhFT/hGweK+mA7FdbY1aAGPEWCkpaTaZVpEeWDXaiqxLOT8orYhBgNWo5mjOEUkYQjcQZvIT2yTdAdZhEnmvQkol4RjaGCIGPbD4W29+8/cMp+AKDKVSSFHaOYdnK0STEz0ChGchAAFQ+BsUd5jQgQsfmYDG67zP3/gB8HnNievg8J8BMA58QUDxHJaCrbyI5DmvtyKy+fvg0Z/TA8szl2cx5iQALqXPBG8ULMDgRvnBzaP/AkzAIDBMLvpUpbVQAzhJmQgTaibZVFXXlMiao7tMrkBUoNfylf5SWFWkHu/TNNcBI4l041KBK0sB59isGCcS05XlkDAmUfFCed1VnRNgrDLHlE7sCUQACsZifx3PVlWt8rJrhF5fKGP5awZYs9oxNuRPlEjMzhujWGGKTaKN0dTiAGPNmqOte+XibydHR2KweYnMZgELYCD3YRcA4EWgBxZMNkvl2mX1U6xILoZJ8rh7YMEq6F6AKaB3sJIDwAKME2ey2iY7/YgbhtLuGCpUlAUZhxvovwvdDXAh+z1jOSCFDG68Z1V/dGBAhAVBNV8g8IAJFYNeD/PnCwWsA1vQ8OB8nIMjgPLineeIBiY7VMR4gAEqblxlUMQBKoBRVCeL2oFmvEAk3bdcu4QoT52eoRnaeia9ONNGlWZYVlmWi2yQuk22whT9HS0gOUde2ViLkWWYNDpRW/ZmB4ClfCwYDwcp4HVMgygWKBhVrQJ4iwCuMb0FxlRTNo3AY5XjBwfXCaMyPNBgrLn4soLASpaO5YA1ZZq2x5COVTW70jrk12hFyZYiBoIBlrdWuIEAo1uX0KpkImEMnJsABP0K1gJY6FseWICLvwUYHJ13XqISMVgnMeD8TwIUynI3mwTZxrFF8EaiX+GawEgAWETpYTAHVs8oQXYJvckOAMHhWQpm4rta9DsAhxO9QQW+G9w7eM2zWDeQAJTOwUKDqfzrzGFPYMFWHlQzuHkqdQcMxepgjI8pXxmelGmNUqe+5EmjLEH9r+InZ1rE2ASLlliLLUx1oo4W3JlyfBYqn71werGG0mHmVEgVKXe5V9EZAtaYJEvMThR7xWlrlFyXPTqherxjLcAFcMq1fzTHUsStmNKPKQIrzDlNacxcG6OkIVCE4cRzEGBeFDYoXvg7YE2eWuRihVRCt8tEno9fQ+ibpRU1ly0tgqY9jOXdDUweEzmP9Aq9DqiKZ6v/kvQr9CwPLFwCgAFQAi4eO3EmBuSzAItzARwXB8Ss9+InCCyvL7mcJPKv6Z0ZZCxMYNiS13cErFAW8Y+9UYD15xV1XvPsFapXAb5FqwLWotf7YDg+C5hCH/McYPl5QedgeIW4J6jKdTNLHNtIL60a5zr0wU4AKkb60fDsWAvPirZ+aZEWmZNkkaOTbWR2hvQnlXFNVDnXBG0kMG6a+l2JpUrKtbG4dvyaooQCdZgZljrcYvT38dlxNiItSp3/slxDEHLe8ysLHMAmSaTiNCX5b0L1BAfqArU5gi05+sdcH0zHEYB5cMFaAGt2u1QdAathgfrHS8fqZix2WB2Tmy1RqO5uXXKGLlW0WwzAzQI0zhEpi4+S7iYBaduESjYrB5pVh3I5WRdaJBpnsPsnr7M6oX/Ybw5Kno5QMBfHnnsopk7sCVjcaH/zuJHzZGZz41qXoicpLVeg51yIj+nSJRhVoupqPUeXQSfc7oZjscIgweHOFWQ1wOLCRTqiVzrwyBnLwmqTbuQcs3rNDYGd6/PAc6IvKEI5H9/hAQWoEIEMQMV1ob/Uok/RQU8D3TAwZ9Pczc2tyrYMlWgl6+ZH5Y+woUrgG5QWYQOSolTVrDz2fLXVHjNV++GUWepYbV/CPoT5lZaaqdejcy0iOcMipdfEjkqR/0q+K3ncwxOHWYQAFZEmYMYPs4SCDEsen6Xt5TIsTToYu1nkqGEbdYajtLtFWlGmY8I0dWD2g9cz1Th3jILXY9XvYdKsyU6cTtU1syDYkwdVBGAhCrm/uePyLFnK+8TJKqbwwKquq7Qm7YLOhMAsjBoplzAWrACwmlHYgyuVyeQ1RB5WoNevcB3wnC9GFDqlVefhi2dJhgM2Vii7V8GMc3UOb94DMm4a3+Mfex2GmwbQEYGcG/GLJQqwACw64fwlAQA4gAWHZxUPOs69QI5LFy4KGYDI6ZgCF+97YPnr8CLTAzX0fKFsxfw1dMo1o8Fjrm02IjDI/LBtqcQMoCqYrkZoEl1x49IsIifGeieEW1h0lA3LGK2NlqZoI8s52gSgXiGZ2fJFyU+kjZeSUsdZ/8FRFjZosPWLibDozHRta5Kjogmxj+oHqcgJTxxqg2IH26CYoRY2srcNzYi04WOiOxdpwwAAiAhJREFULSov3mLl2xopn1dUbpwbQ5QUCDOGK+N0UEaMDc6MteG5iRaZl2gj5HBNkAWaPnWMZUic5qq7zWQVvzqdrk6ZKE0VVtsmUIlg6qSr5RRSmCN3Aw7SiRPlxxqTpRL76TanTTG4NrGM9BZuIuKQFYb4mSNnGaKPGwOoGsjXCSrtBI8nVyt6rsFjROMMdZDj71yWIcwlBbFa1btMarYa3k8S/aKHcD6vHM+RvuXZAcbyIOPG+e9DvwJUWKF8BwzGjeMmemD5m+/AFdShPGNxTg8eAASYAFg3kNAzZYLDWrznr8EvKvf7gwvMM7gHM+APBRbgAlhsPMmCYlHw+xE/gGq0blhsXoZYaoSFxQyzoaMKA1vtTpyrIPJ8+Z8WqFy9Vd1bGlXiNVmAirG+/QbZ0KihFjMmzpKmZbiC1HxV4YxVU7WcilzLkbgLTxlmfUf0E/jCLGxwmPWLHmj9YgdZn+hB1jduqPWPDbdeIwZaWHgfC4voq+8eZL31elg0QBxsYVH9LSxOn02NsGECWqx8YymqpE7ThgXZ+q7x2hCquF761lxtadcCVnQPhBvvx3LuBtoYjR6TbTNmidbmB1gFvxKggg1YYQAEPcmvRJgGFqqQcse+O0VVhc7CmyT5DbjQt7jxnMdZD1IQZzSodY4afuVJOaWVNOduWiRDQQACWBwbBdZ6AREWYzRIbPpRi0kuQKG/wYgldfIiyxJFrAAubiBABVzdICJkpPMCBF7rtu7ESoCnRaIK0QeAPItxnC8TnCPvOTYKAsk/DgUWjwEYwz0OikLmqh7nYZCxuEb0qoBONd5G6yYlKbNzuJRrQBU5epoVVq4RSFYoQW+RZU/qkud8rpTwqRYVn239Bg63PgP627DESLWIlBIvkZZBoYRUimyJNazGUSUaUvz7xwyxsP4CVa8w6xUWZr1797ZefXpbWO9eeq23ahFHuG0E995nPzvn9JPt/LNOt4vOPcsuPv88O+u0U23PPdZYiXbwio+Lsr4jB1i/hCE2AqerdMAMAXecc10oZNeguW+SVFLjFoCF5x1ROAUH6dSpYpCcMQ5Yda1iIQFrhm6W119gCEDGqgNQTBagwqJA5o7XSiG5n02DGC7RX8pfMXqWgMe+xeX1si5qJsuZp1U6Jctt4NiojMg69RbgRrgbIFFZM18MKfBxkQyezxHVwnZcEyGJibopE3R+xhR0OiL2YgGukfM067xEDlxYSoD1DMPRW39Yv4CnWfoPRxgslKV4zGcAXihDefHnzwNYAZRfFBwBN8MDi3mDsbEC0U0owUKkJCsPPTIr3nrF9bXwdM1Z1UGaz8O1s1ebZRWpc0xeg8VlF9jwkXHWq58YREAZnDhEYizOYuVpT1bWQsaEsZYu7zpgStFijc5PtpjcVOsvRgvr28969+pvfcP6Wj+N9KQ0a5vfameecZrdd9edtnXzE/bqC8/a808/ZS9u3WLPb9liLzz9tL320ov2+ssv2TNPPW4P3Xe3HXnM4VZUMdnCkyNsZE6cvitLPWTHO3WGPapnyikLsLh/MFY3sCZOUF1/VqaVq8tubYt8GpKbKNWwDAN9BnZB3DhdQRuS02oQh1ueyotI0gcsWTKLGTweW5rr8n+IqE+o0rYmTTO1F8++2g54nAsxzGieqR1BtR+OdvycJSpduc9S+cda5AhU/aGsi132W24VAuN09cqcoVVBz0y+r0DOwjwBl0E/TZq18hrdVAAeAGxcKEUe1pLS39IVuPGhrAIYYCPAA7AAD+BiACbeA2g89sDjM3ye170Y9aIy1CfG98zrDFjVfrg5E+gxNjByuGYS8KJk6fVPipDIGSKxuFIqxEmat70ta9p86VP1lpgx1YaMjBTjSFQN6q/PDrfw3BiLLohzvUc5B0p3kgLNsflpFj02RUBNEKONFDOFWZ8+/Sw5LsWWq+T+jDNPscefeNhefuU5e+65J+3Zpx8TsB6yrU88YM9tfd6e2/KsPfPkVnvykc324F0P2d233G333XGPPXH/I/b6M8/bC089bRdecJ5V1s20uNFqXiv/WsB1MckBq6ZNVT9a1F7HmlqinPf8vPGWNirdNbetnjfTiSyANRPLS0eXLqzHgAugwT5FshBy5HRLnpAuJVMl3mMTXXyKkaTIu+sTIKV0bJnkfkm+NS9tsVseuEX6U5taFeZrp7ADFVSdbXsdtIcVzyrWRlAHyN3QZXmqKtn9oN1tTvsctxnn5JkSG1JGx80Y774vfTKWS6Yb3moZLVEAuFAmWRQwHODiBjMQpZ51ABnA8ko6gAkdgAvxB6gAkAeeB5gHntfNnAgN+sO8boh45/s9u8NWsL8Tg1poucqdSlSqcLgU5T7x4ZY2caaVN6y3oupj5HJYpbmrs7iMIktIybV+/aXvDOxnfUYOtaGZMdrJK1liUPNdkGgJ6n4cL+aKUZAZPWhIkvS0IdKr+oS51JW1u+1qmx991F56+Vnb+uxTtvWZp2zL5sft2afEUJufsc33PWoP3nSn3XjGtXbafhtt/7a1ttts9c+vVOXSjE7bvbrL1tYus4M797HDVxxo5x93pm1cd6xNLS6ytLy0gF9MBgjisEpNX7yO5VKwPLDYbHzGLJnuDljqnaTVD7DoBIc+UyaRxms8n1yl3Tk1OSmyZCJHR8uCGWlD5GsZlDLcBkvZi1A4ITYv2U0edE9QtENtC/c5Yh/dhAUuuX/p2mViLAVVKyZZed10O/uyc+VuWGLp+RlW3VQjE79LIQltTVukuJiqTDInK1QgfSQ6L0mWTIKNUCIbx2hZL2nqW06zCxiSa69rVZoOvhUxn2OPoDULuNDh0JMABCABRICmCasy5OjdDh5YvO/1Lv+3/L0/x3a6l1gScQy4uA6AxYJEXOMvYkFw3UPSo62vWKi4fn+1xz5BIv5gSy2aqx5WVZaSPdn6DYgSW6FQ97KBqeEWlTlSbgcBSi6DWM3ryLxUi5QDdEBqpACqzw2UTiVxOa+p3u6+42Z7+7WX7NknHrWtEmnPbd5szz3xtN17491KZd5kJx1worIj9raFZZ3WMKXFGorUZ6NILZImKZw2RVm1M7RNjUbnxFarTVVWRayMjYgxNj5JZBKbaMkZqY4w8vR7aO09XX3PMMxGK6SDVeiAVVQUsAqrZsut0CRzXoACSCX18sTK14II8kfypgFVYn6qDRsVI+thgPUa0tt6D+sbGMO1YiL72UBRfERmnFuVI1PjbXhajJuAoTJtx05T2feUHJtYQfhHyWfVYqUKmd0CYpImKy43yaI1YYNTRtjwjDiLkPUzUoBCyR2UOsL6xA6xAVrpqfLLkCUZny2gZSs2Jv1uolgLcVo9R3VzLQpBCVhYmgBqbofAIREJoyAiEZULpIvBaOhGzvLEWBAQABGirxHxLyfgXL3etkyhHLUKal4YMBB8QJzzMjyQHEsK1DyHPWe11zgDY3JdoY3Tb01SS4OIrJE2MHqINnYHeKfalDlHWPb0NWLkFvmoZljkyGSncPfuJ8V7xAA3F8MUWB42Nt4ilbUwXIHlwaOibUBypPWW1RfWN8zGaHfTjRtOdDrS1i2P2jObH7Fnnn7CHrznYbv0jCvs6DXH2prqPW2X0t1s6ZQVtqRkmXWVqm9syRJbK1F84Ow1dvC83WyX6g6bVVBq+Wk5lhqXamFS/hGtYQM0dI+559E5SsdRQ7d83cNplZJoCo7DXGk5gf0Ki4oFLJR3HKQAa4b0HsdKQa/sxKoJjglcvrQUdUIDKbJIBuNvCe9tI0bF2kGHH2g333GTPfTkQ3b8GRstOVsXM6SPJm6onXHpOXbptVdI8ZPfZeRAixoTbxNnqPtJmUxWgWlCFSJVJUPoCALOcNF55vhs3Xwl++2xUp1VFip0kWN9ogZa38gB1ieivyVkJdul111uH379iX341cd238P3qJp5V4FRvS8F+qnKSZo+B/1MQ4sEYOBvq9MRNuNmAy7neA3qYR6AWKROAZfCDcDmykghDwrWa0K8tapiZqH8fGKiKgVzccFwPs4LuLwY5jHg4nWsJtieSAMFpAmFY6x/4mAbkhBtdQ37WHXrRsUID5KfaJGYucHSc6fZsEhZilh0A2XFjehvA1O0KMVYMVIzBsirPkiAGhI33DEUjUCOOOIIB6IXntGQUv7CU1vtrpvutWOPONmW1K+xhmkdNneKCn1n7moLS1ba8unaPKtmVzu0aR87vf1gW9+01lonaEvfuEwb0nuAwCQrsp9ApGsIE7j7DutvA0YOca6KIemB60iUfyu7VO2TpqsfhAw1cJMuHAU2aZK7wfuxKmtlzmulF2vF4+qHnSgZYgCsQuk56E5DRd9hQ3vb6n12tQ8+/8DM/m3/+tev7vgfjRdeet4GDh5gVbMq3XNGvXZJ4AJTCtJVMaKUD9W7EefKVSl4yoTRNjBhmHb/rLBzLjvfnZO/4Xz2n3/ZX/7+pa079ii3KmOT4uzlV1+yf/3nt8D7wfHbv3+1czadp10XsiSqpeTTflrhhyly3lbKy1+j8IMHV60eM7jxMI8TlyGsUytjoloKKaCYJVBUypKr5agViaFRqfcqxOY1zWobwLn0GoPPezEMwBizZejMCqa+MKej9LtHKoYXFt1XTs0iMeCp6q96vDIZ9tcuXgussLTRohIydUN1U2GJQfIzxQy2XmJpxB03NjwhQlJCr+umV1XOsNtuvNWe3/qUvbD1EQequ2+42w7d4zhrm7WbzSlZalWlK2x22Qprnb7a2oq1VY3AvE/DHrZ2zgqx00IrGjPeRgwIl+XYy/qInRj95ZbgOFCsGTZI4BaAe8vv5XxgKfJtiT3jpQqlECoqLnBb1QGslEyFoyQqHWOxM0W2KIyQDowFsGAqAAVD4RrA6sIKGSwRl6141K33365b+qv959+/6OZu+/frr7/ah+9/YH3kK9l0yaW67/+xX3762TJHZzhgJGYnKz9Iyr30hNHStRLVvyktP9POuPhs++q7v9u/OOu/OKdA8y+Apf8CF8Ddf/997aADDnSvMf716292xmmn2yUXXar39Rn9TYN2YcgozLCiSnm1pdBPwtcl8VgukY4bY6ZcJJ61EJGwGOzDax4cVY3y7NcVO30NF0mx9qApVZLcVDkFaWCGMYGeyWuwIudFv8A1wsAy9YPns/C9SWnPr1DXYuWih4+KlDjpK1fJAmtedJ6Vtp5keZV7Wc7UdsscW2b9B8lS1E3t21/gAVywVnhfuRCkyA/WjZZyDqgWL+iwJx+Wcv6MALXlMdv8wGN23omX2oKaPW1u8RprKltr88p2t9aKXWxZzVpbXb+n6g4XWNnoYksfmWKD+8nXBTP10vn1fb2C5+Xc/Qb0tUGDBmgMcoTQe6iAjjN1qD4rVSdsWG/rHzfYhqWN0EZR2vRcfjRUmtSsDIuLV2fmafJj0TU5R3VgAAvGYgIBVuH0ApdugVmPhYfuk1c6wV5+7w37TbcxwCgwkm6yjoz//Oc/tmDBAhs4cKB99smnDgCvv/yKza6ptUcee9iJS0RdjFI6YrRymeyn5UPxzMa5+AdAX3/9dXvzzTfdOfn30ksv2a677mp/+ctf7Nabb7MZFTOtdxgrt6/tuudad0WHHHWYjVCMDXpmU6KJ8ptNcSBQNqsAA1hgI5gIxoFRGLBLtXojVOs1xjTmQPoDg4b79JfKlpcchh01Se4VPcaNwhxxbtwiMBl/W6Vzw2x+VBCJ0GrOVcglaVyWDU4WQIb0kgjcS5keF1p+/Xo179hDbLXIIqLEVnIvDNZNDR860Dk3w5xjUze3r26qjgMG9LMNxxxtLz33vD39xBZ75pGH7JE7HrFj9j/LOmr2sznFq612cpfVS3eaP12sVLfC6ibUWmZMhg3sFTwn5xWAAM9gPR4gtnIg1uIPG6w57QfYetvggVJ5eJ3vHdrfcsblWE2TGsGpCnv1Pmv0uNZGZCihUC4PFnNieqpFxyTY5JIpAc/7GFWukjZToZ6VbpcoicF8+ahIwchQHRvJY6l5o+yBzY+6G8i/f/+mR2IknnPr33nvXetcvMhd8ETV7gMIBwoklg5//fovdsyJx1g/USqKf1Rmgt311AOSdgFmciwk5rn+zzfY7Dl11m/QQIUwBtk52s2K17/88ksbNmyYHXPMsXbPPfdZefl0rTZNgj6XU1joruOk00+0YRIVBeoJxYaPhdLfxpWOE0AmOh9aaa1CQVo85bMVRBUrzWqSOBMIqhoVGVCIAsV/8kxF/bU3dmFZgavJw6BIVx+EKBkSI1KjbWS6QhzZSkmRAYPyOkHOzqmaszKBB4Dhf3OWNV5pxKbOyZxmqomHc17G9rNBcdGqKjpO4bLjLa9mX1nY85U7pbZP0xvsqCPW2dNbnrKP33/H7rldLho5NQFY3z693HH90UfZq1qsjz/6hD3x2JN2w6a7bZX0pJqSFTZ3xmpb03WIXXLmFXbHn+6wqy+42ipn1tjgwRJhcpgOGTzQIgYPtpFDhmrningbIXcG/q4wzWPv/hxhLrGYQBXRf5jVldfaIQcfaDfeeIO9/fab9tNPPzg1RDTiyIDHBx59RCA1R9Z7/CgBKz7JXH8sNhCAsQBWea286ZUBMehAJZ0qU6EC/FPL91xlv4qVAqgKAOHvf/+7XXfddY6l4uPjHaWed9559tBDD9lf//43h5eXX37VOtoWWO4Yib60JKfI48gbkRGvia+xfffd14466ih3nDhRFMoKQWlk6HFWVpZjsLvuusudf968efbuu+/bk09uFjNq9Wt11TbUuR9Zrx1GhyvkkaYKlQRVqmAUJI1JkbEgb/dkdV6RjpM9MdumVBY5dmYAsmliH4AB8Fh5+NoSJbKjsGoz47W1yBRbpV7qF266yO5+4B7bcOpx0udUkSJ/Dmm/41Tajm5XMrvYiYRpNdoNQkZEsTI8i6umOcZPEkhHiKUHxgywkcmjVC62QVsX723taw630y+43l588V0tVk3tvwN6qfunxcvaXNzZ5UC1QhtbvvriS7bl8c2OrS676HLbZ/U6O3H9hXb/Xc/a5x9/Y079/DW4oNEofviXHbHfYTYmUfpQnKp2YqQbyeqMHDrC+vUdZAOHDhcLDpJe1cdih0XatHETbd+1e9mjjz5uP/3GHUSH/pe7B6H/fvrpJ3d/X337bYtRFgXAiklXgFvAmjRNdYVTtcM5IZ3p1UoU0yRMmC76VxYiYhD6zypT0pkswXsfv9+efnqrHX34ejvq0HV28MGHSnfK6lb4+OG1NdXuQvbdd2876aSN7vHzL7xiF5x3oV195VV26LrDbbhWPXI6PGWkLI1wF/8CRKOUa9ShJvjr1h+lbdDKXKl2c/M87VedYo898qjtsnKVDew/wMbmqHV4RYVyq1MCjCUd4O5777Dzzj3T+uhxgvS4GLFMuKyoHN3w0y8529794gN7/q2X7IiNRwlYKneTwTClUkwigBUpGAywJio1pKBYLCemSpRXHENj8Z7L7bYH77Tvf/3R6XqeWVmx195ygwyZEa6TC+yItQuYODrLF6tXczmxTPvaaIFGCeSD1AmmT2RfS9SWuiddcJfd9fyX9nMQQ/abVy1+s79//0978NHH7Jt/iiE0i+vF0jNmzLBntzwtB+cWe+Khx+zaS662O66/zX785ufAdUlB+eqvf7Gff/m3ffvNT/bFZ1/Z1198bi/e/6zts2Qvmz6+ysomVNrUfKUvJyhTQT6pvKQci4+KtaEDhtjyriX26isyjKTP/huEe8kUVFR4+t1337kFfcEFF9n+Bxxk11x7nf31b/+wuNRYVxgblaqsiPjEQMFqyTQliqnBLdkNAIvVh06BU5JMRXY8p8fSCWeeaEPCBwcCmsho0eWZZ55pnZ2d7jXYZMOGDW7FrVmzxu68807761//KgY7x+pqZ1vEsOE2adIkO/XMM+zsTRfIfVFqvRRtD4vpKx/IDPv868+c6Hz77Xft2ONOsBWrVrqIwIABA/RDLrB+/fo59nr//fftl19+sdraWved+++7n5122ikOYAMUtQ/PiHXR+93338c+//xz+02guGzTJbbPPvvYa2+9aY9sfVJe7hKJt9HO+YpHP08RgkKyDZSTlJyTavsftr+98MrLulWBf17P85PtxfyiRYtsZEq05U2WLjot37lR8orHCpx5bhNw9mwepTTdLNXbxYih+6VIYZbfKU0L+eFnX7W/fGv2/S8/2OeffGV33H6vna7Qy157rbactHQrmVxsX3//DXixG6+73u67+zbnm3rikQftxmtutA2HnWovPvWB3X/LI3bm8efbsvnatrdOO7Ut3Fdb+e5nS2q1V3bL3rZAXvQ5k5QOVKnN3vXaourltqB8sS0oXmCrq5bboXOW2Ml7HKLvgSnRnrdJpW8++4fde/vddtrGU5zUGaMU9t59AxYp44Yb/2z3P/iAhccOdcCKleN0pHLDJkyR5CmeWuIcpBVV2pKkbIKbGMQgyjrZiFlyZuLx9RYJVgQyGH3n559/dko1Nzg6Olp0/qKb+3/+8592/vnna9+8NFuyrEt1i9kOjGefeZZ7n4t/7YM31OVX0fP4wTY0bpgdue4IJ0bXr19va/feywYNkZktSyUvL68bRImJidbV1WWHHHKIRURE2MyZM23J4i4nMnvJchmg85AOcuyZJzlQMFVnn35awOLRKFS2LOzz4hsvOhFJVICFA8PAOoSRNl1zqf3yn58DJMA5tFBCj4iF77//3r12ww03OB/bKFl7WSpnH6MFmKIihiSFWRDFIxSGIUoQkx6ltBX5h6I1JLpHJI5SM16Vxq84UQ7S9WK6ZTY4Ml3zOFQSQIHmEVH26qsvOyb6+dv/yJWgWF4QVLdcf5dAda4tnX+otdXta611e9jMSdrZvkDFL9OXacevNbakYa2t7TzEDltznG3c/xg1EznaFsxaqN5ac8RcCvZPnSPLMMvihydYelSalU8otUvOutjuv+N+e3nry3bBaefZslZt4FBaY8WT5HQummZxI2JskILh3MeRI0faNX+61h6TZz8lUz5IWYcF8mmRbBidkGxTy6aJsUrKnCisaaiRsqvdmxRu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")};
__resources__["/resources/bullet.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,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")};
__resources__["/resources/crate.jpg"] = {meta: {mimetype: "image/jpeg"}, data: __imageResource("data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEASABIAAD/7QBoUGhvdG9zaG9wIDMuMAA4QklNBAQAAAAAADAcAVoAAxslRxwCAAACAAIcAgoAAjEwHAJBABNBY29ybiB2ZXJzaW9uIDIuMy4yAAA4QklNBCUAAAAAABDByv4Xjhh/lpWFaX26f+C1/+EQ0kV4aWYAAE1NACoAAAAIAAcBEgADAAAAAQABAAABGgAFAAAAAQAACG4BGwAFAAAAAQAACHYBKAADAAAAAQACAAABMQACAAAAFAAACH6HaQAEAAAAAQAACJLqHAAHAAAIDAAAAGIAAAAAHOoAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABIAAAAAQAAAEgAAAABQWNvcm4gdmVyc2lvbiAyLjMuMgAAA6ACAAQAAAABAAAAgKADAAQAAAABAAAAgOocAAcAAAgMAAAIvAAAAAAc6gAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+EJnmh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8APD94cGFja2V0IGJlZ2luPSfvu78nIGlkPSdXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQnPz4NCjx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iPjxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+PHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9InV1aWQ6ZmFmNWJkZDUtYmEzZC0xMWRhLWFkMzEtZDMzZDc1MTgyZjFiIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iPjx4bXA6Q3JlYXRvclRvb2w+QWNvcm4gdmVyc2lvbiAyLjMuMjwveG1wOkNyZWF0b3JUb29sPjwvcmRmOkRlc2NyaXB0aW9uPjwvcmRmOlJERj48L3g6eG1wbWV0YT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgPD94cGFja2V0IGVuZD0ndyc/Pv/bAEMAAgEBAgEBAgICAgICAgIDBQMDAwMDBgQEAwUHBgcHBwYHBwgJCwkICAoIBwcKDQoKCwwMDAwHCQ4PDQwOCwwMDP/bAEMBAgICAwMDBgMDBgwIBwgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDP/AABEIAEgASAMBIgACEQEDEQH/xAAfAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgv/xAC1EAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOE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")};
__resources__["/resources/down.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAIAAAAlC+aJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAFUSURBVGhD7ZnBEsMgCERr//+f03Qyk7bBirIgmCGnHMTwdkHstGzb9lj5ea6c/Dv3BPB2sFx6oJTinVLr+7Rjf0ooePY7Gc3wRj0QX/5qbX0cWHQg3KiEdoPim0AzvB6jR51F64eGsnUAcBT847dw+F49AArvEp4OuMj+9dF0IB0AFcgSAgWEw2dP4suQxmfz1BKiVwz80jUVoFovIIM/AHj5DQGAMEQBEDNMBWDPHEE/TAXo+dU6yjAbQJ3BAUCXwQdAkcENQIvBE6CHgb3sOQOwDOyh5A/QZmBHRwgA1odGIUUBqDKw8u9RgQAOhiPp82WBJqYp9gh/RsVygNWbLkgAgWiqIemAqpyCzdIBgWiqIemAqpyCzdIBgWiqIemAqpyCzdIBgWiqISYODF3oQRwTADCnoXArAGqCkS0mf/INSQgutnIATKs/PAH6tbJZubwDLzxzaVGhuhsoAAAAAElFTkSuQmCC")};
__resources__["/resources/hole.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJAgM2Nc7dB7kAAAAdaVRYdENvbW1lbnQAAAAAAENyZWF0ZWQgd2l0aCBHSU1QZC5lBwAAAhJJREFUeNrtm7FOAkEQhr9bKGwMFsbEwh4Koo20VLT3ANR21L6B5T2CTwEvQkdDZ2GiFhAbEyFY3K45Ngdq5I67++9LprrA7T/sLrM7MwHZ0wAugQ5wY60DXAHnwApYAE/ADJhamwHPwJoS0gJCYAxs/mlj+12toosOgN6BRO9zRs++q1DCB8BrhsJ9e7XvPLojroF5jsJ9m9sx5M4JEB1RuG+RHVMutIHPAol39mnHlilhAYX7FmYlflQC8c5GhxZ/XyLxzu4Vf/mDz4SwxOL/vSe0KyDeWXtfFLfrf/4daFINVsAp8OE/MDs+8FAh8VgtD38JbzcVtR/D5uDIsX0eZ4e9B6hBhcU7G+zaBAPgxd7SVJk34MI6Y2sTvBUQj9V4m/ZgLDD9kzdLW0ugZS8mlTgDlm4J9NGjn9wD7gQdcOeWQMOGioo0jU1aqHJpiLM0qnQMcapKlZvaAfUSiLO0qlwFxAmFpqgDVgZxjOAZIMnCEFdmqPJkiEtRVJkZ4nocVaa1A9SXQH0cJq7DmwiKnwBrFwg9CjrgEepL0e9L0aXYMphYzVv00MkL9JzoOjWWeLABhgLTf+jEpyGfHgfxAglHVEHx0a4pn4Z8kdQH0K3QxtdNE/8bpAslHdKlsg7pYukyzoRRVpuJdMOEQ7plJhknyDZN+WGzZNucH03KNk76jpBsnU2jNM3TeXiy0O3zXxRJTqou5XceAAAAAElFTkSuQmCC")};
__resources__["/resources/left.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAIAAAAlC+aJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAG5SURBVGhD7VrREsIwCLP+/z/Ped7t5tZC6EKhOh+9DkhCaDsty7I8Zv48Zy7+XfsNIFrB4ueBUsoenVMirxY6VL8iOX9DEc8FgFOtVcAuACjUgkH4AEbSf4/Rk8wC/ZNNIbCDry9jemA8/UwPDPbuJh1TgVY/OHX/Jx0HQBT9NACCF13p5wAI8e5GWf00GtgSZzFlDSsAUlW/4WnB4Jj4+n6kRmjROg2AFsIbgKq984KKAt6Tm4tIutSnGkctWnveSsTuXAcBzSZOJQvnKKHuNdymv6RAquZhHqddOZaDGzyQkH6DB7J5l3mljN34oBZKS/+qA7SRDQDQLaMOYED1+zljRaK00ODq3y3x/bOIOqAhD6hRAhdIAKxkhMD4XQVy7rtnkTsVsM4KvLuskc0vtpAELfWQZ3GozdPoFN7tPAt5UGilXLnQzEW/4Ti9Lk1I/xHALKNz30WdY/Ri4xIfhwDkbJ6/udRnpr9yI1P/pTRyziLc6TeyzXAjSz+4XEACmbjjokScM3J2FAC3IGI0CEBg86hQIQCImdRMTgsgAE65KWFRALEiCNkNY5RCGD0IqgA9MSvg9ABetNCHXRkFMYAAAAAASUVORK5CYII=")};
__resources__["/resources/right.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAIAAAAlC+aJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAGYSURBVGhD7VjbrsIwDKP8/z+PAdI0ujaXzbmU9TweTUlsx0lKWZblMfLfc+Ti37VPANEKFjsPlFL26IwSWbVQVf2K5PgfiHgmAIxqbQI2AQChVhgED8CT/jlGDzIT9A82hYQdfP0zpAf86Ud6wNm7m3RIBXr9YNT933QYAFH0wwAQXjSlHwMgxLsbZe1rNLAljmLSGjYApKp+w9ODgTHx9X3ERujROgyAHsIJgNXe+IOGAtaTG4uIetSnGkc9Ws/8KhG7uSoB1SZOJQvmlGB3DbbpLymQqnmQ57Qpx3RwhQcS0q/wQDbvIp+UsYtPtAc86dfSkQ7A3rISMLyJPemvBo4kNQNAEiJwhiqmUGyVRHZKgfz0/7UCQ9C/KtAdoyoAknlHu6iXjo3c9oCq+lh/NwAMVP0/mngs+nUKsH4KMcOPB3I+WWAvshCC2aT8NbqGyNk8t3nUZ6a/nkLHWpNXT91CTfecvlhYL56OLHoTb+n91xzbAqIpxPIX+MEEEEj+J/XNFGAt5a/HzRRwvoskguv2gH+HsBlfUMCBXfdKUqcAAAAASUVORK5CYII=")};
__resources__["/resources/sprites.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,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")};
__resources__["/resources/up.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAIAAAAlC+aJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAELSURBVGhD7ZnrCsIwDIX3/i89B4Kw2dUeD0mb8e2f0LQ5t2jnthd/tuL97wCYrSAK3CuwnZ8gqaIUuHT//hiBIWTTo9HaAJrdV1IAAEJYQjKAAiggMNBaioUEAgkxFhLs0iTLrG+WE2KBVUJMiAW7TA/xXbid0KdmQAXwWd9RqQaAzm0OAMoU+ttCKCCOOodpdSLVyMAqU0gUcmh5qgJDHYmLAKCMUZHcoeUogAJDRun8jWLWcyd2CSTEhNj0EBbCQljIZAALmQQyhda0UMRrBWdP4VLvHJNQ+43klIGEDvwjLhgeBMDnJmeH5ypwIMuh0Dylp8D6GH5MIfNbfUp5yE+JTCQAyGS7ddYLEBesTuY6kvQAAAAASUVORK5CYII=")};/*globals module exports resource require window Module __main_module_name__ __resources__*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

function resource(path) {
    // Check for packed resource
    var r = __resources__[path];
    if (r) {
        return r.data;
    }

    // Check for remote resource
    r = __remote_resources__[path];
    if (r) {
        // Load remote image
        if (r.meta.mimetype.split('/')[0] == 'image') {
            return require('cocos2d').RemoteImage.create({url: r.data, path: path});
        } else {
            return require('cocos2d').RemoteResource.create({url: r.data, path: path});
        }
    }

    throw("Unable to find resource: " + path.toString());
}

(function () {
    var process = {};
    var modulePaths = ['/__builtin__', '/__builtin__/libs', '/libs', '/'];

    var path; // Will be loaded further down

    function resolveModulePath(request, parent) {
        // If not a relative path then search the modulePaths for it
        var start = request.substring(0, 2);
        if (start !== "./" && start !== "..") {
            return modulePaths;
        }

        var parentIsIndex = path.basename(parent.filename).match(/^index\.js$/),
            parentPath    = parentIsIndex ? parent.id : path.dirname(parent.id);

        // Relative path so searching inside parent's directory
        return [path.dirname(parent.filename)];
    }

    function findModulePath(id, dirs) {
        if (id.charAt(0) === '/') {
            dirs = [''];
        }
        for (var i = 0; i < dirs.length; i++) {
            var dir = dirs[i];
            var p = path.join(dir, id);

            // Check for index first
            if (path.exists(path.join(p, 'index.js'))) {
                return path.join(p, 'index.js');
            } else if (path.exists(p + '.js')) {
                return p + '.js';
            }
        }

        return false;
    }

    function loadModule(request, parent) {
        parent = parent || process.mainModule;

        var paths    = resolveModulePath(request, parent),
            filename = findModulePath(request, paths);

        if (filename === false) {
            throw "Unable to find module: " + request;
        }


        if (parent) {
            var cachedModule = parent.moduleCache[filename];
            if (cachedModule) {
                return cachedModule;
            }
        }

        //console.log('Loading module: ', filename);

        var module = new Module(filename, parent);

        // Assign main module to process
        if (request == __main_module_name__ && !process.mainModule) {
            process.mainModule = module;
        }

        // Run all the code in the module
        module._initialize(filename);

        return module;
    }

    function Module(id, parent) {
        this.id = id;
        this.parent = parent;
        this.children = [];
        this.exports = {};

        if (parent) {
            this.moduleCache = parent.moduleCache;
            parent.children.push(this);
        } else {
            this.moduleCache = {};
        }
        this.moduleCache[this.id] = this;

        this.filename = null;
        this.dirname = null;
    }

    Module.prototype._initialize = function (filename) {
        var module = this;
        function require(request) {
            return loadModule(request, module).exports;
        }

        this.filename = filename;

        // Work around incase this IS the path module
        if (path) {
            this.dirname = path.dirname(filename);
        } else {
            this.dirname = '';
        }

        require.paths = modulePaths;
        require.main = process.mainModule;

        __resources__[this.filename].data.apply(this.exports, [this.exports, require, this, this.filename, this.dirname]);

        return this;
    };

    // Manually load the path module because we need it to load other modules
    path = (new Module('path'))._initialize('/__builtin__/path.js').exports;

    var util = loadModule('util').exports;
    util.ready(function () {
        // Populate globals
        var globals = loadModule('global').exports;
        for (var x in globals) {
            if (globals.hasOwnProperty(x)) {
                window[x] = globals[x];
            }
        }

        // Add a global require. Useful in the debug console.
        window.require = function require(request, parent) {
            return loadModule(request, parent).exports;
        };
        window.require.paths = modulePaths;

        process.mainModule = loadModule(__main_module_name__);

        window.require.main = process.mainModule;

        if (process.mainModule.exports.main) {
            process.mainModule.exports.main();
        }

    });
})();

// vim:ft=javascript

})();
