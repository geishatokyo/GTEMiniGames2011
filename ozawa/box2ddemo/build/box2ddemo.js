
(function() {
var __main_module_name__ = "main";
var __resources__ = {};
var __remote_resources__ = {};
function __imageResource(data) { var img = new Image(); img.src = data; return img; };
var FLIP_Y_AXIS = false;
var ENABLE_WEB_GL = false;
var SHOW_REDRAW_REGIONS = false;

__resources__["/__builtin__/event.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*global module exports require*/
/*jslint white: true, undef: true, nomen: true, bitwise: true, regexp: true, newcap: true*/


/**
 * @namespace
 * Support for listening for and triggering events
 */
var event = {};

/**
 * @private
 * @ignore
 * Returns the event listener property of an object, creating it if it doesn't
 * already exist.
 *
 * @returns {Object}
 */
function getListeners(obj, eventName) {
    if (!obj.js_listeners_) {
        obj.js_listeners_ = {};
    }
    if (!eventName) {
        return obj.js_listeners_;
    }
    if (!obj.js_listeners_[eventName]) {
        obj.js_listeners_[eventName] = {};
    }
    return obj.js_listeners_[eventName];
}

/**
 * @private
 * @ignore
 * Keep track of the next ID for each new EventListener
 */
var eventID = 0;

/**
 * @class
 * Represents an event being listened to. You should not create instances of
 * this directly, it is instead returned by event.addListener
 *
 * @extends Object
 * 
 * @param {Object} source Object to listen to for an event
 * @param {String} eventName Name of the event to listen for
 * @param {Function} handler Callback to fire when the event triggers
 */
event.EventListener = function (source, eventName, handler) {
    /**
     * Object to listen to for an event
     * @type Object 
     */
    this.source = source;
    
    /**
     * Name of the event to listen for
     * @type String
     */
    this.eventName = eventName;

    /**
     * Callback to fire when the event triggers
     * @type Function
     */
    this.handler = handler;

    /**
     * Unique ID number for this instance
     * @type Integer 
     */
    this.id = ++eventID;

    getListeners(source, eventName)[this.id] = this;
};

/**
 * Register an event listener
 *
 * @param {Object} source Object to listen to for an event
 * @param {String} eventName Name of the event to listen for
 * @param {Function} handler Callback to fire when the event triggers
 *
 * @returns {event.EventListener} The event listener. Pass to removeListener to destroy it.
 */
event.addListener = function (source, eventName, handler) {
    return new event.EventListener(source, eventName, handler);
};

/**
 * Trigger an event. All listeners will be notified.
 *
 * @param {Object} source Object to trigger the event on
 * @param {String} eventName Name of the event to trigger
 */
event.trigger = function (source, eventName) {
    var listeners = getListeners(source, eventName),
        args = Array.prototype.slice.call(arguments, 2),
        eventID,
        l;

    for (eventID in listeners) {
        if (listeners.hasOwnProperty(eventID)) {
            l = listeners[eventID];
            if (l) {
                l.handler.apply(undefined, args);
            }
        }
    }
};

/**
 * Remove a previously registered event listener
 *
 * @param {event.EventListener} listener EventListener to remove, as returned by event.addListener
 */
event.removeListener = function (listener) {
    delete getListeners(listener.source, listener.eventName)[listener.eventID];
};

/**
 * Remove a all event listeners for a given event
 *
 * @param {Object} source Object to remove listeners from
 * @param {String} eventName Name of event to remove listeners from
 */
event.clearListeners = function (source, eventName) {
    var listeners = getListeners(source, eventName),
        eventID;


    for (eventID in listeners) {
        if (listeners.hasOwnProperty(eventID)) {
            var l = listeners[eventID];
            if (l) {
                event.removeListener(l);
            }
        }
    }
};

/**
 * Remove all event listeners on an object
 *
 * @param {Object} source Object to remove listeners from
 */
event.clearInstanceListeners = function (source, eventName) {
    var listeners = getListeners(source),
        eventID;

    for (eventName in listeners) {
        if (listeners.hasOwnProperty(eventName)) {
            var el = listeners[eventName];
            for (eventID in el) {
                if (el.hasOwnProperty(eventID)) {
                    var l = el[eventID];
                    if (l) {
                        event.removeListener(l);
                    }
                }
            }
        }
    }
};

module.exports = event;

}};
__resources__["/__builtin__/events.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*global module exports require*/
/*jslint white: true, undef: true, nomen: true, bitwise: true, regexp: true, newcap: true*/

/**
 * @namespace
 * Support for listening for and triggering events
 */
var events = {};

/**
 * @private
 * @ignore
 * Returns the event listener property of an object, creating it if it doesn't
 * already exist.
 *
 * @returns {Object}
 */
function getListeners(obj, eventName) {
    if (!obj.js_listeners_) {
        obj.js_listeners_ = {};
    }
    if (!eventName) {
        return obj.js_listeners_;
    }
    if (!obj.js_listeners_[eventName]) {
        obj.js_listeners_[eventName] = {};
    }
    return obj.js_listeners_[eventName];
}

/**
 * @private
 * @ignore
 * Keep track of the next ID for each new EventListener
 */
var eventID = 0;

/**
 * @class
 * Represents an event being listened to. You should not create instances of
 * this directly, it is instead returned by events.addListener
 *
 * @extends Object
 * 
 * @param {Object} source Object to listen to for an event
 * @param {String} eventName Name of the event to listen for
 * @param {Function} handler Callback to fire when the event triggers
 */
events.EventListener = function (source, eventName, handler) {
    /**
     * Object to listen to for an event
     * @type Object 
     */
    this.source = source;
    
    /**
     * Name of the event to listen for
     * @type String
     */
    this.eventName = eventName;

    /**
     * Callback to fire when the event triggers
     * @type Function
     */
    this.handler = handler;

    /**
     * Unique ID number for this instance
     * @type Integer 
     */
    this.id = ++eventID;

    getListeners(source, eventName)[this.id] = this;
};

/**
 * Register an event listener
 *
 * @param {Object} source Object to listen to for an event
 * @param {String|Stringp[} eventName Name or Array of names of the event(s) to listen for
 * @param {Function} handler Callback to fire when the event triggers
 *
 * @returns {events.EventListener|events.EventListener[]} The event listener(s). Pass to removeListener to destroy it.
 */
events.addListener = function (source, eventName, handler) {
    if (eventName instanceof Array) {
        var listeners = [];
        for (var i = 0, len = eventName.length; i < len; i++) {
            listeners.push(new events.EventListener(source, eventName[i], handler));
        }
        return listeners;
    } else {
        return new events.EventListener(source, eventName, handler);
    }
};

/**
 * Trigger an event. All listeners will be notified.
 *
 * @param {Object} source Object to trigger the event on
 * @param {String} eventName Name of the event to trigger
 */
events.trigger = function (source, eventName) {
    var listeners = getListeners(source, eventName),
        args = Array.prototype.slice.call(arguments, 2),
        eventID,
        l;

    for (eventID in listeners) {
        if (listeners.hasOwnProperty(eventID)) {
            l = listeners[eventID];
            if (l) {
                l.handler.apply(undefined, args);
            }
        }
    }
};

/**
 * Remove a previously registered event listener
 *
 * @param {events.EventListener} listener EventListener to remove, as returned by events.addListener
 */
events.removeListener = function (listener) {
    delete getListeners(listener.source, listener.eventName)[listener.eventID];
};

/**
 * Remove a all event listeners for a given event
 *
 * @param {Object} source Object to remove listeners from
 * @param {String} eventName Name of event to remove listeners from
 */
events.clearListeners = function (source, eventName) {
    var listeners = getListeners(source, eventName),
        eventID;


    for (eventID in listeners) {
        if (listeners.hasOwnProperty(eventID)) {
            var l = listeners[eventID];
            if (l) {
                events.removeListener(l);
            }
        }
    }
};

/**
 * Remove all event listeners on an object
 *
 * @param {Object} source Object to remove listeners from
 */
events.clearInstanceListeners = function (source) {
    var listeners = getListeners(source),
        eventID;

    for (var eventName in listeners) {
        if (listeners.hasOwnProperty(eventName)) {
            var el = listeners[eventName];
            for (eventID in el) {
                if (el.hasOwnProperty(eventID)) {
                    var l = el[eventID];
                    if (l) {
                        events.removeListener(l);
                    }
                }
            }
        }
    }
};

module.exports = events;

}};
__resources__["/__builtin__/global.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    events = require('events');


/**
 * @ignore
 */
function getAccessors(obj) {
    if (!obj.js_accessors_) {
        obj.js_accessors_ = {};
    }
    return obj.js_accessors_;
}

/**
 * @ignore
 */
function getBindings(obj) {
    if (!obj.js_bindings_) {
        obj.js_bindings_ = {};
    }
    return obj.js_bindings_;
}

/**
 * @ignore
 */
function addAccessor(obj, key, target, targetKey, noNotify) {
    getAccessors(obj)[key] = {
        key: targetKey,
        target: target
    };

    if (!noNotify) {
        obj.triggerChanged(key);
    }
}


/**
 * @ignore
 */
var objectID = 0;

/**
 * @class
 * A bindable object. Allows observing and binding to its properties.
 */
var BObject = function () {};
BObject.prototype = util.extend(BObject.prototype, /** @lends BObject# */{
    /**
     * Unique ID
     * @type Integer
     */
    _id: 0,
    

    /**
     * The constructor for subclasses. Overwrite this for any initalisation you
     * need to do.
     * @ignore
     */
    init: function () {},

    /**
     * Get a property from the object. Always use this instead of trying to
     * access the property directly. This will ensure all bindings, setters and
     * getters work correctly.
     * 
     * @param {String} key Name of property to get or dot (.) separated path to a property
     * @returns {*} Value of the property
     */
    get: function (key) {
        var next = false
        if (~key.indexOf('.')) {
            var tokens = key.split('.');
            key = tokens.shift();
            next = tokens.join('.');
        }


        var accessor = getAccessors(this)[key],
            val;
        if (accessor) {
            val = accessor.target.get(accessor.key);
        } else {
            // Call getting function
            if (this['get_' + key]) {
                val = this['get_' + key]();
            } else {
                val = this[key];
            }
        }

        if (next) {
            return val.get(next);
        } else {
            return val;
        }
    },


    /**
     * Set a property on the object. Always use this instead of trying to
     * access the property directly. This will ensure all bindings, setters and
     * getters work correctly.
     * 
     * @param {String} key Name of property to get
     * @param {*} value New value for the property
     */
    set: function (key, value) {
        var accessor = getAccessors(this)[key],
            oldVal = this.get(key);


        this.triggerBeforeChanged(key, oldVal);

        if (accessor) {
            accessor.target.set(accessor.key, value);
        } else {

            if (this['set_' + key]) {
                this['set_' + key](value);
            } else {
                this[key] = value;
            }
        }
        this.triggerChanged(key, oldVal);
    },

    /**
     * Set multiple propertys in one go
     *
     * @param {Object} kvp An Object where the key is a property name and the value is the value to assign to the property
     *
     * @example
     * var props = {
     *   monkey: 'ook',
     *   cat: 'meow',
     *   dog: 'woof'
     * };
     * foo.setValues(props);
     * console.log(foo.get('cat')); // Logs 'meow'
     */
    setValues: function (kvp) {
        for (var x in kvp) {
            if (kvp.hasOwnProperty(x)) {
                this.set(x, kvp[x]);
            }
        }
    },

    changed: function (key) {
    },

    /**
     * @private
     */
    notify: function (key, oldVal) {
        var accessor = getAccessors(this)[key];
        if (accessor) {
            accessor.target.notify(accessor.key, oldVal);
        }
    },

    /**
     * @private
     */
    triggerBeforeChanged: function (key, oldVal) {
        events.trigger(this, key.toLowerCase() + '_before_changed', oldVal);
    },

    /**
     * @private
     */
    triggerChanged: function (key, oldVal) {
        events.trigger(this, key.toLowerCase() + '_changed', oldVal);
    },

    /**
     * Bind the value of a property on this object to that of another object so
     * they always have the same value. Setting the value on either object will update
     * the other too.
     *
     * @param {String} key Name of the property on this object that should be bound
     * @param {BOject} target Object to bind to
     * @param {String} [targetKey=key] Key on the target object to bind to
     * @param {Boolean} [noNotify=false] Set to true to prevent this object's property triggering a 'changed' event when adding the binding
     */
    bindTo: function (key, target, targetKey, noNotify) {
        targetKey = targetKey || key;
        var self = this;
        this.unbind(key);

        var oldVal = this.get(key);

        // When bound property changes, trigger a 'changed' event on this one too
        getBindings(this)[key] = events.addListener(target, targetKey.toLowerCase() + '_changed', function (oldVal) {
            self.triggerChanged(key, oldVal);
        });

        addAccessor(this, key, target, targetKey, noNotify);
    },

    /**
     * Remove binding from a property which set setup using BObject#bindTo.
     *
     * @param {String} key Name of the property on this object to unbind
     */
    unbind: function (key) {
        var binding = getBindings(this)[key];
        if (!binding) {
            return;
        }

        delete getBindings(this)[key];
        events.removeListener(binding);
        // Grab current value from bound property
        var val = this.get(key);
        delete getAccessors(this)[key];
        // Set bound value
        this[key] = val;
    },

    /**
     * Remove all bindings on this object
     */
    unbindAll: function () {
        var keys = [],
            bindings = getBindings(this);
        for (var k in bindings) {
            if (bindings.hasOwnProperty(k)) {
                this.unbind(k);
            }
        }
    },

    /**
     * Unique ID for this object
     * @getter id
     * @type Integer
     */
    get_id: function () {
        if (!this._id) {
            this._id = ++objectID;
        }

        return this._id;
    }
});


/**
 * Create a new instance of this object
 * @returns {BObject} New instance of this object
 */
BObject.create = function () {
    var ret = new this();
    ret.init.apply(ret, arguments);
    return ret;
};

/**
 * Create a new subclass by extending this one
 * @returns {Object} A new subclass of this object
 */
BObject.extend = function() {
    var newObj = function() {},
        args = [],
        i,
        x;

    // Copy 'class' methods
    for (x in this) {
        if (this.hasOwnProperty(x)) {
            newObj[x] = this[x];
        }
    }


    // Add given properties to the prototype
    newObj.prototype = util.beget(this.prototype);
    args.push(newObj.prototype);
    for (i = 0; i<arguments.length; i++) {
        args.push(arguments[i]);
    }
    util.extend.apply(null, args);

    newObj.superclass = this.prototype;
    // Create new instance
    return newObj;
};

/**
 * Get a property from the class. Always use this instead of trying to
 * access the property directly. This will ensure all bindings, setters and
 * getters work correctly.
 * 
 * @function
 * @param {String} key Name of property to get
 * @returns {*} Value of the property
 */
BObject.get = BObject.prototype.get;

/**
 * Set a property on the class. Always use this instead of trying to
 * access the property directly. This will ensure all bindings, setters and
 * getters work correctly.
 * 
 * @function
 * @param {String} key Name of property to get
 * @param {*} value New value for the property
 */
BObject.set = BObject.prototype.set;

var BArray = BObject.extend(/** @lends BArray# */{

    /**
     * @constructs 
     * A bindable array. Allows observing for changes made to its contents
     *
     * @extends BObject
     * @param {Array} [array=[]] A normal JS array to use for data
     */
    init: function (array) {
        this.array = array || [];
        this.set('length', this.array.length);
    },

    /**
     * Get an item
     *
     * @param {Integer} i Index to get item from
     * @returns {*} Value stored in the array at index 'i'
     */
    getAt: function (i) {
        return this.array[i];
    },

    /**
     * Set an item -- Overwrites any existing item at index
     *
     * @param {Integer} i Index to set item to
     * @param {*} value Value to assign to index
     */
    setAt: function (i, value) {
        var oldVal = this.array[i];
        this.array[i] = value;

        events.trigger(this, 'set_at', i, oldVal);
    },

    /**
     * Insert a new item into the array without overwriting anything
     *
     * @param {Integer} i Index to insert item at
     * @param {*} value Value to insert
     */
    insertAt: function (i, value) {
        this.array.splice(i, 0, value);
        this.set('length', this.array.length);
        events.trigger(this, 'insert_at', i);
    },

    /**
     * Remove item from the array and return it
     *
     * @param {Integer} i Index to remove
     * @returns {*} Value that was removed
     */
    removeAt: function (i) {
        var oldVal = this.array[i];
        this.array.splice(i, 1);
        this.set('length', this.array.length);
        events.trigger(this, 'remove_at', i, oldVal);

        return oldVal;
    },

    /**
     * Get the internal Javascript Array instance
     *
     * @returns {Array} Internal Javascript Array
     */
    getArray: function () {
        return this.array;
    },

    /**
     * Append a value to the end of the array and return its new length
     *
     * @param {*} value Value to append to the array
     * @returns {Integer} New length of the array
     */
    push: function (value) {
        this.insertAt(this.array.length, value);
        return this.array.length;
    },

    /**
     * Remove value from the end of the array and return it
     *
     * @returns {*} Value that was removed
     */
    pop: function () {
        return this.removeAt(this.array.length - 1);
    }
});

exports.BObject = BObject;
exports.BArray = BArray;

}};
__resources__["/__builtin__/libs/base64.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/**
 * Thin wrapper around JXG's Base64 utils
 */

/** @ignore */
var JXG = require('JXGUtil');

/** @namespace */
var base64 = {
    /**
     * Decode a base64 encoded string into a binary string
     *
     * @param {String} input Base64 encoded data
     * @returns {String} Binary string
     */
    decode: function(input) {
        return JXG.Util.Base64.decode(input);
    },

    /**
     * Decode a base64 encoded string into a byte array
     *
     * @param {String} input Base64 encoded data
     * @returns {Integer[]} Array of bytes
     */
    decodeAsArray: function(input, bytes) {
        bytes = bytes || 1;

        var dec = JXG.Util.Base64.decode(input),
            ar = [], i, j, len;

        for (i = 0, len = dec.length/bytes; i < len; i++){
            ar[i] = 0;
            for (j = bytes-1; j >= 0; --j){
                ar[i] += dec.charCodeAt((i *bytes) +j) << (j *8);
            }
        }
        return ar;
    },

    /**
     * Encode a binary string into base64
     *
     * @param {String} input Binary string
     * @returns {String} Base64 encoded data
     */
    encode: function(input) {
        return JXG.Util.Base64.encode(input);
    }
};

module.exports = base64;

}};
__resources__["/__builtin__/libs/box2d.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
function extend(a, b) {
  for(var c in b) {
    a[c] = b[c]
  }
}
function isInstanceOf(obj, _constructor) {
  while(typeof obj === "object") {
    if(obj.constructor === _constructor) {
      return true
    }
    obj = obj._super
  }
  return false
}
;var b2BoundValues = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2BoundValues.prototype.__constructor = function() {
  this.lowerValues = new Array;
  this.lowerValues[0] = 0;
  this.lowerValues[1] = 0;
  this.upperValues = new Array;
  this.upperValues[0] = 0;
  this.upperValues[1] = 0
};
b2BoundValues.prototype.__varz = function() {
};
b2BoundValues.prototype.lowerValues = null;
b2BoundValues.prototype.upperValues = null;var b2PairManager = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2PairManager.prototype.__constructor = function() {
  this.m_pairs = new Array;
  this.m_pairBuffer = new Array;
  this.m_pairCount = 0;
  this.m_pairBufferCount = 0;
  this.m_freePair = null
};
b2PairManager.prototype.__varz = function() {
};
b2PairManager.prototype.AddPair = function(proxy1, proxy2) {
  var pair = proxy1.pairs[proxy2];
  if(pair != null) {
    return pair
  }
  if(this.m_freePair == null) {
    this.m_freePair = new b2Pair;
    this.m_pairs.push(this.m_freePair)
  }
  pair = this.m_freePair;
  this.m_freePair = pair.next;
  pair.proxy1 = proxy1;
  pair.proxy2 = proxy2;
  pair.status = 0;
  pair.userData = null;
  pair.next = null;
  proxy1.pairs[proxy2] = pair;
  proxy2.pairs[proxy1] = pair;
  ++this.m_pairCount;
  return pair
};
b2PairManager.prototype.RemovePair = function(proxy1, proxy2) {
  var pair = proxy1.pairs[proxy2];
  if(pair == null) {
    return null
  }
  var userData = pair.userData;
  delete proxy1.pairs[proxy2];
  delete proxy2.pairs[proxy1];
  pair.next = this.m_freePair;
  pair.proxy1 = null;
  pair.proxy2 = null;
  pair.userData = null;
  pair.status = 0;
  this.m_freePair = pair;
  --this.m_pairCount;
  return userData
};
b2PairManager.prototype.Find = function(proxy1, proxy2) {
  return proxy1.pairs[proxy2]
};
b2PairManager.prototype.ValidateBuffer = function() {
};
b2PairManager.prototype.ValidateTable = function() {
};
b2PairManager.prototype.Initialize = function(broadPhase) {
  this.m_broadPhase = broadPhase
};
b2PairManager.prototype.AddBufferedPair = function(proxy1, proxy2) {
  var pair = this.AddPair(proxy1, proxy2);
  if(pair.IsBuffered() == false) {
    pair.SetBuffered();
    this.m_pairBuffer[this.m_pairBufferCount] = pair;
    ++this.m_pairBufferCount
  }
  pair.ClearRemoved();
  if(b2BroadPhase.s_validate) {
    this.ValidateBuffer()
  }
};
b2PairManager.prototype.RemoveBufferedPair = function(proxy1, proxy2) {
  var pair = this.Find(proxy1, proxy2);
  if(pair == null) {
    return
  }
  if(pair.IsBuffered() == false) {
    pair.SetBuffered();
    this.m_pairBuffer[this.m_pairBufferCount] = pair;
    ++this.m_pairBufferCount
  }
  pair.SetRemoved();
  if(b2BroadPhase.s_validate) {
    this.ValidateBuffer()
  }
};
b2PairManager.prototype.Commit = function(callback) {
  var i = 0;
  var removeCount = 0;
  for(i = 0;i < this.m_pairBufferCount;++i) {
    var pair = this.m_pairBuffer[i];
    pair.ClearBuffered();
    var proxy1 = pair.proxy1;
    var proxy2 = pair.proxy2;
    if(pair.IsRemoved()) {
    }else {
      if(pair.IsFinal() == false) {
        callback(proxy1.userData, proxy2.userData)
      }
    }
  }
  this.m_pairBufferCount = 0;
  if(b2BroadPhase.s_validate) {
    this.ValidateTable()
  }
};
b2PairManager.prototype.m_broadPhase = null;
b2PairManager.prototype.m_pairs = null;
b2PairManager.prototype.m_freePair = null;
b2PairManager.prototype.m_pairCount = 0;
b2PairManager.prototype.m_pairBuffer = null;
b2PairManager.prototype.m_pairBufferCount = 0;var b2TimeStep = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2TimeStep.prototype.__constructor = function() {
};
b2TimeStep.prototype.__varz = function() {
};
b2TimeStep.prototype.Set = function(step) {
  this.dt = step.dt;
  this.inv_dt = step.inv_dt;
  this.positionIterations = step.positionIterations;
  this.velocityIterations = step.velocityIterations;
  this.warmStarting = step.warmStarting
};
b2TimeStep.prototype.dt = null;
b2TimeStep.prototype.inv_dt = null;
b2TimeStep.prototype.dtRatio = null;
b2TimeStep.prototype.velocityIterations = 0;
b2TimeStep.prototype.positionIterations = 0;
b2TimeStep.prototype.warmStarting = null;var b2Controller = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Controller.prototype.__constructor = function() {
};
b2Controller.prototype.__varz = function() {
};
b2Controller.prototype.Step = function(step) {
};
b2Controller.prototype.Draw = function(debugDraw) {
};
b2Controller.prototype.AddBody = function(body) {
  var edge = new b2ControllerEdge;
  edge.controller = this;
  edge.body = body;
  edge.nextBody = m_bodyList;
  edge.prevBody = null;
  m_bodyList = edge;
  if(edge.nextBody) {
    edge.nextBody.prevBody = edge
  }
  m_bodyCount++;
  edge.nextController = body.m_controllerList;
  edge.prevController = null;
  body.m_controllerList = edge;
  if(edge.nextController) {
    edge.nextController.prevController = edge
  }
  body.m_controllerCount++
};
b2Controller.prototype.RemoveBody = function(body) {
  var edge = body.m_controllerList;
  while(edge && edge.controller != this) {
    edge = edge.nextController
  }
  if(edge.prevBody) {
    edge.prevBody.nextBody = edge.nextBody
  }
  if(edge.nextBody) {
    edge.nextBody.prevBody = edge.prevBody
  }
  if(edge.nextController) {
    edge.nextController.prevController = edge.prevController
  }
  if(edge.prevController) {
    edge.prevController.nextController = edge.nextController
  }
  if(m_bodyList == edge) {
    m_bodyList = edge.nextBody
  }
  if(body.m_controllerList == edge) {
    body.m_controllerList = edge.nextController
  }
  body.m_controllerCount--;
  m_bodyCount--
};
b2Controller.prototype.Clear = function() {
  while(m_bodyList) {
    this.RemoveBody(m_bodyList.body)
  }
};
b2Controller.prototype.GetNext = function() {
  return this.m_next
};
b2Controller.prototype.GetWorld = function() {
  return this.m_world
};
b2Controller.prototype.GetBodyList = function() {
  return m_bodyList
};
b2Controller.prototype.m_next = null;
b2Controller.prototype.m_prev = null;
b2Controller.prototype.m_world = null;var b2GravityController = function() {
  b2Controller.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2GravityController.prototype, b2Controller.prototype);
b2GravityController.prototype._super = b2Controller.prototype;
b2GravityController.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2GravityController.prototype.__varz = function() {
};
b2GravityController.prototype.Step = function(step) {
  var i = null;
  var body1 = null;
  var p1 = null;
  var mass1 = 0;
  var j = null;
  var body2 = null;
  var p2 = null;
  var dx = 0;
  var dy = 0;
  var r2 = 0;
  var f = null;
  if(this.invSqr) {
    for(i = m_bodyList;i;i = i.nextBody) {
      body1 = i.body;
      p1 = body1.GetWorldCenter();
      mass1 = body1.GetMass();
      for(j = m_bodyList;j != i;j = j.nextBody) {
        body2 = j.body;
        p2 = body2.GetWorldCenter();
        dx = p2.x - p1.x;
        dy = p2.y - p1.y;
        r2 = dx * dx + dy * dy;
        if(r2 < Number.MIN_VALUE) {
          continue
        }
        f = new b2Vec2(dx, dy);
        f.Multiply(this.G / r2 / Math.sqrt(r2) * mass1 * body2.GetMass());
        if(body1.IsAwake()) {
          body1.ApplyForce(f, p1)
        }
        f.Multiply(-1);
        if(body2.IsAwake()) {
          body2.ApplyForce(f, p2)
        }
      }
    }
  }else {
    for(i = m_bodyList;i;i = i.nextBody) {
      body1 = i.body;
      p1 = body1.GetWorldCenter();
      mass1 = body1.GetMass();
      for(j = m_bodyList;j != i;j = j.nextBody) {
        body2 = j.body;
        p2 = body2.GetWorldCenter();
        dx = p2.x - p1.x;
        dy = p2.y - p1.y;
        r2 = dx * dx + dy * dy;
        if(r2 < Number.MIN_VALUE) {
          continue
        }
        f = new b2Vec2(dx, dy);
        f.Multiply(this.G / r2 * mass1 * body2.GetMass());
        if(body1.IsAwake()) {
          body1.ApplyForce(f, p1)
        }
        f.Multiply(-1);
        if(body2.IsAwake()) {
          body2.ApplyForce(f, p2)
        }
      }
    }
  }
};
b2GravityController.prototype.G = 1;
b2GravityController.prototype.invSqr = true;var b2DestructionListener = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DestructionListener.prototype.__constructor = function() {
};
b2DestructionListener.prototype.__varz = function() {
};
b2DestructionListener.prototype.SayGoodbyeJoint = function(joint) {
};
b2DestructionListener.prototype.SayGoodbyeFixture = function(fixture) {
};var b2ContactEdge = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactEdge.prototype.__constructor = function() {
};
b2ContactEdge.prototype.__varz = function() {
};
b2ContactEdge.prototype.other = null;
b2ContactEdge.prototype.contact = null;
b2ContactEdge.prototype.prev = null;
b2ContactEdge.prototype.next = null;var b2EdgeChainDef = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2EdgeChainDef.prototype.__constructor = function() {
  this.vertexCount = 0;
  this.isALoop = true;
  this.vertices = []
};
b2EdgeChainDef.prototype.__varz = function() {
};
b2EdgeChainDef.prototype.vertices = null;
b2EdgeChainDef.prototype.vertexCount = null;
b2EdgeChainDef.prototype.isALoop = null;var b2Vec2 = function(x_, y_) {
  if(arguments.length == 2) {
    this.x = x_;
    this.y = y_
  }
};
b2Vec2.Make = function(x_, y_) {
  return new b2Vec2(x_, y_)
};
b2Vec2.prototype.SetZero = function() {
  this.x = 0;
  this.y = 0
};
b2Vec2.prototype.Set = function(x_, y_) {
  this.x = x_;
  this.y = y_
};
b2Vec2.prototype.SetV = function(v) {
  this.x = v.x;
  this.y = v.y
};
b2Vec2.prototype.GetNegative = function() {
  return new b2Vec2(-this.x, -this.y)
};
b2Vec2.prototype.NegativeSelf = function() {
  this.x = -this.x;
  this.y = -this.y
};
b2Vec2.prototype.Copy = function() {
  return new b2Vec2(this.x, this.y)
};
b2Vec2.prototype.Add = function(v) {
  this.x += v.x;
  this.y += v.y
};
b2Vec2.prototype.Subtract = function(v) {
  this.x -= v.x;
  this.y -= v.y
};
b2Vec2.prototype.Multiply = function(a) {
  this.x *= a;
  this.y *= a
};
b2Vec2.prototype.MulM = function(A) {
  var tX = this.x;
  this.x = A.col1.x * tX + A.col2.x * this.y;
  this.y = A.col1.y * tX + A.col2.y * this.y
};
b2Vec2.prototype.MulTM = function(A) {
  var tX = b2Math.Dot(this, A.col1);
  this.y = b2Math.Dot(this, A.col2);
  this.x = tX
};
b2Vec2.prototype.CrossVF = function(s) {
  var tX = this.x;
  this.x = s * this.y;
  this.y = -s * tX
};
b2Vec2.prototype.CrossFV = function(s) {
  var tX = this.x;
  this.x = -s * this.y;
  this.y = s * tX
};
b2Vec2.prototype.MinV = function(b) {
  this.x = this.x < b.x ? this.x : b.x;
  this.y = this.y < b.y ? this.y : b.y
};
b2Vec2.prototype.MaxV = function(b) {
  this.x = this.x > b.x ? this.x : b.x;
  this.y = this.y > b.y ? this.y : b.y
};
b2Vec2.prototype.Abs = function() {
  if(this.x < 0) {
    this.x = -this.x
  }
  if(this.y < 0) {
    this.y = -this.y
  }
};
b2Vec2.prototype.Length = function() {
  return Math.sqrt(this.x * this.x + this.y * this.y)
};
b2Vec2.prototype.LengthSquared = function() {
  return this.x * this.x + this.y * this.y
};
b2Vec2.prototype.Normalize = function() {
  var length = Math.sqrt(this.x * this.x + this.y * this.y);
  if(length < Number.MIN_VALUE) {
    return 0
  }
  var invLength = 1 / length;
  this.x *= invLength;
  this.y *= invLength;
  return length
};
b2Vec2.prototype.IsValid = function() {
  return b2Math.IsValid(this.x) && b2Math.IsValid(this.y)
};
b2Vec2.prototype.x = 0;
b2Vec2.prototype.y = 0;var b2Vec3 = function(x, y, z) {
  if(arguments.length == 3) {
    this.x = x;
    this.y = y;
    this.z = z
  }
};
b2Vec3.prototype.SetZero = function() {
  this.x = this.y = this.z = 0
};
b2Vec3.prototype.Set = function(x, y, z) {
  this.x = x;
  this.y = y;
  this.z = z
};
b2Vec3.prototype.SetV = function(v) {
  this.x = v.x;
  this.y = v.y;
  this.z = v.z
};
b2Vec3.prototype.GetNegative = function() {
  return new b2Vec3(-this.x, -this.y, -this.z)
};
b2Vec3.prototype.NegativeSelf = function() {
  this.x = -this.x;
  this.y = -this.y;
  this.z = -this.z
};
b2Vec3.prototype.Copy = function() {
  return new b2Vec3(this.x, this.y, this.z)
};
b2Vec3.prototype.Add = function(v) {
  this.x += v.x;
  this.y += v.y;
  this.z += v.z
};
b2Vec3.prototype.Subtract = function(v) {
  this.x -= v.x;
  this.y -= v.y;
  this.z -= v.z
};
b2Vec3.prototype.Multiply = function(a) {
  this.x *= a;
  this.y *= a;
  this.z *= a
};
b2Vec3.prototype.x = 0;
b2Vec3.prototype.y = 0;
b2Vec3.prototype.z = 0;var b2DistanceProxy = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DistanceProxy.prototype.__constructor = function() {
};
b2DistanceProxy.prototype.__varz = function() {
};
b2DistanceProxy.prototype.Set = function(shape) {
  switch(shape.GetType()) {
    case b2Shape.e_circleShape:
      var circle = shape;
      this.m_vertices = new Array(1);
      this.m_vertices[0] = circle.m_p;
      this.m_count = 1;
      this.m_radius = circle.m_radius;
      break;
    case b2Shape.e_polygonShape:
      var polygon = shape;
      this.m_vertices = polygon.m_vertices;
      this.m_count = polygon.m_vertexCount;
      this.m_radius = polygon.m_radius;
      break;
    default:
      b2Settings.b2Assert(false)
  }
};
b2DistanceProxy.prototype.GetSupport = function(d) {
  var bestIndex = 0;
  var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
  for(var i = 1;i < this.m_count;++i) {
    var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
    if(value > bestValue) {
      bestIndex = i;
      bestValue = value
    }
  }
  return bestIndex
};
b2DistanceProxy.prototype.GetSupportVertex = function(d) {
  var bestIndex = 0;
  var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
  for(var i = 1;i < this.m_count;++i) {
    var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
    if(value > bestValue) {
      bestIndex = i;
      bestValue = value
    }
  }
  return this.m_vertices[bestIndex]
};
b2DistanceProxy.prototype.GetVertexCount = function() {
  return this.m_count
};
b2DistanceProxy.prototype.GetVertex = function(index) {
  b2Settings.b2Assert(0 <= index && index < this.m_count);
  return this.m_vertices[index]
};
b2DistanceProxy.prototype.m_vertices = null;
b2DistanceProxy.prototype.m_count = 0;
b2DistanceProxy.prototype.m_radius = null;var b2ContactFactory = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactFactory.prototype.__constructor = function() {
};
b2ContactFactory.prototype.__varz = function() {
  this.InitializeRegisters()
};
b2ContactFactory.prototype.AddType = function(createFcn, destroyFcn, type1, type2) {
  this.m_registers[type1][type2].createFcn = createFcn;
  this.m_registers[type1][type2].destroyFcn = destroyFcn;
  this.m_registers[type1][type2].primary = true;
  if(type1 != type2) {
    this.m_registers[type2][type1].createFcn = createFcn;
    this.m_registers[type2][type1].destroyFcn = destroyFcn;
    this.m_registers[type2][type1].primary = false
  }
};
b2ContactFactory.prototype.InitializeRegisters = function() {
  this.m_registers = new Array(b2Shape.e_shapeTypeCount);
  for(var i = 0;i < b2Shape.e_shapeTypeCount;i++) {
    this.m_registers[i] = new Array(b2Shape.e_shapeTypeCount);
    for(var j = 0;j < b2Shape.e_shapeTypeCount;j++) {
      this.m_registers[i][j] = new b2ContactRegister
    }
  }
  this.AddType(b2CircleContact.Create, b2CircleContact.Destroy, b2Shape.e_circleShape, b2Shape.e_circleShape);
  this.AddType(b2PolyAndCircleContact.Create, b2PolyAndCircleContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_circleShape);
  this.AddType(b2PolygonContact.Create, b2PolygonContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_polygonShape);
  this.AddType(b2EdgeAndCircleContact.Create, b2EdgeAndCircleContact.Destroy, b2Shape.e_edgeShape, b2Shape.e_circleShape);
  this.AddType(b2PolyAndEdgeContact.Create, b2PolyAndEdgeContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_edgeShape)
};
b2ContactFactory.prototype.Create = function(fixtureA, fixtureB) {
  var type1 = fixtureA.GetType();
  var type2 = fixtureB.GetType();
  var reg = this.m_registers[type1][type2];
  var c;
  if(reg.pool) {
    c = reg.pool;
    reg.pool = c.m_next;
    reg.poolCount--;
    c.Reset(fixtureA, fixtureB);
    return c
  }
  var createFcn = reg.createFcn;
  if(createFcn != null) {
    if(reg.primary) {
      c = createFcn(this.m_allocator);
      c.Reset(fixtureA, fixtureB);
      return c
    }else {
      c = createFcn(this.m_allocator);
      c.Reset(fixtureB, fixtureA);
      return c
    }
  }else {
    return null
  }
};
b2ContactFactory.prototype.Destroy = function(contact) {
  if(contact.m_manifold.m_pointCount > 0) {
    contact.m_fixtureA.m_body.SetAwake(true);
    contact.m_fixtureB.m_body.SetAwake(true)
  }
  var type1 = contact.m_fixtureA.GetType();
  var type2 = contact.m_fixtureB.GetType();
  var reg = this.m_registers[type1][type2];
  if(true) {
    reg.poolCount++;
    contact.m_next = reg.pool;
    reg.pool = contact
  }
  var destroyFcn = reg.destroyFcn;
  destroyFcn(contact, this.m_allocator)
};
b2ContactFactory.prototype.m_registers = null;
b2ContactFactory.prototype.m_allocator = null;var b2ConstantAccelController = function() {
  b2Controller.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2ConstantAccelController.prototype, b2Controller.prototype);
b2ConstantAccelController.prototype._super = b2Controller.prototype;
b2ConstantAccelController.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2ConstantAccelController.prototype.__varz = function() {
  this.A = new b2Vec2(0, 0)
};
b2ConstantAccelController.prototype.Step = function(step) {
  var smallA = new b2Vec2(this.A.x * step.dt, this.A.y * step.dt);
  for(var i = m_bodyList;i;i = i.nextBody) {
    var body = i.body;
    if(!body.IsAwake()) {
      continue
    }
    body.SetLinearVelocity(new b2Vec2(body.GetLinearVelocity().x + smallA.x, body.GetLinearVelocity().y + smallA.y))
  }
};
b2ConstantAccelController.prototype.A = new b2Vec2(0, 0);var b2SeparationFunction = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2SeparationFunction.prototype.__constructor = function() {
};
b2SeparationFunction.prototype.__varz = function() {
  this.m_localPoint = new b2Vec2;
  this.m_axis = new b2Vec2
};
b2SeparationFunction.e_points = 1;
b2SeparationFunction.e_faceA = 2;
b2SeparationFunction.e_faceB = 4;
b2SeparationFunction.prototype.Initialize = function(cache, proxyA, transformA, proxyB, transformB) {
  this.m_proxyA = proxyA;
  this.m_proxyB = proxyB;
  var count = cache.count;
  b2Settings.b2Assert(0 < count && count < 3);
  var localPointA;
  var localPointA1;
  var localPointA2;
  var localPointB;
  var localPointB1;
  var localPointB2;
  var pointAX;
  var pointAY;
  var pointBX;
  var pointBY;
  var normalX;
  var normalY;
  var tMat;
  var tVec;
  var s;
  var sgn;
  if(count == 1) {
    this.m_type = b2SeparationFunction.e_points;
    localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);
    localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);
    tVec = localPointA;
    tMat = transformA.R;
    pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
    pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
    tVec = localPointB;
    tMat = transformB.R;
    pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
    pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
    this.m_axis.x = pointBX - pointAX;
    this.m_axis.y = pointBY - pointAY;
    this.m_axis.Normalize()
  }else {
    if(cache.indexB[0] == cache.indexB[1]) {
      this.m_type = b2SeparationFunction.e_faceA;
      localPointA1 = this.m_proxyA.GetVertex(cache.indexA[0]);
      localPointA2 = this.m_proxyA.GetVertex(cache.indexA[1]);
      localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);
      this.m_localPoint.x = 0.5 * (localPointA1.x + localPointA2.x);
      this.m_localPoint.y = 0.5 * (localPointA1.y + localPointA2.y);
      this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointA2, localPointA1), 1);
      this.m_axis.Normalize();
      tVec = this.m_axis;
      tMat = transformA.R;
      normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      tVec = this.m_localPoint;
      tMat = transformA.R;
      pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tVec = localPointB;
      tMat = transformB.R;
      pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      s = (pointBX - pointAX) * normalX + (pointBY - pointAY) * normalY;
      if(s < 0) {
        this.m_axis.NegativeSelf()
      }
    }else {
      if(cache.indexA[0] == cache.indexA[0]) {
        this.m_type = b2SeparationFunction.e_faceB;
        localPointB1 = this.m_proxyB.GetVertex(cache.indexB[0]);
        localPointB2 = this.m_proxyB.GetVertex(cache.indexB[1]);
        localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);
        this.m_localPoint.x = 0.5 * (localPointB1.x + localPointB2.x);
        this.m_localPoint.y = 0.5 * (localPointB1.y + localPointB2.y);
        this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointB2, localPointB1), 1);
        this.m_axis.Normalize();
        tVec = this.m_axis;
        tMat = transformB.R;
        normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
        normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
        tVec = this.m_localPoint;
        tMat = transformB.R;
        pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        tVec = localPointA;
        tMat = transformA.R;
        pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        s = (pointAX - pointBX) * normalX + (pointAY - pointBY) * normalY;
        if(s < 0) {
          this.m_axis.NegativeSelf()
        }
      }else {
        localPointA1 = this.m_proxyA.GetVertex(cache.indexA[0]);
        localPointA2 = this.m_proxyA.GetVertex(cache.indexA[1]);
        localPointB1 = this.m_proxyB.GetVertex(cache.indexB[0]);
        localPointB2 = this.m_proxyB.GetVertex(cache.indexB[1]);
        var pA = b2Math.MulX(transformA, localPointA);
        var dA = b2Math.MulMV(transformA.R, b2Math.SubtractVV(localPointA2, localPointA1));
        var pB = b2Math.MulX(transformB, localPointB);
        var dB = b2Math.MulMV(transformB.R, b2Math.SubtractVV(localPointB2, localPointB1));
        var a = dA.x * dA.x + dA.y * dA.y;
        var e = dB.x * dB.x + dB.y * dB.y;
        var r = b2Math.SubtractVV(dB, dA);
        var c = dA.x * r.x + dA.y * r.y;
        var f = dB.x * r.x + dB.y * r.y;
        var b = dA.x * dB.x + dA.y * dB.y;
        var denom = a * e - b * b;
        s = 0;
        if(denom != 0) {
          s = b2Math.Clamp((b * f - c * e) / denom, 0, 1)
        }
        var t = (b * s + f) / e;
        if(t < 0) {
          t = 0;
          s = b2Math.Clamp((b - c) / a, 0, 1)
        }
        localPointA = new b2Vec2;
        localPointA.x = localPointA1.x + s * (localPointA2.x - localPointA1.x);
        localPointA.y = localPointA1.y + s * (localPointA2.y - localPointA1.y);
        localPointB = new b2Vec2;
        localPointB.x = localPointB1.x + s * (localPointB2.x - localPointB1.x);
        localPointB.y = localPointB1.y + s * (localPointB2.y - localPointB1.y);
        if(s == 0 || s == 1) {
          this.m_type = b2SeparationFunction.e_faceB;
          this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointB2, localPointB1), 1);
          this.m_axis.Normalize();
          this.m_localPoint = localPointB;
          tVec = this.m_axis;
          tMat = transformB.R;
          normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
          normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
          tVec = this.m_localPoint;
          tMat = transformB.R;
          pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
          pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
          tVec = localPointA;
          tMat = transformA.R;
          pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
          pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
          sgn = (pointAX - pointBX) * normalX + (pointAY - pointBY) * normalY;
          if(s < 0) {
            this.m_axis.NegativeSelf()
          }
        }else {
          this.m_type = b2SeparationFunction.e_faceA;
          this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointA2, localPointA1), 1);
          this.m_localPoint = localPointA;
          tVec = this.m_axis;
          tMat = transformA.R;
          normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
          normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
          tVec = this.m_localPoint;
          tMat = transformA.R;
          pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
          pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
          tVec = localPointB;
          tMat = transformB.R;
          pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
          pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
          sgn = (pointBX - pointAX) * normalX + (pointBY - pointAY) * normalY;
          if(s < 0) {
            this.m_axis.NegativeSelf()
          }
        }
      }
    }
  }
};
b2SeparationFunction.prototype.Evaluate = function(transformA, transformB) {
  var axisA;
  var axisB;
  var localPointA;
  var localPointB;
  var pointA;
  var pointB;
  var seperation;
  var normal;
  switch(this.m_type) {
    case b2SeparationFunction.e_points:
      axisA = b2Math.MulTMV(transformA.R, this.m_axis);
      axisB = b2Math.MulTMV(transformB.R, this.m_axis.GetNegative());
      localPointA = this.m_proxyA.GetSupportVertex(axisA);
      localPointB = this.m_proxyB.GetSupportVertex(axisB);
      pointA = b2Math.MulX(transformA, localPointA);
      pointB = b2Math.MulX(transformB, localPointB);
      seperation = (pointB.x - pointA.x) * this.m_axis.x + (pointB.y - pointA.y) * this.m_axis.y;
      return seperation;
    case b2SeparationFunction.e_faceA:
      normal = b2Math.MulMV(transformA.R, this.m_axis);
      pointA = b2Math.MulX(transformA, this.m_localPoint);
      axisB = b2Math.MulTMV(transformB.R, normal.GetNegative());
      localPointB = this.m_proxyB.GetSupportVertex(axisB);
      pointB = b2Math.MulX(transformB, localPointB);
      seperation = (pointB.x - pointA.x) * normal.x + (pointB.y - pointA.y) * normal.y;
      return seperation;
    case b2SeparationFunction.e_faceB:
      normal = b2Math.MulMV(transformB.R, this.m_axis);
      pointB = b2Math.MulX(transformB, this.m_localPoint);
      axisA = b2Math.MulTMV(transformA.R, normal.GetNegative());
      localPointA = this.m_proxyA.GetSupportVertex(axisA);
      pointA = b2Math.MulX(transformA, localPointA);
      seperation = (pointA.x - pointB.x) * normal.x + (pointA.y - pointB.y) * normal.y;
      return seperation;
    default:
      b2Settings.b2Assert(false);
      return 0
  }
};
b2SeparationFunction.prototype.m_proxyA = null;
b2SeparationFunction.prototype.m_proxyB = null;
b2SeparationFunction.prototype.m_type = 0;
b2SeparationFunction.prototype.m_localPoint = new b2Vec2;
b2SeparationFunction.prototype.m_axis = new b2Vec2;var b2DynamicTreePair = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DynamicTreePair.prototype.__constructor = function() {
};
b2DynamicTreePair.prototype.__varz = function() {
};
b2DynamicTreePair.prototype.proxyA = null;
b2DynamicTreePair.prototype.proxyB = null;var b2ContactConstraintPoint = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactConstraintPoint.prototype.__constructor = function() {
};
b2ContactConstraintPoint.prototype.__varz = function() {
  this.localPoint = new b2Vec2;
  this.rA = new b2Vec2;
  this.rB = new b2Vec2
};
b2ContactConstraintPoint.prototype.localPoint = new b2Vec2;
b2ContactConstraintPoint.prototype.rA = new b2Vec2;
b2ContactConstraintPoint.prototype.rB = new b2Vec2;
b2ContactConstraintPoint.prototype.normalImpulse = null;
b2ContactConstraintPoint.prototype.tangentImpulse = null;
b2ContactConstraintPoint.prototype.normalMass = null;
b2ContactConstraintPoint.prototype.tangentMass = null;
b2ContactConstraintPoint.prototype.equalizedMass = null;
b2ContactConstraintPoint.prototype.velocityBias = null;var b2ControllerEdge = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ControllerEdge.prototype.__constructor = function() {
};
b2ControllerEdge.prototype.__varz = function() {
};
b2ControllerEdge.prototype.controller = null;
b2ControllerEdge.prototype.body = null;
b2ControllerEdge.prototype.prevBody = null;
b2ControllerEdge.prototype.nextBody = null;
b2ControllerEdge.prototype.prevController = null;
b2ControllerEdge.prototype.nextController = null;var b2DistanceInput = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DistanceInput.prototype.__constructor = function() {
};
b2DistanceInput.prototype.__varz = function() {
};
b2DistanceInput.prototype.proxyA = null;
b2DistanceInput.prototype.proxyB = null;
b2DistanceInput.prototype.transformA = null;
b2DistanceInput.prototype.transformB = null;
b2DistanceInput.prototype.useRadii = null;var b2Settings = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Settings.prototype.__constructor = function() {
};
b2Settings.prototype.__varz = function() {
};
b2Settings.b2MixFriction = function(friction1, friction2) {
  return Math.sqrt(friction1 * friction2)
};
b2Settings.b2MixRestitution = function(restitution1, restitution2) {
  return restitution1 > restitution2 ? restitution1 : restitution2
};
b2Settings.b2Assert = function(a) {
  if(!a) {
    throw"Assertion Failed";
  }
};
b2Settings.VERSION = "2.1alpha";
b2Settings.USHRT_MAX = 65535;
b2Settings.b2_pi = Math.PI;
b2Settings.b2_maxManifoldPoints = 2;
b2Settings.b2_aabbExtension = 0.1;
b2Settings.b2_aabbMultiplier = 2;
b2Settings.b2_polygonRadius = 2 * b2Settings.b2_linearSlop;
b2Settings.b2_linearSlop = 0.0050;
b2Settings.b2_angularSlop = 2 / 180 * b2Settings.b2_pi;
b2Settings.b2_toiSlop = 8 * b2Settings.b2_linearSlop;
b2Settings.b2_maxTOIContactsPerIsland = 32;
b2Settings.b2_maxTOIJointsPerIsland = 32;
b2Settings.b2_velocityThreshold = 1;
b2Settings.b2_maxLinearCorrection = 0.2;
b2Settings.b2_maxAngularCorrection = 8 / 180 * b2Settings.b2_pi;
b2Settings.b2_maxTranslation = 2;
b2Settings.b2_maxTranslationSquared = b2Settings.b2_maxTranslation * b2Settings.b2_maxTranslation;
b2Settings.b2_maxRotation = 0.5 * b2Settings.b2_pi;
b2Settings.b2_maxRotationSquared = b2Settings.b2_maxRotation * b2Settings.b2_maxRotation;
b2Settings.b2_contactBaumgarte = 0.2;
b2Settings.b2_timeToSleep = 0.5;
b2Settings.b2_linearSleepTolerance = 0.01;
b2Settings.b2_angularSleepTolerance = 2 / 180 * b2Settings.b2_pi;var b2Proxy = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Proxy.prototype.__constructor = function() {
};
b2Proxy.prototype.__varz = function() {
  this.lowerBounds = new Array(2);
  this.upperBounds = new Array(2);
  this.pairs = new Object
};
b2Proxy.prototype.IsValid = function() {
  return this.overlapCount != b2BroadPhase.b2_invalid
};
b2Proxy.prototype.lowerBounds = new Array(2);
b2Proxy.prototype.upperBounds = new Array(2);
b2Proxy.prototype.overlapCount = 0;
b2Proxy.prototype.timeStamp = 0;
b2Proxy.prototype.pairs = new Object;
b2Proxy.prototype.next = null;
b2Proxy.prototype.userData = null;var b2Point = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Point.prototype.__constructor = function() {
};
b2Point.prototype.__varz = function() {
  this.p = new b2Vec2
};
b2Point.prototype.Support = function(xf, vX, vY) {
  return this.p
};
b2Point.prototype.GetFirstVertex = function(xf) {
  return this.p
};
b2Point.prototype.p = new b2Vec2;var b2WorldManifold = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2WorldManifold.prototype.__constructor = function() {
  this.m_points = new Array(b2Settings.b2_maxManifoldPoints);
  for(var i = 0;i < b2Settings.b2_maxManifoldPoints;i++) {
    this.m_points[i] = new b2Vec2
  }
};
b2WorldManifold.prototype.__varz = function() {
  this.m_normal = new b2Vec2
};
b2WorldManifold.prototype.Initialize = function(manifold, xfA, radiusA, xfB, radiusB) {
  if(manifold.m_pointCount == 0) {
    return
  }
  var i = 0;
  var tVec;
  var tMat;
  var normalX;
  var normalY;
  var planePointX;
  var planePointY;
  var clipPointX;
  var clipPointY;
  switch(manifold.m_type) {
    case b2Manifold.e_circles:
      tMat = xfA.R;
      tVec = manifold.m_localPoint;
      var pointAX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      var pointAY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      tMat = xfB.R;
      tVec = manifold.m_points[0].m_localPoint;
      var pointBX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      var pointBY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      var dX = pointBX - pointAX;
      var dY = pointBY - pointAY;
      var d2 = dX * dX + dY * dY;
      if(d2 > Number.MIN_VALUE * Number.MIN_VALUE) {
        var d = Math.sqrt(d2);
        this.m_normal.x = dX / d;
        this.m_normal.y = dY / d
      }else {
        this.m_normal.x = 1;
        this.m_normal.y = 0
      }
      var cAX = pointAX + radiusA * this.m_normal.x;
      var cAY = pointAY + radiusA * this.m_normal.y;
      var cBX = pointBX - radiusB * this.m_normal.x;
      var cBY = pointBY - radiusB * this.m_normal.y;
      this.m_points[0].x = 0.5 * (cAX + cBX);
      this.m_points[0].y = 0.5 * (cAY + cBY);
      break;
    case b2Manifold.e_faceA:
      tMat = xfA.R;
      tVec = manifold.m_localPlaneNormal;
      normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      tMat = xfA.R;
      tVec = manifold.m_localPoint;
      planePointX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      planePointY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      this.m_normal.x = normalX;
      this.m_normal.y = normalY;
      for(i = 0;i < manifold.m_pointCount;i++) {
        tMat = xfB.R;
        tVec = manifold.m_points[i].m_localPoint;
        clipPointX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
        clipPointY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
        this.m_points[i].x = clipPointX + 0.5 * (radiusA - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusB) * normalX;
        this.m_points[i].y = clipPointY + 0.5 * (radiusA - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusB) * normalY
      }
      break;
    case b2Manifold.e_faceB:
      tMat = xfB.R;
      tVec = manifold.m_localPlaneNormal;
      normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      tMat = xfB.R;
      tVec = manifold.m_localPoint;
      planePointX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      planePointY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      this.m_normal.x = -normalX;
      this.m_normal.y = -normalY;
      for(i = 0;i < manifold.m_pointCount;i++) {
        tMat = xfA.R;
        tVec = manifold.m_points[i].m_localPoint;
        clipPointX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
        clipPointY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
        this.m_points[i].x = clipPointX + 0.5 * (radiusB - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusA) * normalX;
        this.m_points[i].y = clipPointY + 0.5 * (radiusB - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusA) * normalY
      }
      break
  }
};
b2WorldManifold.prototype.m_normal = new b2Vec2;
b2WorldManifold.prototype.m_points = null;var b2RayCastOutput = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2RayCastOutput.prototype.__constructor = function() {
};
b2RayCastOutput.prototype.__varz = function() {
  this.normal = new b2Vec2
};
b2RayCastOutput.prototype.normal = new b2Vec2;
b2RayCastOutput.prototype.fraction = null;var b2ConstantForceController = function() {
  b2Controller.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2ConstantForceController.prototype, b2Controller.prototype);
b2ConstantForceController.prototype._super = b2Controller.prototype;
b2ConstantForceController.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2ConstantForceController.prototype.__varz = function() {
  this.F = new b2Vec2(0, 0)
};
b2ConstantForceController.prototype.Step = function(step) {
  for(var i = m_bodyList;i;i = i.nextBody) {
    var body = i.body;
    if(!body.IsAwake()) {
      continue
    }
    body.ApplyForce(this.F, body.GetWorldCenter())
  }
};
b2ConstantForceController.prototype.F = new b2Vec2(0, 0);var b2MassData = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2MassData.prototype.__constructor = function() {
};
b2MassData.prototype.__varz = function() {
  this.center = new b2Vec2(0, 0)
};
b2MassData.prototype.mass = 0;
b2MassData.prototype.center = new b2Vec2(0, 0);
b2MassData.prototype.I = 0;var b2DynamicTree = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DynamicTree.prototype.__constructor = function() {
  this.m_root = null;
  this.m_freeList = null;
  this.m_path = 0;
  this.m_insertionCount = 0
};
b2DynamicTree.prototype.__varz = function() {
};
b2DynamicTree.prototype.AllocateNode = function() {
  if(this.m_freeList) {
    var node = this.m_freeList;
    this.m_freeList = node.parent;
    node.parent = null;
    node.child1 = null;
    node.child2 = null;
    return node
  }
  return new b2DynamicTreeNode
};
b2DynamicTree.prototype.FreeNode = function(node) {
  node.parent = this.m_freeList;
  this.m_freeList = node
};
b2DynamicTree.prototype.InsertLeaf = function(leaf) {
  ++this.m_insertionCount;
  if(this.m_root == null) {
    this.m_root = leaf;
    this.m_root.parent = null;
    return
  }
  var center = leaf.aabb.GetCenter();
  var sibling = this.m_root;
  if(sibling.IsLeaf() == false) {
    do {
      var child1 = sibling.child1;
      var child2 = sibling.child2;
      var norm1 = Math.abs((child1.aabb.lowerBound.x + child1.aabb.upperBound.x) / 2 - center.x) + Math.abs((child1.aabb.lowerBound.y + child1.aabb.upperBound.y) / 2 - center.y);
      var norm2 = Math.abs((child2.aabb.lowerBound.x + child2.aabb.upperBound.x) / 2 - center.x) + Math.abs((child2.aabb.lowerBound.y + child2.aabb.upperBound.y) / 2 - center.y);
      if(norm1 < norm2) {
        sibling = child1
      }else {
        sibling = child2
      }
    }while(sibling.IsLeaf() == false)
  }
  var node1 = sibling.parent;
  var node2 = this.AllocateNode();
  node2.parent = node1;
  node2.userData = null;
  node2.aabb.Combine(leaf.aabb, sibling.aabb);
  if(node1) {
    if(sibling.parent.child1 == sibling) {
      node1.child1 = node2
    }else {
      node1.child2 = node2
    }
    node2.child1 = sibling;
    node2.child2 = leaf;
    sibling.parent = node2;
    leaf.parent = node2;
    do {
      if(node1.aabb.Contains(node2.aabb)) {
        break
      }
      node1.aabb.Combine(node1.child1.aabb, node1.child2.aabb);
      node2 = node1;
      node1 = node1.parent
    }while(node1)
  }else {
    node2.child1 = sibling;
    node2.child2 = leaf;
    sibling.parent = node2;
    leaf.parent = node2;
    this.m_root = node2
  }
};
b2DynamicTree.prototype.RemoveLeaf = function(leaf) {
  if(leaf == this.m_root) {
    this.m_root = null;
    return
  }
  var node2 = leaf.parent;
  var node1 = node2.parent;
  var sibling;
  if(node2.child1 == leaf) {
    sibling = node2.child2
  }else {
    sibling = node2.child1
  }
  if(node1) {
    if(node1.child1 == node2) {
      node1.child1 = sibling
    }else {
      node1.child2 = sibling
    }
    sibling.parent = node1;
    this.FreeNode(node2);
    while(node1) {
      var oldAABB = node1.aabb;
      node1.aabb = b2AABB.Combine(node1.child1.aabb, node1.child2.aabb);
      if(oldAABB.Contains(node1.aabb)) {
        break
      }
      node1 = node1.parent
    }
  }else {
    this.m_root = sibling;
    sibling.parent = null;
    this.FreeNode(node2)
  }
};
b2DynamicTree.prototype.CreateProxy = function(aabb, userData) {
  var node = this.AllocateNode();
  var extendX = b2Settings.b2_aabbExtension;
  var extendY = b2Settings.b2_aabbExtension;
  node.aabb.lowerBound.x = aabb.lowerBound.x - extendX;
  node.aabb.lowerBound.y = aabb.lowerBound.y - extendY;
  node.aabb.upperBound.x = aabb.upperBound.x + extendX;
  node.aabb.upperBound.y = aabb.upperBound.y + extendY;
  node.userData = userData;
  this.InsertLeaf(node);
  return node
};
b2DynamicTree.prototype.DestroyProxy = function(proxy) {
  this.RemoveLeaf(proxy);
  this.FreeNode(proxy)
};
b2DynamicTree.prototype.MoveProxy = function(proxy, aabb, displacement) {
  b2Settings.b2Assert(proxy.IsLeaf());
  if(proxy.aabb.Contains(aabb)) {
    return false
  }
  this.RemoveLeaf(proxy);
  var extendX = b2Settings.b2_aabbExtension + b2Settings.b2_aabbMultiplier * (displacement.x > 0 ? displacement.x : -displacement.x);
  var extendY = b2Settings.b2_aabbExtension + b2Settings.b2_aabbMultiplier * (displacement.y > 0 ? displacement.y : -displacement.y);
  proxy.aabb.lowerBound.x = aabb.lowerBound.x - extendX;
  proxy.aabb.lowerBound.y = aabb.lowerBound.y - extendY;
  proxy.aabb.upperBound.x = aabb.upperBound.x + extendX;
  proxy.aabb.upperBound.y = aabb.upperBound.y + extendY;
  this.InsertLeaf(proxy);
  return true
};
b2DynamicTree.prototype.Rebalance = function(iterations) {
  if(this.m_root == null) {
    return
  }
  for(var i = 0;i < iterations;i++) {
    var node = this.m_root;
    var bit = 0;
    while(node.IsLeaf() == false) {
      node = this.m_path >> bit & 1 ? node.child2 : node.child1;
      bit = bit + 1 & 31
    }
    ++this.m_path;
    this.RemoveLeaf(node);
    this.InsertLeaf(node)
  }
};
b2DynamicTree.prototype.GetFatAABB = function(proxy) {
  return proxy.aabb
};
b2DynamicTree.prototype.GetUserData = function(proxy) {
  return proxy.userData
};
b2DynamicTree.prototype.Query = function(callback, aabb) {
  if(this.m_root == null) {
    return
  }
  var stack = new Array;
  var count = 0;
  stack[count++] = this.m_root;
  while(count > 0) {
    var node = stack[--count];
    if(node.aabb.TestOverlap(aabb)) {
      if(node.IsLeaf()) {
        var proceed = callback(node);
        if(!proceed) {
          return
        }
      }else {
        stack[count++] = node.child1;
        stack[count++] = node.child2
      }
    }
  }
};
b2DynamicTree.prototype.RayCast = function(callback, input) {
  if(this.m_root == null) {
    return
  }
  var p1 = input.p1;
  var p2 = input.p2;
  var r = b2Math.SubtractVV(p1, p2);
  r.Normalize();
  var v = b2Math.CrossFV(1, r);
  var abs_v = b2Math.AbsV(v);
  var maxFraction = input.maxFraction;
  var segmentAABB = new b2AABB;
  var tX;
  var tY;
  tX = p1.x + maxFraction * (p2.x - p1.x);
  tY = p1.y + maxFraction * (p2.y - p1.y);
  segmentAABB.lowerBound.x = Math.min(p1.x, tX);
  segmentAABB.lowerBound.y = Math.min(p1.y, tY);
  segmentAABB.upperBound.x = Math.max(p1.x, tX);
  segmentAABB.upperBound.y = Math.max(p1.y, tY);
  var stack = new Array;
  var count = 0;
  stack[count++] = this.m_root;
  while(count > 0) {
    var node = stack[--count];
    if(node.aabb.TestOverlap(segmentAABB) == false) {
      continue
    }
    var c = node.aabb.GetCenter();
    var h = node.aabb.GetExtents();
    var separation = Math.abs(v.x * (p1.x - c.x) + v.y * (p1.y - c.y)) - abs_v.x * h.x - abs_v.y * h.y;
    if(separation > 0) {
      continue
    }
    if(node.IsLeaf()) {
      var subInput = new b2RayCastInput;
      subInput.p1 = input.p1;
      subInput.p2 = input.p2;
      subInput.maxFraction = input.maxFraction;
      maxFraction = callback(subInput, node);
      if(maxFraction == 0) {
        return
      }
      tX = p1.x + maxFraction * (p2.x - p1.x);
      tY = p1.y + maxFraction * (p2.y - p1.y);
      segmentAABB.lowerBound.x = Math.min(p1.x, tX);
      segmentAABB.lowerBound.y = Math.min(p1.y, tY);
      segmentAABB.upperBound.x = Math.max(p1.x, tX);
      segmentAABB.upperBound.y = Math.max(p1.y, tY)
    }else {
      stack[count++] = node.child1;
      stack[count++] = node.child2
    }
  }
};
b2DynamicTree.prototype.m_root = null;
b2DynamicTree.prototype.m_freeList = null;
b2DynamicTree.prototype.m_path = 0;
b2DynamicTree.prototype.m_insertionCount = 0;var b2JointEdge = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2JointEdge.prototype.__constructor = function() {
};
b2JointEdge.prototype.__varz = function() {
};
b2JointEdge.prototype.other = null;
b2JointEdge.prototype.joint = null;
b2JointEdge.prototype.prev = null;
b2JointEdge.prototype.next = null;var b2RayCastInput = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2RayCastInput.prototype.__constructor = function() {
};
b2RayCastInput.prototype.__varz = function() {
  this.p1 = new b2Vec2;
  this.p2 = new b2Vec2
};
b2RayCastInput.prototype.p1 = new b2Vec2;
b2RayCastInput.prototype.p2 = new b2Vec2;
b2RayCastInput.prototype.maxFraction = null;var Features = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
Features.prototype.__constructor = function() {
};
Features.prototype.__varz = function() {
};
Features.prototype.__defineGetter__("referenceEdge", function() {
  return this._referenceEdge
});
Features.prototype.__defineSetter__("referenceEdge", function(value) {
  this._referenceEdge = value;
  this._m_id._key = this._m_id._key & 4294967040 | this._referenceEdge & 255
});
Features.prototype.__defineGetter__("incidentEdge", function() {
  return this._incidentEdge
});
Features.prototype.__defineSetter__("incidentEdge", function(value) {
  this._incidentEdge = value;
  this._m_id._key = this._m_id._key & 4294902015 | this._incidentEdge << 8 & 65280
});
Features.prototype.__defineGetter__("incidentVertex", function() {
  return this._incidentVertex
});
Features.prototype.__defineSetter__("incidentVertex", function(value) {
  this._incidentVertex = value;
  this._m_id._key = this._m_id._key & 4278255615 | this._incidentVertex << 16 & 16711680
});
Features.prototype.__defineGetter__("flip", function() {
  return this._flip
});
Features.prototype.__defineSetter__("flip", function(value) {
  this._flip = value;
  this._m_id._key = this._m_id._key & 16777215 | this._flip << 24 & 4278190080
});
Features.prototype._referenceEdge = 0;
Features.prototype._incidentEdge = 0;
Features.prototype._incidentVertex = 0;
Features.prototype._flip = 0;
Features.prototype._m_id = null;var b2FilterData = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2FilterData.prototype.__constructor = function() {
};
b2FilterData.prototype.__varz = function() {
  this.categoryBits = 1;
  this.maskBits = 65535
};
b2FilterData.prototype.Copy = function() {
  var copy = new b2FilterData;
  copy.categoryBits = this.categoryBits;
  copy.maskBits = this.maskBits;
  copy.groupIndex = this.groupIndex;
  return copy
};
b2FilterData.prototype.categoryBits = 1;
b2FilterData.prototype.maskBits = 65535;
b2FilterData.prototype.groupIndex = 0;var b2AABB = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2AABB.prototype.__constructor = function() {
};
b2AABB.prototype.__varz = function() {
  this.lowerBound = new b2Vec2;
  this.upperBound = new b2Vec2
};
b2AABB.Combine = function(aabb1, aabb2) {
  var aabb = new b2AABB;
  aabb.Combine(aabb1, aabb2);
  return aabb
};
b2AABB.prototype.IsValid = function() {
  var dX = this.upperBound.x - this.lowerBound.x;
  var dY = this.upperBound.y - this.lowerBound.y;
  var valid = dX >= 0 && dY >= 0;
  valid = valid && this.lowerBound.IsValid() && this.upperBound.IsValid();
  return valid
};
b2AABB.prototype.GetCenter = function() {
  return new b2Vec2((this.lowerBound.x + this.upperBound.x) / 2, (this.lowerBound.y + this.upperBound.y) / 2)
};
b2AABB.prototype.GetExtents = function() {
  return new b2Vec2((this.upperBound.x - this.lowerBound.x) / 2, (this.upperBound.y - this.lowerBound.y) / 2)
};
b2AABB.prototype.Contains = function(aabb) {
  var result = true && this.lowerBound.x <= aabb.lowerBound.x && this.lowerBound.y <= aabb.lowerBound.y && aabb.upperBound.x <= this.upperBound.x && aabb.upperBound.y <= this.upperBound.y;
  return result
};
b2AABB.prototype.RayCast = function(output, input) {
  var tmin = -Number.MAX_VALUE;
  var tmax = Number.MAX_VALUE;
  var pX = input.p1.x;
  var pY = input.p1.y;
  var dX = input.p2.x - input.p1.x;
  var dY = input.p2.y - input.p1.y;
  var absDX = Math.abs(dX);
  var absDY = Math.abs(dY);
  var normal = output.normal;
  var inv_d;
  var t1;
  var t2;
  var t3;
  var s;
  if(absDX < Number.MIN_VALUE) {
    if(pX < this.lowerBound.x || this.upperBound.x < pX) {
      return false
    }
  }else {
    inv_d = 1 / dX;
    t1 = (this.lowerBound.x - pX) * inv_d;
    t2 = (this.upperBound.x - pX) * inv_d;
    s = -1;
    if(t1 > t2) {
      t3 = t1;
      t1 = t2;
      t2 = t3;
      s = 1
    }
    if(t1 > tmin) {
      normal.x = s;
      normal.y = 0;
      tmin = t1
    }
    tmax = Math.min(tmax, t2);
    if(tmin > tmax) {
      return false
    }
  }
  if(absDY < Number.MIN_VALUE) {
    if(pY < this.lowerBound.y || this.upperBound.y < pY) {
      return false
    }
  }else {
    inv_d = 1 / dY;
    t1 = (this.lowerBound.y - pY) * inv_d;
    t2 = (this.upperBound.y - pY) * inv_d;
    s = -1;
    if(t1 > t2) {
      t3 = t1;
      t1 = t2;
      t2 = t3;
      s = 1
    }
    if(t1 > tmin) {
      normal.y = s;
      normal.x = 0;
      tmin = t1
    }
    tmax = Math.min(tmax, t2);
    if(tmin > tmax) {
      return false
    }
  }
  output.fraction = tmin;
  return true
};
b2AABB.prototype.TestOverlap = function(other) {
  var d1X = other.lowerBound.x - this.upperBound.x;
  var d1Y = other.lowerBound.y - this.upperBound.y;
  var d2X = this.lowerBound.x - other.upperBound.x;
  var d2Y = this.lowerBound.y - other.upperBound.y;
  if(d1X > 0 || d1Y > 0) {
    return false
  }
  if(d2X > 0 || d2Y > 0) {
    return false
  }
  return true
};
b2AABB.prototype.Combine = function(aabb1, aabb2) {
  this.lowerBound.x = Math.min(aabb1.lowerBound.x, aabb2.lowerBound.x);
  this.lowerBound.y = Math.min(aabb1.lowerBound.y, aabb2.lowerBound.y);
  this.upperBound.x = Math.max(aabb1.upperBound.x, aabb2.upperBound.x);
  this.upperBound.y = Math.max(aabb1.upperBound.y, aabb2.upperBound.y)
};
b2AABB.prototype.lowerBound = new b2Vec2;
b2AABB.prototype.upperBound = new b2Vec2;var b2Jacobian = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Jacobian.prototype.__constructor = function() {
};
b2Jacobian.prototype.__varz = function() {
  this.linearA = new b2Vec2;
  this.linearB = new b2Vec2
};
b2Jacobian.prototype.SetZero = function() {
  this.linearA.SetZero();
  this.angularA = 0;
  this.linearB.SetZero();
  this.angularB = 0
};
b2Jacobian.prototype.Set = function(x1, a1, x2, a2) {
  this.linearA.SetV(x1);
  this.angularA = a1;
  this.linearB.SetV(x2);
  this.angularB = a2
};
b2Jacobian.prototype.Compute = function(x1, a1, x2, a2) {
  return this.linearA.x * x1.x + this.linearA.y * x1.y + this.angularA * a1 + (this.linearB.x * x2.x + this.linearB.y * x2.y) + this.angularB * a2
};
b2Jacobian.prototype.linearA = new b2Vec2;
b2Jacobian.prototype.angularA = null;
b2Jacobian.prototype.linearB = new b2Vec2;
b2Jacobian.prototype.angularB = null;var b2Bound = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Bound.prototype.__constructor = function() {
};
b2Bound.prototype.__varz = function() {
};
b2Bound.prototype.IsLower = function() {
  return(this.value & 1) == 0
};
b2Bound.prototype.IsUpper = function() {
  return(this.value & 1) == 1
};
b2Bound.prototype.Swap = function(b) {
  var tempValue = this.value;
  var tempProxy = this.proxy;
  var tempStabbingCount = this.stabbingCount;
  this.value = b.value;
  this.proxy = b.proxy;
  this.stabbingCount = b.stabbingCount;
  b.value = tempValue;
  b.proxy = tempProxy;
  b.stabbingCount = tempStabbingCount
};
b2Bound.prototype.value = 0;
b2Bound.prototype.proxy = null;
b2Bound.prototype.stabbingCount = 0;var b2SimplexVertex = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2SimplexVertex.prototype.__constructor = function() {
};
b2SimplexVertex.prototype.__varz = function() {
};
b2SimplexVertex.prototype.Set = function(other) {
  this.wA.SetV(other.wA);
  this.wB.SetV(other.wB);
  this.w.SetV(other.w);
  this.a = other.a;
  this.indexA = other.indexA;
  this.indexB = other.indexB
};
b2SimplexVertex.prototype.wA = null;
b2SimplexVertex.prototype.wB = null;
b2SimplexVertex.prototype.w = null;
b2SimplexVertex.prototype.a = null;
b2SimplexVertex.prototype.indexA = 0;
b2SimplexVertex.prototype.indexB = 0;var b2Mat22 = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Mat22.prototype.__constructor = function() {
  this.col1.x = this.col2.y = 1
};
b2Mat22.prototype.__varz = function() {
  this.col1 = new b2Vec2;
  this.col2 = new b2Vec2
};
b2Mat22.FromAngle = function(angle) {
  var mat = new b2Mat22;
  mat.Set(angle);
  return mat
};
b2Mat22.FromVV = function(c1, c2) {
  var mat = new b2Mat22;
  mat.SetVV(c1, c2);
  return mat
};
b2Mat22.prototype.Set = function(angle) {
  var c = Math.cos(angle);
  var s = Math.sin(angle);
  this.col1.x = c;
  this.col2.x = -s;
  this.col1.y = s;
  this.col2.y = c
};
b2Mat22.prototype.SetVV = function(c1, c2) {
  this.col1.SetV(c1);
  this.col2.SetV(c2)
};
b2Mat22.prototype.Copy = function() {
  var mat = new b2Mat22;
  mat.SetM(this);
  return mat
};
b2Mat22.prototype.SetM = function(m) {
  this.col1.SetV(m.col1);
  this.col2.SetV(m.col2)
};
b2Mat22.prototype.AddM = function(m) {
  this.col1.x += m.col1.x;
  this.col1.y += m.col1.y;
  this.col2.x += m.col2.x;
  this.col2.y += m.col2.y
};
b2Mat22.prototype.SetIdentity = function() {
  this.col1.x = 1;
  this.col2.x = 0;
  this.col1.y = 0;
  this.col2.y = 1
};
b2Mat22.prototype.SetZero = function() {
  this.col1.x = 0;
  this.col2.x = 0;
  this.col1.y = 0;
  this.col2.y = 0
};
b2Mat22.prototype.GetAngle = function() {
  return Math.atan2(this.col1.y, this.col1.x)
};
b2Mat22.prototype.GetInverse = function(out) {
  var a = this.col1.x;
  var b = this.col2.x;
  var c = this.col1.y;
  var d = this.col2.y;
  var det = a * d - b * c;
  if(det != 0) {
    det = 1 / det
  }
  out.col1.x = det * d;
  out.col2.x = -det * b;
  out.col1.y = -det * c;
  out.col2.y = det * a;
  return out
};
b2Mat22.prototype.Solve = function(out, bX, bY) {
  var a11 = this.col1.x;
  var a12 = this.col2.x;
  var a21 = this.col1.y;
  var a22 = this.col2.y;
  var det = a11 * a22 - a12 * a21;
  if(det != 0) {
    det = 1 / det
  }
  out.x = det * (a22 * bX - a12 * bY);
  out.y = det * (a11 * bY - a21 * bX);
  return out
};
b2Mat22.prototype.Abs = function() {
  this.col1.Abs();
  this.col2.Abs()
};
b2Mat22.prototype.col1 = new b2Vec2;
b2Mat22.prototype.col2 = new b2Vec2;var b2SimplexCache = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2SimplexCache.prototype.__constructor = function() {
};
b2SimplexCache.prototype.__varz = function() {
  this.indexA = new Array(3);
  this.indexB = new Array(3)
};
b2SimplexCache.prototype.metric = null;
b2SimplexCache.prototype.count = 0;
b2SimplexCache.prototype.indexA = new Array(3);
b2SimplexCache.prototype.indexB = new Array(3);var b2Shape = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Shape.prototype.__constructor = function() {
  this.m_type = b2Shape.e_unknownShape;
  this.m_radius = b2Settings.b2_linearSlop
};
b2Shape.prototype.__varz = function() {
};
b2Shape.TestOverlap = function(shape1, transform1, shape2, transform2) {
  var input = new b2DistanceInput;
  input.proxyA = new b2DistanceProxy;
  input.proxyA.Set(shape1);
  input.proxyB = new b2DistanceProxy;
  input.proxyB.Set(shape2);
  input.transformA = transform1;
  input.transformB = transform2;
  input.useRadii = true;
  var simplexCache = new b2SimplexCache;
  simplexCache.count = 0;
  var output = new b2DistanceOutput;
  b2Distance.Distance(output, simplexCache, input);
  return output.distance < 10 * Number.MIN_VALUE
};
b2Shape.e_hitCollide = 1;
b2Shape.e_missCollide = 0;
b2Shape.e_startsInsideCollide = -1;
b2Shape.e_unknownShape = -1;
b2Shape.e_circleShape = 0;
b2Shape.e_polygonShape = 1;
b2Shape.e_edgeShape = 2;
b2Shape.e_shapeTypeCount = 3;
b2Shape.prototype.Copy = function() {
  return null
};
b2Shape.prototype.Set = function(other) {
  this.m_radius = other.m_radius
};
b2Shape.prototype.GetType = function() {
  return this.m_type
};
b2Shape.prototype.TestPoint = function(xf, p) {
  return false
};
b2Shape.prototype.RayCast = function(output, input, transform) {
  return false
};
b2Shape.prototype.ComputeAABB = function(aabb, xf) {
};
b2Shape.prototype.ComputeMass = function(massData, density) {
};
b2Shape.prototype.ComputeSubmergedArea = function(normal, offset, xf, c) {
  return 0
};
b2Shape.prototype.m_type = 0;
b2Shape.prototype.m_radius = null;var b2Segment = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Segment.prototype.__constructor = function() {
};
b2Segment.prototype.__varz = function() {
  this.p1 = new b2Vec2;
  this.p2 = new b2Vec2
};
b2Segment.prototype.TestSegment = function(lambda, normal, segment, maxLambda) {
  var s = segment.p1;
  var rX = segment.p2.x - s.x;
  var rY = segment.p2.y - s.y;
  var dX = this.p2.x - this.p1.x;
  var dY = this.p2.y - this.p1.y;
  var nX = dY;
  var nY = -dX;
  var k_slop = 100 * Number.MIN_VALUE;
  var denom = -(rX * nX + rY * nY);
  if(denom > k_slop) {
    var bX = s.x - this.p1.x;
    var bY = s.y - this.p1.y;
    var a = bX * nX + bY * nY;
    if(0 <= a && a <= maxLambda * denom) {
      var mu2 = -rX * bY + rY * bX;
      if(-k_slop * denom <= mu2 && mu2 <= denom * (1 + k_slop)) {
        a /= denom;
        var nLen = Math.sqrt(nX * nX + nY * nY);
        nX /= nLen;
        nY /= nLen;
        lambda[0] = a;
        normal.Set(nX, nY);
        return true
      }
    }
  }
  return false
};
b2Segment.prototype.Extend = function(aabb) {
  this.ExtendForward(aabb);
  this.ExtendBackward(aabb)
};
b2Segment.prototype.ExtendForward = function(aabb) {
  var dX = this.p2.x - this.p1.x;
  var dY = this.p2.y - this.p1.y;
  var lambda = Math.min(dX > 0 ? (aabb.upperBound.x - this.p1.x) / dX : dX < 0 ? (aabb.lowerBound.x - this.p1.x) / dX : Number.POSITIVE_INFINITY, dY > 0 ? (aabb.upperBound.y - this.p1.y) / dY : dY < 0 ? (aabb.lowerBound.y - this.p1.y) / dY : Number.POSITIVE_INFINITY);
  this.p2.x = this.p1.x + dX * lambda;
  this.p2.y = this.p1.y + dY * lambda
};
b2Segment.prototype.ExtendBackward = function(aabb) {
  var dX = -this.p2.x + this.p1.x;
  var dY = -this.p2.y + this.p1.y;
  var lambda = Math.min(dX > 0 ? (aabb.upperBound.x - this.p2.x) / dX : dX < 0 ? (aabb.lowerBound.x - this.p2.x) / dX : Number.POSITIVE_INFINITY, dY > 0 ? (aabb.upperBound.y - this.p2.y) / dY : dY < 0 ? (aabb.lowerBound.y - this.p2.y) / dY : Number.POSITIVE_INFINITY);
  this.p1.x = this.p2.x + dX * lambda;
  this.p1.y = this.p2.y + dY * lambda
};
b2Segment.prototype.p1 = new b2Vec2;
b2Segment.prototype.p2 = new b2Vec2;var b2ContactRegister = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactRegister.prototype.__constructor = function() {
};
b2ContactRegister.prototype.__varz = function() {
};
b2ContactRegister.prototype.createFcn = null;
b2ContactRegister.prototype.destroyFcn = null;
b2ContactRegister.prototype.primary = null;
b2ContactRegister.prototype.pool = null;
b2ContactRegister.prototype.poolCount = 0;var b2DebugDraw = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DebugDraw.prototype.__constructor = function() {
  this.m_drawFlags = 0
};
b2DebugDraw.prototype.__varz = function() {
};
b2DebugDraw.e_shapeBit = 1;
b2DebugDraw.e_jointBit = 2;
b2DebugDraw.e_aabbBit = 4;
b2DebugDraw.e_pairBit = 8;
b2DebugDraw.e_centerOfMassBit = 16;
b2DebugDraw.e_controllerBit = 32;
b2DebugDraw.prototype.SetFlags = function(flags) {
  this.m_drawFlags = flags
};
b2DebugDraw.prototype.GetFlags = function() {
  return this.m_drawFlags
};
b2DebugDraw.prototype.AppendFlags = function(flags) {
  this.m_drawFlags |= flags
};
b2DebugDraw.prototype.ClearFlags = function(flags) {
  this.m_drawFlags &= ~flags
};
b2DebugDraw.prototype.SetSprite = function(sprite) {
  this.m_sprite = sprite
};
b2DebugDraw.prototype.GetSprite = function() {
  return this.m_sprite
};
b2DebugDraw.prototype.SetDrawScale = function(drawScale) {
  this.m_drawScale = drawScale
};
b2DebugDraw.prototype.GetDrawScale = function() {
  return this.m_drawScale
};
b2DebugDraw.prototype.SetLineThickness = function(lineThickness) {
  this.m_lineThickness = lineThickness
};
b2DebugDraw.prototype.GetLineThickness = function() {
  return this.m_lineThickness
};
b2DebugDraw.prototype.SetAlpha = function(alpha) {
  this.m_alpha = alpha
};
b2DebugDraw.prototype.GetAlpha = function() {
  return this.m_alpha
};
b2DebugDraw.prototype.SetFillAlpha = function(alpha) {
  this.m_fillAlpha = alpha
};
b2DebugDraw.prototype.GetFillAlpha = function() {
  return this.m_fillAlpha
};
b2DebugDraw.prototype.SetXFormScale = function(xformScale) {
  this.m_xformScale = xformScale
};
b2DebugDraw.prototype.GetXFormScale = function() {
  return this.m_xformScale
};
b2DebugDraw.prototype.Clear = function() {
  this.m_sprite.clearRect(0, 0, this.m_sprite.canvas.width, this.m_sprite.canvas.height)
};
b2DebugDraw.prototype.Y = function(y) {
  return this.m_sprite.canvas.height - y
};
b2DebugDraw.prototype.ToWorldPoint = function(localPoint) {
  return new b2Vec2(localPoint.x / this.m_drawScale, this.Y(localPoint.y) / this.m_drawScale)
};
b2DebugDraw.prototype.ColorStyle = function(color, alpha) {
  return"rgba(" + color.r + ", " + color.g + ", " + color.b + ", " + alpha + ")"
};
b2DebugDraw.prototype.DrawPolygon = function(vertices, vertexCount, color) {
  this.m_sprite.graphics.lineStyle(this.m_lineThickness, color.color, this.m_alpha);
  this.m_sprite.graphics.moveTo(vertices[0].x * this.m_drawScale, vertices[0].y * this.m_drawScale);
  for(var i = 1;i < vertexCount;i++) {
    this.m_sprite.graphics.lineTo(vertices[i].x * this.m_drawScale, vertices[i].y * this.m_drawScale)
  }
  this.m_sprite.graphics.lineTo(vertices[0].x * this.m_drawScale, vertices[0].y * this.m_drawScale)
};
b2DebugDraw.prototype.DrawSolidPolygon = function(vertices, vertexCount, color) {
  this.m_sprite.strokeSyle = this.ColorStyle(color, this.m_alpha);
  this.m_sprite.lineWidth = this.m_lineThickness;
  this.m_sprite.fillStyle = this.ColorStyle(color, this.m_fillAlpha);
  this.m_sprite.beginPath();
  this.m_sprite.moveTo(vertices[0].x * this.m_drawScale, this.Y(vertices[0].y * this.m_drawScale));
  for(var i = 1;i < vertexCount;i++) {
    this.m_sprite.lineTo(vertices[i].x * this.m_drawScale, this.Y(vertices[i].y * this.m_drawScale))
  }
  this.m_sprite.lineTo(vertices[0].x * this.m_drawScale, this.Y(vertices[0].y * this.m_drawScale));
  this.m_sprite.fill();
  this.m_sprite.stroke();
  this.m_sprite.closePath()
};
b2DebugDraw.prototype.DrawCircle = function(center, radius, color) {
  this.m_sprite.graphics.lineStyle(this.m_lineThickness, color.color, this.m_alpha);
  this.m_sprite.graphics.drawCircle(center.x * this.m_drawScale, center.y * this.m_drawScale, radius * this.m_drawScale)
};
b2DebugDraw.prototype.DrawSolidCircle = function(center, radius, axis, color) {
  this.m_sprite.strokeSyle = this.ColorStyle(color, this.m_alpha);
  this.m_sprite.lineWidth = this.m_lineThickness;
  this.m_sprite.fillStyle = this.ColorStyle(color, this.m_fillAlpha);
  this.m_sprite.beginPath();
  this.m_sprite.arc(center.x * this.m_drawScale, this.Y(center.y * this.m_drawScale), radius * this.m_drawScale, 0, Math.PI * 2, true);
  this.m_sprite.fill();
  this.m_sprite.stroke();
  this.m_sprite.closePath()
};
b2DebugDraw.prototype.DrawSegment = function(p1, p2, color) {
  this.m_sprite.lineWidth = this.m_lineThickness;
  this.m_sprite.strokeSyle = this.ColorStyle(color, this.m_alpha);
  this.m_sprite.beginPath();
  this.m_sprite.moveTo(p1.x * this.m_drawScale, this.Y(p1.y * this.m_drawScale));
  this.m_sprite.lineTo(p2.x * this.m_drawScale, this.Y(p2.y * this.m_drawScale));
  this.m_sprite.stroke();
  this.m_sprite.closePath()
};
b2DebugDraw.prototype.DrawTransform = function(xf) {
  this.m_sprite.lineWidth = this.m_lineThickness;
  this.m_sprite.strokeSyle = this.ColorStyle(new b2Color(255, 0, 0), this.m_alpha);
  this.m_sprite.beginPath();
  this.m_sprite.moveTo(xf.position.x * this.m_drawScale, this.Y(xf.position.y * this.m_drawScale));
  this.m_sprite.lineTo((xf.position.x + this.m_xformScale * xf.R.col1.x) * this.m_drawScale, this.Y((xf.position.y + this.m_xformScale * xf.R.col1.y) * this.m_drawScale));
  this.m_sprite.stroke();
  this.m_sprite.closePath();
  this.m_sprite.strokeSyle = this.ColorStyle(new b2Color(0, 255, 0), this.m_alpha);
  this.m_sprite.beginPath();
  this.m_sprite.moveTo(xf.position.x * this.m_drawScale, this.Y(xf.position.y * this.m_drawScale));
  this.m_sprite.lineTo((xf.position.x + this.m_xformScale * xf.R.col2.x) * this.m_drawScale, this.Y((xf.position.y + this.m_xformScale * xf.R.col2.y) * this.m_drawScale));
  this.m_sprite.stroke();
  this.m_sprite.closePath()
};
b2DebugDraw.prototype.m_drawFlags = 0;
b2DebugDraw.prototype.m_sprite = null;
b2DebugDraw.prototype.m_drawScale = 1;
b2DebugDraw.prototype.m_lineThickness = 1;
b2DebugDraw.prototype.m_alpha = 1;
b2DebugDraw.prototype.m_fillAlpha = 1;
b2DebugDraw.prototype.m_xformScale = 1;var b2Sweep = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Sweep.prototype.__constructor = function() {
};
b2Sweep.prototype.__varz = function() {
  this.localCenter = new b2Vec2;
  this.c0 = new b2Vec2;
  this.c = new b2Vec2
};
b2Sweep.prototype.Set = function(other) {
  this.localCenter.SetV(other.localCenter);
  this.c0.SetV(other.c0);
  this.c.SetV(other.c);
  this.a0 = other.a0;
  this.a = other.a;
  this.t0 = other.t0
};
b2Sweep.prototype.Copy = function() {
  var copy = new b2Sweep;
  copy.localCenter.SetV(this.localCenter);
  copy.c0.SetV(this.c0);
  copy.c.SetV(this.c);
  copy.a0 = this.a0;
  copy.a = this.a;
  copy.t0 = this.t0;
  return copy
};
b2Sweep.prototype.GetTransform = function(xf, alpha) {
  xf.position.x = (1 - alpha) * this.c0.x + alpha * this.c.x;
  xf.position.y = (1 - alpha) * this.c0.y + alpha * this.c.y;
  var angle = (1 - alpha) * this.a0 + alpha * this.a;
  xf.R.Set(angle);
  var tMat = xf.R;
  xf.position.x -= tMat.col1.x * this.localCenter.x + tMat.col2.x * this.localCenter.y;
  xf.position.y -= tMat.col1.y * this.localCenter.x + tMat.col2.y * this.localCenter.y
};
b2Sweep.prototype.Advance = function(t) {
  if(this.t0 < t && 1 - this.t0 > Number.MIN_VALUE) {
    var alpha = (t - this.t0) / (1 - this.t0);
    this.c0.x = (1 - alpha) * this.c0.x + alpha * this.c.x;
    this.c0.y = (1 - alpha) * this.c0.y + alpha * this.c.y;
    this.a0 = (1 - alpha) * this.a0 + alpha * this.a;
    this.t0 = t
  }
};
b2Sweep.prototype.localCenter = new b2Vec2;
b2Sweep.prototype.c0 = new b2Vec2;
b2Sweep.prototype.c = new b2Vec2;
b2Sweep.prototype.a0 = null;
b2Sweep.prototype.a = null;
b2Sweep.prototype.t0 = null;var b2DistanceOutput = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DistanceOutput.prototype.__constructor = function() {
};
b2DistanceOutput.prototype.__varz = function() {
  this.pointA = new b2Vec2;
  this.pointB = new b2Vec2
};
b2DistanceOutput.prototype.pointA = new b2Vec2;
b2DistanceOutput.prototype.pointB = new b2Vec2;
b2DistanceOutput.prototype.distance = null;
b2DistanceOutput.prototype.iterations = 0;var b2Mat33 = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Mat33.prototype.__constructor = function(c1, c2, c3) {
  if(!c1 && !c2 && !c3) {
    this.col1.SetZero();
    this.col2.SetZero();
    this.col3.SetZero()
  }else {
    this.col1.SetV(c1);
    this.col2.SetV(c2);
    this.col3.SetV(c3)
  }
};
b2Mat33.prototype.__varz = function() {
  this.col1 = new b2Vec3;
  this.col2 = new b2Vec3;
  this.col3 = new b2Vec3
};
b2Mat33.prototype.SetVVV = function(c1, c2, c3) {
  this.col1.SetV(c1);
  this.col2.SetV(c2);
  this.col3.SetV(c3)
};
b2Mat33.prototype.Copy = function() {
  return new b2Mat33(this.col1, this.col2, this.col3)
};
b2Mat33.prototype.SetM = function(m) {
  this.col1.SetV(m.col1);
  this.col2.SetV(m.col2);
  this.col3.SetV(m.col3)
};
b2Mat33.prototype.AddM = function(m) {
  this.col1.x += m.col1.x;
  this.col1.y += m.col1.y;
  this.col1.z += m.col1.z;
  this.col2.x += m.col2.x;
  this.col2.y += m.col2.y;
  this.col2.z += m.col2.z;
  this.col3.x += m.col3.x;
  this.col3.y += m.col3.y;
  this.col3.z += m.col3.z
};
b2Mat33.prototype.SetIdentity = function() {
  this.col1.x = 1;
  this.col2.x = 0;
  this.col3.x = 0;
  this.col1.y = 0;
  this.col2.y = 1;
  this.col3.y = 0;
  this.col1.z = 0;
  this.col2.z = 0;
  this.col3.z = 1
};
b2Mat33.prototype.SetZero = function() {
  this.col1.x = 0;
  this.col2.x = 0;
  this.col3.x = 0;
  this.col1.y = 0;
  this.col2.y = 0;
  this.col3.y = 0;
  this.col1.z = 0;
  this.col2.z = 0;
  this.col3.z = 0
};
b2Mat33.prototype.Solve22 = function(out, bX, bY) {
  var a11 = this.col1.x;
  var a12 = this.col2.x;
  var a21 = this.col1.y;
  var a22 = this.col2.y;
  var det = a11 * a22 - a12 * a21;
  if(det != 0) {
    det = 1 / det
  }
  out.x = det * (a22 * bX - a12 * bY);
  out.y = det * (a11 * bY - a21 * bX);
  return out
};
b2Mat33.prototype.Solve33 = function(out, bX, bY, bZ) {
  var a11 = this.col1.x;
  var a21 = this.col1.y;
  var a31 = this.col1.z;
  var a12 = this.col2.x;
  var a22 = this.col2.y;
  var a32 = this.col2.z;
  var a13 = this.col3.x;
  var a23 = this.col3.y;
  var a33 = this.col3.z;
  var det = a11 * (a22 * a33 - a32 * a23) + a21 * (a32 * a13 - a12 * a33) + a31 * (a12 * a23 - a22 * a13);
  if(det != 0) {
    det = 1 / det
  }
  out.x = det * (bX * (a22 * a33 - a32 * a23) + bY * (a32 * a13 - a12 * a33) + bZ * (a12 * a23 - a22 * a13));
  out.y = det * (a11 * (bY * a33 - bZ * a23) + a21 * (bZ * a13 - bX * a33) + a31 * (bX * a23 - bY * a13));
  out.z = det * (a11 * (a22 * bZ - a32 * bY) + a21 * (a32 * bX - a12 * bZ) + a31 * (a12 * bY - a22 * bX));
  return out
};
b2Mat33.prototype.col1 = new b2Vec3;
b2Mat33.prototype.col2 = new b2Vec3;
b2Mat33.prototype.col3 = new b2Vec3;var b2PositionSolverManifold = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2PositionSolverManifold.prototype.__constructor = function() {
  this.m_normal = new b2Vec2;
  this.m_separations = new Array(b2Settings.b2_maxManifoldPoints);
  this.m_points = new Array(b2Settings.b2_maxManifoldPoints);
  for(var i = 0;i < b2Settings.b2_maxManifoldPoints;i++) {
    this.m_points[i] = new b2Vec2
  }
};
b2PositionSolverManifold.prototype.__varz = function() {
};
b2PositionSolverManifold.circlePointA = new b2Vec2;
b2PositionSolverManifold.circlePointB = new b2Vec2;
b2PositionSolverManifold.prototype.Initialize = function(cc) {
  b2Settings.b2Assert(cc.pointCount > 0);
  var i = 0;
  var clipPointX;
  var clipPointY;
  var tMat;
  var tVec;
  var planePointX;
  var planePointY;
  switch(cc.type) {
    case b2Manifold.e_circles:
      tMat = cc.bodyA.m_xf.R;
      tVec = cc.localPoint;
      var pointAX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var pointAY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tMat = cc.bodyB.m_xf.R;
      tVec = cc.points[0].localPoint;
      var pointBX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var pointBY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      var dX = pointBX - pointAX;
      var dY = pointBY - pointAY;
      var d2 = dX * dX + dY * dY;
      if(d2 > Number.MIN_VALUE * Number.MIN_VALUE) {
        var d = Math.sqrt(d2);
        this.m_normal.x = dX / d;
        this.m_normal.y = dY / d
      }else {
        this.m_normal.x = 1;
        this.m_normal.y = 0
      }
      this.m_points[0].x = 0.5 * (pointAX + pointBX);
      this.m_points[0].y = 0.5 * (pointAY + pointBY);
      this.m_separations[0] = dX * this.m_normal.x + dY * this.m_normal.y - cc.radius;
      break;
    case b2Manifold.e_faceA:
      tMat = cc.bodyA.m_xf.R;
      tVec = cc.localPlaneNormal;
      this.m_normal.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      this.m_normal.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      tMat = cc.bodyA.m_xf.R;
      tVec = cc.localPoint;
      planePointX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      planePointY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tMat = cc.bodyB.m_xf.R;
      for(i = 0;i < cc.pointCount;++i) {
        tVec = cc.points[i].localPoint;
        clipPointX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        clipPointY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        this.m_separations[i] = (clipPointX - planePointX) * this.m_normal.x + (clipPointY - planePointY) * this.m_normal.y - cc.radius;
        this.m_points[i].x = clipPointX;
        this.m_points[i].y = clipPointY
      }
      break;
    case b2Manifold.e_faceB:
      tMat = cc.bodyB.m_xf.R;
      tVec = cc.localPlaneNormal;
      this.m_normal.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      this.m_normal.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      tMat = cc.bodyB.m_xf.R;
      tVec = cc.localPoint;
      planePointX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      planePointY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tMat = cc.bodyA.m_xf.R;
      for(i = 0;i < cc.pointCount;++i) {
        tVec = cc.points[i].localPoint;
        clipPointX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        clipPointY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        this.m_separations[i] = (clipPointX - planePointX) * this.m_normal.x + (clipPointY - planePointY) * this.m_normal.y - cc.radius;
        this.m_points[i].Set(clipPointX, clipPointY)
      }
      this.m_normal.x *= -1;
      this.m_normal.y *= -1;
      break
  }
};
b2PositionSolverManifold.prototype.m_normal = null;
b2PositionSolverManifold.prototype.m_points = null;
b2PositionSolverManifold.prototype.m_separations = null;var b2OBB = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2OBB.prototype.__constructor = function() {
};
b2OBB.prototype.__varz = function() {
  this.R = new b2Mat22;
  this.center = new b2Vec2;
  this.extents = new b2Vec2
};
b2OBB.prototype.R = new b2Mat22;
b2OBB.prototype.center = new b2Vec2;
b2OBB.prototype.extents = new b2Vec2;var b2Pair = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Pair.prototype.__constructor = function() {
};
b2Pair.prototype.__varz = function() {
};
b2Pair.b2_nullProxy = b2Settings.USHRT_MAX;
b2Pair.e_pairBuffered = 1;
b2Pair.e_pairRemoved = 2;
b2Pair.e_pairFinal = 4;
b2Pair.prototype.SetBuffered = function() {
  this.status |= b2Pair.e_pairBuffered
};
b2Pair.prototype.ClearBuffered = function() {
  this.status &= ~b2Pair.e_pairBuffered
};
b2Pair.prototype.IsBuffered = function() {
  return(this.status & b2Pair.e_pairBuffered) == b2Pair.e_pairBuffered
};
b2Pair.prototype.SetRemoved = function() {
  this.status |= b2Pair.e_pairRemoved
};
b2Pair.prototype.ClearRemoved = function() {
  this.status &= ~b2Pair.e_pairRemoved
};
b2Pair.prototype.IsRemoved = function() {
  return(this.status & b2Pair.e_pairRemoved) == b2Pair.e_pairRemoved
};
b2Pair.prototype.SetFinal = function() {
  this.status |= b2Pair.e_pairFinal
};
b2Pair.prototype.IsFinal = function() {
  return(this.status & b2Pair.e_pairFinal) == b2Pair.e_pairFinal
};
b2Pair.prototype.userData = null;
b2Pair.prototype.proxy1 = null;
b2Pair.prototype.proxy2 = null;
b2Pair.prototype.next = null;
b2Pair.prototype.status = 0;var b2FixtureDef = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2FixtureDef.prototype.__constructor = function() {
  this.shape = null;
  this.userData = null;
  this.friction = 0.2;
  this.restitution = 0;
  this.density = 0;
  this.filter.categoryBits = 1;
  this.filter.maskBits = 65535;
  this.filter.groupIndex = 0;
  this.isSensor = false
};
b2FixtureDef.prototype.__varz = function() {
  this.filter = new b2FilterData
};
b2FixtureDef.prototype.shape = null;
b2FixtureDef.prototype.userData = null;
b2FixtureDef.prototype.friction = null;
b2FixtureDef.prototype.restitution = null;
b2FixtureDef.prototype.density = null;
b2FixtureDef.prototype.isSensor = null;
b2FixtureDef.prototype.filter = new b2FilterData;var b2ContactID = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactID.prototype.__constructor = function() {
  this.features._m_id = this
};
b2ContactID.prototype.__varz = function() {
  this.features = new Features
};
b2ContactID.prototype.Set = function(id) {
  key = id._key
};
b2ContactID.prototype.Copy = function() {
  var id = new b2ContactID;
  id.key = key;
  return id
};
b2ContactID.prototype.__defineSetter__("key", function() {
  return this._key
});
b2ContactID.prototype.__defineSetter__("key", function(value) {
  this._key = value;
  this.features._referenceEdge = this._key & 255;
  this.features._incidentEdge = (this._key & 65280) >> 8 & 255;
  this.features._incidentVertex = (this._key & 16711680) >> 16 & 255;
  this.features._flip = (this._key & 4278190080) >> 24 & 255
});
b2ContactID.prototype._key = 0;
b2ContactID.prototype.features = new Features;var b2Transform = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Transform.prototype.__constructor = function(pos, r) {
  if(pos) {
    this.position.SetV(pos);
    this.R.SetM(r)
  }
};
b2Transform.prototype.__varz = function() {
  this.position = new b2Vec2;
  this.R = new b2Mat22
};
b2Transform.prototype.Initialize = function(pos, r) {
  this.position.SetV(pos);
  this.R.SetM(r)
};
b2Transform.prototype.SetIdentity = function() {
  this.position.SetZero();
  this.R.SetIdentity()
};
b2Transform.prototype.Set = function(x) {
  this.position.SetV(x.position);
  this.R.SetM(x.R)
};
b2Transform.prototype.GetAngle = function() {
  return Math.atan2(this.R.col1.y, this.R.col1.x)
};
b2Transform.prototype.position = new b2Vec2;
b2Transform.prototype.R = new b2Mat22;var b2EdgeShape = function() {
  b2Shape.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2EdgeShape.prototype, b2Shape.prototype);
b2EdgeShape.prototype._super = b2Shape.prototype;
b2EdgeShape.prototype.__constructor = function(v1, v2) {
  this._super.__constructor.apply(this, []);
  this.m_type = b2Shape.e_edgeShape;
  this.m_prevEdge = null;
  this.m_nextEdge = null;
  this.m_v1 = v1;
  this.m_v2 = v2;
  this.m_direction.Set(this.m_v2.x - this.m_v1.x, this.m_v2.y - this.m_v1.y);
  this.m_length = this.m_direction.Normalize();
  this.m_normal.Set(this.m_direction.y, -this.m_direction.x);
  this.m_coreV1.Set(-b2Settings.b2_toiSlop * (this.m_normal.x - this.m_direction.x) + this.m_v1.x, -b2Settings.b2_toiSlop * (this.m_normal.y - this.m_direction.y) + this.m_v1.y);
  this.m_coreV2.Set(-b2Settings.b2_toiSlop * (this.m_normal.x + this.m_direction.x) + this.m_v2.x, -b2Settings.b2_toiSlop * (this.m_normal.y + this.m_direction.y) + this.m_v2.y);
  this.m_cornerDir1 = this.m_normal;
  this.m_cornerDir2.Set(-this.m_normal.x, -this.m_normal.y)
};
b2EdgeShape.prototype.__varz = function() {
  this.s_supportVec = new b2Vec2;
  this.m_v1 = new b2Vec2;
  this.m_v2 = new b2Vec2;
  this.m_coreV1 = new b2Vec2;
  this.m_coreV2 = new b2Vec2;
  this.m_normal = new b2Vec2;
  this.m_direction = new b2Vec2;
  this.m_cornerDir1 = new b2Vec2;
  this.m_cornerDir2 = new b2Vec2
};
b2EdgeShape.prototype.SetPrevEdge = function(edge, core, cornerDir, convex) {
  this.m_prevEdge = edge;
  this.m_coreV1 = core;
  this.m_cornerDir1 = cornerDir;
  this.m_cornerConvex1 = convex
};
b2EdgeShape.prototype.SetNextEdge = function(edge, core, cornerDir, convex) {
  this.m_nextEdge = edge;
  this.m_coreV2 = core;
  this.m_cornerDir2 = cornerDir;
  this.m_cornerConvex2 = convex
};
b2EdgeShape.prototype.TestPoint = function(transform, p) {
  return false
};
b2EdgeShape.prototype.RayCast = function(output, input, transform) {
  var tMat;
  var rX = input.p2.x - input.p1.x;
  var rY = input.p2.y - input.p1.y;
  tMat = transform.R;
  var v1X = transform.position.x + (tMat.col1.x * this.m_v1.x + tMat.col2.x * this.m_v1.y);
  var v1Y = transform.position.y + (tMat.col1.y * this.m_v1.x + tMat.col2.y * this.m_v1.y);
  var nX = transform.position.y + (tMat.col1.y * this.m_v2.x + tMat.col2.y * this.m_v2.y) - v1Y;
  var nY = -(transform.position.x + (tMat.col1.x * this.m_v2.x + tMat.col2.x * this.m_v2.y) - v1X);
  var k_slop = 100 * Number.MIN_VALUE;
  var denom = -(rX * nX + rY * nY);
  if(denom > k_slop) {
    var bX = input.p1.x - v1X;
    var bY = input.p1.y - v1Y;
    var a = bX * nX + bY * nY;
    if(0 <= a && a <= input.maxFraction * denom) {
      var mu2 = -rX * bY + rY * bX;
      if(-k_slop * denom <= mu2 && mu2 <= denom * (1 + k_slop)) {
        a /= denom;
        output.fraction = a;
        var nLen = Math.sqrt(nX * nX + nY * nY);
        output.normal.x = nX / nLen;
        output.normal.y = nY / nLen;
        return true
      }
    }
  }
  return false
};
b2EdgeShape.prototype.ComputeAABB = function(aabb, transform) {
  var tMat = transform.R;
  var v1X = transform.position.x + (tMat.col1.x * this.m_v1.x + tMat.col2.x * this.m_v1.y);
  var v1Y = transform.position.y + (tMat.col1.y * this.m_v1.x + tMat.col2.y * this.m_v1.y);
  var v2X = transform.position.x + (tMat.col1.x * this.m_v2.x + tMat.col2.x * this.m_v2.y);
  var v2Y = transform.position.y + (tMat.col1.y * this.m_v2.x + tMat.col2.y * this.m_v2.y);
  if(v1X < v2X) {
    aabb.lowerBound.x = v1X;
    aabb.upperBound.x = v2X
  }else {
    aabb.lowerBound.x = v2X;
    aabb.upperBound.x = v1X
  }
  if(v1Y < v2Y) {
    aabb.lowerBound.y = v1Y;
    aabb.upperBound.y = v2Y
  }else {
    aabb.lowerBound.y = v2Y;
    aabb.upperBound.y = v1Y
  }
};
b2EdgeShape.prototype.ComputeMass = function(massData, density) {
  massData.mass = 0;
  massData.center.SetV(this.m_v1);
  massData.I = 0
};
b2EdgeShape.prototype.ComputeSubmergedArea = function(normal, offset, xf, c) {
  var v0 = new b2Vec2(normal.x * offset, normal.y * offset);
  var v1 = b2Math.MulX(xf, this.m_v1);
  var v2 = b2Math.MulX(xf, this.m_v2);
  var d1 = b2Math.Dot(normal, v1) - offset;
  var d2 = b2Math.Dot(normal, v2) - offset;
  if(d1 > 0) {
    if(d2 > 0) {
      return 0
    }else {
      v1.x = -d2 / (d1 - d2) * v1.x + d1 / (d1 - d2) * v2.x;
      v1.y = -d2 / (d1 - d2) * v1.y + d1 / (d1 - d2) * v2.y
    }
  }else {
    if(d2 > 0) {
      v2.x = -d2 / (d1 - d2) * v1.x + d1 / (d1 - d2) * v2.x;
      v2.y = -d2 / (d1 - d2) * v1.y + d1 / (d1 - d2) * v2.y
    }else {
    }
  }
  c.x = (v0.x + v1.x + v2.x) / 3;
  c.y = (v0.y + v1.y + v2.y) / 3;
  return 0.5 * ((v1.x - v0.x) * (v2.y - v0.y) - (v1.y - v0.y) * (v2.x - v0.x))
};
b2EdgeShape.prototype.GetLength = function() {
  return this.m_length
};
b2EdgeShape.prototype.GetVertex1 = function() {
  return this.m_v1
};
b2EdgeShape.prototype.GetVertex2 = function() {
  return this.m_v2
};
b2EdgeShape.prototype.GetCoreVertex1 = function() {
  return this.m_coreV1
};
b2EdgeShape.prototype.GetCoreVertex2 = function() {
  return this.m_coreV2
};
b2EdgeShape.prototype.GetNormalVector = function() {
  return this.m_normal
};
b2EdgeShape.prototype.GetDirectionVector = function() {
  return this.m_direction
};
b2EdgeShape.prototype.GetCorner1Vector = function() {
  return this.m_cornerDir1
};
b2EdgeShape.prototype.GetCorner2Vector = function() {
  return this.m_cornerDir2
};
b2EdgeShape.prototype.Corner1IsConvex = function() {
  return this.m_cornerConvex1
};
b2EdgeShape.prototype.Corner2IsConvex = function() {
  return this.m_cornerConvex2
};
b2EdgeShape.prototype.GetFirstVertex = function(xf) {
  var tMat = xf.R;
  return new b2Vec2(xf.position.x + (tMat.col1.x * this.m_coreV1.x + tMat.col2.x * this.m_coreV1.y), xf.position.y + (tMat.col1.y * this.m_coreV1.x + tMat.col2.y * this.m_coreV1.y))
};
b2EdgeShape.prototype.GetNextEdge = function() {
  return this.m_nextEdge
};
b2EdgeShape.prototype.GetPrevEdge = function() {
  return this.m_prevEdge
};
b2EdgeShape.prototype.Support = function(xf, dX, dY) {
  var tMat = xf.R;
  var v1X = xf.position.x + (tMat.col1.x * this.m_coreV1.x + tMat.col2.x * this.m_coreV1.y);
  var v1Y = xf.position.y + (tMat.col1.y * this.m_coreV1.x + tMat.col2.y * this.m_coreV1.y);
  var v2X = xf.position.x + (tMat.col1.x * this.m_coreV2.x + tMat.col2.x * this.m_coreV2.y);
  var v2Y = xf.position.y + (tMat.col1.y * this.m_coreV2.x + tMat.col2.y * this.m_coreV2.y);
  if(v1X * dX + v1Y * dY > v2X * dX + v2Y * dY) {
    this.s_supportVec.x = v1X;
    this.s_supportVec.y = v1Y
  }else {
    this.s_supportVec.x = v2X;
    this.s_supportVec.y = v2Y
  }
  return this.s_supportVec
};
b2EdgeShape.prototype.s_supportVec = new b2Vec2;
b2EdgeShape.prototype.m_v1 = new b2Vec2;
b2EdgeShape.prototype.m_v2 = new b2Vec2;
b2EdgeShape.prototype.m_coreV1 = new b2Vec2;
b2EdgeShape.prototype.m_coreV2 = new b2Vec2;
b2EdgeShape.prototype.m_length = null;
b2EdgeShape.prototype.m_normal = new b2Vec2;
b2EdgeShape.prototype.m_direction = new b2Vec2;
b2EdgeShape.prototype.m_cornerDir1 = new b2Vec2;
b2EdgeShape.prototype.m_cornerDir2 = new b2Vec2;
b2EdgeShape.prototype.m_cornerConvex1 = null;
b2EdgeShape.prototype.m_cornerConvex2 = null;
b2EdgeShape.prototype.m_nextEdge = null;
b2EdgeShape.prototype.m_prevEdge = null;var b2BuoyancyController = function() {
  b2Controller.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2BuoyancyController.prototype, b2Controller.prototype);
b2BuoyancyController.prototype._super = b2Controller.prototype;
b2BuoyancyController.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2BuoyancyController.prototype.__varz = function() {
  this.normal = new b2Vec2(0, -1);
  this.velocity = new b2Vec2(0, 0)
};
b2BuoyancyController.prototype.Step = function(step) {
  if(!m_bodyList) {
    return
  }
  if(this.useWorldGravity) {
    this.gravity = this.GetWorld().GetGravity().Copy()
  }
  for(var i = m_bodyList;i;i = i.nextBody) {
    var body = i.body;
    if(body.IsAwake() == false) {
      continue
    }
    var areac = new b2Vec2;
    var massc = new b2Vec2;
    var area = 0;
    var mass = 0;
    for(var fixture = body.GetFixtureList();fixture;fixture = fixture.GetNext()) {
      var sc = new b2Vec2;
      var sarea = fixture.GetShape().ComputeSubmergedArea(this.normal, this.offset, body.GetTransform(), sc);
      area += sarea;
      areac.x += sarea * sc.x;
      areac.y += sarea * sc.y;
      var shapeDensity;
      if(this.useDensity) {
        shapeDensity = 1
      }else {
        shapeDensity = 1
      }
      mass += sarea * shapeDensity;
      massc.x += sarea * sc.x * shapeDensity;
      massc.y += sarea * sc.y * shapeDensity
    }
    areac.x /= area;
    areac.y /= area;
    massc.x /= mass;
    massc.y /= mass;
    if(area < Number.MIN_VALUE) {
      continue
    }
    var buoyancyForce = this.gravity.GetNegative();
    buoyancyForce.Multiply(this.density * area);
    body.ApplyForce(buoyancyForce, massc);
    var dragForce = body.GetLinearVelocityFromWorldPoint(areac);
    dragForce.Subtract(this.velocity);
    dragForce.Multiply(-this.linearDrag * area);
    body.ApplyForce(dragForce, areac);
    body.ApplyTorque(-body.GetInertia() / body.GetMass() * area * body.GetAngularVelocity() * this.angularDrag)
  }
};
b2BuoyancyController.prototype.Draw = function(debugDraw) {
  var r = 1E3;
  var p1 = new b2Vec2;
  var p2 = new b2Vec2;
  p1.x = this.normal.x * this.offset + this.normal.y * r;
  p1.y = this.normal.y * this.offset - this.normal.x * r;
  p2.x = this.normal.x * this.offset - this.normal.y * r;
  p2.y = this.normal.y * this.offset + this.normal.x * r;
  var color = new b2Color(0, 0, 1);
  debugDraw.DrawSegment(p1, p2, color)
};
b2BuoyancyController.prototype.normal = new b2Vec2(0, -1);
b2BuoyancyController.prototype.offset = 0;
b2BuoyancyController.prototype.density = 0;
b2BuoyancyController.prototype.velocity = new b2Vec2(0, 0);
b2BuoyancyController.prototype.linearDrag = 2;
b2BuoyancyController.prototype.angularDrag = 1;
b2BuoyancyController.prototype.useDensity = false;
b2BuoyancyController.prototype.useWorldGravity = true;
b2BuoyancyController.prototype.gravity = null;var b2Body = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Body.prototype.__constructor = function(bd, world) {
  this.m_flags = 0;
  if(bd.bullet) {
    this.m_flags |= b2Body.e_bulletFlag
  }
  if(bd.fixedRotation) {
    this.m_flags |= b2Body.e_fixedRotationFlag
  }
  if(bd.allowSleep) {
    this.m_flags |= b2Body.e_allowSleepFlag
  }
  if(bd.awake) {
    this.m_flags |= b2Body.e_awakeFlag
  }
  if(bd.active) {
    this.m_flags |= b2Body.e_activeFlag
  }
  this.m_world = world;
  this.m_xf.position.SetV(bd.position);
  this.m_xf.R.Set(bd.angle);
  this.m_sweep.localCenter.SetZero();
  this.m_sweep.t0 = 1;
  this.m_sweep.a0 = this.m_sweep.a = bd.angle;
  var tMat = this.m_xf.R;
  var tVec = this.m_sweep.localCenter;
  this.m_sweep.c.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
  this.m_sweep.c.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
  this.m_sweep.c.x += this.m_xf.position.x;
  this.m_sweep.c.y += this.m_xf.position.y;
  this.m_sweep.c0.SetV(this.m_sweep.c);
  this.m_jointList = null;
  this.m_controllerList = null;
  this.m_contactList = null;
  this.m_controllerCount = 0;
  this.m_prev = null;
  this.m_next = null;
  this.m_linearVelocity.SetV(bd.linearVelocity);
  this.m_angularVelocity = bd.angularVelocity;
  this.m_linearDamping = bd.linearDamping;
  this.m_angularDamping = bd.angularDamping;
  this.m_force.Set(0, 0);
  this.m_torque = 0;
  this.m_sleepTime = 0;
  this.m_type = bd.type;
  if(this.m_type == b2Body.b2_dynamicBody) {
    this.m_mass = 1;
    this.m_invMass = 1
  }else {
    this.m_mass = 0;
    this.m_invMass = 0
  }
  this.m_I = 0;
  this.m_invI = 0;
  this.m_inertiaScale = bd.inertiaScale;
  this.m_userData = bd.userData;
  this.m_fixtureList = null;
  this.m_fixtureCount = 0
};
b2Body.prototype.__varz = function() {
  this.m_xf = new b2Transform;
  this.m_sweep = new b2Sweep;
  this.m_linearVelocity = new b2Vec2;
  this.m_force = new b2Vec2
};
b2Body.b2_staticBody = 0;
b2Body.b2_kinematicBody = 1;
b2Body.b2_dynamicBody = 2;
b2Body.s_xf1 = new b2Transform;
b2Body.e_islandFlag = 1;
b2Body.e_awakeFlag = 2;
b2Body.e_allowSleepFlag = 4;
b2Body.e_bulletFlag = 8;
b2Body.e_fixedRotationFlag = 16;
b2Body.e_activeFlag = 32;
b2Body.prototype.connectEdges = function(s1, s2, angle1) {
  var angle2 = Math.atan2(s2.GetDirectionVector().y, s2.GetDirectionVector().x);
  var coreOffset = Math.tan((angle2 - angle1) * 0.5);
  var core = b2Math.MulFV(coreOffset, s2.GetDirectionVector());
  core = b2Math.SubtractVV(core, s2.GetNormalVector());
  core = b2Math.MulFV(b2Settings.b2_toiSlop, core);
  core = b2Math.AddVV(core, s2.GetVertex1());
  var cornerDir = b2Math.AddVV(s1.GetDirectionVector(), s2.GetDirectionVector());
  cornerDir.Normalize();
  var convex = b2Math.Dot(s1.GetDirectionVector(), s2.GetNormalVector()) > 0;
  s1.SetNextEdge(s2, core, cornerDir, convex);
  s2.SetPrevEdge(s1, core, cornerDir, convex);
  return angle2
};
b2Body.prototype.SynchronizeFixtures = function() {
  var xf1 = b2Body.s_xf1;
  xf1.R.Set(this.m_sweep.a0);
  var tMat = xf1.R;
  var tVec = this.m_sweep.localCenter;
  xf1.position.x = this.m_sweep.c0.x - (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  xf1.position.y = this.m_sweep.c0.y - (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  var f;
  var broadPhase = this.m_world.m_contactManager.m_broadPhase;
  for(f = this.m_fixtureList;f;f = f.m_next) {
    f.Synchronize(broadPhase, xf1, this.m_xf)
  }
};
b2Body.prototype.SynchronizeTransform = function() {
  this.m_xf.R.Set(this.m_sweep.a);
  var tMat = this.m_xf.R;
  var tVec = this.m_sweep.localCenter;
  this.m_xf.position.x = this.m_sweep.c.x - (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  this.m_xf.position.y = this.m_sweep.c.y - (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y)
};
b2Body.prototype.ShouldCollide = function(other) {
  if(this.m_type != b2Body.b2_dynamicBody && other.m_type != b2Body.b2_dynamicBody) {
    return false
  }
  for(var jn = this.m_jointList;jn;jn = jn.next) {
    if(jn.other == other) {
      if(jn.joint.m_collideConnected == false) {
        return false
      }
    }
  }
  return true
};
b2Body.prototype.Advance = function(t) {
  this.m_sweep.Advance(t);
  this.m_sweep.c.SetV(this.m_sweep.c0);
  this.m_sweep.a = this.m_sweep.a0;
  this.SynchronizeTransform()
};
b2Body.prototype.CreateFixture = function(def) {
  if(this.m_world.IsLocked() == true) {
    return null
  }
  var fixture = new b2Fixture;
  fixture.Create(this, this.m_xf, def);
  if(this.m_flags & b2Body.e_activeFlag) {
    var broadPhase = this.m_world.m_contactManager.m_broadPhase;
    fixture.CreateProxy(broadPhase, this.m_xf)
  }
  fixture.m_next = this.m_fixtureList;
  this.m_fixtureList = fixture;
  ++this.m_fixtureCount;
  fixture.m_body = this;
  if(fixture.m_density > 0) {
    this.ResetMassData()
  }
  this.m_world.m_flags |= b2World.e_newFixture;
  return fixture
};
b2Body.prototype.CreateFixture2 = function(shape, density) {
  var def = new b2FixtureDef;
  def.shape = shape;
  def.density = density;
  return this.CreateFixture(def)
};
b2Body.prototype.DestroyFixture = function(fixture) {
  if(this.m_world.IsLocked() == true) {
    return
  }
  var node = this.m_fixtureList;
  var ppF = null;
  var found = false;
  while(node != null) {
    if(node == fixture) {
      if(ppF) {
        ppF.m_next = fixture.m_next
      }else {
        this.m_fixtureList = fixture.m_next
      }
      found = true;
      break
    }
    ppF = node;
    node = node.m_next
  }
  var edge = this.m_contactList;
  while(edge) {
    var c = edge.contact;
    edge = edge.next;
    var fixtureA = c.GetFixtureA();
    var fixtureB = c.GetFixtureB();
    if(fixture == fixtureA || fixture == fixtureB) {
      this.m_world.m_contactManager.Destroy(c)
    }
  }
  if(this.m_flags & b2Body.e_activeFlag) {
    var broadPhase = this.m_world.m_contactManager.m_broadPhase;
    fixture.DestroyProxy(broadPhase)
  }else {
  }
  fixture.Destroy();
  fixture.m_body = null;
  fixture.m_next = null;
  --this.m_fixtureCount;
  this.ResetMassData()
};
b2Body.prototype.SetPositionAndAngle = function(position, angle) {
  var f;
  if(this.m_world.IsLocked() == true) {
    return
  }
  this.m_xf.R.Set(angle);
  this.m_xf.position.SetV(position);
  var tMat = this.m_xf.R;
  var tVec = this.m_sweep.localCenter;
  this.m_sweep.c.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
  this.m_sweep.c.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
  this.m_sweep.c.x += this.m_xf.position.x;
  this.m_sweep.c.y += this.m_xf.position.y;
  this.m_sweep.c0.SetV(this.m_sweep.c);
  this.m_sweep.a0 = this.m_sweep.a = angle;
  var broadPhase = this.m_world.m_contactManager.m_broadPhase;
  for(f = this.m_fixtureList;f;f = f.m_next) {
    f.Synchronize(broadPhase, this.m_xf, this.m_xf)
  }
  this.m_world.m_contactManager.FindNewContacts()
};
b2Body.prototype.SetTransform = function(xf) {
  this.SetPositionAndAngle(xf.position, xf.GetAngle())
};
b2Body.prototype.GetTransform = function() {
  return this.m_xf
};
b2Body.prototype.GetPosition = function() {
  return this.m_xf.position
};
b2Body.prototype.SetPosition = function(position) {
  this.SetPositionAndAngle(position, this.GetAngle())
};
b2Body.prototype.GetAngle = function() {
  return this.m_sweep.a
};
b2Body.prototype.SetAngle = function(angle) {
  this.SetPositionAndAngle(this.GetPosition(), angle)
};
b2Body.prototype.GetWorldCenter = function() {
  return this.m_sweep.c
};
b2Body.prototype.GetLocalCenter = function() {
  return this.m_sweep.localCenter
};
b2Body.prototype.SetLinearVelocity = function(v) {
  if(this.m_type == b2Body.b2_staticBody) {
    return
  }
  this.m_linearVelocity.SetV(v)
};
b2Body.prototype.GetLinearVelocity = function() {
  return this.m_linearVelocity
};
b2Body.prototype.SetAngularVelocity = function(omega) {
  if(this.m_type == b2Body.b2_staticBody) {
    return
  }
  this.m_angularVelocity = omega
};
b2Body.prototype.GetAngularVelocity = function() {
  return this.m_angularVelocity
};
b2Body.prototype.GetDefinition = function() {
  var bd = new b2BodyDef;
  bd.type = this.GetType();
  bd.allowSleep = (this.m_flags & b2Body.e_allowSleepFlag) == b2Body.e_allowSleepFlag;
  bd.angle = this.GetAngle();
  bd.angularDamping = this.m_angularDamping;
  bd.angularVelocity = this.m_angularVelocity;
  bd.fixedRotation = (this.m_flags & b2Body.e_fixedRotationFlag) == b2Body.e_fixedRotationFlag;
  bd.bullet = (this.m_flags & b2Body.e_bulletFlag) == b2Body.e_bulletFlag;
  bd.awake = (this.m_flags & b2Body.e_awakeFlag) == b2Body.e_awakeFlag;
  bd.linearDamping = this.m_linearDamping;
  bd.linearVelocity.SetV(this.GetLinearVelocity());
  bd.position = this.GetPosition();
  bd.userData = this.GetUserData();
  return bd
};
b2Body.prototype.ApplyForce = function(force, point) {
  if(this.m_type != b2Body.b2_dynamicBody) {
    return
  }
  if(this.IsAwake() == false) {
    this.SetAwake(true)
  }
  this.m_force.x += force.x;
  this.m_force.y += force.y;
  this.m_torque += (point.x - this.m_sweep.c.x) * force.y - (point.y - this.m_sweep.c.y) * force.x
};
b2Body.prototype.ApplyTorque = function(torque) {
  if(this.m_type != b2Body.b2_dynamicBody) {
    return
  }
  if(this.IsAwake() == false) {
    this.SetAwake(true)
  }
  this.m_torque += torque
};
b2Body.prototype.ApplyImpulse = function(impulse, point) {
  if(this.m_type != b2Body.b2_dynamicBody) {
    return
  }
  if(this.IsAwake() == false) {
    this.SetAwake(true)
  }
  this.m_linearVelocity.x += this.m_invMass * impulse.x;
  this.m_linearVelocity.y += this.m_invMass * impulse.y;
  this.m_angularVelocity += this.m_invI * ((point.x - this.m_sweep.c.x) * impulse.y - (point.y - this.m_sweep.c.y) * impulse.x)
};
b2Body.prototype.Split = function(callback) {
  var linearVelocity = this.GetLinearVelocity().Copy();
  var angularVelocity = this.GetAngularVelocity();
  var center = this.GetWorldCenter();
  var body1 = this;
  var body2 = this.m_world.CreateBody(this.GetDefinition());
  var prev;
  for(var f = body1.m_fixtureList;f;) {
    if(callback(f)) {
      var next = f.m_next;
      if(prev) {
        prev.m_next = next
      }else {
        body1.m_fixtureList = next
      }
      body1.m_fixtureCount--;
      f.m_next = body2.m_fixtureList;
      body2.m_fixtureList = f;
      body2.m_fixtureCount++;
      f.m_body = body2;
      f = next
    }else {
      prev = f;
      f = f.m_next
    }
  }
  body1.ResetMassData();
  body2.ResetMassData();
  var center1 = body1.GetWorldCenter();
  var center2 = body2.GetWorldCenter();
  var velocity1 = b2Math.AddVV(linearVelocity, b2Math.CrossFV(angularVelocity, b2Math.SubtractVV(center1, center)));
  var velocity2 = b2Math.AddVV(linearVelocity, b2Math.CrossFV(angularVelocity, b2Math.SubtractVV(center2, center)));
  body1.SetLinearVelocity(velocity1);
  body2.SetLinearVelocity(velocity2);
  body1.SetAngularVelocity(angularVelocity);
  body2.SetAngularVelocity(angularVelocity);
  body1.SynchronizeFixtures();
  body2.SynchronizeFixtures();
  return body2
};
b2Body.prototype.Merge = function(other) {
  var f;
  for(f = other.m_fixtureList;f;) {
    var next = f.m_next;
    other.m_fixtureCount--;
    f.m_next = this.m_fixtureList;
    this.m_fixtureList = f;
    this.m_fixtureCount++;
    f.m_body = body2;
    f = next
  }
  body1.m_fixtureCount = 0;
  var body1 = this;
  var body2 = other;
  var center1 = body1.GetWorldCenter();
  var center2 = body2.GetWorldCenter();
  var velocity1 = body1.GetLinearVelocity().Copy();
  var velocity2 = body2.GetLinearVelocity().Copy();
  var angular1 = body1.GetAngularVelocity();
  var angular = body2.GetAngularVelocity();
  body1.ResetMassData();
  this.SynchronizeFixtures()
};
b2Body.prototype.GetMass = function() {
  return this.m_mass
};
b2Body.prototype.GetInertia = function() {
  return this.m_I
};
b2Body.prototype.GetMassData = function(data) {
  data.mass = this.m_mass;
  data.I = this.m_I;
  data.center.SetV(this.m_sweep.localCenter)
};
b2Body.prototype.SetMassData = function(massData) {
  b2Settings.b2Assert(this.m_world.IsLocked() == false);
  if(this.m_world.IsLocked() == true) {
    return
  }
  if(this.m_type != b2Body.b2_dynamicBody) {
    return
  }
  this.m_invMass = 0;
  this.m_I = 0;
  this.m_invI = 0;
  this.m_mass = massData.mass;
  if(this.m_mass <= 0) {
    this.m_mass = 1
  }
  this.m_invMass = 1 / this.m_mass;
  if(massData.I > 0 && (this.m_flags & b2Body.e_fixedRotationFlag) == 0) {
    this.m_I = massData.I - this.m_mass * (massData.center.x * massData.center.x + massData.center.y * massData.center.y);
    this.m_invI = 1 / this.m_I
  }
  var oldCenter = this.m_sweep.c.Copy();
  this.m_sweep.localCenter.SetV(massData.center);
  this.m_sweep.c0.SetV(b2Math.MulX(this.m_xf, this.m_sweep.localCenter));
  this.m_sweep.c.SetV(this.m_sweep.c0);
  this.m_linearVelocity.x += this.m_angularVelocity * -(this.m_sweep.c.y - oldCenter.y);
  this.m_linearVelocity.y += this.m_angularVelocity * +(this.m_sweep.c.x - oldCenter.x)
};
b2Body.prototype.ResetMassData = function() {
  this.m_mass = 0;
  this.m_invMass = 0;
  this.m_I = 0;
  this.m_invI = 0;
  this.m_sweep.localCenter.SetZero();
  if(this.m_type == b2Body.b2_staticBody || this.m_type == b2Body.b2_kinematicBody) {
    return
  }
  var center = b2Vec2.Make(0, 0);
  for(var f = this.m_fixtureList;f;f = f.m_next) {
    if(f.m_density == 0) {
      continue
    }
    var massData = f.GetMassData();
    this.m_mass += massData.mass;
    center.x += massData.center.x * massData.mass;
    center.y += massData.center.y * massData.mass;
    this.m_I += massData.I
  }
  if(this.m_mass > 0) {
    this.m_invMass = 1 / this.m_mass;
    center.x *= this.m_invMass;
    center.y *= this.m_invMass
  }else {
    this.m_mass = 1;
    this.m_invMass = 1
  }
  if(this.m_I > 0 && (this.m_flags & b2Body.e_fixedRotationFlag) == 0) {
    this.m_I -= this.m_mass * (center.x * center.x + center.y * center.y);
    this.m_I *= this.m_inertiaScale;
    b2Settings.b2Assert(this.m_I > 0);
    this.m_invI = 1 / this.m_I
  }else {
    this.m_I = 0;
    this.m_invI = 0
  }
  var oldCenter = this.m_sweep.c.Copy();
  this.m_sweep.localCenter.SetV(center);
  this.m_sweep.c0.SetV(b2Math.MulX(this.m_xf, this.m_sweep.localCenter));
  this.m_sweep.c.SetV(this.m_sweep.c0);
  this.m_linearVelocity.x += this.m_angularVelocity * -(this.m_sweep.c.y - oldCenter.y);
  this.m_linearVelocity.y += this.m_angularVelocity * +(this.m_sweep.c.x - oldCenter.x)
};
b2Body.prototype.GetWorldPoint = function(localPoint) {
  var A = this.m_xf.R;
  var u = new b2Vec2(A.col1.x * localPoint.x + A.col2.x * localPoint.y, A.col1.y * localPoint.x + A.col2.y * localPoint.y);
  u.x += this.m_xf.position.x;
  u.y += this.m_xf.position.y;
  return u
};
b2Body.prototype.GetWorldVector = function(localVector) {
  return b2Math.MulMV(this.m_xf.R, localVector)
};
b2Body.prototype.GetLocalPoint = function(worldPoint) {
  return b2Math.MulXT(this.m_xf, worldPoint)
};
b2Body.prototype.GetLocalVector = function(worldVector) {
  return b2Math.MulTMV(this.m_xf.R, worldVector)
};
b2Body.prototype.GetLinearVelocityFromWorldPoint = function(worldPoint) {
  return new b2Vec2(this.m_linearVelocity.x - this.m_angularVelocity * (worldPoint.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (worldPoint.x - this.m_sweep.c.x))
};
b2Body.prototype.GetLinearVelocityFromLocalPoint = function(localPoint) {
  var A = this.m_xf.R;
  var worldPoint = new b2Vec2(A.col1.x * localPoint.x + A.col2.x * localPoint.y, A.col1.y * localPoint.x + A.col2.y * localPoint.y);
  worldPoint.x += this.m_xf.position.x;
  worldPoint.y += this.m_xf.position.y;
  return new b2Vec2(this.m_linearVelocity.x - this.m_angularVelocity * (worldPoint.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (worldPoint.x - this.m_sweep.c.x))
};
b2Body.prototype.GetLinearDamping = function() {
  return this.m_linearDamping
};
b2Body.prototype.SetLinearDamping = function(linearDamping) {
  this.m_linearDamping = linearDamping
};
b2Body.prototype.GetAngularDamping = function() {
  return this.m_angularDamping
};
b2Body.prototype.SetAngularDamping = function(angularDamping) {
  this.m_angularDamping = angularDamping
};
b2Body.prototype.SetType = function(type) {
  if(this.m_type == type) {
    return
  }
  this.m_type = type;
  this.ResetMassData();
  if(this.m_type == b2Body.b2_staticBody) {
    this.m_linearVelocity.SetZero();
    this.m_angularVelocity = 0
  }
  this.SetAwake(true);
  this.m_force.SetZero();
  this.m_torque = 0;
  for(var ce = this.m_contactList;ce;ce = ce.next) {
    ce.contact.FlagForFiltering()
  }
};
b2Body.prototype.GetType = function() {
  return this.m_type
};
b2Body.prototype.SetBullet = function(flag) {
  if(flag) {
    this.m_flags |= b2Body.e_bulletFlag
  }else {
    this.m_flags &= ~b2Body.e_bulletFlag
  }
};
b2Body.prototype.IsBullet = function() {
  return(this.m_flags & b2Body.e_bulletFlag) == b2Body.e_bulletFlag
};
b2Body.prototype.SetSleepingAllowed = function(flag) {
  if(flag) {
    this.m_flags |= b2Body.e_allowSleepFlag
  }else {
    this.m_flags &= ~b2Body.e_allowSleepFlag;
    this.SetAwake(true)
  }
};
b2Body.prototype.SetAwake = function(flag) {
  if(flag) {
    this.m_flags |= b2Body.e_awakeFlag;
    this.m_sleepTime = 0
  }else {
    this.m_flags &= ~b2Body.e_awakeFlag;
    this.m_sleepTime = 0;
    this.m_linearVelocity.SetZero();
    this.m_angularVelocity = 0;
    this.m_force.SetZero();
    this.m_torque = 0
  }
};
b2Body.prototype.IsAwake = function() {
  return(this.m_flags & b2Body.e_awakeFlag) == b2Body.e_awakeFlag
};
b2Body.prototype.SetFixedRotation = function(fixed) {
  if(fixed) {
    this.m_flags |= b2Body.e_fixedRotationFlag
  }else {
    this.m_flags &= ~b2Body.e_fixedRotationFlag
  }
  this.ResetMassData()
};
b2Body.prototype.IsFixedRotation = function() {
  return(this.m_flags & b2Body.e_fixedRotationFlag) == b2Body.e_fixedRotationFlag
};
b2Body.prototype.SetActive = function(flag) {
  if(flag == this.IsActive()) {
    return
  }
  var broadPhase;
  var f;
  if(flag) {
    this.m_flags |= b2Body.e_activeFlag;
    broadPhase = this.m_world.m_contactManager.m_broadPhase;
    for(f = this.m_fixtureList;f;f = f.m_next) {
      f.CreateProxy(broadPhase, this.m_xf)
    }
  }else {
    this.m_flags &= ~b2Body.e_activeFlag;
    broadPhase = this.m_world.m_contactManager.m_broadPhase;
    for(f = this.m_fixtureList;f;f = f.m_next) {
      f.DestroyProxy(broadPhase)
    }
    var ce = this.m_contactList;
    while(ce) {
      var ce0 = ce;
      ce = ce.next;
      this.m_world.m_contactManager.Destroy(ce0.contact)
    }
    this.m_contactList = null
  }
};
b2Body.prototype.IsActive = function() {
  return(this.m_flags & b2Body.e_activeFlag) == b2Body.e_activeFlag
};
b2Body.prototype.IsSleepingAllowed = function() {
  return(this.m_flags & b2Body.e_allowSleepFlag) == b2Body.e_allowSleepFlag
};
b2Body.prototype.GetFixtureList = function() {
  return this.m_fixtureList
};
b2Body.prototype.GetJointList = function() {
  return this.m_jointList
};
b2Body.prototype.GetControllerList = function() {
  return this.m_controllerList
};
b2Body.prototype.GetContactList = function() {
  return this.m_contactList
};
b2Body.prototype.GetNext = function() {
  return this.m_next
};
b2Body.prototype.GetUserData = function() {
  return this.m_userData
};
b2Body.prototype.SetUserData = function(data) {
  this.m_userData = data
};
b2Body.prototype.GetWorld = function() {
  return this.m_world
};
b2Body.prototype.m_flags = 0;
b2Body.prototype.m_type = 0;
b2Body.prototype.m_islandIndex = 0;
b2Body.prototype.m_xf = new b2Transform;
b2Body.prototype.m_sweep = new b2Sweep;
b2Body.prototype.m_linearVelocity = new b2Vec2;
b2Body.prototype.m_angularVelocity = null;
b2Body.prototype.m_force = new b2Vec2;
b2Body.prototype.m_torque = null;
b2Body.prototype.m_world = null;
b2Body.prototype.m_prev = null;
b2Body.prototype.m_next = null;
b2Body.prototype.m_fixtureList = null;
b2Body.prototype.m_fixtureCount = 0;
b2Body.prototype.m_controllerList = null;
b2Body.prototype.m_controllerCount = 0;
b2Body.prototype.m_jointList = null;
b2Body.prototype.m_contactList = null;
b2Body.prototype.m_mass = null;
b2Body.prototype.m_invMass = null;
b2Body.prototype.m_I = null;
b2Body.prototype.m_invI = null;
b2Body.prototype.m_inertiaScale = null;
b2Body.prototype.m_linearDamping = null;
b2Body.prototype.m_angularDamping = null;
b2Body.prototype.m_sleepTime = null;
b2Body.prototype.m_userData = null;var b2ContactImpulse = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactImpulse.prototype.__constructor = function() {
};
b2ContactImpulse.prototype.__varz = function() {
  this.normalImpulses = new Array(b2Settings.b2_maxManifoldPoints);
  this.tangentImpulses = new Array(b2Settings.b2_maxManifoldPoints)
};
b2ContactImpulse.prototype.normalImpulses = new Array(b2Settings.b2_maxManifoldPoints);
b2ContactImpulse.prototype.tangentImpulses = new Array(b2Settings.b2_maxManifoldPoints);var b2TensorDampingController = function() {
  b2Controller.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2TensorDampingController.prototype, b2Controller.prototype);
b2TensorDampingController.prototype._super = b2Controller.prototype;
b2TensorDampingController.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2TensorDampingController.prototype.__varz = function() {
  this.T = new b2Mat22
};
b2TensorDampingController.prototype.SetAxisAligned = function(xDamping, yDamping) {
  this.T.col1.x = -xDamping;
  this.T.col1.y = 0;
  this.T.col2.x = 0;
  this.T.col2.y = -yDamping;
  if(xDamping > 0 || yDamping > 0) {
    this.maxTimestep = 1 / Math.max(xDamping, yDamping)
  }else {
    this.maxTimestep = 0
  }
};
b2TensorDampingController.prototype.Step = function(step) {
  var timestep = step.dt;
  if(timestep <= Number.MIN_VALUE) {
    return
  }
  if(timestep > this.maxTimestep && this.maxTimestep > 0) {
    timestep = this.maxTimestep
  }
  for(var i = m_bodyList;i;i = i.nextBody) {
    var body = i.body;
    if(!body.IsAwake()) {
      continue
    }
    var damping = body.GetWorldVector(b2Math.MulMV(this.T, body.GetLocalVector(body.GetLinearVelocity())));
    body.SetLinearVelocity(new b2Vec2(body.GetLinearVelocity().x + damping.x * timestep, body.GetLinearVelocity().y + damping.y * timestep))
  }
};
b2TensorDampingController.prototype.T = new b2Mat22;
b2TensorDampingController.prototype.maxTimestep = 0;var b2ManifoldPoint = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ManifoldPoint.prototype.__constructor = function() {
  this.Reset()
};
b2ManifoldPoint.prototype.__varz = function() {
  this.m_localPoint = new b2Vec2;
  this.m_id = new b2ContactID
};
b2ManifoldPoint.prototype.Reset = function() {
  this.m_localPoint.SetZero();
  this.m_normalImpulse = 0;
  this.m_tangentImpulse = 0;
  this.m_id.key = 0
};
b2ManifoldPoint.prototype.Set = function(m) {
  this.m_localPoint.SetV(m.m_localPoint);
  this.m_normalImpulse = m.m_normalImpulse;
  this.m_tangentImpulse = m.m_tangentImpulse;
  this.m_id.Set(m.m_id)
};
b2ManifoldPoint.prototype.m_localPoint = new b2Vec2;
b2ManifoldPoint.prototype.m_normalImpulse = null;
b2ManifoldPoint.prototype.m_tangentImpulse = null;
b2ManifoldPoint.prototype.m_id = new b2ContactID;var b2PolygonShape = function() {
  b2Shape.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2PolygonShape.prototype, b2Shape.prototype);
b2PolygonShape.prototype._super = b2Shape.prototype;
b2PolygonShape.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.m_type = b2Shape.e_polygonShape;
  this.m_centroid = new b2Vec2;
  this.m_vertices = new Array;
  this.m_normals = new Array
};
b2PolygonShape.prototype.__varz = function() {
};
b2PolygonShape.AsArray = function(vertices, vertexCount) {
  var polygonShape = new b2PolygonShape;
  polygonShape.SetAsArray(vertices, vertexCount);
  return polygonShape
};
b2PolygonShape.AsVector = function(vertices, vertexCount) {
  var polygonShape = new b2PolygonShape;
  polygonShape.SetAsVector(vertices, vertexCount);
  return polygonShape
};
b2PolygonShape.AsBox = function(hx, hy) {
  var polygonShape = new b2PolygonShape;
  polygonShape.SetAsBox(hx, hy);
  return polygonShape
};
b2PolygonShape.AsOrientedBox = function(hx, hy, center, angle) {
  var polygonShape = new b2PolygonShape;
  polygonShape.SetAsOrientedBox(hx, hy, center, angle);
  return polygonShape
};
b2PolygonShape.AsEdge = function(v1, v2) {
  var polygonShape = new b2PolygonShape;
  polygonShape.SetAsEdge(v1, v2);
  return polygonShape
};
b2PolygonShape.ComputeCentroid = function(vs, count) {
  var c = new b2Vec2;
  var area = 0;
  var p1X = 0;
  var p1Y = 0;
  var inv3 = 1 / 3;
  for(var i = 0;i < count;++i) {
    var p2 = vs[i];
    var p3 = i + 1 < count ? vs[parseInt(i + 1)] : vs[0];
    var e1X = p2.x - p1X;
    var e1Y = p2.y - p1Y;
    var e2X = p3.x - p1X;
    var e2Y = p3.y - p1Y;
    var D = e1X * e2Y - e1Y * e2X;
    var triangleArea = 0.5 * D;
    area += triangleArea;
    c.x += triangleArea * inv3 * (p1X + p2.x + p3.x);
    c.y += triangleArea * inv3 * (p1Y + p2.y + p3.y)
  }
  c.x *= 1 / area;
  c.y *= 1 / area;
  return c
};
b2PolygonShape.ComputeOBB = function(obb, vs, count) {
  var i = 0;
  var p = new Array(count + 1);
  for(i = 0;i < count;++i) {
    p[i] = vs[i]
  }
  p[count] = p[0];
  var minArea = Number.MAX_VALUE;
  for(i = 1;i <= count;++i) {
    var root = p[parseInt(i - 1)];
    var uxX = p[i].x - root.x;
    var uxY = p[i].y - root.y;
    var length = Math.sqrt(uxX * uxX + uxY * uxY);
    uxX /= length;
    uxY /= length;
    var uyX = -uxY;
    var uyY = uxX;
    var lowerX = Number.MAX_VALUE;
    var lowerY = Number.MAX_VALUE;
    var upperX = -Number.MAX_VALUE;
    var upperY = -Number.MAX_VALUE;
    for(var j = 0;j < count;++j) {
      var dX = p[j].x - root.x;
      var dY = p[j].y - root.y;
      var rX = uxX * dX + uxY * dY;
      var rY = uyX * dX + uyY * dY;
      if(rX < lowerX) {
        lowerX = rX
      }
      if(rY < lowerY) {
        lowerY = rY
      }
      if(rX > upperX) {
        upperX = rX
      }
      if(rY > upperY) {
        upperY = rY
      }
    }
    var area = (upperX - lowerX) * (upperY - lowerY);
    if(area < 0.95 * minArea) {
      minArea = area;
      obb.R.col1.x = uxX;
      obb.R.col1.y = uxY;
      obb.R.col2.x = uyX;
      obb.R.col2.y = uyY;
      var centerX = 0.5 * (lowerX + upperX);
      var centerY = 0.5 * (lowerY + upperY);
      var tMat = obb.R;
      obb.center.x = root.x + (tMat.col1.x * centerX + tMat.col2.x * centerY);
      obb.center.y = root.y + (tMat.col1.y * centerX + tMat.col2.y * centerY);
      obb.extents.x = 0.5 * (upperX - lowerX);
      obb.extents.y = 0.5 * (upperY - lowerY)
    }
  }
};
b2PolygonShape.s_mat = new b2Mat22;
b2PolygonShape.prototype.Validate = function() {
  return false
};
b2PolygonShape.prototype.Reserve = function(count) {
  for(var i = this.m_vertices.length;i < count;i++) {
    this.m_vertices[i] = new b2Vec2;
    this.m_normals[i] = new b2Vec2
  }
};
b2PolygonShape.prototype.Copy = function() {
  var s = new b2PolygonShape;
  s.Set(this);
  return s
};
b2PolygonShape.prototype.Set = function(other) {
  this._super.Set.apply(this, [other]);
  if(isInstanceOf(other, b2PolygonShape)) {
    var other2 = other;
    this.m_centroid.SetV(other2.m_centroid);
    this.m_vertexCount = other2.m_vertexCount;
    this.Reserve(this.m_vertexCount);
    for(var i = 0;i < this.m_vertexCount;i++) {
      this.m_vertices[i].SetV(other2.m_vertices[i]);
      this.m_normals[i].SetV(other2.m_normals[i])
    }
  }
};
b2PolygonShape.prototype.SetAsArray = function(vertices, vertexCount) {
  var v = new Array;
  for(var i = 0, tVec = null;i < vertices.length, tVec = vertices[i];i++) {
    v.push(tVec)
  }
  this.SetAsVector(v, vertexCount)
};
b2PolygonShape.prototype.SetAsVector = function(vertices, vertexCount) {
  if(typeof vertexCount == "undefined") {
    vertexCount = vertices.length
  }
  b2Settings.b2Assert(2 <= vertexCount);
  this.m_vertexCount = vertexCount;
  this.Reserve(vertexCount);
  var i = 0;
  for(i = 0;i < this.m_vertexCount;i++) {
    this.m_vertices[i].SetV(vertices[i])
  }
  for(i = 0;i < this.m_vertexCount;++i) {
    var i1 = i;
    var i2 = i + 1 < this.m_vertexCount ? i + 1 : 0;
    var edge = b2Math.SubtractVV(this.m_vertices[i2], this.m_vertices[i1]);
    b2Settings.b2Assert(edge.LengthSquared() > Number.MIN_VALUE);
    this.m_normals[i].SetV(b2Math.CrossVF(edge, 1));
    this.m_normals[i].Normalize()
  }
  this.m_centroid = b2PolygonShape.ComputeCentroid(this.m_vertices, this.m_vertexCount)
};
b2PolygonShape.prototype.SetAsBox = function(hx, hy) {
  this.m_vertexCount = 4;
  this.Reserve(4);
  this.m_vertices[0].Set(-hx, -hy);
  this.m_vertices[1].Set(hx, -hy);
  this.m_vertices[2].Set(hx, hy);
  this.m_vertices[3].Set(-hx, hy);
  this.m_normals[0].Set(0, -1);
  this.m_normals[1].Set(1, 0);
  this.m_normals[2].Set(0, 1);
  this.m_normals[3].Set(-1, 0);
  this.m_centroid.SetZero()
};
b2PolygonShape.prototype.SetAsOrientedBox = function(hx, hy, center, angle) {
  this.m_vertexCount = 4;
  this.Reserve(4);
  this.m_vertices[0].Set(-hx, -hy);
  this.m_vertices[1].Set(hx, -hy);
  this.m_vertices[2].Set(hx, hy);
  this.m_vertices[3].Set(-hx, hy);
  this.m_normals[0].Set(0, -1);
  this.m_normals[1].Set(1, 0);
  this.m_normals[2].Set(0, 1);
  this.m_normals[3].Set(-1, 0);
  this.m_centroid = center;
  var xf = new b2Transform;
  xf.position = center;
  xf.R.Set(angle);
  for(var i = 0;i < this.m_vertexCount;++i) {
    this.m_vertices[i] = b2Math.MulX(xf, this.m_vertices[i]);
    this.m_normals[i] = b2Math.MulMV(xf.R, this.m_normals[i])
  }
};
b2PolygonShape.prototype.SetAsEdge = function(v1, v2) {
  this.m_vertexCount = 2;
  this.Reserve(2);
  this.m_vertices[0].SetV(v1);
  this.m_vertices[1].SetV(v2);
  this.m_centroid.x = 0.5 * (v1.x + v2.x);
  this.m_centroid.y = 0.5 * (v1.y + v2.y);
  this.m_normals[0] = b2Math.CrossVF(b2Math.SubtractVV(v2, v1), 1);
  this.m_normals[0].Normalize();
  this.m_normals[1].x = -this.m_normals[0].x;
  this.m_normals[1].y = -this.m_normals[0].y
};
b2PolygonShape.prototype.TestPoint = function(xf, p) {
  var tVec;
  var tMat = xf.R;
  var tX = p.x - xf.position.x;
  var tY = p.y - xf.position.y;
  var pLocalX = tX * tMat.col1.x + tY * tMat.col1.y;
  var pLocalY = tX * tMat.col2.x + tY * tMat.col2.y;
  for(var i = 0;i < this.m_vertexCount;++i) {
    tVec = this.m_vertices[i];
    tX = pLocalX - tVec.x;
    tY = pLocalY - tVec.y;
    tVec = this.m_normals[i];
    var dot = tVec.x * tX + tVec.y * tY;
    if(dot > 0) {
      return false
    }
  }
  return true
};
b2PolygonShape.prototype.RayCast = function(output, input, transform) {
  var lower = 0;
  var upper = input.maxFraction;
  var tX;
  var tY;
  var tMat;
  var tVec;
  tX = input.p1.x - transform.position.x;
  tY = input.p1.y - transform.position.y;
  tMat = transform.R;
  var p1X = tX * tMat.col1.x + tY * tMat.col1.y;
  var p1Y = tX * tMat.col2.x + tY * tMat.col2.y;
  tX = input.p2.x - transform.position.x;
  tY = input.p2.y - transform.position.y;
  tMat = transform.R;
  var p2X = tX * tMat.col1.x + tY * tMat.col1.y;
  var p2Y = tX * tMat.col2.x + tY * tMat.col2.y;
  var dX = p2X - p1X;
  var dY = p2Y - p1Y;
  var index = -1;
  for(var i = 0;i < this.m_vertexCount;++i) {
    tVec = this.m_vertices[i];
    tX = tVec.x - p1X;
    tY = tVec.y - p1Y;
    tVec = this.m_normals[i];
    var numerator = tVec.x * tX + tVec.y * tY;
    var denominator = tVec.x * dX + tVec.y * dY;
    if(denominator == 0) {
      if(numerator < 0) {
        return false
      }
    }else {
      if(denominator < 0 && numerator < lower * denominator) {
        lower = numerator / denominator;
        index = i
      }else {
        if(denominator > 0 && numerator < upper * denominator) {
          upper = numerator / denominator
        }
      }
    }
    if(upper < lower - Number.MIN_VALUE) {
      return false
    }
  }
  if(index >= 0) {
    output.fraction = lower;
    tMat = transform.R;
    tVec = this.m_normals[index];
    output.normal.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
    output.normal.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
    return true
  }
  return false
};
b2PolygonShape.prototype.ComputeAABB = function(aabb, xf) {
  var tMat = xf.R;
  var tVec = this.m_vertices[0];
  var lowerX = xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  var lowerY = xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  var upperX = lowerX;
  var upperY = lowerY;
  for(var i = 1;i < this.m_vertexCount;++i) {
    tVec = this.m_vertices[i];
    var vX = xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
    var vY = xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
    lowerX = lowerX < vX ? lowerX : vX;
    lowerY = lowerY < vY ? lowerY : vY;
    upperX = upperX > vX ? upperX : vX;
    upperY = upperY > vY ? upperY : vY
  }
  aabb.lowerBound.x = lowerX - this.m_radius;
  aabb.lowerBound.y = lowerY - this.m_radius;
  aabb.upperBound.x = upperX + this.m_radius;
  aabb.upperBound.y = upperY + this.m_radius
};
b2PolygonShape.prototype.ComputeMass = function(massData, density) {
  if(this.m_vertexCount == 2) {
    massData.center.x = 0.5 * (this.m_vertices[0].x + this.m_vertices[1].x);
    massData.center.y = 0.5 * (this.m_vertices[0].y + this.m_vertices[1].y);
    massData.mass = 0;
    massData.I = 0;
    return
  }
  var centerX = 0;
  var centerY = 0;
  var area = 0;
  var I = 0;
  var p1X = 0;
  var p1Y = 0;
  var k_inv3 = 1 / 3;
  for(var i = 0;i < this.m_vertexCount;++i) {
    var p2 = this.m_vertices[i];
    var p3 = i + 1 < this.m_vertexCount ? this.m_vertices[parseInt(i + 1)] : this.m_vertices[0];
    var e1X = p2.x - p1X;
    var e1Y = p2.y - p1Y;
    var e2X = p3.x - p1X;
    var e2Y = p3.y - p1Y;
    var D = e1X * e2Y - e1Y * e2X;
    var triangleArea = 0.5 * D;
    area += triangleArea;
    centerX += triangleArea * k_inv3 * (p1X + p2.x + p3.x);
    centerY += triangleArea * k_inv3 * (p1Y + p2.y + p3.y);
    var px = p1X;
    var py = p1Y;
    var ex1 = e1X;
    var ey1 = e1Y;
    var ex2 = e2X;
    var ey2 = e2Y;
    var intx2 = k_inv3 * (0.25 * (ex1 * ex1 + ex2 * ex1 + ex2 * ex2) + (px * ex1 + px * ex2)) + 0.5 * px * px;
    var inty2 = k_inv3 * (0.25 * (ey1 * ey1 + ey2 * ey1 + ey2 * ey2) + (py * ey1 + py * ey2)) + 0.5 * py * py;
    I += D * (intx2 + inty2)
  }
  massData.mass = density * area;
  centerX *= 1 / area;
  centerY *= 1 / area;
  massData.center.Set(centerX, centerY);
  massData.I = density * I
};
b2PolygonShape.prototype.ComputeSubmergedArea = function(normal, offset, xf, c) {
  var normalL = b2Math.MulTMV(xf.R, normal);
  var offsetL = offset - b2Math.Dot(normal, xf.position);
  var depths = new Array;
  var diveCount = 0;
  var intoIndex = -1;
  var outoIndex = -1;
  var lastSubmerged = false;
  var i = 0;
  for(i = 0;i < this.m_vertexCount;++i) {
    depths[i] = b2Math.Dot(normalL, this.m_vertices[i]) - offsetL;
    var isSubmerged = depths[i] < -Number.MIN_VALUE;
    if(i > 0) {
      if(isSubmerged) {
        if(!lastSubmerged) {
          intoIndex = i - 1;
          diveCount++
        }
      }else {
        if(lastSubmerged) {
          outoIndex = i - 1;
          diveCount++
        }
      }
    }
    lastSubmerged = isSubmerged
  }
  switch(diveCount) {
    case 0:
      if(lastSubmerged) {
        var md = new b2MassData;
        this.ComputeMass(md, 1);
        c.SetV(b2Math.MulX(xf, md.center));
        return md.mass
      }else {
        return 0
      }
      break;
    case 1:
      if(intoIndex == -1) {
        intoIndex = this.m_vertexCount - 1
      }else {
        outoIndex = this.m_vertexCount - 1
      }
      break
  }
  var intoIndex2 = (intoIndex + 1) % this.m_vertexCount;
  var outoIndex2 = (outoIndex + 1) % this.m_vertexCount;
  var intoLamdda = (0 - depths[intoIndex]) / (depths[intoIndex2] - depths[intoIndex]);
  var outoLamdda = (0 - depths[outoIndex]) / (depths[outoIndex2] - depths[outoIndex]);
  var intoVec = new b2Vec2(this.m_vertices[intoIndex].x * (1 - intoLamdda) + this.m_vertices[intoIndex2].x * intoLamdda, this.m_vertices[intoIndex].y * (1 - intoLamdda) + this.m_vertices[intoIndex2].y * intoLamdda);
  var outoVec = new b2Vec2(this.m_vertices[outoIndex].x * (1 - outoLamdda) + this.m_vertices[outoIndex2].x * outoLamdda, this.m_vertices[outoIndex].y * (1 - outoLamdda) + this.m_vertices[outoIndex2].y * outoLamdda);
  var area = 0;
  var center = new b2Vec2;
  var p2 = this.m_vertices[intoIndex2];
  var p3;
  i = intoIndex2;
  while(i != outoIndex2) {
    i = (i + 1) % this.m_vertexCount;
    if(i == outoIndex2) {
      p3 = outoVec
    }else {
      p3 = this.m_vertices[i]
    }
    var triangleArea = 0.5 * ((p2.x - intoVec.x) * (p3.y - intoVec.y) - (p2.y - intoVec.y) * (p3.x - intoVec.x));
    area += triangleArea;
    center.x += triangleArea * (intoVec.x + p2.x + p3.x) / 3;
    center.y += triangleArea * (intoVec.y + p2.y + p3.y) / 3;
    p2 = p3
  }
  center.Multiply(1 / area);
  c.SetV(b2Math.MulX(xf, center));
  return area
};
b2PolygonShape.prototype.GetVertexCount = function() {
  return this.m_vertexCount
};
b2PolygonShape.prototype.GetVertices = function() {
  return this.m_vertices
};
b2PolygonShape.prototype.GetNormals = function() {
  return this.m_normals
};
b2PolygonShape.prototype.GetSupport = function(d) {
  var bestIndex = 0;
  var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
  for(var i = 1;i < this.m_vertexCount;++i) {
    var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
    if(value > bestValue) {
      bestIndex = i;
      bestValue = value
    }
  }
  return bestIndex
};
b2PolygonShape.prototype.GetSupportVertex = function(d) {
  var bestIndex = 0;
  var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
  for(var i = 1;i < this.m_vertexCount;++i) {
    var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
    if(value > bestValue) {
      bestIndex = i;
      bestValue = value
    }
  }
  return this.m_vertices[bestIndex]
};
b2PolygonShape.prototype.m_centroid = null;
b2PolygonShape.prototype.m_vertices = null;
b2PolygonShape.prototype.m_normals = null;
b2PolygonShape.prototype.m_vertexCount = 0;var b2Fixture = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Fixture.prototype.__constructor = function() {
  this.m_aabb = new b2AABB;
  this.m_userData = null;
  this.m_body = null;
  this.m_next = null;
  this.m_shape = null;
  this.m_density = 0;
  this.m_friction = 0;
  this.m_restitution = 0
};
b2Fixture.prototype.__varz = function() {
  this.m_filter = new b2FilterData
};
b2Fixture.prototype.Create = function(body, xf, def) {
  this.m_userData = def.userData;
  this.m_friction = def.friction;
  this.m_restitution = def.restitution;
  this.m_body = body;
  this.m_next = null;
  this.m_filter = def.filter.Copy();
  this.m_isSensor = def.isSensor;
  this.m_shape = def.shape.Copy();
  this.m_density = def.density
};
b2Fixture.prototype.Destroy = function() {
  this.m_shape = null
};
b2Fixture.prototype.CreateProxy = function(broadPhase, xf) {
  this.m_shape.ComputeAABB(this.m_aabb, xf);
  this.m_proxy = broadPhase.CreateProxy(this.m_aabb, this)
};
b2Fixture.prototype.DestroyProxy = function(broadPhase) {
  if(this.m_proxy == null) {
    return
  }
  broadPhase.DestroyProxy(this.m_proxy);
  this.m_proxy = null
};
b2Fixture.prototype.Synchronize = function(broadPhase, transform1, transform2) {
  if(!this.m_proxy) {
    return
  }
  var aabb1 = new b2AABB;
  var aabb2 = new b2AABB;
  this.m_shape.ComputeAABB(aabb1, transform1);
  this.m_shape.ComputeAABB(aabb2, transform2);
  this.m_aabb.Combine(aabb1, aabb2);
  var displacement = b2Math.SubtractVV(transform2.position, transform1.position);
  broadPhase.MoveProxy(this.m_proxy, this.m_aabb, displacement)
};
b2Fixture.prototype.GetType = function() {
  return this.m_shape.GetType()
};
b2Fixture.prototype.GetShape = function() {
  return this.m_shape
};
b2Fixture.prototype.SetSensor = function(sensor) {
  if(this.m_isSensor == sensor) {
    return
  }
  this.m_isSensor = sensor;
  if(this.m_body == null) {
    return
  }
  var edge = this.m_body.GetContactList();
  while(edge) {
    var contact = edge.contact;
    var fixtureA = contact.GetFixtureA();
    var fixtureB = contact.GetFixtureB();
    if(fixtureA == this || fixtureB == this) {
      contact.SetSensor(fixtureA.IsSensor() || fixtureB.IsSensor())
    }
    edge = edge.next
  }
};
b2Fixture.prototype.IsSensor = function() {
  return this.m_isSensor
};
b2Fixture.prototype.SetFilterData = function(filter) {
  this.m_filter = filter.Copy();
  if(this.m_body) {
    return
  }
  var edge = this.m_body.GetContactList();
  while(edge) {
    var contact = edge.contact;
    var fixtureA = contact.GetFixtureA();
    var fixtureB = contact.GetFixtureB();
    if(fixtureA == this || fixtureB == this) {
      contact.FlagForFiltering()
    }
    edge = edge.next
  }
};
b2Fixture.prototype.GetFilterData = function() {
  return this.m_filter.Copy()
};
b2Fixture.prototype.GetBody = function() {
  return this.m_body
};
b2Fixture.prototype.GetNext = function() {
  return this.m_next
};
b2Fixture.prototype.GetUserData = function() {
  return this.m_userData
};
b2Fixture.prototype.SetUserData = function(data) {
  this.m_userData = data
};
b2Fixture.prototype.TestPoint = function(p) {
  return this.m_shape.TestPoint(this.m_body.GetTransform(), p)
};
b2Fixture.prototype.RayCast = function(output, input) {
  return this.m_shape.RayCast(output, input, this.m_body.GetTransform())
};
b2Fixture.prototype.GetMassData = function(massData) {
  if(massData == null) {
    massData = new b2MassData
  }
  this.m_shape.ComputeMass(massData, this.m_density);
  return massData
};
b2Fixture.prototype.SetDensity = function(density) {
  this.m_density = density
};
b2Fixture.prototype.GetDensity = function() {
  return this.m_density
};
b2Fixture.prototype.GetFriction = function() {
  return this.m_friction
};
b2Fixture.prototype.SetFriction = function(friction) {
  this.m_friction = friction
};
b2Fixture.prototype.GetRestitution = function() {
  return this.m_restitution
};
b2Fixture.prototype.SetRestitution = function(restitution) {
  this.m_restitution = restitution
};
b2Fixture.prototype.GetAABB = function() {
  return this.m_aabb
};
b2Fixture.prototype.m_massData = null;
b2Fixture.prototype.m_aabb = null;
b2Fixture.prototype.m_density = null;
b2Fixture.prototype.m_next = null;
b2Fixture.prototype.m_body = null;
b2Fixture.prototype.m_shape = null;
b2Fixture.prototype.m_friction = null;
b2Fixture.prototype.m_restitution = null;
b2Fixture.prototype.m_proxy = null;
b2Fixture.prototype.m_filter = new b2FilterData;
b2Fixture.prototype.m_isSensor = null;
b2Fixture.prototype.m_userData = null;var b2DynamicTreeNode = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DynamicTreeNode.prototype.__constructor = function() {
};
b2DynamicTreeNode.prototype.__varz = function() {
  this.aabb = new b2AABB
};
b2DynamicTreeNode.prototype.IsLeaf = function() {
  return this.child1 == null
};
b2DynamicTreeNode.prototype.userData = null;
b2DynamicTreeNode.prototype.aabb = new b2AABB;
b2DynamicTreeNode.prototype.parent = null;
b2DynamicTreeNode.prototype.child1 = null;
b2DynamicTreeNode.prototype.child2 = null;var b2BodyDef = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2BodyDef.prototype.__constructor = function() {
  this.userData = null;
  this.position.Set(0, 0);
  this.angle = 0;
  this.linearVelocity.Set(0, 0);
  this.angularVelocity = 0;
  this.linearDamping = 0;
  this.angularDamping = 0;
  this.allowSleep = true;
  this.awake = true;
  this.fixedRotation = false;
  this.bullet = false;
  this.type = b2Body.b2_staticBody;
  this.active = true;
  this.inertiaScale = 1
};
b2BodyDef.prototype.__varz = function() {
  this.position = new b2Vec2;
  this.linearVelocity = new b2Vec2
};
b2BodyDef.prototype.type = 0;
b2BodyDef.prototype.position = new b2Vec2;
b2BodyDef.prototype.angle = null;
b2BodyDef.prototype.linearVelocity = new b2Vec2;
b2BodyDef.prototype.angularVelocity = null;
b2BodyDef.prototype.linearDamping = null;
b2BodyDef.prototype.angularDamping = null;
b2BodyDef.prototype.allowSleep = null;
b2BodyDef.prototype.awake = null;
b2BodyDef.prototype.fixedRotation = null;
b2BodyDef.prototype.bullet = null;
b2BodyDef.prototype.active = null;
b2BodyDef.prototype.userData = null;
b2BodyDef.prototype.inertiaScale = null;var b2DynamicTreeBroadPhase = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DynamicTreeBroadPhase.prototype.__constructor = function() {
};
b2DynamicTreeBroadPhase.prototype.__varz = function() {
  this.m_tree = new b2DynamicTree;
  this.m_moveBuffer = new Array;
  this.m_pairBuffer = new Array
};
b2DynamicTreeBroadPhase.prototype.BufferMove = function(proxy) {
  this.m_moveBuffer[this.m_moveBuffer.length] = proxy
};
b2DynamicTreeBroadPhase.prototype.UnBufferMove = function(proxy) {
  var i = this.m_moveBuffer.indexOf(proxy);
  this.m_moveBuffer.splice(i, 1)
};
b2DynamicTreeBroadPhase.prototype.ComparePairs = function(pair1, pair2) {
  return 0
};
b2DynamicTreeBroadPhase.prototype.CreateProxy = function(aabb, userData) {
  var proxy = this.m_tree.CreateProxy(aabb, userData);
  ++this.m_proxyCount;
  this.BufferMove(proxy);
  return proxy
};
b2DynamicTreeBroadPhase.prototype.DestroyProxy = function(proxy) {
  this.UnBufferMove(proxy);
  --this.m_proxyCount;
  this.m_tree.DestroyProxy(proxy)
};
b2DynamicTreeBroadPhase.prototype.MoveProxy = function(proxy, aabb, displacement) {
  var buffer = this.m_tree.MoveProxy(proxy, aabb, displacement);
  if(buffer) {
    this.BufferMove(proxy)
  }
};
b2DynamicTreeBroadPhase.prototype.TestOverlap = function(proxyA, proxyB) {
  var aabbA = this.m_tree.GetFatAABB(proxyA);
  var aabbB = this.m_tree.GetFatAABB(proxyB);
  return aabbA.TestOverlap(aabbB)
};
b2DynamicTreeBroadPhase.prototype.GetUserData = function(proxy) {
  return this.m_tree.GetUserData(proxy)
};
b2DynamicTreeBroadPhase.prototype.GetFatAABB = function(proxy) {
  return this.m_tree.GetFatAABB(proxy)
};
b2DynamicTreeBroadPhase.prototype.GetProxyCount = function() {
  return this.m_proxyCount
};
b2DynamicTreeBroadPhase.prototype.UpdatePairs = function(callback) {
  this.m_pairCount = 0;
  for(var i = 0, queryProxy = null;i < this.m_moveBuffer.length, queryProxy = this.m_moveBuffer[i];i++) {
    var that = this;
    function QueryCallback(proxy) {
      if(proxy == queryProxy) {
        return true
      }
      if(that.m_pairCount == that.m_pairBuffer.length) {
        that.m_pairBuffer[that.m_pairCount] = new b2DynamicTreePair
      }
      var pair = that.m_pairBuffer[that.m_pairCount];
      pair.proxyA = proxy < queryProxy ? proxy : queryProxy;
      pair.proxyB = proxy >= queryProxy ? proxy : queryProxy;
      ++that.m_pairCount;
      return true
    }
    var fatAABB = this.m_tree.GetFatAABB(queryProxy);
    this.m_tree.Query(QueryCallback, fatAABB)
  }
  this.m_moveBuffer.length = 0;
  for(var i = 0;i < this.m_pairCount;) {
    var primaryPair = this.m_pairBuffer[i];
    var userDataA = this.m_tree.GetUserData(primaryPair.proxyA);
    var userDataB = this.m_tree.GetUserData(primaryPair.proxyB);
    callback(userDataA, userDataB);
    ++i;
    while(i < this.m_pairCount) {
      var pair = this.m_pairBuffer[i];
      if(pair.proxyA != primaryPair.proxyA || pair.proxyB != primaryPair.proxyB) {
        break
      }
      ++i
    }
  }
};
b2DynamicTreeBroadPhase.prototype.Query = function(callback, aabb) {
  this.m_tree.Query(callback, aabb)
};
b2DynamicTreeBroadPhase.prototype.RayCast = function(callback, input) {
  this.m_tree.RayCast(callback, input)
};
b2DynamicTreeBroadPhase.prototype.Validate = function() {
};
b2DynamicTreeBroadPhase.prototype.Rebalance = function(iterations) {
  this.m_tree.Rebalance(iterations)
};
b2DynamicTreeBroadPhase.prototype.m_tree = new b2DynamicTree;
b2DynamicTreeBroadPhase.prototype.m_proxyCount = 0;
b2DynamicTreeBroadPhase.prototype.m_moveBuffer = new Array;
b2DynamicTreeBroadPhase.prototype.m_pairBuffer = new Array;
b2DynamicTreeBroadPhase.prototype.m_pairCount = 0;var b2BroadPhase = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2BroadPhase.prototype.__constructor = function(worldAABB) {
  var i = 0;
  this.m_pairManager.Initialize(this);
  this.m_worldAABB = worldAABB;
  this.m_proxyCount = 0;
  this.m_bounds = new Array;
  for(i = 0;i < 2;i++) {
    this.m_bounds[i] = new Array
  }
  var dX = worldAABB.upperBound.x - worldAABB.lowerBound.x;
  var dY = worldAABB.upperBound.y - worldAABB.lowerBound.y;
  this.m_quantizationFactor.x = b2Settings.USHRT_MAX / dX;
  this.m_quantizationFactor.y = b2Settings.USHRT_MAX / dY;
  this.m_timeStamp = 1;
  this.m_queryResultCount = 0
};
b2BroadPhase.prototype.__varz = function() {
  this.m_pairManager = new b2PairManager;
  this.m_proxyPool = new Array;
  this.m_querySortKeys = new Array;
  this.m_queryResults = new Array;
  this.m_quantizationFactor = new b2Vec2
};
b2BroadPhase.BinarySearch = function(bounds, count, value) {
  var low = 0;
  var high = count - 1;
  while(low <= high) {
    var mid = Math.round((low + high) / 2);
    var bound = bounds[mid];
    if(bound.value > value) {
      high = mid - 1
    }else {
      if(bound.value < value) {
        low = mid + 1
      }else {
        return parseInt(mid)
      }
    }
  }
  return parseInt(low)
};
b2BroadPhase.s_validate = false;
b2BroadPhase.b2_invalid = b2Settings.USHRT_MAX;
b2BroadPhase.b2_nullEdge = b2Settings.USHRT_MAX;
b2BroadPhase.prototype.ComputeBounds = function(lowerValues, upperValues, aabb) {
  var minVertexX = aabb.lowerBound.x;
  var minVertexY = aabb.lowerBound.y;
  minVertexX = b2Math.Min(minVertexX, this.m_worldAABB.upperBound.x);
  minVertexY = b2Math.Min(minVertexY, this.m_worldAABB.upperBound.y);
  minVertexX = b2Math.Max(minVertexX, this.m_worldAABB.lowerBound.x);
  minVertexY = b2Math.Max(minVertexY, this.m_worldAABB.lowerBound.y);
  var maxVertexX = aabb.upperBound.x;
  var maxVertexY = aabb.upperBound.y;
  maxVertexX = b2Math.Min(maxVertexX, this.m_worldAABB.upperBound.x);
  maxVertexY = b2Math.Min(maxVertexY, this.m_worldAABB.upperBound.y);
  maxVertexX = b2Math.Max(maxVertexX, this.m_worldAABB.lowerBound.x);
  maxVertexY = b2Math.Max(maxVertexY, this.m_worldAABB.lowerBound.y);
  lowerValues[0] = parseInt(this.m_quantizationFactor.x * (minVertexX - this.m_worldAABB.lowerBound.x)) & b2Settings.USHRT_MAX - 1;
  upperValues[0] = parseInt(this.m_quantizationFactor.x * (maxVertexX - this.m_worldAABB.lowerBound.x)) % 65535 | 1;
  lowerValues[1] = parseInt(this.m_quantizationFactor.y * (minVertexY - this.m_worldAABB.lowerBound.y)) & b2Settings.USHRT_MAX - 1;
  upperValues[1] = parseInt(this.m_quantizationFactor.y * (maxVertexY - this.m_worldAABB.lowerBound.y)) % 65535 | 1
};
b2BroadPhase.prototype.TestOverlapValidate = function(p1, p2) {
  for(var axis = 0;axis < 2;++axis) {
    var bounds = this.m_bounds[axis];
    var bound1 = bounds[p1.lowerBounds[axis]];
    var bound2 = bounds[p2.upperBounds[axis]];
    if(bound1.value > bound2.value) {
      return false
    }
    bound1 = bounds[p1.upperBounds[axis]];
    bound2 = bounds[p2.lowerBounds[axis]];
    if(bound1.value < bound2.value) {
      return false
    }
  }
  return true
};
b2BroadPhase.prototype.QueryAxis = function(lowerQueryOut, upperQueryOut, lowerValue, upperValue, bounds, boundCount, axis) {
  var lowerQuery = b2BroadPhase.BinarySearch(bounds, boundCount, lowerValue);
  var upperQuery = b2BroadPhase.BinarySearch(bounds, boundCount, upperValue);
  var bound;
  for(var j = lowerQuery;j < upperQuery;++j) {
    bound = bounds[j];
    if(bound.IsLower()) {
      this.IncrementOverlapCount(bound.proxy)
    }
  }
  if(lowerQuery > 0) {
    var i = lowerQuery - 1;
    bound = bounds[i];
    var s = bound.stabbingCount;
    while(s) {
      bound = bounds[i];
      if(bound.IsLower()) {
        var proxy = bound.proxy;
        if(lowerQuery <= proxy.upperBounds[axis]) {
          this.IncrementOverlapCount(bound.proxy);
          --s
        }
      }
      --i
    }
  }
  lowerQueryOut[0] = lowerQuery;
  upperQueryOut[0] = upperQuery
};
b2BroadPhase.prototype.IncrementOverlapCount = function(proxy) {
  if(proxy.timeStamp < this.m_timeStamp) {
    proxy.timeStamp = this.m_timeStamp;
    proxy.overlapCount = 1
  }else {
    proxy.overlapCount = 2;
    this.m_queryResults[this.m_queryResultCount] = proxy;
    ++this.m_queryResultCount
  }
};
b2BroadPhase.prototype.IncrementTimeStamp = function() {
  if(this.m_timeStamp == b2Settings.USHRT_MAX) {
    for(var i = 0;i < this.m_proxyPool.length;++i) {
      this.m_proxyPool[i].timeStamp = 0
    }
    this.m_timeStamp = 1
  }else {
    ++this.m_timeStamp
  }
};
b2BroadPhase.prototype.InRange = function(aabb) {
  var dX;
  var dY;
  var d2X;
  var d2Y;
  dX = aabb.lowerBound.x;
  dY = aabb.lowerBound.y;
  dX -= this.m_worldAABB.upperBound.x;
  dY -= this.m_worldAABB.upperBound.y;
  d2X = this.m_worldAABB.lowerBound.x;
  d2Y = this.m_worldAABB.lowerBound.y;
  d2X -= aabb.upperBound.x;
  d2Y -= aabb.upperBound.y;
  dX = b2Math.Max(dX, d2X);
  dY = b2Math.Max(dY, d2Y);
  return b2Math.Max(dX, dY) < 0
};
b2BroadPhase.prototype.CreateProxy = function(aabb, userData) {
  var index = 0;
  var proxy;
  var i = 0;
  var j = 0;
  if(!this.m_freeProxy) {
    this.m_freeProxy = this.m_proxyPool[this.m_proxyCount] = new b2Proxy;
    this.m_freeProxy.next = null;
    this.m_freeProxy.timeStamp = 0;
    this.m_freeProxy.overlapCount = b2BroadPhase.b2_invalid;
    this.m_freeProxy.userData = null;
    for(i = 0;i < 2;i++) {
      j = this.m_proxyCount * 2;
      this.m_bounds[i][j++] = new b2Bound;
      this.m_bounds[i][j] = new b2Bound
    }
  }
  proxy = this.m_freeProxy;
  this.m_freeProxy = proxy.next;
  proxy.overlapCount = 0;
  proxy.userData = userData;
  var boundCount = 2 * this.m_proxyCount;
  var lowerValues = new Array;
  var upperValues = new Array;
  this.ComputeBounds(lowerValues, upperValues, aabb);
  for(var axis = 0;axis < 2;++axis) {
    var bounds = this.m_bounds[axis];
    var lowerIndex = 0;
    var upperIndex = 0;
    var lowerIndexOut = new Array;
    lowerIndexOut.push(lowerIndex);
    var upperIndexOut = new Array;
    upperIndexOut.push(upperIndex);
    this.QueryAxis(lowerIndexOut, upperIndexOut, lowerValues[axis], upperValues[axis], bounds, boundCount, axis);
    lowerIndex = lowerIndexOut[0];
    upperIndex = upperIndexOut[0];
    bounds.splice(upperIndex, 0, bounds[bounds.length - 1]);
    bounds.length--;
    bounds.splice(lowerIndex, 0, bounds[bounds.length - 1]);
    bounds.length--;
    ++upperIndex;
    var tBound1 = bounds[lowerIndex];
    var tBound2 = bounds[upperIndex];
    tBound1.value = lowerValues[axis];
    tBound1.proxy = proxy;
    tBound2.value = upperValues[axis];
    tBound2.proxy = proxy;
    var tBoundAS3 = bounds[parseInt(lowerIndex - 1)];
    tBound1.stabbingCount = lowerIndex == 0 ? 0 : tBoundAS3.stabbingCount;
    tBoundAS3 = bounds[parseInt(upperIndex - 1)];
    tBound2.stabbingCount = tBoundAS3.stabbingCount;
    for(index = lowerIndex;index < upperIndex;++index) {
      tBoundAS3 = bounds[index];
      tBoundAS3.stabbingCount++
    }
    for(index = lowerIndex;index < boundCount + 2;++index) {
      tBound1 = bounds[index];
      var proxy2 = tBound1.proxy;
      if(tBound1.IsLower()) {
        proxy2.lowerBounds[axis] = index
      }else {
        proxy2.upperBounds[axis] = index
      }
    }
  }
  ++this.m_proxyCount;
  for(i = 0;i < this.m_queryResultCount;++i) {
    this.m_pairManager.AddBufferedPair(proxy, this.m_queryResults[i])
  }
  this.m_queryResultCount = 0;
  this.IncrementTimeStamp();
  return proxy
};
b2BroadPhase.prototype.DestroyProxy = function(proxy_) {
  var proxy = proxy_;
  var tBound1;
  var tBound2;
  var boundCount = 2 * this.m_proxyCount;
  for(var axis = 0;axis < 2;++axis) {
    var bounds = this.m_bounds[axis];
    var lowerIndex = proxy.lowerBounds[axis];
    var upperIndex = proxy.upperBounds[axis];
    tBound1 = bounds[lowerIndex];
    var lowerValue = tBound1.value;
    tBound2 = bounds[upperIndex];
    var upperValue = tBound2.value;
    bounds.splice(upperIndex, 1);
    bounds.splice(lowerIndex, 1);
    bounds.push(tBound1);
    bounds.push(tBound2);
    var tEnd = boundCount - 2;
    for(var index = lowerIndex;index < tEnd;++index) {
      tBound1 = bounds[index];
      var proxy2 = tBound1.proxy;
      if(tBound1.IsLower()) {
        proxy2.lowerBounds[axis] = index
      }else {
        proxy2.upperBounds[axis] = index
      }
    }
    tEnd = upperIndex - 1;
    for(var index2 = lowerIndex;index2 < tEnd;++index2) {
      tBound1 = bounds[index2];
      tBound1.stabbingCount--
    }
    var ignore = new Array;
    this.QueryAxis(ignore, ignore, lowerValue, upperValue, bounds, boundCount - 2, axis)
  }
  for(var i = 0;i < this.m_queryResultCount;++i) {
    this.m_pairManager.RemoveBufferedPair(proxy, this.m_queryResults[i])
  }
  this.m_queryResultCount = 0;
  this.IncrementTimeStamp();
  proxy.userData = null;
  proxy.overlapCount = b2BroadPhase.b2_invalid;
  proxy.lowerBounds[0] = b2BroadPhase.b2_invalid;
  proxy.lowerBounds[1] = b2BroadPhase.b2_invalid;
  proxy.upperBounds[0] = b2BroadPhase.b2_invalid;
  proxy.upperBounds[1] = b2BroadPhase.b2_invalid;
  proxy.next = this.m_freeProxy;
  this.m_freeProxy = proxy;
  --this.m_proxyCount
};
b2BroadPhase.prototype.MoveProxy = function(proxy_, aabb, displacement) {
  var proxy = proxy_;
  var as3arr;
  var as3int = 0;
  var axis = 0;
  var index = 0;
  var bound;
  var prevBound;
  var nextBound;
  var nextProxyId = 0;
  var nextProxy;
  if(proxy == null) {
    return
  }
  if(aabb.IsValid() == false) {
    return
  }
  var boundCount = 2 * this.m_proxyCount;
  var newValues = new b2BoundValues;
  this.ComputeBounds(newValues.lowerValues, newValues.upperValues, aabb);
  var oldValues = new b2BoundValues;
  for(axis = 0;axis < 2;++axis) {
    bound = this.m_bounds[axis][proxy.lowerBounds[axis]];
    oldValues.lowerValues[axis] = bound.value;
    bound = this.m_bounds[axis][proxy.upperBounds[axis]];
    oldValues.upperValues[axis] = bound.value
  }
  for(axis = 0;axis < 2;++axis) {
    var bounds = this.m_bounds[axis];
    var lowerIndex = proxy.lowerBounds[axis];
    var upperIndex = proxy.upperBounds[axis];
    var lowerValue = newValues.lowerValues[axis];
    var upperValue = newValues.upperValues[axis];
    bound = bounds[lowerIndex];
    var deltaLower = lowerValue - bound.value;
    bound.value = lowerValue;
    bound = bounds[upperIndex];
    var deltaUpper = upperValue - bound.value;
    bound.value = upperValue;
    if(deltaLower < 0) {
      index = lowerIndex;
      while(index > 0 && lowerValue < bounds[parseInt(index - 1)].value) {
        bound = bounds[index];
        prevBound = bounds[parseInt(index - 1)];
        var prevProxy = prevBound.proxy;
        prevBound.stabbingCount++;
        if(prevBound.IsUpper() == true) {
          if(this.TestOverlapBound(newValues, prevProxy)) {
            this.m_pairManager.AddBufferedPair(proxy, prevProxy)
          }
          as3arr = prevProxy.upperBounds;
          as3int = as3arr[axis];
          as3int++;
          as3arr[axis] = as3int;
          bound.stabbingCount++
        }else {
          as3arr = prevProxy.lowerBounds;
          as3int = as3arr[axis];
          as3int++;
          as3arr[axis] = as3int;
          bound.stabbingCount--
        }
        as3arr = proxy.lowerBounds;
        as3int = as3arr[axis];
        as3int--;
        as3arr[axis] = as3int;
        bound.Swap(prevBound);
        --index
      }
    }
    if(deltaUpper > 0) {
      index = upperIndex;
      while(index < boundCount - 1 && bounds[parseInt(index + 1)].value <= upperValue) {
        bound = bounds[index];
        nextBound = bounds[parseInt(index + 1)];
        nextProxy = nextBound.proxy;
        nextBound.stabbingCount++;
        if(nextBound.IsLower() == true) {
          if(this.TestOverlapBound(newValues, nextProxy)) {
            this.m_pairManager.AddBufferedPair(proxy, nextProxy)
          }
          as3arr = nextProxy.lowerBounds;
          as3int = as3arr[axis];
          as3int--;
          as3arr[axis] = as3int;
          bound.stabbingCount++
        }else {
          as3arr = nextProxy.upperBounds;
          as3int = as3arr[axis];
          as3int--;
          as3arr[axis] = as3int;
          bound.stabbingCount--
        }
        as3arr = proxy.upperBounds;
        as3int = as3arr[axis];
        as3int++;
        as3arr[axis] = as3int;
        bound.Swap(nextBound);
        index++
      }
    }
    if(deltaLower > 0) {
      index = lowerIndex;
      while(index < boundCount - 1 && bounds[parseInt(index + 1)].value <= lowerValue) {
        bound = bounds[index];
        nextBound = bounds[parseInt(index + 1)];
        nextProxy = nextBound.proxy;
        nextBound.stabbingCount--;
        if(nextBound.IsUpper()) {
          if(this.TestOverlapBound(oldValues, nextProxy)) {
            this.m_pairManager.RemoveBufferedPair(proxy, nextProxy)
          }
          as3arr = nextProxy.upperBounds;
          as3int = as3arr[axis];
          as3int--;
          as3arr[axis] = as3int;
          bound.stabbingCount--
        }else {
          as3arr = nextProxy.lowerBounds;
          as3int = as3arr[axis];
          as3int--;
          as3arr[axis] = as3int;
          bound.stabbingCount++
        }
        as3arr = proxy.lowerBounds;
        as3int = as3arr[axis];
        as3int++;
        as3arr[axis] = as3int;
        bound.Swap(nextBound);
        index++
      }
    }
    if(deltaUpper < 0) {
      index = upperIndex;
      while(index > 0 && upperValue < bounds[parseInt(index - 1)].value) {
        bound = bounds[index];
        prevBound = bounds[parseInt(index - 1)];
        prevProxy = prevBound.proxy;
        prevBound.stabbingCount--;
        if(prevBound.IsLower() == true) {
          if(this.TestOverlapBound(oldValues, prevProxy)) {
            this.m_pairManager.RemoveBufferedPair(proxy, prevProxy)
          }
          as3arr = prevProxy.lowerBounds;
          as3int = as3arr[axis];
          as3int++;
          as3arr[axis] = as3int;
          bound.stabbingCount--
        }else {
          as3arr = prevProxy.upperBounds;
          as3int = as3arr[axis];
          as3int++;
          as3arr[axis] = as3int;
          bound.stabbingCount++
        }
        as3arr = proxy.upperBounds;
        as3int = as3arr[axis];
        as3int--;
        as3arr[axis] = as3int;
        bound.Swap(prevBound);
        index--
      }
    }
  }
};
b2BroadPhase.prototype.UpdatePairs = function(callback) {
  this.m_pairManager.Commit(callback)
};
b2BroadPhase.prototype.TestOverlap = function(proxyA, proxyB) {
  var proxyA_ = proxyA;
  var proxyB_ = proxyB;
  if(proxyA_.lowerBounds[0] > proxyB_.upperBounds[0]) {
    return false
  }
  if(proxyB_.lowerBounds[0] > proxyA_.upperBounds[0]) {
    return false
  }
  if(proxyA_.lowerBounds[1] > proxyB_.upperBounds[1]) {
    return false
  }
  if(proxyB_.lowerBounds[1] > proxyA_.upperBounds[1]) {
    return false
  }
  return true
};
b2BroadPhase.prototype.GetUserData = function(proxy) {
  return proxy.userData
};
b2BroadPhase.prototype.GetFatAABB = function(proxy_) {
  var aabb = new b2AABB;
  var proxy = proxy_;
  aabb.lowerBound.x = this.m_worldAABB.lowerBound.x + this.m_bounds[0][proxy.lowerBounds[0]].value / this.m_quantizationFactor.x;
  aabb.lowerBound.y = this.m_worldAABB.lowerBound.y + this.m_bounds[1][proxy.lowerBounds[1]].value / this.m_quantizationFactor.y;
  aabb.upperBound.x = this.m_worldAABB.lowerBound.x + this.m_bounds[0][proxy.upperBounds[0]].value / this.m_quantizationFactor.x;
  aabb.upperBound.y = this.m_worldAABB.lowerBound.y + this.m_bounds[1][proxy.upperBounds[1]].value / this.m_quantizationFactor.y;
  return aabb
};
b2BroadPhase.prototype.GetProxyCount = function() {
  return this.m_proxyCount
};
b2BroadPhase.prototype.Query = function(callback, aabb) {
  var lowerValues = new Array;
  var upperValues = new Array;
  this.ComputeBounds(lowerValues, upperValues, aabb);
  var lowerIndex = 0;
  var upperIndex = 0;
  var lowerIndexOut = new Array;
  lowerIndexOut.push(lowerIndex);
  var upperIndexOut = new Array;
  upperIndexOut.push(upperIndex);
  this.QueryAxis(lowerIndexOut, upperIndexOut, lowerValues[0], upperValues[0], this.m_bounds[0], 2 * this.m_proxyCount, 0);
  this.QueryAxis(lowerIndexOut, upperIndexOut, lowerValues[1], upperValues[1], this.m_bounds[1], 2 * this.m_proxyCount, 1);
  for(var i = 0;i < this.m_queryResultCount;++i) {
    var proxy = this.m_queryResults[i];
    if(!callback(proxy)) {
      break
    }
  }
  this.m_queryResultCount = 0;
  this.IncrementTimeStamp()
};
b2BroadPhase.prototype.Validate = function() {
  var pair;
  var proxy1;
  var proxy2;
  var overlap;
  for(var axis = 0;axis < 2;++axis) {
    var bounds = this.m_bounds[axis];
    var boundCount = 2 * this.m_proxyCount;
    var stabbingCount = 0;
    for(var i = 0;i < boundCount;++i) {
      var bound = bounds[i];
      if(bound.IsLower() == true) {
        stabbingCount++
      }else {
        stabbingCount--
      }
    }
  }
};
b2BroadPhase.prototype.Rebalance = function(iterations) {
};
b2BroadPhase.prototype.RayCast = function(callback, input) {
  var subInput = new b2RayCastInput;
  subInput.p1.SetV(input.p1);
  subInput.p2.SetV(input.p2);
  subInput.maxFraction = input.maxFraction;
  var dx = (input.p2.x - input.p1.x) * this.m_quantizationFactor.x;
  var dy = (input.p2.y - input.p1.y) * this.m_quantizationFactor.y;
  var sx = dx < -Number.MIN_VALUE ? -1 : dx > Number.MIN_VALUE ? 1 : 0;
  var sy = dy < -Number.MIN_VALUE ? -1 : dy > Number.MIN_VALUE ? 1 : 0;
  var p1x = this.m_quantizationFactor.x * (input.p1.x - this.m_worldAABB.lowerBound.x);
  var p1y = this.m_quantizationFactor.y * (input.p1.y - this.m_worldAABB.lowerBound.y);
  var startValues = new Array;
  var startValues2 = new Array;
  startValues[0] = parseInt(p1x) & b2Settings.USHRT_MAX - 1;
  startValues[1] = parseInt(p1y) & b2Settings.USHRT_MAX - 1;
  startValues2[0] = startValues[0] + 1;
  startValues2[1] = startValues[1] + 1;
  var startIndices = new Array;
  var xIndex = 0;
  var yIndex = 0;
  var proxy;
  var lowerIndex = 0;
  var upperIndex = 0;
  var lowerIndexOut = new Array;
  lowerIndexOut.push(lowerIndex);
  var upperIndexOut = new Array;
  upperIndexOut.push(upperIndex);
  this.QueryAxis(lowerIndexOut, upperIndexOut, startValues[0], startValues2[0], this.m_bounds[0], 2 * this.m_proxyCount, 0);
  if(sx >= 0) {
    xIndex = upperIndexOut[0] - 1
  }else {
    xIndex = lowerIndexOut[0]
  }
  this.QueryAxis(lowerIndexOut, upperIndexOut, startValues[1], startValues2[1], this.m_bounds[1], 2 * this.m_proxyCount, 1);
  if(sy >= 0) {
    yIndex = upperIndexOut[0] - 1
  }else {
    yIndex = lowerIndexOut[0]
  }
  for(var i = 0;i < this.m_queryResultCount;i++) {
    subInput.maxFraction = callback(this.m_queryResults[i], subInput)
  }
  for(;;) {
    var xProgress = 0;
    var yProgress = 0;
    xIndex += sx >= 0 ? 1 : -1;
    if(xIndex < 0 || xIndex >= this.m_proxyCount * 2) {
      break
    }
    if(sx != 0) {
      xProgress = (this.m_bounds[0][xIndex].value - p1x) / dx
    }
    yIndex += sy >= 0 ? 1 : -1;
    if(yIndex < 0 || yIndex >= this.m_proxyCount * 2) {
      break
    }
    if(sy != 0) {
      yProgress = (this.m_bounds[1][yIndex].value - p1y) / dy
    }
    for(;;) {
      if(sy == 0 || sx != 0 && xProgress < yProgress) {
        if(xProgress > subInput.maxFraction) {
          break
        }
        if(sx > 0 ? this.m_bounds[0][xIndex].IsLower() : this.m_bounds[0][xIndex].IsUpper()) {
          proxy = this.m_bounds[0][xIndex].proxy;
          if(sy >= 0) {
            if(proxy.lowerBounds[1] <= yIndex - 1 && proxy.upperBounds[1] >= yIndex) {
              subInput.maxFraction = callback(proxy, subInput)
            }
          }else {
            if(proxy.lowerBounds[1] <= yIndex && proxy.upperBounds[1] >= yIndex + 1) {
              subInput.maxFraction = callback(proxy, subInput)
            }
          }
        }
        if(subInput.maxFraction == 0) {
          break
        }
        if(sx > 0) {
          xIndex++;
          if(xIndex == this.m_proxyCount * 2) {
            break
          }
        }else {
          xIndex--;
          if(xIndex < 0) {
            break
          }
        }
        xProgress = (this.m_bounds[0][xIndex].value - p1x) / dx
      }else {
        if(yProgress > subInput.maxFraction) {
          break
        }
        if(sy > 0 ? this.m_bounds[1][yIndex].IsLower() : this.m_bounds[1][yIndex].IsUpper()) {
          proxy = this.m_bounds[1][yIndex].proxy;
          if(sx >= 0) {
            if(proxy.lowerBounds[0] <= xIndex - 1 && proxy.upperBounds[0] >= xIndex) {
              subInput.maxFraction = callback(proxy, subInput)
            }
          }else {
            if(proxy.lowerBounds[0] <= xIndex && proxy.upperBounds[0] >= xIndex + 1) {
              subInput.maxFraction = callback(proxy, subInput)
            }
          }
        }
        if(subInput.maxFraction == 0) {
          break
        }
        if(sy > 0) {
          yIndex++;
          if(yIndex == this.m_proxyCount * 2) {
            break
          }
        }else {
          yIndex--;
          if(yIndex < 0) {
            break
          }
        }
        yProgress = (this.m_bounds[1][yIndex].value - p1y) / dy
      }
    }
    break
  }
  this.m_queryResultCount = 0;
  this.IncrementTimeStamp();
  return
};
b2BroadPhase.prototype.TestOverlapBound = function(b, p) {
  for(var axis = 0;axis < 2;++axis) {
    var bounds = this.m_bounds[axis];
    var bound = bounds[p.upperBounds[axis]];
    if(b.lowerValues[axis] > bound.value) {
      return false
    }
    bound = bounds[p.lowerBounds[axis]];
    if(b.upperValues[axis] < bound.value) {
      return false
    }
  }
  return true
};
b2BroadPhase.prototype.m_pairManager = new b2PairManager;
b2BroadPhase.prototype.m_proxyPool = new Array;
b2BroadPhase.prototype.m_freeProxy = null;
b2BroadPhase.prototype.m_bounds = null;
b2BroadPhase.prototype.m_querySortKeys = new Array;
b2BroadPhase.prototype.m_queryResults = new Array;
b2BroadPhase.prototype.m_queryResultCount = 0;
b2BroadPhase.prototype.m_worldAABB = null;
b2BroadPhase.prototype.m_quantizationFactor = new b2Vec2;
b2BroadPhase.prototype.m_proxyCount = 0;
b2BroadPhase.prototype.m_timeStamp = 0;var b2Manifold = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Manifold.prototype.__constructor = function() {
  this.m_points = new Array(b2Settings.b2_maxManifoldPoints);
  for(var i = 0;i < b2Settings.b2_maxManifoldPoints;i++) {
    this.m_points[i] = new b2ManifoldPoint
  }
  this.m_localPlaneNormal = new b2Vec2;
  this.m_localPoint = new b2Vec2
};
b2Manifold.prototype.__varz = function() {
};
b2Manifold.e_circles = 1;
b2Manifold.e_faceA = 2;
b2Manifold.e_faceB = 4;
b2Manifold.prototype.Reset = function() {
  for(var i = 0;i < b2Settings.b2_maxManifoldPoints;i++) {
    this.m_points[i].Reset()
  }
  this.m_localPlaneNormal.SetZero();
  this.m_localPoint.SetZero();
  this.m_type = 0;
  this.m_pointCount = 0
};
b2Manifold.prototype.Set = function(m) {
  this.m_pointCount = m.m_pointCount;
  for(var i = 0;i < b2Settings.b2_maxManifoldPoints;i++) {
    this.m_points[i].Set(m.m_points[i])
  }
  this.m_localPlaneNormal.SetV(m.m_localPlaneNormal);
  this.m_localPoint.SetV(m.m_localPoint);
  this.m_type = m.m_type
};
b2Manifold.prototype.Copy = function() {
  var copy = new b2Manifold;
  copy.Set(this);
  return copy
};
b2Manifold.prototype.m_points = null;
b2Manifold.prototype.m_localPlaneNormal = null;
b2Manifold.prototype.m_localPoint = null;
b2Manifold.prototype.m_type = 0;
b2Manifold.prototype.m_pointCount = 0;var b2CircleShape = function() {
  b2Shape.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2CircleShape.prototype, b2Shape.prototype);
b2CircleShape.prototype._super = b2Shape.prototype;
b2CircleShape.prototype.__constructor = function(radius) {
  this._super.__constructor.apply(this, []);
  this.m_type = b2Shape.e_circleShape;
  this.m_radius = radius
};
b2CircleShape.prototype.__varz = function() {
  this.m_p = new b2Vec2
};
b2CircleShape.prototype.Copy = function() {
  var s = new b2CircleShape;
  s.Set(this);
  return s
};
b2CircleShape.prototype.Set = function(other) {
  this._super.Set.apply(this, [other]);
  if(isInstanceOf(other, b2CircleShape)) {
    var other2 = other;
    this.m_p.SetV(other2.m_p)
  }
};
b2CircleShape.prototype.TestPoint = function(transform, p) {
  var tMat = transform.R;
  var dX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
  var dY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
  dX = p.x - dX;
  dY = p.y - dY;
  return dX * dX + dY * dY <= this.m_radius * this.m_radius
};
b2CircleShape.prototype.RayCast = function(output, input, transform) {
  var tMat = transform.R;
  var positionX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
  var positionY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
  var sX = input.p1.x - positionX;
  var sY = input.p1.y - positionY;
  var b = sX * sX + sY * sY - this.m_radius * this.m_radius;
  var rX = input.p2.x - input.p1.x;
  var rY = input.p2.y - input.p1.y;
  var c = sX * rX + sY * rY;
  var rr = rX * rX + rY * rY;
  var sigma = c * c - rr * b;
  if(sigma < 0 || rr < Number.MIN_VALUE) {
    return false
  }
  var a = -(c + Math.sqrt(sigma));
  if(0 <= a && a <= input.maxFraction * rr) {
    a /= rr;
    output.fraction = a;
    output.normal.x = sX + a * rX;
    output.normal.y = sY + a * rY;
    output.normal.Normalize();
    return true
  }
  return false
};
b2CircleShape.prototype.ComputeAABB = function(aabb, transform) {
  var tMat = transform.R;
  var pX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
  var pY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
  aabb.lowerBound.Set(pX - this.m_radius, pY - this.m_radius);
  aabb.upperBound.Set(pX + this.m_radius, pY + this.m_radius)
};
b2CircleShape.prototype.ComputeMass = function(massData, density) {
  massData.mass = density * b2Settings.b2_pi * this.m_radius * this.m_radius;
  massData.center.SetV(this.m_p);
  massData.I = massData.mass * (0.5 * this.m_radius * this.m_radius + (this.m_p.x * this.m_p.x + this.m_p.y * this.m_p.y))
};
b2CircleShape.prototype.ComputeSubmergedArea = function(normal, offset, xf, c) {
  var p = b2Math.MulX(xf, this.m_p);
  var l = -(b2Math.Dot(normal, p) - offset);
  if(l < -this.m_radius + Number.MIN_VALUE) {
    return 0
  }
  if(l > this.m_radius) {
    c.SetV(p);
    return Math.PI * this.m_radius * this.m_radius
  }
  var r2 = this.m_radius * this.m_radius;
  var l2 = l * l;
  var area = r2 * (Math.asin(l / this.m_radius) + Math.PI / 2) + l * Math.sqrt(r2 - l2);
  var com = -2 / 3 * Math.pow(r2 - l2, 1.5) / area;
  c.x = p.x + normal.x * com;
  c.y = p.y + normal.y * com;
  return area
};
b2CircleShape.prototype.GetLocalPosition = function() {
  return this.m_p
};
b2CircleShape.prototype.SetLocalPosition = function(position) {
  this.m_p.SetV(position)
};
b2CircleShape.prototype.GetRadius = function() {
  return this.m_radius
};
b2CircleShape.prototype.SetRadius = function(radius) {
  this.m_radius = radius
};
b2CircleShape.prototype.m_p = new b2Vec2;var b2Joint = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Joint.prototype.__constructor = function(def) {
  b2Settings.b2Assert(def.bodyA != def.bodyB);
  this.m_type = def.type;
  this.m_prev = null;
  this.m_next = null;
  this.m_bodyA = def.bodyA;
  this.m_bodyB = def.bodyB;
  this.m_collideConnected = def.collideConnected;
  this.m_islandFlag = false;
  this.m_userData = def.userData
};
b2Joint.prototype.__varz = function() {
  this.m_edgeA = new b2JointEdge;
  this.m_edgeB = new b2JointEdge;
  this.m_localCenterA = new b2Vec2;
  this.m_localCenterB = new b2Vec2
};
b2Joint.Create = function(def, allocator) {
  var joint = null;
  switch(def.type) {
    case b2Joint.e_distanceJoint:
      joint = new b2DistanceJoint(def);
      break;
    case b2Joint.e_mouseJoint:
      joint = new b2MouseJoint(def);
      break;
    case b2Joint.e_prismaticJoint:
      joint = new b2PrismaticJoint(def);
      break;
    case b2Joint.e_revoluteJoint:
      joint = new b2RevoluteJoint(def);
      break;
    case b2Joint.e_pulleyJoint:
      joint = new b2PulleyJoint(def);
      break;
    case b2Joint.e_gearJoint:
      joint = new b2GearJoint(def);
      break;
    case b2Joint.e_lineJoint:
      joint = new b2LineJoint(def);
      break;
    case b2Joint.e_weldJoint:
      joint = new b2WeldJoint(def);
      break;
    case b2Joint.e_frictionJoint:
      joint = new b2FrictionJoint(def);
      break;
    default:
      break
  }
  return joint
};
b2Joint.Destroy = function(joint, allocator) {
};
b2Joint.e_unknownJoint = 0;
b2Joint.e_revoluteJoint = 1;
b2Joint.e_prismaticJoint = 2;
b2Joint.e_distanceJoint = 3;
b2Joint.e_pulleyJoint = 4;
b2Joint.e_mouseJoint = 5;
b2Joint.e_gearJoint = 6;
b2Joint.e_lineJoint = 7;
b2Joint.e_weldJoint = 8;
b2Joint.e_frictionJoint = 9;
b2Joint.e_inactiveLimit = 0;
b2Joint.e_atLowerLimit = 1;
b2Joint.e_atUpperLimit = 2;
b2Joint.e_equalLimits = 3;
b2Joint.prototype.InitVelocityConstraints = function(step) {
};
b2Joint.prototype.SolveVelocityConstraints = function(step) {
};
b2Joint.prototype.FinalizeVelocityConstraints = function() {
};
b2Joint.prototype.SolvePositionConstraints = function(baumgarte) {
  return false
};
b2Joint.prototype.GetType = function() {
  return this.m_type
};
b2Joint.prototype.GetAnchorA = function() {
  return null
};
b2Joint.prototype.GetAnchorB = function() {
  return null
};
b2Joint.prototype.GetReactionForce = function(inv_dt) {
  return null
};
b2Joint.prototype.GetReactionTorque = function(inv_dt) {
  return 0
};
b2Joint.prototype.GetBodyA = function() {
  return this.m_bodyA
};
b2Joint.prototype.GetBodyB = function() {
  return this.m_bodyB
};
b2Joint.prototype.GetNext = function() {
  return this.m_next
};
b2Joint.prototype.GetUserData = function() {
  return this.m_userData
};
b2Joint.prototype.SetUserData = function(data) {
  this.m_userData = data
};
b2Joint.prototype.IsActive = function() {
  return this.m_bodyA.IsActive() && this.m_bodyB.IsActive()
};
b2Joint.prototype.m_type = 0;
b2Joint.prototype.m_prev = null;
b2Joint.prototype.m_next = null;
b2Joint.prototype.m_edgeA = new b2JointEdge;
b2Joint.prototype.m_edgeB = new b2JointEdge;
b2Joint.prototype.m_bodyA = null;
b2Joint.prototype.m_bodyB = null;
b2Joint.prototype.m_islandFlag = null;
b2Joint.prototype.m_collideConnected = null;
b2Joint.prototype.m_userData = null;
b2Joint.prototype.m_localCenterA = new b2Vec2;
b2Joint.prototype.m_localCenterB = new b2Vec2;
b2Joint.prototype.m_invMassA = null;
b2Joint.prototype.m_invMassB = null;
b2Joint.prototype.m_invIA = null;
b2Joint.prototype.m_invIB = null;var b2LineJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2LineJoint.prototype, b2Joint.prototype);
b2LineJoint.prototype._super = b2Joint.prototype;
b2LineJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  var tMat;
  var tX;
  var tY;
  this.m_localAnchor1.SetV(def.localAnchorA);
  this.m_localAnchor2.SetV(def.localAnchorB);
  this.m_localXAxis1.SetV(def.localAxisA);
  this.m_localYAxis1.x = -this.m_localXAxis1.y;
  this.m_localYAxis1.y = this.m_localXAxis1.x;
  this.m_impulse.SetZero();
  this.m_motorMass = 0;
  this.m_motorImpulse = 0;
  this.m_lowerTranslation = def.lowerTranslation;
  this.m_upperTranslation = def.upperTranslation;
  this.m_maxMotorForce = def.maxMotorForce;
  this.m_motorSpeed = def.motorSpeed;
  this.m_enableLimit = def.enableLimit;
  this.m_enableMotor = def.enableMotor;
  this.m_limitState = b2Joint.e_inactiveLimit;
  this.m_axis.SetZero();
  this.m_perp.SetZero()
};
b2LineJoint.prototype.__varz = function() {
  this.m_localAnchor1 = new b2Vec2;
  this.m_localAnchor2 = new b2Vec2;
  this.m_localXAxis1 = new b2Vec2;
  this.m_localYAxis1 = new b2Vec2;
  this.m_axis = new b2Vec2;
  this.m_perp = new b2Vec2;
  this.m_K = new b2Mat22;
  this.m_impulse = new b2Vec2
};
b2LineJoint.prototype.InitVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  var tX;
  this.m_localCenterA.SetV(bA.GetLocalCenter());
  this.m_localCenterB.SetV(bB.GetLocalCenter());
  var xf1 = bA.GetTransform();
  var xf2 = bB.GetTransform();
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
  var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
  tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
  var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
  var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
  this.m_invMassA = bA.m_invMass;
  this.m_invMassB = bB.m_invMass;
  this.m_invIA = bA.m_invI;
  this.m_invIB = bB.m_invI;
  this.m_axis.SetV(b2Math.MulMV(xf1.R, this.m_localXAxis1));
  this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
  this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
  this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2;
  this.m_motorMass = this.m_motorMass > Number.MIN_VALUE ? 1 / this.m_motorMass : 0;
  this.m_perp.SetV(b2Math.MulMV(xf1.R, this.m_localYAxis1));
  this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
  this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
  var m1 = this.m_invMassA;
  var m2 = this.m_invMassB;
  var i1 = this.m_invIA;
  var i2 = this.m_invIB;
  this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
  this.m_K.col1.y = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
  this.m_K.col2.x = this.m_K.col1.y;
  this.m_K.col2.y = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
  if(this.m_enableLimit) {
    var jointTransition = this.m_axis.x * dX + this.m_axis.y * dY;
    if(b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * b2Settings.b2_linearSlop) {
      this.m_limitState = b2Joint.e_equalLimits
    }else {
      if(jointTransition <= this.m_lowerTranslation) {
        if(this.m_limitState != b2Joint.e_atLowerLimit) {
          this.m_limitState = b2Joint.e_atLowerLimit;
          this.m_impulse.y = 0
        }
      }else {
        if(jointTransition >= this.m_upperTranslation) {
          if(this.m_limitState != b2Joint.e_atUpperLimit) {
            this.m_limitState = b2Joint.e_atUpperLimit;
            this.m_impulse.y = 0
          }
        }else {
          this.m_limitState = b2Joint.e_inactiveLimit;
          this.m_impulse.y = 0
        }
      }
    }
  }else {
    this.m_limitState = b2Joint.e_inactiveLimit
  }
  if(this.m_enableMotor == false) {
    this.m_motorImpulse = 0
  }
  if(step.warmStarting) {
    this.m_impulse.x *= step.dtRatio;
    this.m_impulse.y *= step.dtRatio;
    this.m_motorImpulse *= step.dtRatio;
    var PX = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x;
    var PY = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y;
    var L1 = this.m_impulse.x * this.m_s1 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a1;
    var L2 = this.m_impulse.x * this.m_s2 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a2;
    bA.m_linearVelocity.x -= this.m_invMassA * PX;
    bA.m_linearVelocity.y -= this.m_invMassA * PY;
    bA.m_angularVelocity -= this.m_invIA * L1;
    bB.m_linearVelocity.x += this.m_invMassB * PX;
    bB.m_linearVelocity.y += this.m_invMassB * PY;
    bB.m_angularVelocity += this.m_invIB * L2
  }else {
    this.m_impulse.SetZero();
    this.m_motorImpulse = 0
  }
};
b2LineJoint.prototype.SolveVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var v1 = bA.m_linearVelocity;
  var w1 = bA.m_angularVelocity;
  var v2 = bB.m_linearVelocity;
  var w2 = bB.m_angularVelocity;
  var PX;
  var PY;
  var L1;
  var L2;
  if(this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
    var Cdot = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
    var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);
    var oldImpulse = this.m_motorImpulse;
    var maxImpulse = step.dt * this.m_maxMotorForce;
    this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);
    impulse = this.m_motorImpulse - oldImpulse;
    PX = impulse * this.m_axis.x;
    PY = impulse * this.m_axis.y;
    L1 = impulse * this.m_a1;
    L2 = impulse * this.m_a2;
    v1.x -= this.m_invMassA * PX;
    v1.y -= this.m_invMassA * PY;
    w1 -= this.m_invIA * L1;
    v2.x += this.m_invMassB * PX;
    v2.y += this.m_invMassB * PY;
    w2 += this.m_invIB * L2
  }
  var Cdot1 = this.m_perp.x * (v2.x - v1.x) + this.m_perp.y * (v2.y - v1.y) + this.m_s2 * w2 - this.m_s1 * w1;
  if(this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
    var Cdot2 = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
    var f1 = this.m_impulse.Copy();
    var df = this.m_K.Solve(new b2Vec2, -Cdot1, -Cdot2);
    this.m_impulse.Add(df);
    if(this.m_limitState == b2Joint.e_atLowerLimit) {
      this.m_impulse.y = b2Math.Max(this.m_impulse.y, 0)
    }else {
      if(this.m_limitState == b2Joint.e_atUpperLimit) {
        this.m_impulse.y = b2Math.Min(this.m_impulse.y, 0)
      }
    }
    var b = -Cdot1 - (this.m_impulse.y - f1.y) * this.m_K.col2.x;
    var f2r;
    if(this.m_K.col1.x != 0) {
      f2r = b / this.m_K.col1.x + f1.x
    }else {
      f2r = f1.x
    }
    this.m_impulse.x = f2r;
    df.x = this.m_impulse.x - f1.x;
    df.y = this.m_impulse.y - f1.y;
    PX = df.x * this.m_perp.x + df.y * this.m_axis.x;
    PY = df.x * this.m_perp.y + df.y * this.m_axis.y;
    L1 = df.x * this.m_s1 + df.y * this.m_a1;
    L2 = df.x * this.m_s2 + df.y * this.m_a2;
    v1.x -= this.m_invMassA * PX;
    v1.y -= this.m_invMassA * PY;
    w1 -= this.m_invIA * L1;
    v2.x += this.m_invMassB * PX;
    v2.y += this.m_invMassB * PY;
    w2 += this.m_invIB * L2
  }else {
    var df2;
    if(this.m_K.col1.x != 0) {
      df2 = -Cdot1 / this.m_K.col1.x
    }else {
      df2 = 0
    }
    this.m_impulse.x += df2;
    PX = df2 * this.m_perp.x;
    PY = df2 * this.m_perp.y;
    L1 = df2 * this.m_s1;
    L2 = df2 * this.m_s2;
    v1.x -= this.m_invMassA * PX;
    v1.y -= this.m_invMassA * PY;
    w1 -= this.m_invIA * L1;
    v2.x += this.m_invMassB * PX;
    v2.y += this.m_invMassB * PY;
    w2 += this.m_invIB * L2
  }
  bA.m_linearVelocity.SetV(v1);
  bA.m_angularVelocity = w1;
  bB.m_linearVelocity.SetV(v2);
  bB.m_angularVelocity = w2
};
b2LineJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  var limitC;
  var oldLimitImpulse;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var c1 = bA.m_sweep.c;
  var a1 = bA.m_sweep.a;
  var c2 = bB.m_sweep.c;
  var a2 = bB.m_sweep.a;
  var tMat;
  var tX;
  var m1;
  var m2;
  var i1;
  var i2;
  var linearError = 0;
  var angularError = 0;
  var active = false;
  var C2 = 0;
  var R1 = b2Mat22.FromAngle(a1);
  var R2 = b2Mat22.FromAngle(a2);
  tMat = R1;
  var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
  var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
  tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = R2;
  var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
  var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var dX = c2.x + r2X - c1.x - r1X;
  var dY = c2.y + r2Y - c1.y - r1Y;
  if(this.m_enableLimit) {
    this.m_axis = b2Math.MulMV(R1, this.m_localXAxis1);
    this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
    this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
    var translation = this.m_axis.x * dX + this.m_axis.y * dY;
    if(b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * b2Settings.b2_linearSlop) {
      C2 = b2Math.Clamp(translation, -b2Settings.b2_maxLinearCorrection, b2Settings.b2_maxLinearCorrection);
      linearError = b2Math.Abs(translation);
      active = true
    }else {
      if(translation <= this.m_lowerTranslation) {
        C2 = b2Math.Clamp(translation - this.m_lowerTranslation + b2Settings.b2_linearSlop, -b2Settings.b2_maxLinearCorrection, 0);
        linearError = this.m_lowerTranslation - translation;
        active = true
      }else {
        if(translation >= this.m_upperTranslation) {
          C2 = b2Math.Clamp(translation - this.m_upperTranslation + b2Settings.b2_linearSlop, 0, b2Settings.b2_maxLinearCorrection);
          linearError = translation - this.m_upperTranslation;
          active = true
        }
      }
    }
  }
  this.m_perp = b2Math.MulMV(R1, this.m_localYAxis1);
  this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
  this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
  var impulse = new b2Vec2;
  var C1 = this.m_perp.x * dX + this.m_perp.y * dY;
  linearError = b2Math.Max(linearError, b2Math.Abs(C1));
  angularError = 0;
  if(active) {
    m1 = this.m_invMassA;
    m2 = this.m_invMassB;
    i1 = this.m_invIA;
    i2 = this.m_invIB;
    this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
    this.m_K.col1.y = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
    this.m_K.col2.x = this.m_K.col1.y;
    this.m_K.col2.y = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
    this.m_K.Solve(impulse, -C1, -C2)
  }else {
    m1 = this.m_invMassA;
    m2 = this.m_invMassB;
    i1 = this.m_invIA;
    i2 = this.m_invIB;
    var k11 = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
    var impulse1;
    if(k11 != 0) {
      impulse1 = -C1 / k11
    }else {
      impulse1 = 0
    }
    impulse.x = impulse1;
    impulse.y = 0
  }
  var PX = impulse.x * this.m_perp.x + impulse.y * this.m_axis.x;
  var PY = impulse.x * this.m_perp.y + impulse.y * this.m_axis.y;
  var L1 = impulse.x * this.m_s1 + impulse.y * this.m_a1;
  var L2 = impulse.x * this.m_s2 + impulse.y * this.m_a2;
  c1.x -= this.m_invMassA * PX;
  c1.y -= this.m_invMassA * PY;
  a1 -= this.m_invIA * L1;
  c2.x += this.m_invMassB * PX;
  c2.y += this.m_invMassB * PY;
  a2 += this.m_invIB * L2;
  bA.m_sweep.a = a1;
  bB.m_sweep.a = a2;
  bA.SynchronizeTransform();
  bB.SynchronizeTransform();
  return linearError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop
};
b2LineJoint.prototype.GetAnchorA = function() {
  return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
};
b2LineJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
};
b2LineJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x), inv_dt * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y))
};
b2LineJoint.prototype.GetReactionTorque = function(inv_dt) {
  return inv_dt * this.m_impulse.y
};
b2LineJoint.prototype.GetJointTranslation = function() {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  var p1 = bA.GetWorldPoint(this.m_localAnchor1);
  var p2 = bB.GetWorldPoint(this.m_localAnchor2);
  var dX = p2.x - p1.x;
  var dY = p2.y - p1.y;
  var axis = bA.GetWorldVector(this.m_localXAxis1);
  var translation = axis.x * dX + axis.y * dY;
  return translation
};
b2LineJoint.prototype.GetJointSpeed = function() {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var p1X = bA.m_sweep.c.x + r1X;
  var p1Y = bA.m_sweep.c.y + r1Y;
  var p2X = bB.m_sweep.c.x + r2X;
  var p2Y = bB.m_sweep.c.y + r2Y;
  var dX = p2X - p1X;
  var dY = p2Y - p1Y;
  var axis = bA.GetWorldVector(this.m_localXAxis1);
  var v1 = bA.m_linearVelocity;
  var v2 = bB.m_linearVelocity;
  var w1 = bA.m_angularVelocity;
  var w2 = bB.m_angularVelocity;
  var speed = dX * -w1 * axis.y + dY * w1 * axis.x + (axis.x * (v2.x + -w2 * r2Y - v1.x - -w1 * r1Y) + axis.y * (v2.y + w2 * r2X - v1.y - w1 * r1X));
  return speed
};
b2LineJoint.prototype.IsLimitEnabled = function() {
  return this.m_enableLimit
};
b2LineJoint.prototype.EnableLimit = function(flag) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_enableLimit = flag
};
b2LineJoint.prototype.GetLowerLimit = function() {
  return this.m_lowerTranslation
};
b2LineJoint.prototype.GetUpperLimit = function() {
  return this.m_upperTranslation
};
b2LineJoint.prototype.SetLimits = function(lower, upper) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_lowerTranslation = lower;
  this.m_upperTranslation = upper
};
b2LineJoint.prototype.IsMotorEnabled = function() {
  return this.m_enableMotor
};
b2LineJoint.prototype.EnableMotor = function(flag) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_enableMotor = flag
};
b2LineJoint.prototype.SetMotorSpeed = function(speed) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_motorSpeed = speed
};
b2LineJoint.prototype.GetMotorSpeed = function() {
  return this.m_motorSpeed
};
b2LineJoint.prototype.SetMaxMotorForce = function(force) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_maxMotorForce = force
};
b2LineJoint.prototype.GetMaxMotorForce = function() {
  return this.m_maxMotorForce
};
b2LineJoint.prototype.GetMotorForce = function() {
  return this.m_motorImpulse
};
b2LineJoint.prototype.m_localAnchor1 = new b2Vec2;
b2LineJoint.prototype.m_localAnchor2 = new b2Vec2;
b2LineJoint.prototype.m_localXAxis1 = new b2Vec2;
b2LineJoint.prototype.m_localYAxis1 = new b2Vec2;
b2LineJoint.prototype.m_axis = new b2Vec2;
b2LineJoint.prototype.m_perp = new b2Vec2;
b2LineJoint.prototype.m_s1 = null;
b2LineJoint.prototype.m_s2 = null;
b2LineJoint.prototype.m_a1 = null;
b2LineJoint.prototype.m_a2 = null;
b2LineJoint.prototype.m_K = new b2Mat22;
b2LineJoint.prototype.m_impulse = new b2Vec2;
b2LineJoint.prototype.m_motorMass = null;
b2LineJoint.prototype.m_motorImpulse = null;
b2LineJoint.prototype.m_lowerTranslation = null;
b2LineJoint.prototype.m_upperTranslation = null;
b2LineJoint.prototype.m_maxMotorForce = null;
b2LineJoint.prototype.m_motorSpeed = null;
b2LineJoint.prototype.m_enableLimit = null;
b2LineJoint.prototype.m_enableMotor = null;
b2LineJoint.prototype.m_limitState = 0;var b2ContactSolver = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactSolver.prototype.__constructor = function() {
};
b2ContactSolver.prototype.__varz = function() {
  this.m_step = new b2TimeStep;
  this.m_constraints = new Array
};
b2ContactSolver.s_worldManifold = new b2WorldManifold;
b2ContactSolver.s_psm = new b2PositionSolverManifold;
b2ContactSolver.prototype.Initialize = function(step, contacts, contactCount, allocator) {
  var contact;
  this.m_step.Set(step);
  this.m_allocator = allocator;
  var i = 0;
  var tVec;
  var tMat;
  this.m_constraintCount = contactCount;
  while(this.m_constraints.length < this.m_constraintCount) {
    this.m_constraints[this.m_constraints.length] = new b2ContactConstraint
  }
  for(i = 0;i < contactCount;++i) {
    contact = contacts[i];
    var fixtureA = contact.m_fixtureA;
    var fixtureB = contact.m_fixtureB;
    var shapeA = fixtureA.m_shape;
    var shapeB = fixtureB.m_shape;
    var radiusA = shapeA.m_radius;
    var radiusB = shapeB.m_radius;
    var bodyA = fixtureA.m_body;
    var bodyB = fixtureB.m_body;
    var manifold = contact.GetManifold();
    var friction = b2Settings.b2MixFriction(fixtureA.GetFriction(), fixtureB.GetFriction());
    var restitution = b2Settings.b2MixRestitution(fixtureA.GetRestitution(), fixtureB.GetRestitution());
    var vAX = bodyA.m_linearVelocity.x;
    var vAY = bodyA.m_linearVelocity.y;
    var vBX = bodyB.m_linearVelocity.x;
    var vBY = bodyB.m_linearVelocity.y;
    var wA = bodyA.m_angularVelocity;
    var wB = bodyB.m_angularVelocity;
    b2Settings.b2Assert(manifold.m_pointCount > 0);
    b2ContactSolver.s_worldManifold.Initialize(manifold, bodyA.m_xf, radiusA, bodyB.m_xf, radiusB);
    var normalX = b2ContactSolver.s_worldManifold.m_normal.x;
    var normalY = b2ContactSolver.s_worldManifold.m_normal.y;
    var cc = this.m_constraints[i];
    cc.bodyA = bodyA;
    cc.bodyB = bodyB;
    cc.manifold = manifold;
    cc.normal.x = normalX;
    cc.normal.y = normalY;
    cc.pointCount = manifold.m_pointCount;
    cc.friction = friction;
    cc.restitution = restitution;
    cc.localPlaneNormal.x = manifold.m_localPlaneNormal.x;
    cc.localPlaneNormal.y = manifold.m_localPlaneNormal.y;
    cc.localPoint.x = manifold.m_localPoint.x;
    cc.localPoint.y = manifold.m_localPoint.y;
    cc.radius = radiusA + radiusB;
    cc.type = manifold.m_type;
    for(var k = 0;k < cc.pointCount;++k) {
      var cp = manifold.m_points[k];
      var ccp = cc.points[k];
      ccp.normalImpulse = cp.m_normalImpulse;
      ccp.tangentImpulse = cp.m_tangentImpulse;
      ccp.localPoint.SetV(cp.m_localPoint);
      var rAX = ccp.rA.x = b2ContactSolver.s_worldManifold.m_points[k].x - bodyA.m_sweep.c.x;
      var rAY = ccp.rA.y = b2ContactSolver.s_worldManifold.m_points[k].y - bodyA.m_sweep.c.y;
      var rBX = ccp.rB.x = b2ContactSolver.s_worldManifold.m_points[k].x - bodyB.m_sweep.c.x;
      var rBY = ccp.rB.y = b2ContactSolver.s_worldManifold.m_points[k].y - bodyB.m_sweep.c.y;
      var rnA = rAX * normalY - rAY * normalX;
      var rnB = rBX * normalY - rBY * normalX;
      rnA *= rnA;
      rnB *= rnB;
      var kNormal = bodyA.m_invMass + bodyB.m_invMass + bodyA.m_invI * rnA + bodyB.m_invI * rnB;
      ccp.normalMass = 1 / kNormal;
      var kEqualized = bodyA.m_mass * bodyA.m_invMass + bodyB.m_mass * bodyB.m_invMass;
      kEqualized += bodyA.m_mass * bodyA.m_invI * rnA + bodyB.m_mass * bodyB.m_invI * rnB;
      ccp.equalizedMass = 1 / kEqualized;
      var tangentX = normalY;
      var tangentY = -normalX;
      var rtA = rAX * tangentY - rAY * tangentX;
      var rtB = rBX * tangentY - rBY * tangentX;
      rtA *= rtA;
      rtB *= rtB;
      var kTangent = bodyA.m_invMass + bodyB.m_invMass + bodyA.m_invI * rtA + bodyB.m_invI * rtB;
      ccp.tangentMass = 1 / kTangent;
      ccp.velocityBias = 0;
      var tX = vBX + -wB * rBY - vAX - -wA * rAY;
      var tY = vBY + wB * rBX - vAY - wA * rAX;
      var vRel = cc.normal.x * tX + cc.normal.y * tY;
      if(vRel < -b2Settings.b2_velocityThreshold) {
        ccp.velocityBias += -cc.restitution * vRel
      }
    }
    if(cc.pointCount == 2) {
      var ccp1 = cc.points[0];
      var ccp2 = cc.points[1];
      var invMassA = bodyA.m_invMass;
      var invIA = bodyA.m_invI;
      var invMassB = bodyB.m_invMass;
      var invIB = bodyB.m_invI;
      var rn1A = ccp1.rA.x * normalY - ccp1.rA.y * normalX;
      var rn1B = ccp1.rB.x * normalY - ccp1.rB.y * normalX;
      var rn2A = ccp2.rA.x * normalY - ccp2.rA.y * normalX;
      var rn2B = ccp2.rB.x * normalY - ccp2.rB.y * normalX;
      var k11 = invMassA + invMassB + invIA * rn1A * rn1A + invIB * rn1B * rn1B;
      var k22 = invMassA + invMassB + invIA * rn2A * rn2A + invIB * rn2B * rn2B;
      var k12 = invMassA + invMassB + invIA * rn1A * rn2A + invIB * rn1B * rn2B;
      var k_maxConditionNumber = 100;
      if(k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12)) {
        cc.K.col1.Set(k11, k12);
        cc.K.col2.Set(k12, k22);
        cc.K.GetInverse(cc.normalMass)
      }else {
        cc.pointCount = 1
      }
    }
  }
};
b2ContactSolver.prototype.InitVelocityConstraints = function(step) {
  var tVec;
  var tVec2;
  var tMat;
  for(var i = 0;i < this.m_constraintCount;++i) {
    var c = this.m_constraints[i];
    var bodyA = c.bodyA;
    var bodyB = c.bodyB;
    var invMassA = bodyA.m_invMass;
    var invIA = bodyA.m_invI;
    var invMassB = bodyB.m_invMass;
    var invIB = bodyB.m_invI;
    var normalX = c.normal.x;
    var normalY = c.normal.y;
    var tangentX = normalY;
    var tangentY = -normalX;
    var tX;
    var j = 0;
    var tCount = 0;
    if(step.warmStarting) {
      tCount = c.pointCount;
      for(j = 0;j < tCount;++j) {
        var ccp = c.points[j];
        ccp.normalImpulse *= step.dtRatio;
        ccp.tangentImpulse *= step.dtRatio;
        var PX = ccp.normalImpulse * normalX + ccp.tangentImpulse * tangentX;
        var PY = ccp.normalImpulse * normalY + ccp.tangentImpulse * tangentY;
        bodyA.m_angularVelocity -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
        bodyA.m_linearVelocity.x -= invMassA * PX;
        bodyA.m_linearVelocity.y -= invMassA * PY;
        bodyB.m_angularVelocity += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
        bodyB.m_linearVelocity.x += invMassB * PX;
        bodyB.m_linearVelocity.y += invMassB * PY
      }
    }else {
      tCount = c.pointCount;
      for(j = 0;j < tCount;++j) {
        var ccp2 = c.points[j];
        ccp2.normalImpulse = 0;
        ccp2.tangentImpulse = 0
      }
    }
  }
};
b2ContactSolver.prototype.SolveVelocityConstraints = function() {
  var j = 0;
  var ccp;
  var rAX;
  var rAY;
  var rBX;
  var rBY;
  var dvX;
  var dvY;
  var vn;
  var vt;
  var lambda;
  var maxFriction;
  var newImpulse;
  var PX;
  var PY;
  var dX;
  var dY;
  var P1X;
  var P1Y;
  var P2X;
  var P2Y;
  var tMat;
  var tVec;
  for(var i = 0;i < this.m_constraintCount;++i) {
    var c = this.m_constraints[i];
    var bodyA = c.bodyA;
    var bodyB = c.bodyB;
    var wA = bodyA.m_angularVelocity;
    var wB = bodyB.m_angularVelocity;
    var vA = bodyA.m_linearVelocity;
    var vB = bodyB.m_linearVelocity;
    var invMassA = bodyA.m_invMass;
    var invIA = bodyA.m_invI;
    var invMassB = bodyB.m_invMass;
    var invIB = bodyB.m_invI;
    var normalX = c.normal.x;
    var normalY = c.normal.y;
    var tangentX = normalY;
    var tangentY = -normalX;
    var friction = c.friction;
    var tX;
    for(j = 0;j < c.pointCount;j++) {
      ccp = c.points[j];
      dvX = vB.x - wB * ccp.rB.y - vA.x + wA * ccp.rA.y;
      dvY = vB.y + wB * ccp.rB.x - vA.y - wA * ccp.rA.x;
      vt = dvX * tangentX + dvY * tangentY;
      lambda = ccp.tangentMass * -vt;
      maxFriction = friction * ccp.normalImpulse;
      newImpulse = b2Math.Clamp(ccp.tangentImpulse + lambda, -maxFriction, maxFriction);
      lambda = newImpulse - ccp.tangentImpulse;
      PX = lambda * tangentX;
      PY = lambda * tangentY;
      vA.x -= invMassA * PX;
      vA.y -= invMassA * PY;
      wA -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
      vB.x += invMassB * PX;
      vB.y += invMassB * PY;
      wB += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
      ccp.tangentImpulse = newImpulse
    }
    var tCount = c.pointCount;
    if(c.pointCount == 1) {
      ccp = c.points[0];
      dvX = vB.x + -wB * ccp.rB.y - vA.x - -wA * ccp.rA.y;
      dvY = vB.y + wB * ccp.rB.x - vA.y - wA * ccp.rA.x;
      vn = dvX * normalX + dvY * normalY;
      lambda = -ccp.normalMass * (vn - ccp.velocityBias);
      newImpulse = ccp.normalImpulse + lambda;
      newImpulse = newImpulse > 0 ? newImpulse : 0;
      lambda = newImpulse - ccp.normalImpulse;
      PX = lambda * normalX;
      PY = lambda * normalY;
      vA.x -= invMassA * PX;
      vA.y -= invMassA * PY;
      wA -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
      vB.x += invMassB * PX;
      vB.y += invMassB * PY;
      wB += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
      ccp.normalImpulse = newImpulse
    }else {
      var cp1 = c.points[0];
      var cp2 = c.points[1];
      var aX = cp1.normalImpulse;
      var aY = cp2.normalImpulse;
      var dv1X = vB.x - wB * cp1.rB.y - vA.x + wA * cp1.rA.y;
      var dv1Y = vB.y + wB * cp1.rB.x - vA.y - wA * cp1.rA.x;
      var dv2X = vB.x - wB * cp2.rB.y - vA.x + wA * cp2.rA.y;
      var dv2Y = vB.y + wB * cp2.rB.x - vA.y - wA * cp2.rA.x;
      var vn1 = dv1X * normalX + dv1Y * normalY;
      var vn2 = dv2X * normalX + dv2Y * normalY;
      var bX = vn1 - cp1.velocityBias;
      var bY = vn2 - cp2.velocityBias;
      tMat = c.K;
      bX -= tMat.col1.x * aX + tMat.col2.x * aY;
      bY -= tMat.col1.y * aX + tMat.col2.y * aY;
      var k_errorTol = 0.0010;
      for(;;) {
        tMat = c.normalMass;
        var xX = -(tMat.col1.x * bX + tMat.col2.x * bY);
        var xY = -(tMat.col1.y * bX + tMat.col2.y * bY);
        if(xX >= 0 && xY >= 0) {
          dX = xX - aX;
          dY = xY - aY;
          P1X = dX * normalX;
          P1Y = dX * normalY;
          P2X = dY * normalX;
          P2Y = dY * normalY;
          vA.x -= invMassA * (P1X + P2X);
          vA.y -= invMassA * (P1Y + P2Y);
          wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
          vB.x += invMassB * (P1X + P2X);
          vB.y += invMassB * (P1Y + P2Y);
          wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
          cp1.normalImpulse = xX;
          cp2.normalImpulse = xY;
          break
        }
        xX = -cp1.normalMass * bX;
        xY = 0;
        vn1 = 0;
        vn2 = c.K.col1.y * xX + bY;
        if(xX >= 0 && vn2 >= 0) {
          dX = xX - aX;
          dY = xY - aY;
          P1X = dX * normalX;
          P1Y = dX * normalY;
          P2X = dY * normalX;
          P2Y = dY * normalY;
          vA.x -= invMassA * (P1X + P2X);
          vA.y -= invMassA * (P1Y + P2Y);
          wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
          vB.x += invMassB * (P1X + P2X);
          vB.y += invMassB * (P1Y + P2Y);
          wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
          cp1.normalImpulse = xX;
          cp2.normalImpulse = xY;
          break
        }
        xX = 0;
        xY = -cp2.normalMass * bY;
        vn1 = c.K.col2.x * xY + bX;
        vn2 = 0;
        if(xY >= 0 && vn1 >= 0) {
          dX = xX - aX;
          dY = xY - aY;
          P1X = dX * normalX;
          P1Y = dX * normalY;
          P2X = dY * normalX;
          P2Y = dY * normalY;
          vA.x -= invMassA * (P1X + P2X);
          vA.y -= invMassA * (P1Y + P2Y);
          wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
          vB.x += invMassB * (P1X + P2X);
          vB.y += invMassB * (P1Y + P2Y);
          wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
          cp1.normalImpulse = xX;
          cp2.normalImpulse = xY;
          break
        }
        xX = 0;
        xY = 0;
        vn1 = bX;
        vn2 = bY;
        if(vn1 >= 0 && vn2 >= 0) {
          dX = xX - aX;
          dY = xY - aY;
          P1X = dX * normalX;
          P1Y = dX * normalY;
          P2X = dY * normalX;
          P2Y = dY * normalY;
          vA.x -= invMassA * (P1X + P2X);
          vA.y -= invMassA * (P1Y + P2Y);
          wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
          vB.x += invMassB * (P1X + P2X);
          vB.y += invMassB * (P1Y + P2Y);
          wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
          cp1.normalImpulse = xX;
          cp2.normalImpulse = xY;
          break
        }
        break
      }
    }
    bodyA.m_angularVelocity = wA;
    bodyB.m_angularVelocity = wB
  }
};
b2ContactSolver.prototype.FinalizeVelocityConstraints = function() {
  for(var i = 0;i < this.m_constraintCount;++i) {
    var c = this.m_constraints[i];
    var m = c.manifold;
    for(var j = 0;j < c.pointCount;++j) {
      var point1 = m.m_points[j];
      var point2 = c.points[j];
      point1.m_normalImpulse = point2.normalImpulse;
      point1.m_tangentImpulse = point2.tangentImpulse
    }
  }
};
b2ContactSolver.prototype.SolvePositionConstraints = function(baumgarte) {
  var minSeparation = 0;
  for(var i = 0;i < this.m_constraintCount;i++) {
    var c = this.m_constraints[i];
    var bodyA = c.bodyA;
    var bodyB = c.bodyB;
    var invMassA = bodyA.m_mass * bodyA.m_invMass;
    var invIA = bodyA.m_mass * bodyA.m_invI;
    var invMassB = bodyB.m_mass * bodyB.m_invMass;
    var invIB = bodyB.m_mass * bodyB.m_invI;
    b2ContactSolver.s_psm.Initialize(c);
    var normal = b2ContactSolver.s_psm.m_normal;
    for(var j = 0;j < c.pointCount;j++) {
      var ccp = c.points[j];
      var point = b2ContactSolver.s_psm.m_points[j];
      var separation = b2ContactSolver.s_psm.m_separations[j];
      var rAX = point.x - bodyA.m_sweep.c.x;
      var rAY = point.y - bodyA.m_sweep.c.y;
      var rBX = point.x - bodyB.m_sweep.c.x;
      var rBY = point.y - bodyB.m_sweep.c.y;
      minSeparation = minSeparation < separation ? minSeparation : separation;
      var C = b2Math.Clamp(baumgarte * (separation + b2Settings.b2_linearSlop), -b2Settings.b2_maxLinearCorrection, 0);
      var impulse = -ccp.equalizedMass * C;
      var PX = impulse * normal.x;
      var PY = impulse * normal.y;
      bodyA.m_sweep.c.x -= invMassA * PX;
      bodyA.m_sweep.c.y -= invMassA * PY;
      bodyA.m_sweep.a -= invIA * (rAX * PY - rAY * PX);
      bodyA.SynchronizeTransform();
      bodyB.m_sweep.c.x += invMassB * PX;
      bodyB.m_sweep.c.y += invMassB * PY;
      bodyB.m_sweep.a += invIB * (rBX * PY - rBY * PX);
      bodyB.SynchronizeTransform()
    }
  }
  return minSeparation > -1.5 * b2Settings.b2_linearSlop
};
b2ContactSolver.prototype.m_step = new b2TimeStep;
b2ContactSolver.prototype.m_allocator = null;
b2ContactSolver.prototype.m_constraints = new Array;
b2ContactSolver.prototype.m_constraintCount = 0;var b2Simplex = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Simplex.prototype.__constructor = function() {
  this.m_vertices[0] = this.m_v1;
  this.m_vertices[1] = this.m_v2;
  this.m_vertices[2] = this.m_v3
};
b2Simplex.prototype.__varz = function() {
  this.m_v1 = new b2SimplexVertex;
  this.m_v2 = new b2SimplexVertex;
  this.m_v3 = new b2SimplexVertex;
  this.m_vertices = new Array(3)
};
b2Simplex.prototype.ReadCache = function(cache, proxyA, transformA, proxyB, transformB) {
  b2Settings.b2Assert(0 <= cache.count && cache.count <= 3);
  var wALocal;
  var wBLocal;
  this.m_count = cache.count;
  var vertices = this.m_vertices;
  for(var i = 0;i < this.m_count;i++) {
    var v = vertices[i];
    v.indexA = cache.indexA[i];
    v.indexB = cache.indexB[i];
    wALocal = proxyA.GetVertex(v.indexA);
    wBLocal = proxyB.GetVertex(v.indexB);
    v.wA = b2Math.MulX(transformA, wALocal);
    v.wB = b2Math.MulX(transformB, wBLocal);
    v.w = b2Math.SubtractVV(v.wB, v.wA);
    v.a = 0
  }
  if(this.m_count > 1) {
    var metric1 = cache.metric;
    var metric2 = this.GetMetric();
    if(metric2 < 0.5 * metric1 || 2 * metric1 < metric2 || metric2 < Number.MIN_VALUE) {
      this.m_count = 0
    }
  }
  if(this.m_count == 0) {
    v = vertices[0];
    v.indexA = 0;
    v.indexB = 0;
    wALocal = proxyA.GetVertex(0);
    wBLocal = proxyB.GetVertex(0);
    v.wA = b2Math.MulX(transformA, wALocal);
    v.wB = b2Math.MulX(transformB, wBLocal);
    v.w = b2Math.SubtractVV(v.wB, v.wA);
    this.m_count = 1
  }
};
b2Simplex.prototype.WriteCache = function(cache) {
  cache.metric = this.GetMetric();
  cache.count = parseInt(this.m_count);
  var vertices = this.m_vertices;
  for(var i = 0;i < this.m_count;i++) {
    cache.indexA[i] = parseInt(vertices[i].indexA);
    cache.indexB[i] = parseInt(vertices[i].indexB)
  }
};
b2Simplex.prototype.GetSearchDirection = function() {
  switch(this.m_count) {
    case 1:
      return this.m_v1.w.GetNegative();
    case 2:
      var e12 = b2Math.SubtractVV(this.m_v2.w, this.m_v1.w);
      var sgn = b2Math.CrossVV(e12, this.m_v1.w.GetNegative());
      if(sgn > 0) {
        return b2Math.CrossFV(1, e12)
      }else {
        return b2Math.CrossVF(e12, 1)
      }
    ;
    default:
      b2Settings.b2Assert(false);
      return new b2Vec2
  }
};
b2Simplex.prototype.GetClosestPoint = function() {
  switch(this.m_count) {
    case 0:
      b2Settings.b2Assert(false);
      return new b2Vec2;
    case 1:
      return this.m_v1.w;
    case 2:
      return new b2Vec2(this.m_v1.a * this.m_v1.w.x + this.m_v2.a * this.m_v2.w.x, this.m_v1.a * this.m_v1.w.y + this.m_v2.a * this.m_v2.w.y);
    default:
      b2Settings.b2Assert(false);
      return new b2Vec2
  }
};
b2Simplex.prototype.GetWitnessPoints = function(pA, pB) {
  switch(this.m_count) {
    case 0:
      b2Settings.b2Assert(false);
      break;
    case 1:
      pA.SetV(this.m_v1.wA);
      pB.SetV(this.m_v1.wB);
      break;
    case 2:
      pA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x;
      pA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y;
      pB.x = this.m_v1.a * this.m_v1.wB.x + this.m_v2.a * this.m_v2.wB.x;
      pB.y = this.m_v1.a * this.m_v1.wB.y + this.m_v2.a * this.m_v2.wB.y;
      break;
    case 3:
      pB.x = pA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x + this.m_v3.a * this.m_v3.wA.x;
      pB.y = pA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y + this.m_v3.a * this.m_v3.wA.y;
      break;
    default:
      b2Settings.b2Assert(false);
      break
  }
};
b2Simplex.prototype.GetMetric = function() {
  switch(this.m_count) {
    case 0:
      b2Settings.b2Assert(false);
      return 0;
    case 1:
      return 0;
    case 2:
      return b2Math.SubtractVV(this.m_v1.w, this.m_v2.w).Length();
    case 3:
      return b2Math.CrossVV(b2Math.SubtractVV(this.m_v2.w, this.m_v1.w), b2Math.SubtractVV(this.m_v3.w, this.m_v1.w));
    default:
      b2Settings.b2Assert(false);
      return 0
  }
};
b2Simplex.prototype.Solve2 = function() {
  var w1 = this.m_v1.w;
  var w2 = this.m_v2.w;
  var e12 = b2Math.SubtractVV(w2, w1);
  var d12_2 = -(w1.x * e12.x + w1.y * e12.y);
  if(d12_2 <= 0) {
    this.m_v1.a = 1;
    this.m_count = 1;
    return
  }
  var d12_1 = w2.x * e12.x + w2.y * e12.y;
  if(d12_1 <= 0) {
    this.m_v2.a = 1;
    this.m_count = 1;
    this.m_v1.Set(this.m_v2);
    return
  }
  var inv_d12 = 1 / (d12_1 + d12_2);
  this.m_v1.a = d12_1 * inv_d12;
  this.m_v2.a = d12_2 * inv_d12;
  this.m_count = 2
};
b2Simplex.prototype.Solve3 = function() {
  var w1 = this.m_v1.w;
  var w2 = this.m_v2.w;
  var w3 = this.m_v3.w;
  var e12 = b2Math.SubtractVV(w2, w1);
  var w1e12 = b2Math.Dot(w1, e12);
  var w2e12 = b2Math.Dot(w2, e12);
  var d12_1 = w2e12;
  var d12_2 = -w1e12;
  var e13 = b2Math.SubtractVV(w3, w1);
  var w1e13 = b2Math.Dot(w1, e13);
  var w3e13 = b2Math.Dot(w3, e13);
  var d13_1 = w3e13;
  var d13_2 = -w1e13;
  var e23 = b2Math.SubtractVV(w3, w2);
  var w2e23 = b2Math.Dot(w2, e23);
  var w3e23 = b2Math.Dot(w3, e23);
  var d23_1 = w3e23;
  var d23_2 = -w2e23;
  var n123 = b2Math.CrossVV(e12, e13);
  var d123_1 = n123 * b2Math.CrossVV(w2, w3);
  var d123_2 = n123 * b2Math.CrossVV(w3, w1);
  var d123_3 = n123 * b2Math.CrossVV(w1, w2);
  if(d12_2 <= 0 && d13_2 <= 0) {
    this.m_v1.a = 1;
    this.m_count = 1;
    return
  }
  if(d12_1 > 0 && d12_2 > 0 && d123_3 <= 0) {
    var inv_d12 = 1 / (d12_1 + d12_2);
    this.m_v1.a = d12_1 * inv_d12;
    this.m_v2.a = d12_2 * inv_d12;
    this.m_count = 2;
    return
  }
  if(d13_1 > 0 && d13_2 > 0 && d123_2 <= 0) {
    var inv_d13 = 1 / (d13_1 + d13_2);
    this.m_v1.a = d13_1 * inv_d13;
    this.m_v3.a = d13_2 * inv_d13;
    this.m_count = 2;
    this.m_v2.Set(this.m_v3);
    return
  }
  if(d12_1 <= 0 && d23_2 <= 0) {
    this.m_v2.a = 1;
    this.m_count = 1;
    this.m_v1.Set(this.m_v2);
    return
  }
  if(d13_1 <= 0 && d23_1 <= 0) {
    this.m_v3.a = 1;
    this.m_count = 1;
    this.m_v1.Set(this.m_v3);
    return
  }
  if(d23_1 > 0 && d23_2 > 0 && d123_1 <= 0) {
    var inv_d23 = 1 / (d23_1 + d23_2);
    this.m_v2.a = d23_1 * inv_d23;
    this.m_v3.a = d23_2 * inv_d23;
    this.m_count = 2;
    this.m_v1.Set(this.m_v3);
    return
  }
  var inv_d123 = 1 / (d123_1 + d123_2 + d123_3);
  this.m_v1.a = d123_1 * inv_d123;
  this.m_v2.a = d123_2 * inv_d123;
  this.m_v3.a = d123_3 * inv_d123;
  this.m_count = 3
};
b2Simplex.prototype.m_v1 = new b2SimplexVertex;
b2Simplex.prototype.m_v2 = new b2SimplexVertex;
b2Simplex.prototype.m_v3 = new b2SimplexVertex;
b2Simplex.prototype.m_vertices = new Array(3);
b2Simplex.prototype.m_count = 0;var b2WeldJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2WeldJoint.prototype, b2Joint.prototype);
b2WeldJoint.prototype._super = b2Joint.prototype;
b2WeldJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  this.m_localAnchorA.SetV(def.localAnchorA);
  this.m_localAnchorB.SetV(def.localAnchorB);
  this.m_referenceAngle = def.referenceAngle;
  this.m_impulse.SetZero();
  this.m_mass = new b2Mat33
};
b2WeldJoint.prototype.__varz = function() {
  this.m_localAnchorA = new b2Vec2;
  this.m_localAnchorB = new b2Vec2;
  this.m_impulse = new b2Vec3;
  this.m_mass = new b2Mat33
};
b2WeldJoint.prototype.InitVelocityConstraints = function(step) {
  var tMat;
  var tX;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  tMat = bA.m_xf.R;
  var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
  var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
  tX = tMat.col1.x * rAX + tMat.col2.x * rAY;
  rAY = tMat.col1.y * rAX + tMat.col2.y * rAY;
  rAX = tX;
  tMat = bB.m_xf.R;
  var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
  var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * rBX + tMat.col2.x * rBY;
  rBY = tMat.col1.y * rBX + tMat.col2.y * rBY;
  rBX = tX;
  var mA = bA.m_invMass;
  var mB = bB.m_invMass;
  var iA = bA.m_invI;
  var iB = bB.m_invI;
  this.m_mass.col1.x = mA + mB + rAY * rAY * iA + rBY * rBY * iB;
  this.m_mass.col2.x = -rAY * rAX * iA - rBY * rBX * iB;
  this.m_mass.col3.x = -rAY * iA - rBY * iB;
  this.m_mass.col1.y = this.m_mass.col2.x;
  this.m_mass.col2.y = mA + mB + rAX * rAX * iA + rBX * rBX * iB;
  this.m_mass.col3.y = rAX * iA + rBX * iB;
  this.m_mass.col1.z = this.m_mass.col3.x;
  this.m_mass.col2.z = this.m_mass.col3.y;
  this.m_mass.col3.z = iA + iB;
  if(step.warmStarting) {
    this.m_impulse.x *= step.dtRatio;
    this.m_impulse.y *= step.dtRatio;
    this.m_impulse.z *= step.dtRatio;
    bA.m_linearVelocity.x -= mA * this.m_impulse.x;
    bA.m_linearVelocity.y -= mA * this.m_impulse.y;
    bA.m_angularVelocity -= iA * (rAX * this.m_impulse.y - rAY * this.m_impulse.x + this.m_impulse.z);
    bB.m_linearVelocity.x += mB * this.m_impulse.x;
    bB.m_linearVelocity.y += mB * this.m_impulse.y;
    bB.m_angularVelocity += iB * (rBX * this.m_impulse.y - rBY * this.m_impulse.x + this.m_impulse.z)
  }else {
    this.m_impulse.SetZero()
  }
};
b2WeldJoint.prototype.SolveVelocityConstraints = function(step) {
  var tMat;
  var tX;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var vA = bA.m_linearVelocity;
  var wA = bA.m_angularVelocity;
  var vB = bB.m_linearVelocity;
  var wB = bB.m_angularVelocity;
  var mA = bA.m_invMass;
  var mB = bB.m_invMass;
  var iA = bA.m_invI;
  var iB = bB.m_invI;
  tMat = bA.m_xf.R;
  var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
  var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
  tX = tMat.col1.x * rAX + tMat.col2.x * rAY;
  rAY = tMat.col1.y * rAX + tMat.col2.y * rAY;
  rAX = tX;
  tMat = bB.m_xf.R;
  var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
  var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * rBX + tMat.col2.x * rBY;
  rBY = tMat.col1.y * rBX + tMat.col2.y * rBY;
  rBX = tX;
  var Cdot1X = vB.x - wB * rBY - vA.x + wA * rAY;
  var Cdot1Y = vB.y + wB * rBX - vA.y - wA * rAX;
  var Cdot2 = wB - wA;
  var impulse = new b2Vec3;
  this.m_mass.Solve33(impulse, -Cdot1X, -Cdot1Y, -Cdot2);
  this.m_impulse.Add(impulse);
  vA.x -= mA * impulse.x;
  vA.y -= mA * impulse.y;
  wA -= iA * (rAX * impulse.y - rAY * impulse.x + impulse.z);
  vB.x += mB * impulse.x;
  vB.y += mB * impulse.y;
  wB += iB * (rBX * impulse.y - rBY * impulse.x + impulse.z);
  bA.m_angularVelocity = wA;
  bB.m_angularVelocity = wB
};
b2WeldJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  var tMat;
  var tX;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  tMat = bA.m_xf.R;
  var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
  var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
  tX = tMat.col1.x * rAX + tMat.col2.x * rAY;
  rAY = tMat.col1.y * rAX + tMat.col2.y * rAY;
  rAX = tX;
  tMat = bB.m_xf.R;
  var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
  var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * rBX + tMat.col2.x * rBY;
  rBY = tMat.col1.y * rBX + tMat.col2.y * rBY;
  rBX = tX;
  var mA = bA.m_invMass;
  var mB = bB.m_invMass;
  var iA = bA.m_invI;
  var iB = bB.m_invI;
  var C1X = bB.m_sweep.c.x + rBX - bA.m_sweep.c.x - rAX;
  var C1Y = bB.m_sweep.c.y + rBY - bA.m_sweep.c.y - rAY;
  var C2 = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
  var k_allowedStretch = 10 * b2Settings.b2_linearSlop;
  var positionError = Math.sqrt(C1X * C1X + C1Y * C1Y);
  var angularError = b2Math.Abs(C2);
  if(positionError > k_allowedStretch) {
    iA *= 1;
    iB *= 1
  }
  this.m_mass.col1.x = mA + mB + rAY * rAY * iA + rBY * rBY * iB;
  this.m_mass.col2.x = -rAY * rAX * iA - rBY * rBX * iB;
  this.m_mass.col3.x = -rAY * iA - rBY * iB;
  this.m_mass.col1.y = this.m_mass.col2.x;
  this.m_mass.col2.y = mA + mB + rAX * rAX * iA + rBX * rBX * iB;
  this.m_mass.col3.y = rAX * iA + rBX * iB;
  this.m_mass.col1.z = this.m_mass.col3.x;
  this.m_mass.col2.z = this.m_mass.col3.y;
  this.m_mass.col3.z = iA + iB;
  var impulse = new b2Vec3;
  this.m_mass.Solve33(impulse, -C1X, -C1Y, -C2);
  bA.m_sweep.c.x -= mA * impulse.x;
  bA.m_sweep.c.y -= mA * impulse.y;
  bA.m_sweep.a -= iA * (rAX * impulse.y - rAY * impulse.x + impulse.z);
  bB.m_sweep.c.x += mB * impulse.x;
  bB.m_sweep.c.y += mB * impulse.y;
  bB.m_sweep.a += iB * (rBX * impulse.y - rBY * impulse.x + impulse.z);
  bA.SynchronizeTransform();
  bB.SynchronizeTransform();
  return positionError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop
};
b2WeldJoint.prototype.GetAnchorA = function() {
  return this.m_bodyA.GetWorldPoint(this.m_localAnchorA)
};
b2WeldJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchorB)
};
b2WeldJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y)
};
b2WeldJoint.prototype.GetReactionTorque = function(inv_dt) {
  return inv_dt * this.m_impulse.z
};
b2WeldJoint.prototype.m_localAnchorA = new b2Vec2;
b2WeldJoint.prototype.m_localAnchorB = new b2Vec2;
b2WeldJoint.prototype.m_referenceAngle = null;
b2WeldJoint.prototype.m_impulse = new b2Vec3;
b2WeldJoint.prototype.m_mass = new b2Mat33;var b2Math = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Math.prototype.__constructor = function() {
};
b2Math.prototype.__varz = function() {
};
b2Math.IsValid = function(x) {
  return isFinite(x)
};
b2Math.Dot = function(a, b) {
  return a.x * b.x + a.y * b.y
};
b2Math.CrossVV = function(a, b) {
  return a.x * b.y - a.y * b.x
};
b2Math.CrossVF = function(a, s) {
  var v = new b2Vec2(s * a.y, -s * a.x);
  return v
};
b2Math.CrossFV = function(s, a) {
  var v = new b2Vec2(-s * a.y, s * a.x);
  return v
};
b2Math.MulMV = function(A, v) {
  var u = new b2Vec2(A.col1.x * v.x + A.col2.x * v.y, A.col1.y * v.x + A.col2.y * v.y);
  return u
};
b2Math.MulTMV = function(A, v) {
  var u = new b2Vec2(b2Math.Dot(v, A.col1), b2Math.Dot(v, A.col2));
  return u
};
b2Math.MulX = function(T, v) {
  var a = b2Math.MulMV(T.R, v);
  a.x += T.position.x;
  a.y += T.position.y;
  return a
};
b2Math.MulXT = function(T, v) {
  var a = b2Math.SubtractVV(v, T.position);
  var tX = a.x * T.R.col1.x + a.y * T.R.col1.y;
  a.y = a.x * T.R.col2.x + a.y * T.R.col2.y;
  a.x = tX;
  return a
};
b2Math.AddVV = function(a, b) {
  var v = new b2Vec2(a.x + b.x, a.y + b.y);
  return v
};
b2Math.SubtractVV = function(a, b) {
  var v = new b2Vec2(a.x - b.x, a.y - b.y);
  return v
};
b2Math.Distance = function(a, b) {
  var cX = a.x - b.x;
  var cY = a.y - b.y;
  return Math.sqrt(cX * cX + cY * cY)
};
b2Math.DistanceSquared = function(a, b) {
  var cX = a.x - b.x;
  var cY = a.y - b.y;
  return cX * cX + cY * cY
};
b2Math.MulFV = function(s, a) {
  var v = new b2Vec2(s * a.x, s * a.y);
  return v
};
b2Math.AddMM = function(A, B) {
  var C = b2Mat22.FromVV(b2Math.AddVV(A.col1, B.col1), b2Math.AddVV(A.col2, B.col2));
  return C
};
b2Math.MulMM = function(A, B) {
  var C = b2Mat22.FromVV(b2Math.MulMV(A, B.col1), b2Math.MulMV(A, B.col2));
  return C
};
b2Math.MulTMM = function(A, B) {
  var c1 = new b2Vec2(b2Math.Dot(A.col1, B.col1), b2Math.Dot(A.col2, B.col1));
  var c2 = new b2Vec2(b2Math.Dot(A.col1, B.col2), b2Math.Dot(A.col2, B.col2));
  var C = b2Mat22.FromVV(c1, c2);
  return C
};
b2Math.Abs = function(a) {
  return a > 0 ? a : -a
};
b2Math.AbsV = function(a) {
  var b = new b2Vec2(b2Math.Abs(a.x), b2Math.Abs(a.y));
  return b
};
b2Math.AbsM = function(A) {
  var B = b2Mat22.FromVV(b2Math.AbsV(A.col1), b2Math.AbsV(A.col2));
  return B
};
b2Math.Min = function(a, b) {
  return a < b ? a : b
};
b2Math.MinV = function(a, b) {
  var c = new b2Vec2(b2Math.Min(a.x, b.x), b2Math.Min(a.y, b.y));
  return c
};
b2Math.Max = function(a, b) {
  return a > b ? a : b
};
b2Math.MaxV = function(a, b) {
  var c = new b2Vec2(b2Math.Max(a.x, b.x), b2Math.Max(a.y, b.y));
  return c
};
b2Math.Clamp = function(a, low, high) {
  return a < low ? low : a > high ? high : a
};
b2Math.ClampV = function(a, low, high) {
  return b2Math.MaxV(low, b2Math.MinV(a, high))
};
b2Math.Swap = function(a, b) {
  var tmp = a[0];
  a[0] = b[0];
  b[0] = tmp
};
b2Math.Random = function() {
  return Math.random() * 2 - 1
};
b2Math.RandomRange = function(lo, hi) {
  var r = Math.random();
  r = (hi - lo) * r + lo;
  return r
};
b2Math.NextPowerOfTwo = function(x) {
  x |= x >> 1 & 2147483647;
  x |= x >> 2 & 1073741823;
  x |= x >> 4 & 268435455;
  x |= x >> 8 & 16777215;
  x |= x >> 16 & 65535;
  return x + 1
};
b2Math.IsPowerOfTwo = function(x) {
  var result = x > 0 && (x & x - 1) == 0;
  return result
};
b2Math.b2Vec2_zero = new b2Vec2(0, 0);
b2Math.b2Mat22_identity = b2Mat22.FromVV(new b2Vec2(1, 0), new b2Vec2(0, 1));
b2Math.b2Transform_identity = new b2Transform(b2Math.b2Vec2_zero, b2Math.b2Mat22_identity);var b2PulleyJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2PulleyJoint.prototype, b2Joint.prototype);
b2PulleyJoint.prototype._super = b2Joint.prototype;
b2PulleyJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  var tMat;
  var tX;
  var tY;
  this.m_ground = this.m_bodyA.m_world.m_groundBody;
  this.m_groundAnchor1.x = def.groundAnchorA.x - this.m_ground.m_xf.position.x;
  this.m_groundAnchor1.y = def.groundAnchorA.y - this.m_ground.m_xf.position.y;
  this.m_groundAnchor2.x = def.groundAnchorB.x - this.m_ground.m_xf.position.x;
  this.m_groundAnchor2.y = def.groundAnchorB.y - this.m_ground.m_xf.position.y;
  this.m_localAnchor1.SetV(def.localAnchorA);
  this.m_localAnchor2.SetV(def.localAnchorB);
  this.m_ratio = def.ratio;
  this.m_constant = def.lengthA + this.m_ratio * def.lengthB;
  this.m_maxLength1 = b2Math.Min(def.maxLengthA, this.m_constant - this.m_ratio * b2PulleyJoint.b2_minPulleyLength);
  this.m_maxLength2 = b2Math.Min(def.maxLengthB, (this.m_constant - b2PulleyJoint.b2_minPulleyLength) / this.m_ratio);
  this.m_impulse = 0;
  this.m_limitImpulse1 = 0;
  this.m_limitImpulse2 = 0
};
b2PulleyJoint.prototype.__varz = function() {
  this.m_groundAnchor1 = new b2Vec2;
  this.m_groundAnchor2 = new b2Vec2;
  this.m_localAnchor1 = new b2Vec2;
  this.m_localAnchor2 = new b2Vec2;
  this.m_u1 = new b2Vec2;
  this.m_u2 = new b2Vec2
};
b2PulleyJoint.b2_minPulleyLength = 2;
b2PulleyJoint.prototype.InitVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var p1X = bA.m_sweep.c.x + r1X;
  var p1Y = bA.m_sweep.c.y + r1Y;
  var p2X = bB.m_sweep.c.x + r2X;
  var p2Y = bB.m_sweep.c.y + r2Y;
  var s1X = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
  var s1Y = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
  var s2X = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
  var s2Y = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
  this.m_u1.Set(p1X - s1X, p1Y - s1Y);
  this.m_u2.Set(p2X - s2X, p2Y - s2Y);
  var length1 = this.m_u1.Length();
  var length2 = this.m_u2.Length();
  if(length1 > b2Settings.b2_linearSlop) {
    this.m_u1.Multiply(1 / length1)
  }else {
    this.m_u1.SetZero()
  }
  if(length2 > b2Settings.b2_linearSlop) {
    this.m_u2.Multiply(1 / length2)
  }else {
    this.m_u2.SetZero()
  }
  var C = this.m_constant - length1 - this.m_ratio * length2;
  if(C > 0) {
    this.m_state = b2Joint.e_inactiveLimit;
    this.m_impulse = 0
  }else {
    this.m_state = b2Joint.e_atUpperLimit
  }
  if(length1 < this.m_maxLength1) {
    this.m_limitState1 = b2Joint.e_inactiveLimit;
    this.m_limitImpulse1 = 0
  }else {
    this.m_limitState1 = b2Joint.e_atUpperLimit
  }
  if(length2 < this.m_maxLength2) {
    this.m_limitState2 = b2Joint.e_inactiveLimit;
    this.m_limitImpulse2 = 0
  }else {
    this.m_limitState2 = b2Joint.e_atUpperLimit
  }
  var cr1u1 = r1X * this.m_u1.y - r1Y * this.m_u1.x;
  var cr2u2 = r2X * this.m_u2.y - r2Y * this.m_u2.x;
  this.m_limitMass1 = bA.m_invMass + bA.m_invI * cr1u1 * cr1u1;
  this.m_limitMass2 = bB.m_invMass + bB.m_invI * cr2u2 * cr2u2;
  this.m_pulleyMass = this.m_limitMass1 + this.m_ratio * this.m_ratio * this.m_limitMass2;
  this.m_limitMass1 = 1 / this.m_limitMass1;
  this.m_limitMass2 = 1 / this.m_limitMass2;
  this.m_pulleyMass = 1 / this.m_pulleyMass;
  if(step.warmStarting) {
    this.m_impulse *= step.dtRatio;
    this.m_limitImpulse1 *= step.dtRatio;
    this.m_limitImpulse2 *= step.dtRatio;
    var P1X = (-this.m_impulse - this.m_limitImpulse1) * this.m_u1.x;
    var P1Y = (-this.m_impulse - this.m_limitImpulse1) * this.m_u1.y;
    var P2X = (-this.m_ratio * this.m_impulse - this.m_limitImpulse2) * this.m_u2.x;
    var P2Y = (-this.m_ratio * this.m_impulse - this.m_limitImpulse2) * this.m_u2.y;
    bA.m_linearVelocity.x += bA.m_invMass * P1X;
    bA.m_linearVelocity.y += bA.m_invMass * P1Y;
    bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
    bB.m_linearVelocity.x += bB.m_invMass * P2X;
    bB.m_linearVelocity.y += bB.m_invMass * P2Y;
    bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X)
  }else {
    this.m_impulse = 0;
    this.m_limitImpulse1 = 0;
    this.m_limitImpulse2 = 0
  }
};
b2PulleyJoint.prototype.SolveVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var v1X;
  var v1Y;
  var v2X;
  var v2Y;
  var P1X;
  var P1Y;
  var P2X;
  var P2Y;
  var Cdot;
  var impulse;
  var oldImpulse;
  if(this.m_state == b2Joint.e_atUpperLimit) {
    v1X = bA.m_linearVelocity.x + -bA.m_angularVelocity * r1Y;
    v1Y = bA.m_linearVelocity.y + bA.m_angularVelocity * r1X;
    v2X = bB.m_linearVelocity.x + -bB.m_angularVelocity * r2Y;
    v2Y = bB.m_linearVelocity.y + bB.m_angularVelocity * r2X;
    Cdot = -(this.m_u1.x * v1X + this.m_u1.y * v1Y) - this.m_ratio * (this.m_u2.x * v2X + this.m_u2.y * v2Y);
    impulse = this.m_pulleyMass * -Cdot;
    oldImpulse = this.m_impulse;
    this.m_impulse = b2Math.Max(0, this.m_impulse + impulse);
    impulse = this.m_impulse - oldImpulse;
    P1X = -impulse * this.m_u1.x;
    P1Y = -impulse * this.m_u1.y;
    P2X = -this.m_ratio * impulse * this.m_u2.x;
    P2Y = -this.m_ratio * impulse * this.m_u2.y;
    bA.m_linearVelocity.x += bA.m_invMass * P1X;
    bA.m_linearVelocity.y += bA.m_invMass * P1Y;
    bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
    bB.m_linearVelocity.x += bB.m_invMass * P2X;
    bB.m_linearVelocity.y += bB.m_invMass * P2Y;
    bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X)
  }
  if(this.m_limitState1 == b2Joint.e_atUpperLimit) {
    v1X = bA.m_linearVelocity.x + -bA.m_angularVelocity * r1Y;
    v1Y = bA.m_linearVelocity.y + bA.m_angularVelocity * r1X;
    Cdot = -(this.m_u1.x * v1X + this.m_u1.y * v1Y);
    impulse = -this.m_limitMass1 * Cdot;
    oldImpulse = this.m_limitImpulse1;
    this.m_limitImpulse1 = b2Math.Max(0, this.m_limitImpulse1 + impulse);
    impulse = this.m_limitImpulse1 - oldImpulse;
    P1X = -impulse * this.m_u1.x;
    P1Y = -impulse * this.m_u1.y;
    bA.m_linearVelocity.x += bA.m_invMass * P1X;
    bA.m_linearVelocity.y += bA.m_invMass * P1Y;
    bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X)
  }
  if(this.m_limitState2 == b2Joint.e_atUpperLimit) {
    v2X = bB.m_linearVelocity.x + -bB.m_angularVelocity * r2Y;
    v2Y = bB.m_linearVelocity.y + bB.m_angularVelocity * r2X;
    Cdot = -(this.m_u2.x * v2X + this.m_u2.y * v2Y);
    impulse = -this.m_limitMass2 * Cdot;
    oldImpulse = this.m_limitImpulse2;
    this.m_limitImpulse2 = b2Math.Max(0, this.m_limitImpulse2 + impulse);
    impulse = this.m_limitImpulse2 - oldImpulse;
    P2X = -impulse * this.m_u2.x;
    P2Y = -impulse * this.m_u2.y;
    bB.m_linearVelocity.x += bB.m_invMass * P2X;
    bB.m_linearVelocity.y += bB.m_invMass * P2Y;
    bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X)
  }
};
b2PulleyJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  var s1X = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
  var s1Y = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
  var s2X = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
  var s2Y = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
  var r1X;
  var r1Y;
  var r2X;
  var r2Y;
  var p1X;
  var p1Y;
  var p2X;
  var p2Y;
  var length1;
  var length2;
  var C;
  var impulse;
  var oldImpulse;
  var oldLimitPositionImpulse;
  var tX;
  var linearError = 0;
  if(this.m_state == b2Joint.e_atUpperLimit) {
    tMat = bA.m_xf.R;
    r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
    r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
    tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
    r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
    r1X = tX;
    tMat = bB.m_xf.R;
    r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
    r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
    tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
    r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
    r2X = tX;
    p1X = bA.m_sweep.c.x + r1X;
    p1Y = bA.m_sweep.c.y + r1Y;
    p2X = bB.m_sweep.c.x + r2X;
    p2Y = bB.m_sweep.c.y + r2Y;
    this.m_u1.Set(p1X - s1X, p1Y - s1Y);
    this.m_u2.Set(p2X - s2X, p2Y - s2Y);
    length1 = this.m_u1.Length();
    length2 = this.m_u2.Length();
    if(length1 > b2Settings.b2_linearSlop) {
      this.m_u1.Multiply(1 / length1)
    }else {
      this.m_u1.SetZero()
    }
    if(length2 > b2Settings.b2_linearSlop) {
      this.m_u2.Multiply(1 / length2)
    }else {
      this.m_u2.SetZero()
    }
    C = this.m_constant - length1 - this.m_ratio * length2;
    linearError = b2Math.Max(linearError, -C);
    C = b2Math.Clamp(C + b2Settings.b2_linearSlop, -b2Settings.b2_maxLinearCorrection, 0);
    impulse = -this.m_pulleyMass * C;
    p1X = -impulse * this.m_u1.x;
    p1Y = -impulse * this.m_u1.y;
    p2X = -this.m_ratio * impulse * this.m_u2.x;
    p2Y = -this.m_ratio * impulse * this.m_u2.y;
    bA.m_sweep.c.x += bA.m_invMass * p1X;
    bA.m_sweep.c.y += bA.m_invMass * p1Y;
    bA.m_sweep.a += bA.m_invI * (r1X * p1Y - r1Y * p1X);
    bB.m_sweep.c.x += bB.m_invMass * p2X;
    bB.m_sweep.c.y += bB.m_invMass * p2Y;
    bB.m_sweep.a += bB.m_invI * (r2X * p2Y - r2Y * p2X);
    bA.SynchronizeTransform();
    bB.SynchronizeTransform()
  }
  if(this.m_limitState1 == b2Joint.e_atUpperLimit) {
    tMat = bA.m_xf.R;
    r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
    r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
    tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
    r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
    r1X = tX;
    p1X = bA.m_sweep.c.x + r1X;
    p1Y = bA.m_sweep.c.y + r1Y;
    this.m_u1.Set(p1X - s1X, p1Y - s1Y);
    length1 = this.m_u1.Length();
    if(length1 > b2Settings.b2_linearSlop) {
      this.m_u1.x *= 1 / length1;
      this.m_u1.y *= 1 / length1
    }else {
      this.m_u1.SetZero()
    }
    C = this.m_maxLength1 - length1;
    linearError = b2Math.Max(linearError, -C);
    C = b2Math.Clamp(C + b2Settings.b2_linearSlop, -b2Settings.b2_maxLinearCorrection, 0);
    impulse = -this.m_limitMass1 * C;
    p1X = -impulse * this.m_u1.x;
    p1Y = -impulse * this.m_u1.y;
    bA.m_sweep.c.x += bA.m_invMass * p1X;
    bA.m_sweep.c.y += bA.m_invMass * p1Y;
    bA.m_sweep.a += bA.m_invI * (r1X * p1Y - r1Y * p1X);
    bA.SynchronizeTransform()
  }
  if(this.m_limitState2 == b2Joint.e_atUpperLimit) {
    tMat = bB.m_xf.R;
    r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
    r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
    tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
    r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
    r2X = tX;
    p2X = bB.m_sweep.c.x + r2X;
    p2Y = bB.m_sweep.c.y + r2Y;
    this.m_u2.Set(p2X - s2X, p2Y - s2Y);
    length2 = this.m_u2.Length();
    if(length2 > b2Settings.b2_linearSlop) {
      this.m_u2.x *= 1 / length2;
      this.m_u2.y *= 1 / length2
    }else {
      this.m_u2.SetZero()
    }
    C = this.m_maxLength2 - length2;
    linearError = b2Math.Max(linearError, -C);
    C = b2Math.Clamp(C + b2Settings.b2_linearSlop, -b2Settings.b2_maxLinearCorrection, 0);
    impulse = -this.m_limitMass2 * C;
    p2X = -impulse * this.m_u2.x;
    p2Y = -impulse * this.m_u2.y;
    bB.m_sweep.c.x += bB.m_invMass * p2X;
    bB.m_sweep.c.y += bB.m_invMass * p2Y;
    bB.m_sweep.a += bB.m_invI * (r2X * p2Y - r2Y * p2X);
    bB.SynchronizeTransform()
  }
  return linearError < b2Settings.b2_linearSlop
};
b2PulleyJoint.prototype.GetAnchorA = function() {
  return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
};
b2PulleyJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
};
b2PulleyJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * this.m_impulse * this.m_u2.x, inv_dt * this.m_impulse * this.m_u2.y)
};
b2PulleyJoint.prototype.GetReactionTorque = function(inv_dt) {
  return 0
};
b2PulleyJoint.prototype.GetGroundAnchorA = function() {
  var a = this.m_ground.m_xf.position.Copy();
  a.Add(this.m_groundAnchor1);
  return a
};
b2PulleyJoint.prototype.GetGroundAnchorB = function() {
  var a = this.m_ground.m_xf.position.Copy();
  a.Add(this.m_groundAnchor2);
  return a
};
b2PulleyJoint.prototype.GetLength1 = function() {
  var p = this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
  var sX = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
  var sY = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
  var dX = p.x - sX;
  var dY = p.y - sY;
  return Math.sqrt(dX * dX + dY * dY)
};
b2PulleyJoint.prototype.GetLength2 = function() {
  var p = this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
  var sX = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
  var sY = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
  var dX = p.x - sX;
  var dY = p.y - sY;
  return Math.sqrt(dX * dX + dY * dY)
};
b2PulleyJoint.prototype.GetRatio = function() {
  return this.m_ratio
};
b2PulleyJoint.prototype.m_ground = null;
b2PulleyJoint.prototype.m_groundAnchor1 = new b2Vec2;
b2PulleyJoint.prototype.m_groundAnchor2 = new b2Vec2;
b2PulleyJoint.prototype.m_localAnchor1 = new b2Vec2;
b2PulleyJoint.prototype.m_localAnchor2 = new b2Vec2;
b2PulleyJoint.prototype.m_u1 = new b2Vec2;
b2PulleyJoint.prototype.m_u2 = new b2Vec2;
b2PulleyJoint.prototype.m_constant = null;
b2PulleyJoint.prototype.m_ratio = null;
b2PulleyJoint.prototype.m_maxLength1 = null;
b2PulleyJoint.prototype.m_maxLength2 = null;
b2PulleyJoint.prototype.m_pulleyMass = null;
b2PulleyJoint.prototype.m_limitMass1 = null;
b2PulleyJoint.prototype.m_limitMass2 = null;
b2PulleyJoint.prototype.m_impulse = null;
b2PulleyJoint.prototype.m_limitImpulse1 = null;
b2PulleyJoint.prototype.m_limitImpulse2 = null;
b2PulleyJoint.prototype.m_state = 0;
b2PulleyJoint.prototype.m_limitState1 = 0;
b2PulleyJoint.prototype.m_limitState2 = 0;var b2PrismaticJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2PrismaticJoint.prototype, b2Joint.prototype);
b2PrismaticJoint.prototype._super = b2Joint.prototype;
b2PrismaticJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  var tMat;
  var tX;
  var tY;
  this.m_localAnchor1.SetV(def.localAnchorA);
  this.m_localAnchor2.SetV(def.localAnchorB);
  this.m_localXAxis1.SetV(def.localAxisA);
  this.m_localYAxis1.x = -this.m_localXAxis1.y;
  this.m_localYAxis1.y = this.m_localXAxis1.x;
  this.m_refAngle = def.referenceAngle;
  this.m_impulse.SetZero();
  this.m_motorMass = 0;
  this.m_motorImpulse = 0;
  this.m_lowerTranslation = def.lowerTranslation;
  this.m_upperTranslation = def.upperTranslation;
  this.m_maxMotorForce = def.maxMotorForce;
  this.m_motorSpeed = def.motorSpeed;
  this.m_enableLimit = def.enableLimit;
  this.m_enableMotor = def.enableMotor;
  this.m_limitState = b2Joint.e_inactiveLimit;
  this.m_axis.SetZero();
  this.m_perp.SetZero()
};
b2PrismaticJoint.prototype.__varz = function() {
  this.m_localAnchor1 = new b2Vec2;
  this.m_localAnchor2 = new b2Vec2;
  this.m_localXAxis1 = new b2Vec2;
  this.m_localYAxis1 = new b2Vec2;
  this.m_axis = new b2Vec2;
  this.m_perp = new b2Vec2;
  this.m_K = new b2Mat33;
  this.m_impulse = new b2Vec3
};
b2PrismaticJoint.prototype.InitVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  var tX;
  this.m_localCenterA.SetV(bA.GetLocalCenter());
  this.m_localCenterB.SetV(bB.GetLocalCenter());
  var xf1 = bA.GetTransform();
  var xf2 = bB.GetTransform();
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
  var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
  tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
  var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
  var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
  this.m_invMassA = bA.m_invMass;
  this.m_invMassB = bB.m_invMass;
  this.m_invIA = bA.m_invI;
  this.m_invIB = bB.m_invI;
  this.m_axis.SetV(b2Math.MulMV(xf1.R, this.m_localXAxis1));
  this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
  this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
  this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2;
  if(this.m_motorMass > Number.MIN_VALUE) {
    this.m_motorMass = 1 / this.m_motorMass
  }
  this.m_perp.SetV(b2Math.MulMV(xf1.R, this.m_localYAxis1));
  this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
  this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
  var m1 = this.m_invMassA;
  var m2 = this.m_invMassB;
  var i1 = this.m_invIA;
  var i2 = this.m_invIB;
  this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
  this.m_K.col1.y = i1 * this.m_s1 + i2 * this.m_s2;
  this.m_K.col1.z = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
  this.m_K.col2.x = this.m_K.col1.y;
  this.m_K.col2.y = i1 + i2;
  this.m_K.col2.z = i1 * this.m_a1 + i2 * this.m_a2;
  this.m_K.col3.x = this.m_K.col1.z;
  this.m_K.col3.y = this.m_K.col2.z;
  this.m_K.col3.z = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
  if(this.m_enableLimit) {
    var jointTransition = this.m_axis.x * dX + this.m_axis.y * dY;
    if(b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * b2Settings.b2_linearSlop) {
      this.m_limitState = b2Joint.e_equalLimits
    }else {
      if(jointTransition <= this.m_lowerTranslation) {
        if(this.m_limitState != b2Joint.e_atLowerLimit) {
          this.m_limitState = b2Joint.e_atLowerLimit;
          this.m_impulse.z = 0
        }
      }else {
        if(jointTransition >= this.m_upperTranslation) {
          if(this.m_limitState != b2Joint.e_atUpperLimit) {
            this.m_limitState = b2Joint.e_atUpperLimit;
            this.m_impulse.z = 0
          }
        }else {
          this.m_limitState = b2Joint.e_inactiveLimit;
          this.m_impulse.z = 0
        }
      }
    }
  }else {
    this.m_limitState = b2Joint.e_inactiveLimit
  }
  if(this.m_enableMotor == false) {
    this.m_motorImpulse = 0
  }
  if(step.warmStarting) {
    this.m_impulse.x *= step.dtRatio;
    this.m_impulse.y *= step.dtRatio;
    this.m_motorImpulse *= step.dtRatio;
    var PX = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x;
    var PY = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y;
    var L1 = this.m_impulse.x * this.m_s1 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1;
    var L2 = this.m_impulse.x * this.m_s2 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;
    bA.m_linearVelocity.x -= this.m_invMassA * PX;
    bA.m_linearVelocity.y -= this.m_invMassA * PY;
    bA.m_angularVelocity -= this.m_invIA * L1;
    bB.m_linearVelocity.x += this.m_invMassB * PX;
    bB.m_linearVelocity.y += this.m_invMassB * PY;
    bB.m_angularVelocity += this.m_invIB * L2
  }else {
    this.m_impulse.SetZero();
    this.m_motorImpulse = 0
  }
};
b2PrismaticJoint.prototype.SolveVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var v1 = bA.m_linearVelocity;
  var w1 = bA.m_angularVelocity;
  var v2 = bB.m_linearVelocity;
  var w2 = bB.m_angularVelocity;
  var PX;
  var PY;
  var L1;
  var L2;
  if(this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
    var Cdot = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
    var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);
    var oldImpulse = this.m_motorImpulse;
    var maxImpulse = step.dt * this.m_maxMotorForce;
    this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);
    impulse = this.m_motorImpulse - oldImpulse;
    PX = impulse * this.m_axis.x;
    PY = impulse * this.m_axis.y;
    L1 = impulse * this.m_a1;
    L2 = impulse * this.m_a2;
    v1.x -= this.m_invMassA * PX;
    v1.y -= this.m_invMassA * PY;
    w1 -= this.m_invIA * L1;
    v2.x += this.m_invMassB * PX;
    v2.y += this.m_invMassB * PY;
    w2 += this.m_invIB * L2
  }
  var Cdot1X = this.m_perp.x * (v2.x - v1.x) + this.m_perp.y * (v2.y - v1.y) + this.m_s2 * w2 - this.m_s1 * w1;
  var Cdot1Y = w2 - w1;
  if(this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
    var Cdot2 = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
    var f1 = this.m_impulse.Copy();
    var df = this.m_K.Solve33(new b2Vec3, -Cdot1X, -Cdot1Y, -Cdot2);
    this.m_impulse.Add(df);
    if(this.m_limitState == b2Joint.e_atLowerLimit) {
      this.m_impulse.z = b2Math.Max(this.m_impulse.z, 0)
    }else {
      if(this.m_limitState == b2Joint.e_atUpperLimit) {
        this.m_impulse.z = b2Math.Min(this.m_impulse.z, 0)
      }
    }
    var bX = -Cdot1X - (this.m_impulse.z - f1.z) * this.m_K.col3.x;
    var bY = -Cdot1Y - (this.m_impulse.z - f1.z) * this.m_K.col3.y;
    var f2r = this.m_K.Solve22(new b2Vec2, bX, bY);
    f2r.x += f1.x;
    f2r.y += f1.y;
    this.m_impulse.x = f2r.x;
    this.m_impulse.y = f2r.y;
    df.x = this.m_impulse.x - f1.x;
    df.y = this.m_impulse.y - f1.y;
    df.z = this.m_impulse.z - f1.z;
    PX = df.x * this.m_perp.x + df.z * this.m_axis.x;
    PY = df.x * this.m_perp.y + df.z * this.m_axis.y;
    L1 = df.x * this.m_s1 + df.y + df.z * this.m_a1;
    L2 = df.x * this.m_s2 + df.y + df.z * this.m_a2;
    v1.x -= this.m_invMassA * PX;
    v1.y -= this.m_invMassA * PY;
    w1 -= this.m_invIA * L1;
    v2.x += this.m_invMassB * PX;
    v2.y += this.m_invMassB * PY;
    w2 += this.m_invIB * L2
  }else {
    var df2 = this.m_K.Solve22(new b2Vec2, -Cdot1X, -Cdot1Y);
    this.m_impulse.x += df2.x;
    this.m_impulse.y += df2.y;
    PX = df2.x * this.m_perp.x;
    PY = df2.x * this.m_perp.y;
    L1 = df2.x * this.m_s1 + df2.y;
    L2 = df2.x * this.m_s2 + df2.y;
    v1.x -= this.m_invMassA * PX;
    v1.y -= this.m_invMassA * PY;
    w1 -= this.m_invIA * L1;
    v2.x += this.m_invMassB * PX;
    v2.y += this.m_invMassB * PY;
    w2 += this.m_invIB * L2
  }
  bA.m_linearVelocity.SetV(v1);
  bA.m_angularVelocity = w1;
  bB.m_linearVelocity.SetV(v2);
  bB.m_angularVelocity = w2
};
b2PrismaticJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  var limitC;
  var oldLimitImpulse;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var c1 = bA.m_sweep.c;
  var a1 = bA.m_sweep.a;
  var c2 = bB.m_sweep.c;
  var a2 = bB.m_sweep.a;
  var tMat;
  var tX;
  var m1;
  var m2;
  var i1;
  var i2;
  var linearError = 0;
  var angularError = 0;
  var active = false;
  var C2 = 0;
  var R1 = b2Mat22.FromAngle(a1);
  var R2 = b2Mat22.FromAngle(a2);
  tMat = R1;
  var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
  var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
  tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = R2;
  var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
  var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var dX = c2.x + r2X - c1.x - r1X;
  var dY = c2.y + r2Y - c1.y - r1Y;
  if(this.m_enableLimit) {
    this.m_axis = b2Math.MulMV(R1, this.m_localXAxis1);
    this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
    this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
    var translation = this.m_axis.x * dX + this.m_axis.y * dY;
    if(b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * b2Settings.b2_linearSlop) {
      C2 = b2Math.Clamp(translation, -b2Settings.b2_maxLinearCorrection, b2Settings.b2_maxLinearCorrection);
      linearError = b2Math.Abs(translation);
      active = true
    }else {
      if(translation <= this.m_lowerTranslation) {
        C2 = b2Math.Clamp(translation - this.m_lowerTranslation + b2Settings.b2_linearSlop, -b2Settings.b2_maxLinearCorrection, 0);
        linearError = this.m_lowerTranslation - translation;
        active = true
      }else {
        if(translation >= this.m_upperTranslation) {
          C2 = b2Math.Clamp(translation - this.m_upperTranslation + b2Settings.b2_linearSlop, 0, b2Settings.b2_maxLinearCorrection);
          linearError = translation - this.m_upperTranslation;
          active = true
        }
      }
    }
  }
  this.m_perp = b2Math.MulMV(R1, this.m_localYAxis1);
  this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
  this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
  var impulse = new b2Vec3;
  var C1X = this.m_perp.x * dX + this.m_perp.y * dY;
  var C1Y = a2 - a1 - this.m_refAngle;
  linearError = b2Math.Max(linearError, b2Math.Abs(C1X));
  angularError = b2Math.Abs(C1Y);
  if(active) {
    m1 = this.m_invMassA;
    m2 = this.m_invMassB;
    i1 = this.m_invIA;
    i2 = this.m_invIB;
    this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
    this.m_K.col1.y = i1 * this.m_s1 + i2 * this.m_s2;
    this.m_K.col1.z = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
    this.m_K.col2.x = this.m_K.col1.y;
    this.m_K.col2.y = i1 + i2;
    this.m_K.col2.z = i1 * this.m_a1 + i2 * this.m_a2;
    this.m_K.col3.x = this.m_K.col1.z;
    this.m_K.col3.y = this.m_K.col2.z;
    this.m_K.col3.z = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
    this.m_K.Solve33(impulse, -C1X, -C1Y, -C2)
  }else {
    m1 = this.m_invMassA;
    m2 = this.m_invMassB;
    i1 = this.m_invIA;
    i2 = this.m_invIB;
    var k11 = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
    var k12 = i1 * this.m_s1 + i2 * this.m_s2;
    var k22 = i1 + i2;
    this.m_K.col1.Set(k11, k12, 0);
    this.m_K.col2.Set(k12, k22, 0);
    var impulse1 = this.m_K.Solve22(new b2Vec2, -C1X, -C1Y);
    impulse.x = impulse1.x;
    impulse.y = impulse1.y;
    impulse.z = 0
  }
  var PX = impulse.x * this.m_perp.x + impulse.z * this.m_axis.x;
  var PY = impulse.x * this.m_perp.y + impulse.z * this.m_axis.y;
  var L1 = impulse.x * this.m_s1 + impulse.y + impulse.z * this.m_a1;
  var L2 = impulse.x * this.m_s2 + impulse.y + impulse.z * this.m_a2;
  c1.x -= this.m_invMassA * PX;
  c1.y -= this.m_invMassA * PY;
  a1 -= this.m_invIA * L1;
  c2.x += this.m_invMassB * PX;
  c2.y += this.m_invMassB * PY;
  a2 += this.m_invIB * L2;
  bA.m_sweep.a = a1;
  bB.m_sweep.a = a2;
  bA.SynchronizeTransform();
  bB.SynchronizeTransform();
  return linearError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop
};
b2PrismaticJoint.prototype.GetAnchorA = function() {
  return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
};
b2PrismaticJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
};
b2PrismaticJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x), inv_dt * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y))
};
b2PrismaticJoint.prototype.GetReactionTorque = function(inv_dt) {
  return inv_dt * this.m_impulse.y
};
b2PrismaticJoint.prototype.GetJointTranslation = function() {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  var p1 = bA.GetWorldPoint(this.m_localAnchor1);
  var p2 = bB.GetWorldPoint(this.m_localAnchor2);
  var dX = p2.x - p1.x;
  var dY = p2.y - p1.y;
  var axis = bA.GetWorldVector(this.m_localXAxis1);
  var translation = axis.x * dX + axis.y * dY;
  return translation
};
b2PrismaticJoint.prototype.GetJointSpeed = function() {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var p1X = bA.m_sweep.c.x + r1X;
  var p1Y = bA.m_sweep.c.y + r1Y;
  var p2X = bB.m_sweep.c.x + r2X;
  var p2Y = bB.m_sweep.c.y + r2Y;
  var dX = p2X - p1X;
  var dY = p2Y - p1Y;
  var axis = bA.GetWorldVector(this.m_localXAxis1);
  var v1 = bA.m_linearVelocity;
  var v2 = bB.m_linearVelocity;
  var w1 = bA.m_angularVelocity;
  var w2 = bB.m_angularVelocity;
  var speed = dX * -w1 * axis.y + dY * w1 * axis.x + (axis.x * (v2.x + -w2 * r2Y - v1.x - -w1 * r1Y) + axis.y * (v2.y + w2 * r2X - v1.y - w1 * r1X));
  return speed
};
b2PrismaticJoint.prototype.IsLimitEnabled = function() {
  return this.m_enableLimit
};
b2PrismaticJoint.prototype.EnableLimit = function(flag) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_enableLimit = flag
};
b2PrismaticJoint.prototype.GetLowerLimit = function() {
  return this.m_lowerTranslation
};
b2PrismaticJoint.prototype.GetUpperLimit = function() {
  return this.m_upperTranslation
};
b2PrismaticJoint.prototype.SetLimits = function(lower, upper) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_lowerTranslation = lower;
  this.m_upperTranslation = upper
};
b2PrismaticJoint.prototype.IsMotorEnabled = function() {
  return this.m_enableMotor
};
b2PrismaticJoint.prototype.EnableMotor = function(flag) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_enableMotor = flag
};
b2PrismaticJoint.prototype.SetMotorSpeed = function(speed) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_motorSpeed = speed
};
b2PrismaticJoint.prototype.GetMotorSpeed = function() {
  return this.m_motorSpeed
};
b2PrismaticJoint.prototype.SetMaxMotorForce = function(force) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_maxMotorForce = force
};
b2PrismaticJoint.prototype.GetMotorForce = function() {
  return this.m_motorImpulse
};
b2PrismaticJoint.prototype.m_localAnchor1 = new b2Vec2;
b2PrismaticJoint.prototype.m_localAnchor2 = new b2Vec2;
b2PrismaticJoint.prototype.m_localXAxis1 = new b2Vec2;
b2PrismaticJoint.prototype.m_localYAxis1 = new b2Vec2;
b2PrismaticJoint.prototype.m_refAngle = null;
b2PrismaticJoint.prototype.m_axis = new b2Vec2;
b2PrismaticJoint.prototype.m_perp = new b2Vec2;
b2PrismaticJoint.prototype.m_s1 = null;
b2PrismaticJoint.prototype.m_s2 = null;
b2PrismaticJoint.prototype.m_a1 = null;
b2PrismaticJoint.prototype.m_a2 = null;
b2PrismaticJoint.prototype.m_K = new b2Mat33;
b2PrismaticJoint.prototype.m_impulse = new b2Vec3;
b2PrismaticJoint.prototype.m_motorMass = null;
b2PrismaticJoint.prototype.m_motorImpulse = null;
b2PrismaticJoint.prototype.m_lowerTranslation = null;
b2PrismaticJoint.prototype.m_upperTranslation = null;
b2PrismaticJoint.prototype.m_maxMotorForce = null;
b2PrismaticJoint.prototype.m_motorSpeed = null;
b2PrismaticJoint.prototype.m_enableLimit = null;
b2PrismaticJoint.prototype.m_enableMotor = null;
b2PrismaticJoint.prototype.m_limitState = 0;var b2RevoluteJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2RevoluteJoint.prototype, b2Joint.prototype);
b2RevoluteJoint.prototype._super = b2Joint.prototype;
b2RevoluteJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  this.m_localAnchor1.SetV(def.localAnchorA);
  this.m_localAnchor2.SetV(def.localAnchorB);
  this.m_referenceAngle = def.referenceAngle;
  this.m_impulse.SetZero();
  this.m_motorImpulse = 0;
  this.m_lowerAngle = def.lowerAngle;
  this.m_upperAngle = def.upperAngle;
  this.m_maxMotorTorque = def.maxMotorTorque;
  this.m_motorSpeed = def.motorSpeed;
  this.m_enableLimit = def.enableLimit;
  this.m_enableMotor = def.enableMotor;
  this.m_limitState = b2Joint.e_inactiveLimit
};
b2RevoluteJoint.prototype.__varz = function() {
  this.K = new b2Mat22;
  this.K1 = new b2Mat22;
  this.K2 = new b2Mat22;
  this.K3 = new b2Mat22;
  this.impulse3 = new b2Vec3;
  this.impulse2 = new b2Vec2;
  this.reduced = new b2Vec2;
  this.m_localAnchor1 = new b2Vec2;
  this.m_localAnchor2 = new b2Vec2;
  this.m_impulse = new b2Vec3;
  this.m_mass = new b2Mat33
};
b2RevoluteJoint.tImpulse = new b2Vec2;
b2RevoluteJoint.prototype.InitVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  var tX;
  if(this.m_enableMotor || this.m_enableLimit) {
  }
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var m1 = bA.m_invMass;
  var m2 = bB.m_invMass;
  var i1 = bA.m_invI;
  var i2 = bB.m_invI;
  this.m_mass.col1.x = m1 + m2 + r1Y * r1Y * i1 + r2Y * r2Y * i2;
  this.m_mass.col2.x = -r1Y * r1X * i1 - r2Y * r2X * i2;
  this.m_mass.col3.x = -r1Y * i1 - r2Y * i2;
  this.m_mass.col1.y = this.m_mass.col2.x;
  this.m_mass.col2.y = m1 + m2 + r1X * r1X * i1 + r2X * r2X * i2;
  this.m_mass.col3.y = r1X * i1 + r2X * i2;
  this.m_mass.col1.z = this.m_mass.col3.x;
  this.m_mass.col2.z = this.m_mass.col3.y;
  this.m_mass.col3.z = i1 + i2;
  this.m_motorMass = 1 / (i1 + i2);
  if(this.m_enableMotor == false) {
    this.m_motorImpulse = 0
  }
  if(this.m_enableLimit) {
    var jointAngle = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
    if(b2Math.Abs(this.m_upperAngle - this.m_lowerAngle) < 2 * b2Settings.b2_angularSlop) {
      this.m_limitState = b2Joint.e_equalLimits
    }else {
      if(jointAngle <= this.m_lowerAngle) {
        if(this.m_limitState != b2Joint.e_atLowerLimit) {
          this.m_impulse.z = 0
        }
        this.m_limitState = b2Joint.e_atLowerLimit
      }else {
        if(jointAngle >= this.m_upperAngle) {
          if(this.m_limitState != b2Joint.e_atUpperLimit) {
            this.m_impulse.z = 0
          }
          this.m_limitState = b2Joint.e_atUpperLimit
        }else {
          this.m_limitState = b2Joint.e_inactiveLimit;
          this.m_impulse.z = 0
        }
      }
    }
  }else {
    this.m_limitState = b2Joint.e_inactiveLimit
  }
  if(step.warmStarting) {
    this.m_impulse.x *= step.dtRatio;
    this.m_impulse.y *= step.dtRatio;
    this.m_motorImpulse *= step.dtRatio;
    var PX = this.m_impulse.x;
    var PY = this.m_impulse.y;
    bA.m_linearVelocity.x -= m1 * PX;
    bA.m_linearVelocity.y -= m1 * PY;
    bA.m_angularVelocity -= i1 * (r1X * PY - r1Y * PX + this.m_motorImpulse + this.m_impulse.z);
    bB.m_linearVelocity.x += m2 * PX;
    bB.m_linearVelocity.y += m2 * PY;
    bB.m_angularVelocity += i2 * (r2X * PY - r2Y * PX + this.m_motorImpulse + this.m_impulse.z)
  }else {
    this.m_impulse.SetZero();
    this.m_motorImpulse = 0
  }
};
b2RevoluteJoint.prototype.SolveVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  var tX;
  var newImpulse;
  var r1X;
  var r1Y;
  var r2X;
  var r2Y;
  var v1 = bA.m_linearVelocity;
  var w1 = bA.m_angularVelocity;
  var v2 = bB.m_linearVelocity;
  var w2 = bB.m_angularVelocity;
  var m1 = bA.m_invMass;
  var m2 = bB.m_invMass;
  var i1 = bA.m_invI;
  var i2 = bB.m_invI;
  if(this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
    var Cdot = w2 - w1 - this.m_motorSpeed;
    var impulse = this.m_motorMass * -Cdot;
    var oldImpulse = this.m_motorImpulse;
    var maxImpulse = step.dt * this.m_maxMotorTorque;
    this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);
    impulse = this.m_motorImpulse - oldImpulse;
    w1 -= i1 * impulse;
    w2 += i2 * impulse
  }
  if(this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
    tMat = bA.m_xf.R;
    r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
    r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
    tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
    r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
    r1X = tX;
    tMat = bB.m_xf.R;
    r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
    r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
    tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
    r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
    r2X = tX;
    var Cdot1X = v2.x + -w2 * r2Y - v1.x - -w1 * r1Y;
    var Cdot1Y = v2.y + w2 * r2X - v1.y - w1 * r1X;
    var Cdot2 = w2 - w1;
    this.m_mass.Solve33(this.impulse3, -Cdot1X, -Cdot1Y, -Cdot2);
    if(this.m_limitState == b2Joint.e_equalLimits) {
      this.m_impulse.Add(this.impulse3)
    }else {
      if(this.m_limitState == b2Joint.e_atLowerLimit) {
        newImpulse = this.m_impulse.z + this.impulse3.z;
        if(newImpulse < 0) {
          this.m_mass.Solve22(this.reduced, -Cdot1X, -Cdot1Y);
          this.impulse3.x = this.reduced.x;
          this.impulse3.y = this.reduced.y;
          this.impulse3.z = -this.m_impulse.z;
          this.m_impulse.x += this.reduced.x;
          this.m_impulse.y += this.reduced.y;
          this.m_impulse.z = 0
        }
      }else {
        if(this.m_limitState == b2Joint.e_atUpperLimit) {
          newImpulse = this.m_impulse.z + this.impulse3.z;
          if(newImpulse > 0) {
            this.m_mass.Solve22(this.reduced, -Cdot1X, -Cdot1Y);
            this.impulse3.x = this.reduced.x;
            this.impulse3.y = this.reduced.y;
            this.impulse3.z = -this.m_impulse.z;
            this.m_impulse.x += this.reduced.x;
            this.m_impulse.y += this.reduced.y;
            this.m_impulse.z = 0
          }
        }
      }
    }
    v1.x -= m1 * this.impulse3.x;
    v1.y -= m1 * this.impulse3.y;
    w1 -= i1 * (r1X * this.impulse3.y - r1Y * this.impulse3.x + this.impulse3.z);
    v2.x += m2 * this.impulse3.x;
    v2.y += m2 * this.impulse3.y;
    w2 += i2 * (r2X * this.impulse3.y - r2Y * this.impulse3.x + this.impulse3.z)
  }else {
    tMat = bA.m_xf.R;
    r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
    r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
    tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
    r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
    r1X = tX;
    tMat = bB.m_xf.R;
    r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
    r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
    tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
    r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
    r2X = tX;
    var CdotX = v2.x + -w2 * r2Y - v1.x - -w1 * r1Y;
    var CdotY = v2.y + w2 * r2X - v1.y - w1 * r1X;
    this.m_mass.Solve22(this.impulse2, -CdotX, -CdotY);
    this.m_impulse.x += this.impulse2.x;
    this.m_impulse.y += this.impulse2.y;
    v1.x -= m1 * this.impulse2.x;
    v1.y -= m1 * this.impulse2.y;
    w1 -= i1 * (r1X * this.impulse2.y - r1Y * this.impulse2.x);
    v2.x += m2 * this.impulse2.x;
    v2.y += m2 * this.impulse2.y;
    w2 += i2 * (r2X * this.impulse2.y - r2Y * this.impulse2.x)
  }
  bA.m_linearVelocity.SetV(v1);
  bA.m_angularVelocity = w1;
  bB.m_linearVelocity.SetV(v2);
  bB.m_angularVelocity = w2
};
b2RevoluteJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  var oldLimitImpulse;
  var C;
  var tMat;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var angularError = 0;
  var positionError = 0;
  var tX;
  var impulseX;
  var impulseY;
  if(this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
    var angle = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
    var limitImpulse = 0;
    if(this.m_limitState == b2Joint.e_equalLimits) {
      C = b2Math.Clamp(angle - this.m_lowerAngle, -b2Settings.b2_maxAngularCorrection, b2Settings.b2_maxAngularCorrection);
      limitImpulse = -this.m_motorMass * C;
      angularError = b2Math.Abs(C)
    }else {
      if(this.m_limitState == b2Joint.e_atLowerLimit) {
        C = angle - this.m_lowerAngle;
        angularError = -C;
        C = b2Math.Clamp(C + b2Settings.b2_angularSlop, -b2Settings.b2_maxAngularCorrection, 0);
        limitImpulse = -this.m_motorMass * C
      }else {
        if(this.m_limitState == b2Joint.e_atUpperLimit) {
          C = angle - this.m_upperAngle;
          angularError = C;
          C = b2Math.Clamp(C - b2Settings.b2_angularSlop, 0, b2Settings.b2_maxAngularCorrection);
          limitImpulse = -this.m_motorMass * C
        }
      }
    }
    bA.m_sweep.a -= bA.m_invI * limitImpulse;
    bB.m_sweep.a += bB.m_invI * limitImpulse;
    bA.SynchronizeTransform();
    bB.SynchronizeTransform()
  }
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var CX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
  var CY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
  var CLengthSquared = CX * CX + CY * CY;
  var CLength = Math.sqrt(CLengthSquared);
  positionError = CLength;
  var invMass1 = bA.m_invMass;
  var invMass2 = bB.m_invMass;
  var invI1 = bA.m_invI;
  var invI2 = bB.m_invI;
  var k_allowedStretch = 10 * b2Settings.b2_linearSlop;
  if(CLengthSquared > k_allowedStretch * k_allowedStretch) {
    var uX = CX / CLength;
    var uY = CY / CLength;
    var k = invMass1 + invMass2;
    var m = 1 / k;
    impulseX = m * -CX;
    impulseY = m * -CY;
    var k_beta = 0.5;
    bA.m_sweep.c.x -= k_beta * invMass1 * impulseX;
    bA.m_sweep.c.y -= k_beta * invMass1 * impulseY;
    bB.m_sweep.c.x += k_beta * invMass2 * impulseX;
    bB.m_sweep.c.y += k_beta * invMass2 * impulseY;
    CX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
    CY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y
  }
  this.K1.col1.x = invMass1 + invMass2;
  this.K1.col2.x = 0;
  this.K1.col1.y = 0;
  this.K1.col2.y = invMass1 + invMass2;
  this.K2.col1.x = invI1 * r1Y * r1Y;
  this.K2.col2.x = -invI1 * r1X * r1Y;
  this.K2.col1.y = -invI1 * r1X * r1Y;
  this.K2.col2.y = invI1 * r1X * r1X;
  this.K3.col1.x = invI2 * r2Y * r2Y;
  this.K3.col2.x = -invI2 * r2X * r2Y;
  this.K3.col1.y = -invI2 * r2X * r2Y;
  this.K3.col2.y = invI2 * r2X * r2X;
  this.K.SetM(this.K1);
  this.K.AddM(this.K2);
  this.K.AddM(this.K3);
  this.K.Solve(b2RevoluteJoint.tImpulse, -CX, -CY);
  impulseX = b2RevoluteJoint.tImpulse.x;
  impulseY = b2RevoluteJoint.tImpulse.y;
  bA.m_sweep.c.x -= bA.m_invMass * impulseX;
  bA.m_sweep.c.y -= bA.m_invMass * impulseY;
  bA.m_sweep.a -= bA.m_invI * (r1X * impulseY - r1Y * impulseX);
  bB.m_sweep.c.x += bB.m_invMass * impulseX;
  bB.m_sweep.c.y += bB.m_invMass * impulseY;
  bB.m_sweep.a += bB.m_invI * (r2X * impulseY - r2Y * impulseX);
  bA.SynchronizeTransform();
  bB.SynchronizeTransform();
  return positionError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop
};
b2RevoluteJoint.prototype.GetAnchorA = function() {
  return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
};
b2RevoluteJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
};
b2RevoluteJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y)
};
b2RevoluteJoint.prototype.GetReactionTorque = function(inv_dt) {
  return inv_dt * this.m_impulse.z
};
b2RevoluteJoint.prototype.GetJointAngle = function() {
  return this.m_bodyB.m_sweep.a - this.m_bodyA.m_sweep.a - this.m_referenceAngle
};
b2RevoluteJoint.prototype.GetJointSpeed = function() {
  return this.m_bodyB.m_angularVelocity - this.m_bodyA.m_angularVelocity
};
b2RevoluteJoint.prototype.IsLimitEnabled = function() {
  return this.m_enableLimit
};
b2RevoluteJoint.prototype.EnableLimit = function(flag) {
  this.m_enableLimit = flag
};
b2RevoluteJoint.prototype.GetLowerLimit = function() {
  return this.m_lowerAngle
};
b2RevoluteJoint.prototype.GetUpperLimit = function() {
  return this.m_upperAngle
};
b2RevoluteJoint.prototype.SetLimits = function(lower, upper) {
  this.m_lowerAngle = lower;
  this.m_upperAngle = upper
};
b2RevoluteJoint.prototype.IsMotorEnabled = function() {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  return this.m_enableMotor
};
b2RevoluteJoint.prototype.EnableMotor = function(flag) {
  this.m_enableMotor = flag
};
b2RevoluteJoint.prototype.SetMotorSpeed = function(speed) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_motorSpeed = speed
};
b2RevoluteJoint.prototype.GetMotorSpeed = function() {
  return this.m_motorSpeed
};
b2RevoluteJoint.prototype.SetMaxMotorTorque = function(torque) {
  this.m_maxMotorTorque = torque
};
b2RevoluteJoint.prototype.GetMotorTorque = function() {
  return this.m_maxMotorTorque
};
b2RevoluteJoint.prototype.K = new b2Mat22;
b2RevoluteJoint.prototype.K1 = new b2Mat22;
b2RevoluteJoint.prototype.K2 = new b2Mat22;
b2RevoluteJoint.prototype.K3 = new b2Mat22;
b2RevoluteJoint.prototype.impulse3 = new b2Vec3;
b2RevoluteJoint.prototype.impulse2 = new b2Vec2;
b2RevoluteJoint.prototype.reduced = new b2Vec2;
b2RevoluteJoint.prototype.m_localAnchor1 = new b2Vec2;
b2RevoluteJoint.prototype.m_localAnchor2 = new b2Vec2;
b2RevoluteJoint.prototype.m_impulse = new b2Vec3;
b2RevoluteJoint.prototype.m_motorImpulse = null;
b2RevoluteJoint.prototype.m_mass = new b2Mat33;
b2RevoluteJoint.prototype.m_motorMass = null;
b2RevoluteJoint.prototype.m_enableMotor = null;
b2RevoluteJoint.prototype.m_maxMotorTorque = null;
b2RevoluteJoint.prototype.m_motorSpeed = null;
b2RevoluteJoint.prototype.m_enableLimit = null;
b2RevoluteJoint.prototype.m_referenceAngle = null;
b2RevoluteJoint.prototype.m_lowerAngle = null;
b2RevoluteJoint.prototype.m_upperAngle = null;
b2RevoluteJoint.prototype.m_limitState = 0;var b2JointDef = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2JointDef.prototype.__constructor = function() {
  this.type = b2Joint.e_unknownJoint;
  this.userData = null;
  this.bodyA = null;
  this.bodyB = null;
  this.collideConnected = false
};
b2JointDef.prototype.__varz = function() {
};
b2JointDef.prototype.type = 0;
b2JointDef.prototype.userData = null;
b2JointDef.prototype.bodyA = null;
b2JointDef.prototype.bodyB = null;
b2JointDef.prototype.collideConnected = null;var b2LineJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2LineJointDef.prototype, b2JointDef.prototype);
b2LineJointDef.prototype._super = b2JointDef.prototype;
b2LineJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_lineJoint;
  this.localAxisA.Set(1, 0);
  this.enableLimit = false;
  this.lowerTranslation = 0;
  this.upperTranslation = 0;
  this.enableMotor = false;
  this.maxMotorForce = 0;
  this.motorSpeed = 0
};
b2LineJointDef.prototype.__varz = function() {
  this.localAnchorA = new b2Vec2;
  this.localAnchorB = new b2Vec2;
  this.localAxisA = new b2Vec2
};
b2LineJointDef.prototype.Initialize = function(bA, bB, anchor, axis) {
  this.bodyA = bA;
  this.bodyB = bB;
  this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
  this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
  this.localAxisA = this.bodyA.GetLocalVector(axis)
};
b2LineJointDef.prototype.localAnchorA = new b2Vec2;
b2LineJointDef.prototype.localAnchorB = new b2Vec2;
b2LineJointDef.prototype.localAxisA = new b2Vec2;
b2LineJointDef.prototype.enableLimit = null;
b2LineJointDef.prototype.lowerTranslation = null;
b2LineJointDef.prototype.upperTranslation = null;
b2LineJointDef.prototype.enableMotor = null;
b2LineJointDef.prototype.maxMotorForce = null;
b2LineJointDef.prototype.motorSpeed = null;var b2DistanceJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2DistanceJoint.prototype, b2Joint.prototype);
b2DistanceJoint.prototype._super = b2Joint.prototype;
b2DistanceJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  var tMat;
  var tX;
  var tY;
  this.m_localAnchor1.SetV(def.localAnchorA);
  this.m_localAnchor2.SetV(def.localAnchorB);
  this.m_length = def.length;
  this.m_frequencyHz = def.frequencyHz;
  this.m_dampingRatio = def.dampingRatio;
  this.m_impulse = 0;
  this.m_gamma = 0;
  this.m_bias = 0
};
b2DistanceJoint.prototype.__varz = function() {
  this.m_localAnchor1 = new b2Vec2;
  this.m_localAnchor2 = new b2Vec2;
  this.m_u = new b2Vec2
};
b2DistanceJoint.prototype.InitVelocityConstraints = function(step) {
  var tMat;
  var tX;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  this.m_u.x = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
  this.m_u.y = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
  var length = Math.sqrt(this.m_u.x * this.m_u.x + this.m_u.y * this.m_u.y);
  if(length > b2Settings.b2_linearSlop) {
    this.m_u.Multiply(1 / length)
  }else {
    this.m_u.SetZero()
  }
  var cr1u = r1X * this.m_u.y - r1Y * this.m_u.x;
  var cr2u = r2X * this.m_u.y - r2Y * this.m_u.x;
  var invMass = bA.m_invMass + bA.m_invI * cr1u * cr1u + bB.m_invMass + bB.m_invI * cr2u * cr2u;
  this.m_mass = invMass != 0 ? 1 / invMass : 0;
  if(this.m_frequencyHz > 0) {
    var C = length - this.m_length;
    var omega = 2 * Math.PI * this.m_frequencyHz;
    var d = 2 * this.m_mass * this.m_dampingRatio * omega;
    var k = this.m_mass * omega * omega;
    this.m_gamma = step.dt * (d + step.dt * k);
    this.m_gamma = this.m_gamma != 0 ? 1 / this.m_gamma : 0;
    this.m_bias = C * step.dt * k * this.m_gamma;
    this.m_mass = invMass + this.m_gamma;
    this.m_mass = this.m_mass != 0 ? 1 / this.m_mass : 0
  }
  if(step.warmStarting) {
    this.m_impulse *= step.dtRatio;
    var PX = this.m_impulse * this.m_u.x;
    var PY = this.m_impulse * this.m_u.y;
    bA.m_linearVelocity.x -= bA.m_invMass * PX;
    bA.m_linearVelocity.y -= bA.m_invMass * PY;
    bA.m_angularVelocity -= bA.m_invI * (r1X * PY - r1Y * PX);
    bB.m_linearVelocity.x += bB.m_invMass * PX;
    bB.m_linearVelocity.y += bB.m_invMass * PY;
    bB.m_angularVelocity += bB.m_invI * (r2X * PY - r2Y * PX)
  }else {
    this.m_impulse = 0
  }
};
b2DistanceJoint.prototype.SolveVelocityConstraints = function(step) {
  var tMat;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var v1X = bA.m_linearVelocity.x + -bA.m_angularVelocity * r1Y;
  var v1Y = bA.m_linearVelocity.y + bA.m_angularVelocity * r1X;
  var v2X = bB.m_linearVelocity.x + -bB.m_angularVelocity * r2Y;
  var v2Y = bB.m_linearVelocity.y + bB.m_angularVelocity * r2X;
  var Cdot = this.m_u.x * (v2X - v1X) + this.m_u.y * (v2Y - v1Y);
  var impulse = -this.m_mass * (Cdot + this.m_bias + this.m_gamma * this.m_impulse);
  this.m_impulse += impulse;
  var PX = impulse * this.m_u.x;
  var PY = impulse * this.m_u.y;
  bA.m_linearVelocity.x -= bA.m_invMass * PX;
  bA.m_linearVelocity.y -= bA.m_invMass * PY;
  bA.m_angularVelocity -= bA.m_invI * (r1X * PY - r1Y * PX);
  bB.m_linearVelocity.x += bB.m_invMass * PX;
  bB.m_linearVelocity.y += bB.m_invMass * PY;
  bB.m_angularVelocity += bB.m_invI * (r2X * PY - r2Y * PX)
};
b2DistanceJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  var tMat;
  if(this.m_frequencyHz > 0) {
    return true
  }
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
  var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
  var length = Math.sqrt(dX * dX + dY * dY);
  dX /= length;
  dY /= length;
  var C = length - this.m_length;
  C = b2Math.Clamp(C, -b2Settings.b2_maxLinearCorrection, b2Settings.b2_maxLinearCorrection);
  var impulse = -this.m_mass * C;
  this.m_u.Set(dX, dY);
  var PX = impulse * this.m_u.x;
  var PY = impulse * this.m_u.y;
  bA.m_sweep.c.x -= bA.m_invMass * PX;
  bA.m_sweep.c.y -= bA.m_invMass * PY;
  bA.m_sweep.a -= bA.m_invI * (r1X * PY - r1Y * PX);
  bB.m_sweep.c.x += bB.m_invMass * PX;
  bB.m_sweep.c.y += bB.m_invMass * PY;
  bB.m_sweep.a += bB.m_invI * (r2X * PY - r2Y * PX);
  bA.SynchronizeTransform();
  bB.SynchronizeTransform();
  return b2Math.Abs(C) < b2Settings.b2_linearSlop
};
b2DistanceJoint.prototype.GetAnchorA = function() {
  return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
};
b2DistanceJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
};
b2DistanceJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * this.m_impulse * this.m_u.x, inv_dt * this.m_impulse * this.m_u.y)
};
b2DistanceJoint.prototype.GetReactionTorque = function(inv_dt) {
  return 0
};
b2DistanceJoint.prototype.GetLength = function() {
  return this.m_length
};
b2DistanceJoint.prototype.SetLength = function(length) {
  this.m_length = length
};
b2DistanceJoint.prototype.GetFrequency = function() {
  return this.m_frequencyHz
};
b2DistanceJoint.prototype.SetFrequency = function(hz) {
  this.m_frequencyHz = hz
};
b2DistanceJoint.prototype.GetDampingRatio = function() {
  return this.m_dampingRatio
};
b2DistanceJoint.prototype.SetDampingRatio = function(ratio) {
  this.m_dampingRatio = ratio
};
b2DistanceJoint.prototype.m_localAnchor1 = new b2Vec2;
b2DistanceJoint.prototype.m_localAnchor2 = new b2Vec2;
b2DistanceJoint.prototype.m_u = new b2Vec2;
b2DistanceJoint.prototype.m_frequencyHz = null;
b2DistanceJoint.prototype.m_dampingRatio = null;
b2DistanceJoint.prototype.m_gamma = null;
b2DistanceJoint.prototype.m_bias = null;
b2DistanceJoint.prototype.m_impulse = null;
b2DistanceJoint.prototype.m_mass = null;
b2DistanceJoint.prototype.m_length = null;var b2PulleyJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2PulleyJointDef.prototype, b2JointDef.prototype);
b2PulleyJointDef.prototype._super = b2JointDef.prototype;
b2PulleyJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_pulleyJoint;
  this.groundAnchorA.Set(-1, 1);
  this.groundAnchorB.Set(1, 1);
  this.localAnchorA.Set(-1, 0);
  this.localAnchorB.Set(1, 0);
  this.lengthA = 0;
  this.maxLengthA = 0;
  this.lengthB = 0;
  this.maxLengthB = 0;
  this.ratio = 1;
  this.collideConnected = true
};
b2PulleyJointDef.prototype.__varz = function() {
  this.groundAnchorA = new b2Vec2;
  this.groundAnchorB = new b2Vec2;
  this.localAnchorA = new b2Vec2;
  this.localAnchorB = new b2Vec2
};
b2PulleyJointDef.prototype.Initialize = function(bA, bB, gaA, gaB, anchorA, anchorB, r) {
  this.bodyA = bA;
  this.bodyB = bB;
  this.groundAnchorA.SetV(gaA);
  this.groundAnchorB.SetV(gaB);
  this.localAnchorA = this.bodyA.GetLocalPoint(anchorA);
  this.localAnchorB = this.bodyB.GetLocalPoint(anchorB);
  var d1X = anchorA.x - gaA.x;
  var d1Y = anchorA.y - gaA.y;
  this.lengthA = Math.sqrt(d1X * d1X + d1Y * d1Y);
  var d2X = anchorB.x - gaB.x;
  var d2Y = anchorB.y - gaB.y;
  this.lengthB = Math.sqrt(d2X * d2X + d2Y * d2Y);
  this.ratio = r;
  var C = this.lengthA + this.ratio * this.lengthB;
  this.maxLengthA = C - this.ratio * b2PulleyJoint.b2_minPulleyLength;
  this.maxLengthB = (C - b2PulleyJoint.b2_minPulleyLength) / this.ratio
};
b2PulleyJointDef.prototype.groundAnchorA = new b2Vec2;
b2PulleyJointDef.prototype.groundAnchorB = new b2Vec2;
b2PulleyJointDef.prototype.localAnchorA = new b2Vec2;
b2PulleyJointDef.prototype.localAnchorB = new b2Vec2;
b2PulleyJointDef.prototype.lengthA = null;
b2PulleyJointDef.prototype.maxLengthA = null;
b2PulleyJointDef.prototype.lengthB = null;
b2PulleyJointDef.prototype.maxLengthB = null;
b2PulleyJointDef.prototype.ratio = null;var b2DistanceJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2DistanceJointDef.prototype, b2JointDef.prototype);
b2DistanceJointDef.prototype._super = b2JointDef.prototype;
b2DistanceJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_distanceJoint;
  this.length = 1;
  this.frequencyHz = 0;
  this.dampingRatio = 0
};
b2DistanceJointDef.prototype.__varz = function() {
  this.localAnchorA = new b2Vec2;
  this.localAnchorB = new b2Vec2
};
b2DistanceJointDef.prototype.Initialize = function(bA, bB, anchorA, anchorB) {
  this.bodyA = bA;
  this.bodyB = bB;
  this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchorA));
  this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchorB));
  var dX = anchorB.x - anchorA.x;
  var dY = anchorB.y - anchorA.y;
  this.length = Math.sqrt(dX * dX + dY * dY);
  this.frequencyHz = 0;
  this.dampingRatio = 0
};
b2DistanceJointDef.prototype.localAnchorA = new b2Vec2;
b2DistanceJointDef.prototype.localAnchorB = new b2Vec2;
b2DistanceJointDef.prototype.length = null;
b2DistanceJointDef.prototype.frequencyHz = null;
b2DistanceJointDef.prototype.dampingRatio = null;var b2FrictionJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2FrictionJointDef.prototype, b2JointDef.prototype);
b2FrictionJointDef.prototype._super = b2JointDef.prototype;
b2FrictionJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_frictionJoint;
  this.maxForce = 0;
  this.maxTorque = 0
};
b2FrictionJointDef.prototype.__varz = function() {
  this.localAnchorA = new b2Vec2;
  this.localAnchorB = new b2Vec2
};
b2FrictionJointDef.prototype.Initialize = function(bA, bB, anchor) {
  this.bodyA = bA;
  this.bodyB = bB;
  this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchor));
  this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchor))
};
b2FrictionJointDef.prototype.localAnchorA = new b2Vec2;
b2FrictionJointDef.prototype.localAnchorB = new b2Vec2;
b2FrictionJointDef.prototype.maxForce = null;
b2FrictionJointDef.prototype.maxTorque = null;var b2WeldJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2WeldJointDef.prototype, b2JointDef.prototype);
b2WeldJointDef.prototype._super = b2JointDef.prototype;
b2WeldJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_weldJoint;
  this.referenceAngle = 0
};
b2WeldJointDef.prototype.__varz = function() {
  this.localAnchorA = new b2Vec2;
  this.localAnchorB = new b2Vec2
};
b2WeldJointDef.prototype.Initialize = function(bA, bB, anchor) {
  this.bodyA = bA;
  this.bodyB = bB;
  this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchor));
  this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchor));
  this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle()
};
b2WeldJointDef.prototype.localAnchorA = new b2Vec2;
b2WeldJointDef.prototype.localAnchorB = new b2Vec2;
b2WeldJointDef.prototype.referenceAngle = null;var b2GearJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2GearJointDef.prototype, b2JointDef.prototype);
b2GearJointDef.prototype._super = b2JointDef.prototype;
b2GearJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_gearJoint;
  this.joint1 = null;
  this.joint2 = null;
  this.ratio = 1
};
b2GearJointDef.prototype.__varz = function() {
};
b2GearJointDef.prototype.joint1 = null;
b2GearJointDef.prototype.joint2 = null;
b2GearJointDef.prototype.ratio = null;var b2Color = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Color.prototype.__constructor = function(rr, gg, bb) {
  this._r = parseInt(255 * b2Math.Clamp(rr, 0, 1));
  this._g = parseInt(255 * b2Math.Clamp(gg, 0, 1));
  this._b = parseInt(255 * b2Math.Clamp(bb, 0, 1))
};
b2Color.prototype.__varz = function() {
};
b2Color.prototype.Set = function(rr, gg, bb) {
  this._r = parseInt(255 * b2Math.Clamp(rr, 0, 1));
  this._g = parseInt(255 * b2Math.Clamp(gg, 0, 1));
  this._b = parseInt(255 * b2Math.Clamp(bb, 0, 1))
};
b2Color.prototype.__defineGetter__("r", function() {
  return this._r
});
b2Color.prototype.__defineSetter__("r", function(rr) {
  this._r = parseInt(255 * b2Math.Clamp(rr, 0, 1))
});
b2Color.prototype.__defineGetter__("g", function() {
  return this._g
});
b2Color.prototype.__defineSetter__("g", function(gg) {
  this._g = parseInt(255 * b2Math.Clamp(gg, 0, 1))
});
b2Color.prototype.__defineGetter__("b", function() {
  return this._g
});
b2Color.prototype.__defineSetter__("b", function(bb) {
  this._b = parseInt(255 * b2Math.Clamp(bb, 0, 1))
});
b2Color.prototype.__defineGetter__("color", function() {
  return this._r << 16 | this._g << 8 | this._b
});
b2Color.prototype._r = 0;
b2Color.prototype._g = 0;
b2Color.prototype._b = 0;var b2FrictionJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2FrictionJoint.prototype, b2Joint.prototype);
b2FrictionJoint.prototype._super = b2Joint.prototype;
b2FrictionJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  this.m_localAnchorA.SetV(def.localAnchorA);
  this.m_localAnchorB.SetV(def.localAnchorB);
  this.m_linearMass.SetZero();
  this.m_angularMass = 0;
  this.m_linearImpulse.SetZero();
  this.m_angularImpulse = 0;
  this.m_maxForce = def.maxForce;
  this.m_maxTorque = def.maxTorque
};
b2FrictionJoint.prototype.__varz = function() {
  this.m_localAnchorA = new b2Vec2;
  this.m_localAnchorB = new b2Vec2;
  this.m_linearImpulse = new b2Vec2;
  this.m_linearMass = new b2Mat22
};
b2FrictionJoint.prototype.InitVelocityConstraints = function(step) {
  var tMat;
  var tX;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  tMat = bA.m_xf.R;
  var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
  var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
  tX = tMat.col1.x * rAX + tMat.col2.x * rAY;
  rAY = tMat.col1.y * rAX + tMat.col2.y * rAY;
  rAX = tX;
  tMat = bB.m_xf.R;
  var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
  var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * rBX + tMat.col2.x * rBY;
  rBY = tMat.col1.y * rBX + tMat.col2.y * rBY;
  rBX = tX;
  var mA = bA.m_invMass;
  var mB = bB.m_invMass;
  var iA = bA.m_invI;
  var iB = bB.m_invI;
  var K = new b2Mat22;
  K.col1.x = mA + mB;
  K.col2.x = 0;
  K.col1.y = 0;
  K.col2.y = mA + mB;
  K.col1.x += iA * rAY * rAY;
  K.col2.x += -iA * rAX * rAY;
  K.col1.y += -iA * rAX * rAY;
  K.col2.y += iA * rAX * rAX;
  K.col1.x += iB * rBY * rBY;
  K.col2.x += -iB * rBX * rBY;
  K.col1.y += -iB * rBX * rBY;
  K.col2.y += iB * rBX * rBX;
  K.GetInverse(this.m_linearMass);
  this.m_angularMass = iA + iB;
  if(this.m_angularMass > 0) {
    this.m_angularMass = 1 / this.m_angularMass
  }
  if(step.warmStarting) {
    this.m_linearImpulse.x *= step.dtRatio;
    this.m_linearImpulse.y *= step.dtRatio;
    this.m_angularImpulse *= step.dtRatio;
    var P = this.m_linearImpulse;
    bA.m_linearVelocity.x -= mA * P.x;
    bA.m_linearVelocity.y -= mA * P.y;
    bA.m_angularVelocity -= iA * (rAX * P.y - rAY * P.x + this.m_angularImpulse);
    bB.m_linearVelocity.x += mB * P.x;
    bB.m_linearVelocity.y += mB * P.y;
    bB.m_angularVelocity += iB * (rBX * P.y - rBY * P.x + this.m_angularImpulse)
  }else {
    this.m_linearImpulse.SetZero();
    this.m_angularImpulse = 0
  }
};
b2FrictionJoint.prototype.SolveVelocityConstraints = function(step) {
  var tMat;
  var tX;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var vA = bA.m_linearVelocity;
  var wA = bA.m_angularVelocity;
  var vB = bB.m_linearVelocity;
  var wB = bB.m_angularVelocity;
  var mA = bA.m_invMass;
  var mB = bB.m_invMass;
  var iA = bA.m_invI;
  var iB = bB.m_invI;
  tMat = bA.m_xf.R;
  var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
  var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
  tX = tMat.col1.x * rAX + tMat.col2.x * rAY;
  rAY = tMat.col1.y * rAX + tMat.col2.y * rAY;
  rAX = tX;
  tMat = bB.m_xf.R;
  var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
  var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * rBX + tMat.col2.x * rBY;
  rBY = tMat.col1.y * rBX + tMat.col2.y * rBY;
  rBX = tX;
  var maxImpulse;
  var Cdot = wB - wA;
  var impulse = -this.m_angularMass * Cdot;
  var oldImpulse = this.m_angularImpulse;
  maxImpulse = step.dt * this.m_maxTorque;
  this.m_angularImpulse = b2Math.Clamp(this.m_angularImpulse + impulse, -maxImpulse, maxImpulse);
  impulse = this.m_angularImpulse - oldImpulse;
  wA -= iA * impulse;
  wB += iB * impulse;
  var CdotX = vB.x - wB * rBY - vA.x + wA * rAY;
  var CdotY = vB.y + wB * rBX - vA.y - wA * rAX;
  var impulseV = b2Math.MulMV(this.m_linearMass, new b2Vec2(-CdotX, -CdotY));
  var oldImpulseV = this.m_linearImpulse.Copy();
  this.m_linearImpulse.Add(impulseV);
  maxImpulse = step.dt * this.m_maxForce;
  if(this.m_linearImpulse.LengthSquared() > maxImpulse * maxImpulse) {
    this.m_linearImpulse.Normalize();
    this.m_linearImpulse.Multiply(maxImpulse)
  }
  impulseV = b2Math.SubtractVV(this.m_linearImpulse, oldImpulseV);
  vA.x -= mA * impulseV.x;
  vA.y -= mA * impulseV.y;
  wA -= iA * (rAX * impulseV.y - rAY * impulseV.x);
  vB.x += mB * impulseV.x;
  vB.y += mB * impulseV.y;
  wB += iB * (rBX * impulseV.y - rBY * impulseV.x);
  bA.m_angularVelocity = wA;
  bB.m_angularVelocity = wB
};
b2FrictionJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  return true
};
b2FrictionJoint.prototype.GetAnchorA = function() {
  return this.m_bodyA.GetWorldPoint(this.m_localAnchorA)
};
b2FrictionJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchorB)
};
b2FrictionJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * this.m_linearImpulse.x, inv_dt * this.m_linearImpulse.y)
};
b2FrictionJoint.prototype.GetReactionTorque = function(inv_dt) {
  return inv_dt * this.m_angularImpulse
};
b2FrictionJoint.prototype.SetMaxForce = function(force) {
  this.m_maxForce = force
};
b2FrictionJoint.prototype.GetMaxForce = function() {
  return this.m_maxForce
};
b2FrictionJoint.prototype.SetMaxTorque = function(torque) {
  this.m_maxTorque = torque
};
b2FrictionJoint.prototype.GetMaxTorque = function() {
  return this.m_maxTorque
};
b2FrictionJoint.prototype.m_localAnchorA = new b2Vec2;
b2FrictionJoint.prototype.m_localAnchorB = new b2Vec2;
b2FrictionJoint.prototype.m_linearImpulse = new b2Vec2;
b2FrictionJoint.prototype.m_angularImpulse = null;
b2FrictionJoint.prototype.m_maxForce = null;
b2FrictionJoint.prototype.m_maxTorque = null;
b2FrictionJoint.prototype.m_linearMass = new b2Mat22;
b2FrictionJoint.prototype.m_angularMass = null;var b2Distance = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Distance.prototype.__constructor = function() {
};
b2Distance.prototype.__varz = function() {
};
b2Distance.Distance = function(output, cache, input) {
  ++b2Distance.b2_gjkCalls;
  var proxyA = input.proxyA;
  var proxyB = input.proxyB;
  var transformA = input.transformA;
  var transformB = input.transformB;
  var simplex = b2Distance.s_simplex;
  simplex.ReadCache(cache, proxyA, transformA, proxyB, transformB);
  var vertices = simplex.m_vertices;
  var k_maxIters = 20;
  var saveA = b2Distance.s_saveA;
  var saveB = b2Distance.s_saveB;
  var saveCount = 0;
  var closestPoint = simplex.GetClosestPoint();
  var distanceSqr1 = closestPoint.LengthSquared();
  var distanceSqr2 = distanceSqr1;
  var i = 0;
  var p;
  var iter = 0;
  while(iter < k_maxIters) {
    saveCount = simplex.m_count;
    for(i = 0;i < saveCount;i++) {
      saveA[i] = vertices[i].indexA;
      saveB[i] = vertices[i].indexB
    }
    switch(simplex.m_count) {
      case 1:
        break;
      case 2:
        simplex.Solve2();
        break;
      case 3:
        simplex.Solve3();
        break;
      default:
        b2Settings.b2Assert(false)
    }
    if(simplex.m_count == 3) {
      break
    }
    p = simplex.GetClosestPoint();
    distanceSqr2 = p.LengthSquared();
    if(distanceSqr2 > distanceSqr1) {
    }
    distanceSqr1 = distanceSqr2;
    var d = simplex.GetSearchDirection();
    if(d.LengthSquared() < Number.MIN_VALUE * Number.MIN_VALUE) {
      break
    }
    var vertex = vertices[simplex.m_count];
    vertex.indexA = proxyA.GetSupport(b2Math.MulTMV(transformA.R, d.GetNegative()));
    vertex.wA = b2Math.MulX(transformA, proxyA.GetVertex(vertex.indexA));
    vertex.indexB = proxyB.GetSupport(b2Math.MulTMV(transformB.R, d));
    vertex.wB = b2Math.MulX(transformB, proxyB.GetVertex(vertex.indexB));
    vertex.w = b2Math.SubtractVV(vertex.wB, vertex.wA);
    ++iter;
    ++b2Distance.b2_gjkIters;
    var duplicate = false;
    for(i = 0;i < saveCount;i++) {
      if(vertex.indexA == saveA[i] && vertex.indexB == saveB[i]) {
        duplicate = true;
        break
      }
    }
    if(duplicate) {
      break
    }
    ++simplex.m_count
  }
  b2Distance.b2_gjkMaxIters = b2Math.Max(b2Distance.b2_gjkMaxIters, iter);
  simplex.GetWitnessPoints(output.pointA, output.pointB);
  output.distance = b2Math.SubtractVV(output.pointA, output.pointB).Length();
  output.iterations = iter;
  simplex.WriteCache(cache);
  if(input.useRadii) {
    var rA = proxyA.m_radius;
    var rB = proxyB.m_radius;
    if(output.distance > rA + rB && output.distance > Number.MIN_VALUE) {
      output.distance -= rA + rB;
      var normal = b2Math.SubtractVV(output.pointB, output.pointA);
      normal.Normalize();
      output.pointA.x += rA * normal.x;
      output.pointA.y += rA * normal.y;
      output.pointB.x -= rB * normal.x;
      output.pointB.y -= rB * normal.y
    }else {
      p = new b2Vec2;
      p.x = 0.5 * (output.pointA.x + output.pointB.x);
      p.y = 0.5 * (output.pointA.y + output.pointB.y);
      output.pointA.x = output.pointB.x = p.x;
      output.pointA.y = output.pointB.y = p.y;
      output.distance = 0
    }
  }
};
b2Distance.b2_gjkCalls = 0;
b2Distance.b2_gjkIters = 0;
b2Distance.b2_gjkMaxIters = 0;
b2Distance.s_simplex = new b2Simplex;
b2Distance.s_saveA = new Array(3);
b2Distance.s_saveB = new Array(3);var b2MouseJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2MouseJoint.prototype, b2Joint.prototype);
b2MouseJoint.prototype._super = b2Joint.prototype;
b2MouseJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  this.m_target.SetV(def.target);
  var tX = this.m_target.x - this.m_bodyB.m_xf.position.x;
  var tY = this.m_target.y - this.m_bodyB.m_xf.position.y;
  var tMat = this.m_bodyB.m_xf.R;
  this.m_localAnchor.x = tX * tMat.col1.x + tY * tMat.col1.y;
  this.m_localAnchor.y = tX * tMat.col2.x + tY * tMat.col2.y;
  this.m_maxForce = def.maxForce;
  this.m_impulse.SetZero();
  this.m_frequencyHz = def.frequencyHz;
  this.m_dampingRatio = def.dampingRatio;
  this.m_beta = 0;
  this.m_gamma = 0
};
b2MouseJoint.prototype.__varz = function() {
  this.K = new b2Mat22;
  this.K1 = new b2Mat22;
  this.K2 = new b2Mat22;
  this.m_localAnchor = new b2Vec2;
  this.m_target = new b2Vec2;
  this.m_impulse = new b2Vec2;
  this.m_mass = new b2Mat22;
  this.m_C = new b2Vec2
};
b2MouseJoint.prototype.InitVelocityConstraints = function(step) {
  var b = this.m_bodyB;
  var mass = b.GetMass();
  var omega = 2 * Math.PI * this.m_frequencyHz;
  var d = 2 * mass * this.m_dampingRatio * omega;
  var k = mass * omega * omega;
  this.m_gamma = step.dt * (d + step.dt * k);
  this.m_gamma = this.m_gamma != 0 ? 1 / this.m_gamma : 0;
  this.m_beta = step.dt * k * this.m_gamma;
  var tMat;
  tMat = b.m_xf.R;
  var rX = this.m_localAnchor.x - b.m_sweep.localCenter.x;
  var rY = this.m_localAnchor.y - b.m_sweep.localCenter.y;
  var tX = tMat.col1.x * rX + tMat.col2.x * rY;
  rY = tMat.col1.y * rX + tMat.col2.y * rY;
  rX = tX;
  var invMass = b.m_invMass;
  var invI = b.m_invI;
  this.K1.col1.x = invMass;
  this.K1.col2.x = 0;
  this.K1.col1.y = 0;
  this.K1.col2.y = invMass;
  this.K2.col1.x = invI * rY * rY;
  this.K2.col2.x = -invI * rX * rY;
  this.K2.col1.y = -invI * rX * rY;
  this.K2.col2.y = invI * rX * rX;
  this.K.SetM(this.K1);
  this.K.AddM(this.K2);
  this.K.col1.x += this.m_gamma;
  this.K.col2.y += this.m_gamma;
  this.K.GetInverse(this.m_mass);
  this.m_C.x = b.m_sweep.c.x + rX - this.m_target.x;
  this.m_C.y = b.m_sweep.c.y + rY - this.m_target.y;
  b.m_angularVelocity *= 0.98;
  this.m_impulse.x *= step.dtRatio;
  this.m_impulse.y *= step.dtRatio;
  b.m_linearVelocity.x += invMass * this.m_impulse.x;
  b.m_linearVelocity.y += invMass * this.m_impulse.y;
  b.m_angularVelocity += invI * (rX * this.m_impulse.y - rY * this.m_impulse.x)
};
b2MouseJoint.prototype.SolveVelocityConstraints = function(step) {
  var b = this.m_bodyB;
  var tMat;
  var tX;
  var tY;
  tMat = b.m_xf.R;
  var rX = this.m_localAnchor.x - b.m_sweep.localCenter.x;
  var rY = this.m_localAnchor.y - b.m_sweep.localCenter.y;
  tX = tMat.col1.x * rX + tMat.col2.x * rY;
  rY = tMat.col1.y * rX + tMat.col2.y * rY;
  rX = tX;
  var CdotX = b.m_linearVelocity.x + -b.m_angularVelocity * rY;
  var CdotY = b.m_linearVelocity.y + b.m_angularVelocity * rX;
  tMat = this.m_mass;
  tX = CdotX + this.m_beta * this.m_C.x + this.m_gamma * this.m_impulse.x;
  tY = CdotY + this.m_beta * this.m_C.y + this.m_gamma * this.m_impulse.y;
  var impulseX = -(tMat.col1.x * tX + tMat.col2.x * tY);
  var impulseY = -(tMat.col1.y * tX + tMat.col2.y * tY);
  var oldImpulseX = this.m_impulse.x;
  var oldImpulseY = this.m_impulse.y;
  this.m_impulse.x += impulseX;
  this.m_impulse.y += impulseY;
  var maxImpulse = step.dt * this.m_maxForce;
  if(this.m_impulse.LengthSquared() > maxImpulse * maxImpulse) {
    this.m_impulse.Multiply(maxImpulse / this.m_impulse.Length())
  }
  impulseX = this.m_impulse.x - oldImpulseX;
  impulseY = this.m_impulse.y - oldImpulseY;
  b.m_linearVelocity.x += b.m_invMass * impulseX;
  b.m_linearVelocity.y += b.m_invMass * impulseY;
  b.m_angularVelocity += b.m_invI * (rX * impulseY - rY * impulseX)
};
b2MouseJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  return true
};
b2MouseJoint.prototype.GetAnchorA = function() {
  return this.m_target
};
b2MouseJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchor)
};
b2MouseJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y)
};
b2MouseJoint.prototype.GetReactionTorque = function(inv_dt) {
  return 0
};
b2MouseJoint.prototype.GetTarget = function() {
  return this.m_target
};
b2MouseJoint.prototype.SetTarget = function(target) {
  if(this.m_bodyB.IsAwake() == false) {
    this.m_bodyB.SetAwake(true)
  }
  this.m_target = target
};
b2MouseJoint.prototype.GetMaxForce = function() {
  return this.m_maxForce
};
b2MouseJoint.prototype.SetMaxForce = function(maxForce) {
  this.m_maxForce = maxForce
};
b2MouseJoint.prototype.GetFrequency = function() {
  return this.m_frequencyHz
};
b2MouseJoint.prototype.SetFrequency = function(hz) {
  this.m_frequencyHz = hz
};
b2MouseJoint.prototype.GetDampingRatio = function() {
  return this.m_dampingRatio
};
b2MouseJoint.prototype.SetDampingRatio = function(ratio) {
  this.m_dampingRatio = ratio
};
b2MouseJoint.prototype.K = new b2Mat22;
b2MouseJoint.prototype.K1 = new b2Mat22;
b2MouseJoint.prototype.K2 = new b2Mat22;
b2MouseJoint.prototype.m_localAnchor = new b2Vec2;
b2MouseJoint.prototype.m_target = new b2Vec2;
b2MouseJoint.prototype.m_impulse = new b2Vec2;
b2MouseJoint.prototype.m_mass = new b2Mat22;
b2MouseJoint.prototype.m_C = new b2Vec2;
b2MouseJoint.prototype.m_maxForce = null;
b2MouseJoint.prototype.m_frequencyHz = null;
b2MouseJoint.prototype.m_dampingRatio = null;
b2MouseJoint.prototype.m_beta = null;
b2MouseJoint.prototype.m_gamma = null;var b2PrismaticJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2PrismaticJointDef.prototype, b2JointDef.prototype);
b2PrismaticJointDef.prototype._super = b2JointDef.prototype;
b2PrismaticJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_prismaticJoint;
  this.localAxisA.Set(1, 0);
  this.referenceAngle = 0;
  this.enableLimit = false;
  this.lowerTranslation = 0;
  this.upperTranslation = 0;
  this.enableMotor = false;
  this.maxMotorForce = 0;
  this.motorSpeed = 0
};
b2PrismaticJointDef.prototype.__varz = function() {
  this.localAnchorA = new b2Vec2;
  this.localAnchorB = new b2Vec2;
  this.localAxisA = new b2Vec2
};
b2PrismaticJointDef.prototype.Initialize = function(bA, bB, anchor, axis) {
  this.bodyA = bA;
  this.bodyB = bB;
  this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
  this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
  this.localAxisA = this.bodyA.GetLocalVector(axis);
  this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle()
};
b2PrismaticJointDef.prototype.localAnchorA = new b2Vec2;
b2PrismaticJointDef.prototype.localAnchorB = new b2Vec2;
b2PrismaticJointDef.prototype.localAxisA = new b2Vec2;
b2PrismaticJointDef.prototype.referenceAngle = null;
b2PrismaticJointDef.prototype.enableLimit = null;
b2PrismaticJointDef.prototype.lowerTranslation = null;
b2PrismaticJointDef.prototype.upperTranslation = null;
b2PrismaticJointDef.prototype.enableMotor = null;
b2PrismaticJointDef.prototype.maxMotorForce = null;
b2PrismaticJointDef.prototype.motorSpeed = null;var b2TimeOfImpact = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2TimeOfImpact.prototype.__constructor = function() {
};
b2TimeOfImpact.prototype.__varz = function() {
};
b2TimeOfImpact.TimeOfImpact = function(input) {
  ++b2TimeOfImpact.b2_toiCalls;
  var proxyA = input.proxyA;
  var proxyB = input.proxyB;
  var sweepA = input.sweepA;
  var sweepB = input.sweepB;
  b2Settings.b2Assert(sweepA.t0 == sweepB.t0);
  b2Settings.b2Assert(1 - sweepA.t0 > Number.MIN_VALUE);
  var radius = proxyA.m_radius + proxyB.m_radius;
  var tolerance = input.tolerance;
  var alpha = 0;
  var k_maxIterations = 1E3;
  var iter = 0;
  var target = 0;
  b2TimeOfImpact.s_cache.count = 0;
  b2TimeOfImpact.s_distanceInput.useRadii = false;
  for(;;) {
    sweepA.GetTransform(b2TimeOfImpact.s_xfA, alpha);
    sweepB.GetTransform(b2TimeOfImpact.s_xfB, alpha);
    b2TimeOfImpact.s_distanceInput.proxyA = proxyA;
    b2TimeOfImpact.s_distanceInput.proxyB = proxyB;
    b2TimeOfImpact.s_distanceInput.transformA = b2TimeOfImpact.s_xfA;
    b2TimeOfImpact.s_distanceInput.transformB = b2TimeOfImpact.s_xfB;
    b2Distance.Distance(b2TimeOfImpact.s_distanceOutput, b2TimeOfImpact.s_cache, b2TimeOfImpact.s_distanceInput);
    if(b2TimeOfImpact.s_distanceOutput.distance <= 0) {
      alpha = 1;
      break
    }
    b2TimeOfImpact.s_fcn.Initialize(b2TimeOfImpact.s_cache, proxyA, b2TimeOfImpact.s_xfA, proxyB, b2TimeOfImpact.s_xfB);
    var separation = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
    if(separation <= 0) {
      alpha = 1;
      break
    }
    if(iter == 0) {
      if(separation > radius) {
        target = b2Math.Max(radius - tolerance, 0.75 * radius)
      }else {
        target = b2Math.Max(separation - tolerance, 0.02 * radius)
      }
    }
    if(separation - target < 0.5 * tolerance) {
      if(iter == 0) {
        alpha = 1;
        break
      }
      break
    }
    var newAlpha = alpha;
    var x1 = alpha;
    var x2 = 1;
    var f1 = separation;
    sweepA.GetTransform(b2TimeOfImpact.s_xfA, x2);
    sweepB.GetTransform(b2TimeOfImpact.s_xfB, x2);
    var f2 = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
    if(f2 >= target) {
      alpha = 1;
      break
    }
    var rootIterCount = 0;
    for(;;) {
      var x;
      if(rootIterCount & 1) {
        x = x1 + (target - f1) * (x2 - x1) / (f2 - f1)
      }else {
        x = 0.5 * (x1 + x2)
      }
      sweepA.GetTransform(b2TimeOfImpact.s_xfA, x);
      sweepB.GetTransform(b2TimeOfImpact.s_xfB, x);
      var f = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
      if(b2Math.Abs(f - target) < 0.025 * tolerance) {
        newAlpha = x;
        break
      }
      if(f > target) {
        x1 = x;
        f1 = f
      }else {
        x2 = x;
        f2 = f
      }
      ++rootIterCount;
      ++b2TimeOfImpact.b2_toiRootIters;
      if(rootIterCount == 50) {
        break
      }
    }
    b2TimeOfImpact.b2_toiMaxRootIters = b2Math.Max(b2TimeOfImpact.b2_toiMaxRootIters, rootIterCount);
    if(newAlpha < (1 + 100 * Number.MIN_VALUE) * alpha) {
      break
    }
    alpha = newAlpha;
    iter++;
    ++b2TimeOfImpact.b2_toiIters;
    if(iter == k_maxIterations) {
      break
    }
  }
  b2TimeOfImpact.b2_toiMaxIters = b2Math.Max(b2TimeOfImpact.b2_toiMaxIters, iter);
  return alpha
};
b2TimeOfImpact.b2_toiCalls = 0;
b2TimeOfImpact.b2_toiIters = 0;
b2TimeOfImpact.b2_toiMaxIters = 0;
b2TimeOfImpact.b2_toiRootIters = 0;
b2TimeOfImpact.b2_toiMaxRootIters = 0;
b2TimeOfImpact.s_cache = new b2SimplexCache;
b2TimeOfImpact.s_distanceInput = new b2DistanceInput;
b2TimeOfImpact.s_xfA = new b2Transform;
b2TimeOfImpact.s_xfB = new b2Transform;
b2TimeOfImpact.s_fcn = new b2SeparationFunction;
b2TimeOfImpact.s_distanceOutput = new b2DistanceOutput;var b2GearJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2GearJoint.prototype, b2Joint.prototype);
b2GearJoint.prototype._super = b2Joint.prototype;
b2GearJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  var type1 = def.joint1.m_type;
  var type2 = def.joint2.m_type;
  this.m_revolute1 = null;
  this.m_prismatic1 = null;
  this.m_revolute2 = null;
  this.m_prismatic2 = null;
  var coordinate1;
  var coordinate2;
  this.m_ground1 = def.joint1.GetBodyA();
  this.m_bodyA = def.joint1.GetBodyB();
  if(type1 == b2Joint.e_revoluteJoint) {
    this.m_revolute1 = def.joint1;
    this.m_groundAnchor1.SetV(this.m_revolute1.m_localAnchor1);
    this.m_localAnchor1.SetV(this.m_revolute1.m_localAnchor2);
    coordinate1 = this.m_revolute1.GetJointAngle()
  }else {
    this.m_prismatic1 = def.joint1;
    this.m_groundAnchor1.SetV(this.m_prismatic1.m_localAnchor1);
    this.m_localAnchor1.SetV(this.m_prismatic1.m_localAnchor2);
    coordinate1 = this.m_prismatic1.GetJointTranslation()
  }
  this.m_ground2 = def.joint2.GetBodyA();
  this.m_bodyB = def.joint2.GetBodyB();
  if(type2 == b2Joint.e_revoluteJoint) {
    this.m_revolute2 = def.joint2;
    this.m_groundAnchor2.SetV(this.m_revolute2.m_localAnchor1);
    this.m_localAnchor2.SetV(this.m_revolute2.m_localAnchor2);
    coordinate2 = this.m_revolute2.GetJointAngle()
  }else {
    this.m_prismatic2 = def.joint2;
    this.m_groundAnchor2.SetV(this.m_prismatic2.m_localAnchor1);
    this.m_localAnchor2.SetV(this.m_prismatic2.m_localAnchor2);
    coordinate2 = this.m_prismatic2.GetJointTranslation()
  }
  this.m_ratio = def.ratio;
  this.m_constant = coordinate1 + this.m_ratio * coordinate2;
  this.m_impulse = 0
};
b2GearJoint.prototype.__varz = function() {
  this.m_groundAnchor1 = new b2Vec2;
  this.m_groundAnchor2 = new b2Vec2;
  this.m_localAnchor1 = new b2Vec2;
  this.m_localAnchor2 = new b2Vec2;
  this.m_J = new b2Jacobian
};
b2GearJoint.prototype.InitVelocityConstraints = function(step) {
  var g1 = this.m_ground1;
  var g2 = this.m_ground2;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var ugX;
  var ugY;
  var rX;
  var rY;
  var tMat;
  var tVec;
  var crug;
  var tX;
  var K = 0;
  this.m_J.SetZero();
  if(this.m_revolute1) {
    this.m_J.angularA = -1;
    K += bA.m_invI
  }else {
    tMat = g1.m_xf.R;
    tVec = this.m_prismatic1.m_localXAxis1;
    ugX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
    ugY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
    tMat = bA.m_xf.R;
    rX = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
    rY = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
    tX = tMat.col1.x * rX + tMat.col2.x * rY;
    rY = tMat.col1.y * rX + tMat.col2.y * rY;
    rX = tX;
    crug = rX * ugY - rY * ugX;
    this.m_J.linearA.Set(-ugX, -ugY);
    this.m_J.angularA = -crug;
    K += bA.m_invMass + bA.m_invI * crug * crug
  }
  if(this.m_revolute2) {
    this.m_J.angularB = -this.m_ratio;
    K += this.m_ratio * this.m_ratio * bB.m_invI
  }else {
    tMat = g2.m_xf.R;
    tVec = this.m_prismatic2.m_localXAxis1;
    ugX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
    ugY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
    tMat = bB.m_xf.R;
    rX = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
    rY = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
    tX = tMat.col1.x * rX + tMat.col2.x * rY;
    rY = tMat.col1.y * rX + tMat.col2.y * rY;
    rX = tX;
    crug = rX * ugY - rY * ugX;
    this.m_J.linearB.Set(-this.m_ratio * ugX, -this.m_ratio * ugY);
    this.m_J.angularB = -this.m_ratio * crug;
    K += this.m_ratio * this.m_ratio * (bB.m_invMass + bB.m_invI * crug * crug)
  }
  this.m_mass = K > 0 ? 1 / K : 0;
  if(step.warmStarting) {
    bA.m_linearVelocity.x += bA.m_invMass * this.m_impulse * this.m_J.linearA.x;
    bA.m_linearVelocity.y += bA.m_invMass * this.m_impulse * this.m_J.linearA.y;
    bA.m_angularVelocity += bA.m_invI * this.m_impulse * this.m_J.angularA;
    bB.m_linearVelocity.x += bB.m_invMass * this.m_impulse * this.m_J.linearB.x;
    bB.m_linearVelocity.y += bB.m_invMass * this.m_impulse * this.m_J.linearB.y;
    bB.m_angularVelocity += bB.m_invI * this.m_impulse * this.m_J.angularB
  }else {
    this.m_impulse = 0
  }
};
b2GearJoint.prototype.SolveVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var Cdot = this.m_J.Compute(bA.m_linearVelocity, bA.m_angularVelocity, bB.m_linearVelocity, bB.m_angularVelocity);
  var impulse = -this.m_mass * Cdot;
  this.m_impulse += impulse;
  bA.m_linearVelocity.x += bA.m_invMass * impulse * this.m_J.linearA.x;
  bA.m_linearVelocity.y += bA.m_invMass * impulse * this.m_J.linearA.y;
  bA.m_angularVelocity += bA.m_invI * impulse * this.m_J.angularA;
  bB.m_linearVelocity.x += bB.m_invMass * impulse * this.m_J.linearB.x;
  bB.m_linearVelocity.y += bB.m_invMass * impulse * this.m_J.linearB.y;
  bB.m_angularVelocity += bB.m_invI * impulse * this.m_J.angularB
};
b2GearJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  var linearError = 0;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var coordinate1;
  var coordinate2;
  if(this.m_revolute1) {
    coordinate1 = this.m_revolute1.GetJointAngle()
  }else {
    coordinate1 = this.m_prismatic1.GetJointTranslation()
  }
  if(this.m_revolute2) {
    coordinate2 = this.m_revolute2.GetJointAngle()
  }else {
    coordinate2 = this.m_prismatic2.GetJointTranslation()
  }
  var C = this.m_constant - (coordinate1 + this.m_ratio * coordinate2);
  var impulse = -this.m_mass * C;
  bA.m_sweep.c.x += bA.m_invMass * impulse * this.m_J.linearA.x;
  bA.m_sweep.c.y += bA.m_invMass * impulse * this.m_J.linearA.y;
  bA.m_sweep.a += bA.m_invI * impulse * this.m_J.angularA;
  bB.m_sweep.c.x += bB.m_invMass * impulse * this.m_J.linearB.x;
  bB.m_sweep.c.y += bB.m_invMass * impulse * this.m_J.linearB.y;
  bB.m_sweep.a += bB.m_invI * impulse * this.m_J.angularB;
  bA.SynchronizeTransform();
  bB.SynchronizeTransform();
  return linearError < b2Settings.b2_linearSlop
};
b2GearJoint.prototype.GetAnchorA = function() {
  return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
};
b2GearJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
};
b2GearJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * this.m_impulse * this.m_J.linearB.x, inv_dt * this.m_impulse * this.m_J.linearB.y)
};
b2GearJoint.prototype.GetReactionTorque = function(inv_dt) {
  var tMat = this.m_bodyB.m_xf.R;
  var rX = this.m_localAnchor1.x - this.m_bodyB.m_sweep.localCenter.x;
  var rY = this.m_localAnchor1.y - this.m_bodyB.m_sweep.localCenter.y;
  var tX = tMat.col1.x * rX + tMat.col2.x * rY;
  rY = tMat.col1.y * rX + tMat.col2.y * rY;
  rX = tX;
  var PX = this.m_impulse * this.m_J.linearB.x;
  var PY = this.m_impulse * this.m_J.linearB.y;
  return inv_dt * (this.m_impulse * this.m_J.angularB - rX * PY + rY * PX)
};
b2GearJoint.prototype.GetRatio = function() {
  return this.m_ratio
};
b2GearJoint.prototype.SetRatio = function(ratio) {
  this.m_ratio = ratio
};
b2GearJoint.prototype.m_ground1 = null;
b2GearJoint.prototype.m_ground2 = null;
b2GearJoint.prototype.m_revolute1 = null;
b2GearJoint.prototype.m_prismatic1 = null;
b2GearJoint.prototype.m_revolute2 = null;
b2GearJoint.prototype.m_prismatic2 = null;
b2GearJoint.prototype.m_groundAnchor1 = new b2Vec2;
b2GearJoint.prototype.m_groundAnchor2 = new b2Vec2;
b2GearJoint.prototype.m_localAnchor1 = new b2Vec2;
b2GearJoint.prototype.m_localAnchor2 = new b2Vec2;
b2GearJoint.prototype.m_J = new b2Jacobian;
b2GearJoint.prototype.m_constant = null;
b2GearJoint.prototype.m_ratio = null;
b2GearJoint.prototype.m_mass = null;
b2GearJoint.prototype.m_impulse = null;var b2TOIInput = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2TOIInput.prototype.__constructor = function() {
};
b2TOIInput.prototype.__varz = function() {
  this.proxyA = new b2DistanceProxy;
  this.proxyB = new b2DistanceProxy;
  this.sweepA = new b2Sweep;
  this.sweepB = new b2Sweep
};
b2TOIInput.prototype.proxyA = new b2DistanceProxy;
b2TOIInput.prototype.proxyB = new b2DistanceProxy;
b2TOIInput.prototype.sweepA = new b2Sweep;
b2TOIInput.prototype.sweepB = new b2Sweep;
b2TOIInput.prototype.tolerance = null;var b2RevoluteJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2RevoluteJointDef.prototype, b2JointDef.prototype);
b2RevoluteJointDef.prototype._super = b2JointDef.prototype;
b2RevoluteJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_revoluteJoint;
  this.localAnchorA.Set(0, 0);
  this.localAnchorB.Set(0, 0);
  this.referenceAngle = 0;
  this.lowerAngle = 0;
  this.upperAngle = 0;
  this.maxMotorTorque = 0;
  this.motorSpeed = 0;
  this.enableLimit = false;
  this.enableMotor = false
};
b2RevoluteJointDef.prototype.__varz = function() {
  this.localAnchorA = new b2Vec2;
  this.localAnchorB = new b2Vec2
};
b2RevoluteJointDef.prototype.Initialize = function(bA, bB, anchor) {
  this.bodyA = bA;
  this.bodyB = bB;
  this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
  this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
  this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle()
};
b2RevoluteJointDef.prototype.localAnchorA = new b2Vec2;
b2RevoluteJointDef.prototype.localAnchorB = new b2Vec2;
b2RevoluteJointDef.prototype.referenceAngle = null;
b2RevoluteJointDef.prototype.enableLimit = null;
b2RevoluteJointDef.prototype.lowerAngle = null;
b2RevoluteJointDef.prototype.upperAngle = null;
b2RevoluteJointDef.prototype.enableMotor = null;
b2RevoluteJointDef.prototype.motorSpeed = null;
b2RevoluteJointDef.prototype.maxMotorTorque = null;var b2MouseJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2MouseJointDef.prototype, b2JointDef.prototype);
b2MouseJointDef.prototype._super = b2JointDef.prototype;
b2MouseJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_mouseJoint;
  this.maxForce = 0;
  this.frequencyHz = 5;
  this.dampingRatio = 0.7
};
b2MouseJointDef.prototype.__varz = function() {
  this.target = new b2Vec2
};
b2MouseJointDef.prototype.target = new b2Vec2;
b2MouseJointDef.prototype.maxForce = null;
b2MouseJointDef.prototype.frequencyHz = null;
b2MouseJointDef.prototype.dampingRatio = null;var b2Contact = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Contact.prototype.__constructor = function() {
};
b2Contact.prototype.__varz = function() {
  this.m_nodeA = new b2ContactEdge;
  this.m_nodeB = new b2ContactEdge;
  this.m_manifold = new b2Manifold;
  this.m_oldManifold = new b2Manifold
};
b2Contact.s_input = new b2TOIInput;
b2Contact.e_sensorFlag = 1;
b2Contact.e_continuousFlag = 2;
b2Contact.e_islandFlag = 4;
b2Contact.e_toiFlag = 8;
b2Contact.e_touchingFlag = 16;
b2Contact.e_enabledFlag = 32;
b2Contact.e_filterFlag = 64;
b2Contact.prototype.Reset = function(fixtureA, fixtureB) {
  this.m_flags = b2Contact.e_enabledFlag;
  if(!fixtureA || !fixtureB) {
    this.m_fixtureA = null;
    this.m_fixtureB = null;
    return
  }
  if(fixtureA.IsSensor() || fixtureB.IsSensor()) {
    this.m_flags |= b2Contact.e_sensorFlag
  }
  var bodyA = fixtureA.GetBody();
  var bodyB = fixtureB.GetBody();
  if(bodyA.GetType() != b2Body.b2_dynamicBody || bodyA.IsBullet() || bodyB.GetType() != b2Body.b2_dynamicBody || bodyB.IsBullet()) {
    this.m_flags |= b2Contact.e_continuousFlag
  }
  this.m_fixtureA = fixtureA;
  this.m_fixtureB = fixtureB;
  this.m_manifold.m_pointCount = 0;
  this.m_prev = null;
  this.m_next = null;
  this.m_nodeA.contact = null;
  this.m_nodeA.prev = null;
  this.m_nodeA.next = null;
  this.m_nodeA.other = null;
  this.m_nodeB.contact = null;
  this.m_nodeB.prev = null;
  this.m_nodeB.next = null;
  this.m_nodeB.other = null
};
b2Contact.prototype.Update = function(listener) {
  var tManifold = this.m_oldManifold;
  this.m_oldManifold = this.m_manifold;
  this.m_manifold = tManifold;
  this.m_flags |= b2Contact.e_enabledFlag;
  var touching = false;
  var wasTouching = (this.m_flags & b2Contact.e_touchingFlag) == b2Contact.e_touchingFlag;
  var bodyA = this.m_fixtureA.m_body;
  var bodyB = this.m_fixtureB.m_body;
  var aabbOverlap = this.m_fixtureA.m_aabb.TestOverlap(this.m_fixtureB.m_aabb);
  if(this.m_flags & b2Contact.e_sensorFlag) {
    if(aabbOverlap) {
      var shapeA = this.m_fixtureA.GetShape();
      var shapeB = this.m_fixtureB.GetShape();
      var xfA = bodyA.GetTransform();
      var xfB = bodyB.GetTransform();
      touching = b2Shape.TestOverlap(shapeA, xfA, shapeB, xfB)
    }
    this.m_manifold.m_pointCount = 0
  }else {
    if(bodyA.GetType() != b2Body.b2_dynamicBody || bodyA.IsBullet() || bodyB.GetType() != b2Body.b2_dynamicBody || bodyB.IsBullet()) {
      this.m_flags |= b2Contact.e_continuousFlag
    }else {
      this.m_flags &= ~b2Contact.e_continuousFlag
    }
    if(aabbOverlap) {
      this.Evaluate();
      touching = this.m_manifold.m_pointCount > 0;
      for(var i = 0;i < this.m_manifold.m_pointCount;++i) {
        var mp2 = this.m_manifold.m_points[i];
        mp2.m_normalImpulse = 0;
        mp2.m_tangentImpulse = 0;
        var id2 = mp2.m_id;
        for(var j = 0;j < this.m_oldManifold.m_pointCount;++j) {
          var mp1 = this.m_oldManifold.m_points[j];
          if(mp1.m_id.key == id2.key) {
            mp2.m_normalImpulse = mp1.m_normalImpulse;
            mp2.m_tangentImpulse = mp1.m_tangentImpulse;
            break
          }
        }
      }
    }else {
      this.m_manifold.m_pointCount = 0
    }
    if(touching != wasTouching) {
      bodyA.SetAwake(true);
      bodyB.SetAwake(true)
    }
  }
  if(touching) {
    this.m_flags |= b2Contact.e_touchingFlag
  }else {
    this.m_flags &= ~b2Contact.e_touchingFlag
  }
  if(wasTouching == false && touching == true) {
    listener.BeginContact(this)
  }
  if(wasTouching == true && touching == false) {
    listener.EndContact(this)
  }
  if((this.m_flags & b2Contact.e_sensorFlag) == 0) {
    listener.PreSolve(this, this.m_oldManifold)
  }
};
b2Contact.prototype.Evaluate = function() {
};
b2Contact.prototype.ComputeTOI = function(sweepA, sweepB) {
  b2Contact.s_input.proxyA.Set(this.m_fixtureA.GetShape());
  b2Contact.s_input.proxyB.Set(this.m_fixtureB.GetShape());
  b2Contact.s_input.sweepA = sweepA;
  b2Contact.s_input.sweepB = sweepB;
  b2Contact.s_input.tolerance = b2Settings.b2_linearSlop;
  return b2TimeOfImpact.TimeOfImpact(b2Contact.s_input)
};
b2Contact.prototype.GetManifold = function() {
  return this.m_manifold
};
b2Contact.prototype.GetWorldManifold = function(worldManifold) {
  var bodyA = this.m_fixtureA.GetBody();
  var bodyB = this.m_fixtureB.GetBody();
  var shapeA = this.m_fixtureA.GetShape();
  var shapeB = this.m_fixtureB.GetShape();
  worldManifold.Initialize(this.m_manifold, bodyA.GetTransform(), shapeA.m_radius, bodyB.GetTransform(), shapeB.m_radius)
};
b2Contact.prototype.IsTouching = function() {
  return(this.m_flags & b2Contact.e_touchingFlag) == b2Contact.e_touchingFlag
};
b2Contact.prototype.IsContinuous = function() {
  return(this.m_flags & b2Contact.e_continuousFlag) == b2Contact.e_continuousFlag
};
b2Contact.prototype.SetSensor = function(sensor) {
  if(sensor) {
    this.m_flags |= b2Contact.e_sensorFlag
  }else {
    this.m_flags &= ~b2Contact.e_sensorFlag
  }
};
b2Contact.prototype.IsSensor = function() {
  return(this.m_flags & b2Contact.e_sensorFlag) == b2Contact.e_sensorFlag
};
b2Contact.prototype.SetEnabled = function(flag) {
  if(flag) {
    this.m_flags |= b2Contact.e_enabledFlag
  }else {
    this.m_flags &= ~b2Contact.e_enabledFlag
  }
};
b2Contact.prototype.IsEnabled = function() {
  return(this.m_flags & b2Contact.e_enabledFlag) == b2Contact.e_enabledFlag
};
b2Contact.prototype.GetNext = function() {
  return this.m_next
};
b2Contact.prototype.GetFixtureA = function() {
  return this.m_fixtureA
};
b2Contact.prototype.GetFixtureB = function() {
  return this.m_fixtureB
};
b2Contact.prototype.FlagForFiltering = function() {
  this.m_flags |= b2Contact.e_filterFlag
};
b2Contact.prototype.m_flags = 0;
b2Contact.prototype.m_prev = null;
b2Contact.prototype.m_next = null;
b2Contact.prototype.m_nodeA = new b2ContactEdge;
b2Contact.prototype.m_nodeB = new b2ContactEdge;
b2Contact.prototype.m_fixtureA = null;
b2Contact.prototype.m_fixtureB = null;
b2Contact.prototype.m_manifold = new b2Manifold;
b2Contact.prototype.m_oldManifold = new b2Manifold;
b2Contact.prototype.m_toi = null;var b2ContactConstraint = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactConstraint.prototype.__constructor = function() {
  this.points = new Array(b2Settings.b2_maxManifoldPoints);
  for(var i = 0;i < b2Settings.b2_maxManifoldPoints;i++) {
    this.points[i] = new b2ContactConstraintPoint
  }
};
b2ContactConstraint.prototype.__varz = function() {
  this.localPlaneNormal = new b2Vec2;
  this.localPoint = new b2Vec2;
  this.normal = new b2Vec2;
  this.normalMass = new b2Mat22;
  this.K = new b2Mat22
};
b2ContactConstraint.prototype.points = null;
b2ContactConstraint.prototype.localPlaneNormal = new b2Vec2;
b2ContactConstraint.prototype.localPoint = new b2Vec2;
b2ContactConstraint.prototype.normal = new b2Vec2;
b2ContactConstraint.prototype.normalMass = new b2Mat22;
b2ContactConstraint.prototype.K = new b2Mat22;
b2ContactConstraint.prototype.bodyA = null;
b2ContactConstraint.prototype.bodyB = null;
b2ContactConstraint.prototype.type = 0;
b2ContactConstraint.prototype.radius = null;
b2ContactConstraint.prototype.friction = null;
b2ContactConstraint.prototype.restitution = null;
b2ContactConstraint.prototype.pointCount = 0;
b2ContactConstraint.prototype.manifold = null;var b2ContactResult = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactResult.prototype.__constructor = function() {
};
b2ContactResult.prototype.__varz = function() {
  this.position = new b2Vec2;
  this.normal = new b2Vec2;
  this.id = new b2ContactID
};
b2ContactResult.prototype.shape1 = null;
b2ContactResult.prototype.shape2 = null;
b2ContactResult.prototype.position = new b2Vec2;
b2ContactResult.prototype.normal = new b2Vec2;
b2ContactResult.prototype.normalImpulse = null;
b2ContactResult.prototype.tangentImpulse = null;
b2ContactResult.prototype.id = new b2ContactID;var b2PolygonContact = function() {
  b2Contact.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2PolygonContact.prototype, b2Contact.prototype);
b2PolygonContact.prototype._super = b2Contact.prototype;
b2PolygonContact.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2PolygonContact.prototype.__varz = function() {
};
b2PolygonContact.Create = function(allocator) {
  return new b2PolygonContact
};
b2PolygonContact.Destroy = function(contact, allocator) {
};
b2PolygonContact.prototype.Evaluate = function() {
  var bA = this.m_fixtureA.GetBody();
  var bB = this.m_fixtureB.GetBody();
  b2Collision.CollidePolygons(this.m_manifold, this.m_fixtureA.GetShape(), bA.m_xf, this.m_fixtureB.GetShape(), bB.m_xf)
};
b2PolygonContact.prototype.Reset = function(fixtureA, fixtureB) {
  this._super.Reset.apply(this, [fixtureA, fixtureB])
};var ClipVertex = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
ClipVertex.prototype.__constructor = function() {
};
ClipVertex.prototype.__varz = function() {
  this.v = new b2Vec2;
  this.id = new b2ContactID
};
ClipVertex.prototype.Set = function(other) {
  this.v.SetV(other.v);
  this.id.Set(other.id)
};
ClipVertex.prototype.v = new b2Vec2;
ClipVertex.prototype.id = new b2ContactID;var b2ContactFilter = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactFilter.prototype.__constructor = function() {
};
b2ContactFilter.prototype.__varz = function() {
};
b2ContactFilter.b2_defaultFilter = new b2ContactFilter;
b2ContactFilter.prototype.ShouldCollide = function(fixtureA, fixtureB) {
  var filter1 = fixtureA.GetFilterData();
  var filter2 = fixtureB.GetFilterData();
  if(filter1.groupIndex == filter2.groupIndex && filter1.groupIndex != 0) {
    return filter1.groupIndex > 0
  }
  var collide = (filter1.maskBits & filter2.categoryBits) != 0 && (filter1.categoryBits & filter2.maskBits) != 0;
  return collide
};
b2ContactFilter.prototype.RayCollide = function(userData, fixture) {
  if(!userData) {
    return true
  }
  return this.ShouldCollide(userData, fixture)
};var b2NullContact = function() {
  b2Contact.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2NullContact.prototype, b2Contact.prototype);
b2NullContact.prototype._super = b2Contact.prototype;
b2NullContact.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2NullContact.prototype.__varz = function() {
};
b2NullContact.prototype.Evaluate = function() {
};var b2ContactListener = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactListener.prototype.__constructor = function() {
};
b2ContactListener.prototype.__varz = function() {
};
b2ContactListener.b2_defaultListener = new b2ContactListener;
b2ContactListener.prototype.BeginContact = function(contact) {
};
b2ContactListener.prototype.EndContact = function(contact) {
};
b2ContactListener.prototype.PreSolve = function(contact, oldManifold) {
};
b2ContactListener.prototype.PostSolve = function(contact, impulse) {
};var b2Island = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Island.prototype.__constructor = function() {
  this.m_bodies = new Array;
  this.m_contacts = new Array;
  this.m_joints = new Array
};
b2Island.prototype.__varz = function() {
};
b2Island.s_impulse = new b2ContactImpulse;
b2Island.prototype.Initialize = function(bodyCapacity, contactCapacity, jointCapacity, allocator, listener, contactSolver) {
  var i = 0;
  this.m_bodyCapacity = bodyCapacity;
  this.m_contactCapacity = contactCapacity;
  this.m_jointCapacity = jointCapacity;
  this.m_bodyCount = 0;
  this.m_contactCount = 0;
  this.m_jointCount = 0;
  this.m_allocator = allocator;
  this.m_listener = listener;
  this.m_contactSolver = contactSolver;
  for(i = this.m_bodies.length;i < bodyCapacity;i++) {
    this.m_bodies[i] = null
  }
  for(i = this.m_contacts.length;i < contactCapacity;i++) {
    this.m_contacts[i] = null
  }
  for(i = this.m_joints.length;i < jointCapacity;i++) {
    this.m_joints[i] = null
  }
};
b2Island.prototype.Clear = function() {
  this.m_bodyCount = 0;
  this.m_contactCount = 0;
  this.m_jointCount = 0
};
b2Island.prototype.Solve = function(step, gravity, allowSleep) {
  var i = 0;
  var j = 0;
  var b;
  var joint;
  for(i = 0;i < this.m_bodyCount;++i) {
    b = this.m_bodies[i];
    if(b.GetType() != b2Body.b2_dynamicBody) {
      continue
    }
    b.m_linearVelocity.x += step.dt * (gravity.x + b.m_invMass * b.m_force.x);
    b.m_linearVelocity.y += step.dt * (gravity.y + b.m_invMass * b.m_force.y);
    b.m_angularVelocity += step.dt * b.m_invI * b.m_torque;
    b.m_linearVelocity.Multiply(b2Math.Clamp(1 - step.dt * b.m_linearDamping, 0, 1));
    b.m_angularVelocity *= b2Math.Clamp(1 - step.dt * b.m_angularDamping, 0, 1)
  }
  this.m_contactSolver.Initialize(step, this.m_contacts, this.m_contactCount, this.m_allocator);
  var contactSolver = this.m_contactSolver;
  contactSolver.InitVelocityConstraints(step);
  for(i = 0;i < this.m_jointCount;++i) {
    joint = this.m_joints[i];
    joint.InitVelocityConstraints(step)
  }
  for(i = 0;i < step.velocityIterations;++i) {
    for(j = 0;j < this.m_jointCount;++j) {
      joint = this.m_joints[j];
      joint.SolveVelocityConstraints(step)
    }
    contactSolver.SolveVelocityConstraints()
  }
  for(i = 0;i < this.m_jointCount;++i) {
    joint = this.m_joints[i];
    joint.FinalizeVelocityConstraints()
  }
  contactSolver.FinalizeVelocityConstraints();
  for(i = 0;i < this.m_bodyCount;++i) {
    b = this.m_bodies[i];
    if(b.GetType() == b2Body.b2_staticBody) {
      continue
    }
    var translationX = step.dt * b.m_linearVelocity.x;
    var translationY = step.dt * b.m_linearVelocity.y;
    if(translationX * translationX + translationY * translationY > b2Settings.b2_maxTranslationSquared) {
      b.m_linearVelocity.Normalize();
      b.m_linearVelocity.x *= b2Settings.b2_maxTranslation * step.inv_dt;
      b.m_linearVelocity.y *= b2Settings.b2_maxTranslation * step.inv_dt
    }
    var rotation = step.dt * b.m_angularVelocity;
    if(rotation * rotation > b2Settings.b2_maxRotationSquared) {
      if(b.m_angularVelocity < 0) {
        b.m_angularVelocity = -b2Settings.b2_maxRotation * step.inv_dt
      }else {
        b.m_angularVelocity = b2Settings.b2_maxRotation * step.inv_dt
      }
    }
    b.m_sweep.c0.SetV(b.m_sweep.c);
    b.m_sweep.a0 = b.m_sweep.a;
    b.m_sweep.c.x += step.dt * b.m_linearVelocity.x;
    b.m_sweep.c.y += step.dt * b.m_linearVelocity.y;
    b.m_sweep.a += step.dt * b.m_angularVelocity;
    b.SynchronizeTransform()
  }
  for(i = 0;i < step.positionIterations;++i) {
    var contactsOkay = contactSolver.SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
    var jointsOkay = true;
    for(j = 0;j < this.m_jointCount;++j) {
      joint = this.m_joints[j];
      var jointOkay = joint.SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
      jointsOkay = jointsOkay && jointOkay
    }
    if(contactsOkay && jointsOkay) {
      break
    }
  }
  this.Report(contactSolver.m_constraints);
  if(allowSleep) {
    var minSleepTime = Number.MAX_VALUE;
    var linTolSqr = b2Settings.b2_linearSleepTolerance * b2Settings.b2_linearSleepTolerance;
    var angTolSqr = b2Settings.b2_angularSleepTolerance * b2Settings.b2_angularSleepTolerance;
    for(i = 0;i < this.m_bodyCount;++i) {
      b = this.m_bodies[i];
      if(b.GetType() == b2Body.b2_staticBody) {
        continue
      }
      if((b.m_flags & b2Body.e_allowSleepFlag) == 0) {
        b.m_sleepTime = 0;
        minSleepTime = 0
      }
      if((b.m_flags & b2Body.e_allowSleepFlag) == 0 || b.m_angularVelocity * b.m_angularVelocity > angTolSqr || b2Math.Dot(b.m_linearVelocity, b.m_linearVelocity) > linTolSqr) {
        b.m_sleepTime = 0;
        minSleepTime = 0
      }else {
        b.m_sleepTime += step.dt;
        minSleepTime = b2Math.Min(minSleepTime, b.m_sleepTime)
      }
    }
    if(minSleepTime >= b2Settings.b2_timeToSleep) {
      for(i = 0;i < this.m_bodyCount;++i) {
        b = this.m_bodies[i];
        b.SetAwake(false)
      }
    }
  }
};
b2Island.prototype.SolveTOI = function(subStep) {
  var i = 0;
  var j = 0;
  this.m_contactSolver.Initialize(subStep, this.m_contacts, this.m_contactCount, this.m_allocator);
  var contactSolver = this.m_contactSolver;
  for(i = 0;i < this.m_jointCount;++i) {
    this.m_joints[i].InitVelocityConstraints(subStep)
  }
  for(i = 0;i < subStep.velocityIterations;++i) {
    contactSolver.SolveVelocityConstraints();
    for(j = 0;j < this.m_jointCount;++j) {
      this.m_joints[j].SolveVelocityConstraints(subStep)
    }
  }
  for(i = 0;i < this.m_bodyCount;++i) {
    var b = this.m_bodies[i];
    if(b.GetType() == b2Body.b2_staticBody) {
      continue
    }
    var translationX = subStep.dt * b.m_linearVelocity.x;
    var translationY = subStep.dt * b.m_linearVelocity.y;
    if(translationX * translationX + translationY * translationY > b2Settings.b2_maxTranslationSquared) {
      b.m_linearVelocity.Normalize();
      b.m_linearVelocity.x *= b2Settings.b2_maxTranslation * subStep.inv_dt;
      b.m_linearVelocity.y *= b2Settings.b2_maxTranslation * subStep.inv_dt
    }
    var rotation = subStep.dt * b.m_angularVelocity;
    if(rotation * rotation > b2Settings.b2_maxRotationSquared) {
      if(b.m_angularVelocity < 0) {
        b.m_angularVelocity = -b2Settings.b2_maxRotation * subStep.inv_dt
      }else {
        b.m_angularVelocity = b2Settings.b2_maxRotation * subStep.inv_dt
      }
    }
    b.m_sweep.c0.SetV(b.m_sweep.c);
    b.m_sweep.a0 = b.m_sweep.a;
    b.m_sweep.c.x += subStep.dt * b.m_linearVelocity.x;
    b.m_sweep.c.y += subStep.dt * b.m_linearVelocity.y;
    b.m_sweep.a += subStep.dt * b.m_angularVelocity;
    b.SynchronizeTransform()
  }
  var k_toiBaumgarte = 0.75;
  for(i = 0;i < subStep.positionIterations;++i) {
    var contactsOkay = contactSolver.SolvePositionConstraints(k_toiBaumgarte);
    var jointsOkay = true;
    for(j = 0;j < this.m_jointCount;++j) {
      var jointOkay = this.m_joints[j].SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
      jointsOkay = jointsOkay && jointOkay
    }
    if(contactsOkay && jointsOkay) {
      break
    }
  }
  this.Report(contactSolver.m_constraints)
};
b2Island.prototype.Report = function(constraints) {
  if(this.m_listener == null) {
    return
  }
  for(var i = 0;i < this.m_contactCount;++i) {
    var c = this.m_contacts[i];
    var cc = constraints[i];
    for(var j = 0;j < cc.pointCount;++j) {
      b2Island.s_impulse.normalImpulses[j] = cc.points[j].normalImpulse;
      b2Island.s_impulse.tangentImpulses[j] = cc.points[j].tangentImpulse
    }
    this.m_listener.PostSolve(c, b2Island.s_impulse)
  }
};
b2Island.prototype.AddBody = function(body) {
  body.m_islandIndex = this.m_bodyCount;
  this.m_bodies[this.m_bodyCount++] = body
};
b2Island.prototype.AddContact = function(contact) {
  this.m_contacts[this.m_contactCount++] = contact
};
b2Island.prototype.AddJoint = function(joint) {
  this.m_joints[this.m_jointCount++] = joint
};
b2Island.prototype.m_allocator = null;
b2Island.prototype.m_listener = null;
b2Island.prototype.m_contactSolver = null;
b2Island.prototype.m_bodies = null;
b2Island.prototype.m_contacts = null;
b2Island.prototype.m_joints = null;
b2Island.prototype.m_bodyCount = 0;
b2Island.prototype.m_jointCount = 0;
b2Island.prototype.m_contactCount = 0;
b2Island.prototype.m_bodyCapacity = 0;
b2Island.prototype.m_contactCapacity = 0;
b2Island.prototype.m_jointCapacity = 0;var b2PolyAndEdgeContact = function() {
  b2Contact.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2PolyAndEdgeContact.prototype, b2Contact.prototype);
b2PolyAndEdgeContact.prototype._super = b2Contact.prototype;
b2PolyAndEdgeContact.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2PolyAndEdgeContact.prototype.__varz = function() {
};
b2PolyAndEdgeContact.Create = function(allocator) {
  return new b2PolyAndEdgeContact
};
b2PolyAndEdgeContact.Destroy = function(contact, allocator) {
};
b2PolyAndEdgeContact.prototype.Evaluate = function() {
  var bA = this.m_fixtureA.GetBody();
  var bB = this.m_fixtureB.GetBody();
  this.b2CollidePolyAndEdge(this.m_manifold, this.m_fixtureA.GetShape(), bA.m_xf, this.m_fixtureB.GetShape(), bB.m_xf)
};
b2PolyAndEdgeContact.prototype.b2CollidePolyAndEdge = function(manifold, polygon, xf1, edge, xf2) {
};
b2PolyAndEdgeContact.prototype.Reset = function(fixtureA, fixtureB) {
  this._super.Reset.apply(this, [fixtureA, fixtureB]);
  b2Settings.b2Assert(fixtureA.GetType() == b2Shape.e_polygonShape);
  b2Settings.b2Assert(fixtureB.GetType() == b2Shape.e_edgeShape)
};var b2Collision = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Collision.prototype.__constructor = function() {
};
b2Collision.prototype.__varz = function() {
};
b2Collision.MakeClipPointVector = function() {
  var r = new Array(2);
  r[0] = new ClipVertex;
  r[1] = new ClipVertex;
  return r
};
b2Collision.ClipSegmentToLine = function(vOut, vIn, normal, offset) {
  var cv;
  var numOut = 0;
  cv = vIn[0];
  var vIn0 = cv.v;
  cv = vIn[1];
  var vIn1 = cv.v;
  var distance0 = normal.x * vIn0.x + normal.y * vIn0.y - offset;
  var distance1 = normal.x * vIn1.x + normal.y * vIn1.y - offset;
  if(distance0 <= 0) {
    vOut[numOut++].Set(vIn[0])
  }
  if(distance1 <= 0) {
    vOut[numOut++].Set(vIn[1])
  }
  if(distance0 * distance1 < 0) {
    var interp = distance0 / (distance0 - distance1);
    cv = vOut[numOut];
    var tVec = cv.v;
    tVec.x = vIn0.x + interp * (vIn1.x - vIn0.x);
    tVec.y = vIn0.y + interp * (vIn1.y - vIn0.y);
    cv = vOut[numOut];
    var cv2;
    if(distance0 > 0) {
      cv2 = vIn[0];
      cv.id = cv2.id
    }else {
      cv2 = vIn[1];
      cv.id = cv2.id
    }
    ++numOut
  }
  return numOut
};
b2Collision.EdgeSeparation = function(poly1, xf1, edge1, poly2, xf2) {
  var count1 = poly1.m_vertexCount;
  var vertices1 = poly1.m_vertices;
  var normals1 = poly1.m_normals;
  var count2 = poly2.m_vertexCount;
  var vertices2 = poly2.m_vertices;
  var tMat;
  var tVec;
  tMat = xf1.R;
  tVec = normals1[edge1];
  var normal1WorldX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
  var normal1WorldY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
  tMat = xf2.R;
  var normal1X = tMat.col1.x * normal1WorldX + tMat.col1.y * normal1WorldY;
  var normal1Y = tMat.col2.x * normal1WorldX + tMat.col2.y * normal1WorldY;
  var index = 0;
  var minDot = Number.MAX_VALUE;
  for(var i = 0;i < count2;++i) {
    tVec = vertices2[i];
    var dot = tVec.x * normal1X + tVec.y * normal1Y;
    if(dot < minDot) {
      minDot = dot;
      index = i
    }
  }
  tVec = vertices1[edge1];
  tMat = xf1.R;
  var v1X = xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  var v1Y = xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  tVec = vertices2[index];
  tMat = xf2.R;
  var v2X = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  var v2Y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  v2X -= v1X;
  v2Y -= v1Y;
  var separation = v2X * normal1WorldX + v2Y * normal1WorldY;
  return separation
};
b2Collision.FindMaxSeparation = function(edgeIndex, poly1, xf1, poly2, xf2) {
  var count1 = poly1.m_vertexCount;
  var normals1 = poly1.m_normals;
  var tVec;
  var tMat;
  tMat = xf2.R;
  tVec = poly2.m_centroid;
  var dX = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  var dY = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  tMat = xf1.R;
  tVec = poly1.m_centroid;
  dX -= xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  dY -= xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  var dLocal1X = dX * xf1.R.col1.x + dY * xf1.R.col1.y;
  var dLocal1Y = dX * xf1.R.col2.x + dY * xf1.R.col2.y;
  var edge = 0;
  var maxDot = -Number.MAX_VALUE;
  for(var i = 0;i < count1;++i) {
    tVec = normals1[i];
    var dot = tVec.x * dLocal1X + tVec.y * dLocal1Y;
    if(dot > maxDot) {
      maxDot = dot;
      edge = i
    }
  }
  var s = b2Collision.EdgeSeparation(poly1, xf1, edge, poly2, xf2);
  var prevEdge = edge - 1 >= 0 ? edge - 1 : count1 - 1;
  var sPrev = b2Collision.EdgeSeparation(poly1, xf1, prevEdge, poly2, xf2);
  var nextEdge = edge + 1 < count1 ? edge + 1 : 0;
  var sNext = b2Collision.EdgeSeparation(poly1, xf1, nextEdge, poly2, xf2);
  var bestEdge = 0;
  var bestSeparation;
  var increment = 0;
  if(sPrev > s && sPrev > sNext) {
    increment = -1;
    bestEdge = prevEdge;
    bestSeparation = sPrev
  }else {
    if(sNext > s) {
      increment = 1;
      bestEdge = nextEdge;
      bestSeparation = sNext
    }else {
      edgeIndex[0] = edge;
      return s
    }
  }
  while(true) {
    if(increment == -1) {
      edge = bestEdge - 1 >= 0 ? bestEdge - 1 : count1 - 1
    }else {
      edge = bestEdge + 1 < count1 ? bestEdge + 1 : 0
    }
    s = b2Collision.EdgeSeparation(poly1, xf1, edge, poly2, xf2);
    if(s > bestSeparation) {
      bestEdge = edge;
      bestSeparation = s
    }else {
      break
    }
  }
  edgeIndex[0] = bestEdge;
  return bestSeparation
};
b2Collision.FindIncidentEdge = function(c, poly1, xf1, edge1, poly2, xf2) {
  var count1 = poly1.m_vertexCount;
  var normals1 = poly1.m_normals;
  var count2 = poly2.m_vertexCount;
  var vertices2 = poly2.m_vertices;
  var normals2 = poly2.m_normals;
  var tMat;
  var tVec;
  tMat = xf1.R;
  tVec = normals1[edge1];
  var normal1X = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
  var normal1Y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
  tMat = xf2.R;
  var tX = tMat.col1.x * normal1X + tMat.col1.y * normal1Y;
  normal1Y = tMat.col2.x * normal1X + tMat.col2.y * normal1Y;
  normal1X = tX;
  var index = 0;
  var minDot = Number.MAX_VALUE;
  for(var i = 0;i < count2;++i) {
    tVec = normals2[i];
    var dot = normal1X * tVec.x + normal1Y * tVec.y;
    if(dot < minDot) {
      minDot = dot;
      index = i
    }
  }
  var tClip;
  var i1 = index;
  var i2 = i1 + 1 < count2 ? i1 + 1 : 0;
  tClip = c[0];
  tVec = vertices2[i1];
  tMat = xf2.R;
  tClip.v.x = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  tClip.v.y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  tClip.id.features.referenceEdge = edge1;
  tClip.id.features.incidentEdge = i1;
  tClip.id.features.incidentVertex = 0;
  tClip = c[1];
  tVec = vertices2[i2];
  tMat = xf2.R;
  tClip.v.x = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  tClip.v.y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  tClip.id.features.referenceEdge = edge1;
  tClip.id.features.incidentEdge = i2;
  tClip.id.features.incidentVertex = 1
};
b2Collision.CollidePolygons = function(manifold, polyA, xfA, polyB, xfB) {
  var cv;
  manifold.m_pointCount = 0;
  var totalRadius = polyA.m_radius + polyB.m_radius;
  var edgeA = 0;
  b2Collision.s_edgeAO[0] = edgeA;
  var separationA = b2Collision.FindMaxSeparation(b2Collision.s_edgeAO, polyA, xfA, polyB, xfB);
  edgeA = b2Collision.s_edgeAO[0];
  if(separationA > totalRadius) {
    return
  }
  var edgeB = 0;
  b2Collision.s_edgeBO[0] = edgeB;
  var separationB = b2Collision.FindMaxSeparation(b2Collision.s_edgeBO, polyB, xfB, polyA, xfA);
  edgeB = b2Collision.s_edgeBO[0];
  if(separationB > totalRadius) {
    return
  }
  var poly1;
  var poly2;
  var xf1;
  var xf2;
  var edge1 = 0;
  var flip = 0;
  var k_relativeTol = 0.98;
  var k_absoluteTol = 0.0010;
  var tMat;
  if(separationB > k_relativeTol * separationA + k_absoluteTol) {
    poly1 = polyB;
    poly2 = polyA;
    xf1 = xfB;
    xf2 = xfA;
    edge1 = edgeB;
    manifold.m_type = b2Manifold.e_faceB;
    flip = 1
  }else {
    poly1 = polyA;
    poly2 = polyB;
    xf1 = xfA;
    xf2 = xfB;
    edge1 = edgeA;
    manifold.m_type = b2Manifold.e_faceA;
    flip = 0
  }
  var incidentEdge = b2Collision.s_incidentEdge;
  b2Collision.FindIncidentEdge(incidentEdge, poly1, xf1, edge1, poly2, xf2);
  var count1 = poly1.m_vertexCount;
  var vertices1 = poly1.m_vertices;
  var local_v11 = vertices1[edge1];
  var local_v12;
  if(edge1 + 1 < count1) {
    local_v12 = vertices1[parseInt(edge1 + 1)]
  }else {
    local_v12 = vertices1[0]
  }
  var localTangent = b2Collision.s_localTangent;
  localTangent.Set(local_v12.x - local_v11.x, local_v12.y - local_v11.y);
  localTangent.Normalize();
  var localNormal = b2Collision.s_localNormal;
  localNormal.x = localTangent.y;
  localNormal.y = -localTangent.x;
  var planePoint = b2Collision.s_planePoint;
  planePoint.Set(0.5 * (local_v11.x + local_v12.x), 0.5 * (local_v11.y + local_v12.y));
  var tangent = b2Collision.s_tangent;
  tMat = xf1.R;
  tangent.x = tMat.col1.x * localTangent.x + tMat.col2.x * localTangent.y;
  tangent.y = tMat.col1.y * localTangent.x + tMat.col2.y * localTangent.y;
  var tangent2 = b2Collision.s_tangent2;
  tangent2.x = -tangent.x;
  tangent2.y = -tangent.y;
  var normal = b2Collision.s_normal;
  normal.x = tangent.y;
  normal.y = -tangent.x;
  var v11 = b2Collision.s_v11;
  var v12 = b2Collision.s_v12;
  v11.x = xf1.position.x + (tMat.col1.x * local_v11.x + tMat.col2.x * local_v11.y);
  v11.y = xf1.position.y + (tMat.col1.y * local_v11.x + tMat.col2.y * local_v11.y);
  v12.x = xf1.position.x + (tMat.col1.x * local_v12.x + tMat.col2.x * local_v12.y);
  v12.y = xf1.position.y + (tMat.col1.y * local_v12.x + tMat.col2.y * local_v12.y);
  var frontOffset = normal.x * v11.x + normal.y * v11.y;
  var sideOffset1 = -tangent.x * v11.x - tangent.y * v11.y + totalRadius;
  var sideOffset2 = tangent.x * v12.x + tangent.y * v12.y + totalRadius;
  var clipPoints1 = b2Collision.s_clipPoints1;
  var clipPoints2 = b2Collision.s_clipPoints2;
  var np = 0;
  np = b2Collision.ClipSegmentToLine(clipPoints1, incidentEdge, tangent2, sideOffset1);
  if(np < 2) {
    return
  }
  np = b2Collision.ClipSegmentToLine(clipPoints2, clipPoints1, tangent, sideOffset2);
  if(np < 2) {
    return
  }
  manifold.m_localPlaneNormal.SetV(localNormal);
  manifold.m_localPoint.SetV(planePoint);
  var pointCount = 0;
  for(var i = 0;i < b2Settings.b2_maxManifoldPoints;++i) {
    cv = clipPoints2[i];
    var separation = normal.x * cv.v.x + normal.y * cv.v.y - frontOffset;
    if(separation <= totalRadius) {
      var cp = manifold.m_points[pointCount];
      tMat = xf2.R;
      var tX = cv.v.x - xf2.position.x;
      var tY = cv.v.y - xf2.position.y;
      cp.m_localPoint.x = tX * tMat.col1.x + tY * tMat.col1.y;
      cp.m_localPoint.y = tX * tMat.col2.x + tY * tMat.col2.y;
      cp.m_id.Set(cv.id);
      cp.m_id.features.flip = flip;
      ++pointCount
    }
  }
  manifold.m_pointCount = pointCount
};
b2Collision.CollideCircles = function(manifold, circle1, xf1, circle2, xf2) {
  manifold.m_pointCount = 0;
  var tMat;
  var tVec;
  tMat = xf1.R;
  tVec = circle1.m_p;
  var p1X = xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  var p1Y = xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  tMat = xf2.R;
  tVec = circle2.m_p;
  var p2X = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  var p2Y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  var dX = p2X - p1X;
  var dY = p2Y - p1Y;
  var distSqr = dX * dX + dY * dY;
  var radius = circle1.m_radius + circle2.m_radius;
  if(distSqr > radius * radius) {
    return
  }
  manifold.m_type = b2Manifold.e_circles;
  manifold.m_localPoint.SetV(circle1.m_p);
  manifold.m_localPlaneNormal.SetZero();
  manifold.m_pointCount = 1;
  manifold.m_points[0].m_localPoint.SetV(circle2.m_p);
  manifold.m_points[0].m_id.key = 0
};
b2Collision.CollidePolygonAndCircle = function(manifold, polygon, xf1, circle, xf2) {
  manifold.m_pointCount = 0;
  var tPoint;
  var dX;
  var dY;
  var positionX;
  var positionY;
  var tVec;
  var tMat;
  tMat = xf2.R;
  tVec = circle.m_p;
  var cX = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  var cY = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  dX = cX - xf1.position.x;
  dY = cY - xf1.position.y;
  tMat = xf1.R;
  var cLocalX = dX * tMat.col1.x + dY * tMat.col1.y;
  var cLocalY = dX * tMat.col2.x + dY * tMat.col2.y;
  var dist;
  var normalIndex = 0;
  var separation = -Number.MAX_VALUE;
  var radius = polygon.m_radius + circle.m_radius;
  var vertexCount = polygon.m_vertexCount;
  var vertices = polygon.m_vertices;
  var normals = polygon.m_normals;
  for(var i = 0;i < vertexCount;++i) {
    tVec = vertices[i];
    dX = cLocalX - tVec.x;
    dY = cLocalY - tVec.y;
    tVec = normals[i];
    var s = tVec.x * dX + tVec.y * dY;
    if(s > radius) {
      return
    }
    if(s > separation) {
      separation = s;
      normalIndex = i
    }
  }
  var vertIndex1 = normalIndex;
  var vertIndex2 = vertIndex1 + 1 < vertexCount ? vertIndex1 + 1 : 0;
  var v1 = vertices[vertIndex1];
  var v2 = vertices[vertIndex2];
  if(separation < Number.MIN_VALUE) {
    manifold.m_pointCount = 1;
    manifold.m_type = b2Manifold.e_faceA;
    manifold.m_localPlaneNormal.SetV(normals[normalIndex]);
    manifold.m_localPoint.x = 0.5 * (v1.x + v2.x);
    manifold.m_localPoint.y = 0.5 * (v1.y + v2.y);
    manifold.m_points[0].m_localPoint.SetV(circle.m_p);
    manifold.m_points[0].m_id.key = 0;
    return
  }
  var u1 = (cLocalX - v1.x) * (v2.x - v1.x) + (cLocalY - v1.y) * (v2.y - v1.y);
  var u2 = (cLocalX - v2.x) * (v1.x - v2.x) + (cLocalY - v2.y) * (v1.y - v2.y);
  if(u1 <= 0) {
    if((cLocalX - v1.x) * (cLocalX - v1.x) + (cLocalY - v1.y) * (cLocalY - v1.y) > radius * radius) {
      return
    }
    manifold.m_pointCount = 1;
    manifold.m_type = b2Manifold.e_faceA;
    manifold.m_localPlaneNormal.x = cLocalX - v1.x;
    manifold.m_localPlaneNormal.y = cLocalY - v1.y;
    manifold.m_localPlaneNormal.Normalize();
    manifold.m_localPoint.SetV(v1);
    manifold.m_points[0].m_localPoint.SetV(circle.m_p);
    manifold.m_points[0].m_id.key = 0
  }else {
    if(u2 <= 0) {
      if((cLocalX - v2.x) * (cLocalX - v2.x) + (cLocalY - v2.y) * (cLocalY - v2.y) > radius * radius) {
        return
      }
      manifold.m_pointCount = 1;
      manifold.m_type = b2Manifold.e_faceA;
      manifold.m_localPlaneNormal.x = cLocalX - v2.x;
      manifold.m_localPlaneNormal.y = cLocalY - v2.y;
      manifold.m_localPlaneNormal.Normalize();
      manifold.m_localPoint.SetV(v2);
      manifold.m_points[0].m_localPoint.SetV(circle.m_p);
      manifold.m_points[0].m_id.key = 0
    }else {
      var faceCenterX = 0.5 * (v1.x + v2.x);
      var faceCenterY = 0.5 * (v1.y + v2.y);
      separation = (cLocalX - faceCenterX) * normals[vertIndex1].x + (cLocalY - faceCenterY) * normals[vertIndex1].y;
      if(separation > radius) {
        return
      }
      manifold.m_pointCount = 1;
      manifold.m_type = b2Manifold.e_faceA;
      manifold.m_localPlaneNormal.x = normals[vertIndex1].x;
      manifold.m_localPlaneNormal.y = normals[vertIndex1].y;
      manifold.m_localPlaneNormal.Normalize();
      manifold.m_localPoint.Set(faceCenterX, faceCenterY);
      manifold.m_points[0].m_localPoint.SetV(circle.m_p);
      manifold.m_points[0].m_id.key = 0
    }
  }
};
b2Collision.TestOverlap = function(a, b) {
  var t1 = b.lowerBound;
  var t2 = a.upperBound;
  var d1X = t1.x - t2.x;
  var d1Y = t1.y - t2.y;
  t1 = a.lowerBound;
  t2 = b.upperBound;
  var d2X = t1.x - t2.x;
  var d2Y = t1.y - t2.y;
  if(d1X > 0 || d1Y > 0) {
    return false
  }
  if(d2X > 0 || d2Y > 0) {
    return false
  }
  return true
};
b2Collision.b2_nullFeature = 255;
b2Collision.s_incidentEdge = b2Collision.MakeClipPointVector();
b2Collision.s_clipPoints1 = b2Collision.MakeClipPointVector();
b2Collision.s_clipPoints2 = b2Collision.MakeClipPointVector();
b2Collision.s_edgeAO = new Array(1);
b2Collision.s_edgeBO = new Array(1);
b2Collision.s_localTangent = new b2Vec2;
b2Collision.s_localNormal = new b2Vec2;
b2Collision.s_planePoint = new b2Vec2;
b2Collision.s_normal = new b2Vec2;
b2Collision.s_tangent = new b2Vec2;
b2Collision.s_tangent2 = new b2Vec2;
b2Collision.s_v11 = new b2Vec2;
b2Collision.s_v12 = new b2Vec2;
b2Collision.b2CollidePolyTempVec = new b2Vec2;var b2PolyAndCircleContact = function() {
  b2Contact.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2PolyAndCircleContact.prototype, b2Contact.prototype);
b2PolyAndCircleContact.prototype._super = b2Contact.prototype;
b2PolyAndCircleContact.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2PolyAndCircleContact.prototype.__varz = function() {
};
b2PolyAndCircleContact.Create = function(allocator) {
  return new b2PolyAndCircleContact
};
b2PolyAndCircleContact.Destroy = function(contact, allocator) {
};
b2PolyAndCircleContact.prototype.Evaluate = function() {
  var bA = this.m_fixtureA.m_body;
  var bB = this.m_fixtureB.m_body;
  b2Collision.CollidePolygonAndCircle(this.m_manifold, this.m_fixtureA.GetShape(), bA.m_xf, this.m_fixtureB.GetShape(), bB.m_xf)
};
b2PolyAndCircleContact.prototype.Reset = function(fixtureA, fixtureB) {
  this._super.Reset.apply(this, [fixtureA, fixtureB]);
  b2Settings.b2Assert(fixtureA.GetType() == b2Shape.e_polygonShape);
  b2Settings.b2Assert(fixtureB.GetType() == b2Shape.e_circleShape)
};var b2ContactPoint = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactPoint.prototype.__constructor = function() {
};
b2ContactPoint.prototype.__varz = function() {
  this.position = new b2Vec2;
  this.velocity = new b2Vec2;
  this.normal = new b2Vec2;
  this.id = new b2ContactID
};
b2ContactPoint.prototype.shape1 = null;
b2ContactPoint.prototype.shape2 = null;
b2ContactPoint.prototype.position = new b2Vec2;
b2ContactPoint.prototype.velocity = new b2Vec2;
b2ContactPoint.prototype.normal = new b2Vec2;
b2ContactPoint.prototype.separation = null;
b2ContactPoint.prototype.friction = null;
b2ContactPoint.prototype.restitution = null;
b2ContactPoint.prototype.id = new b2ContactID;var b2CircleContact = function() {
  b2Contact.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2CircleContact.prototype, b2Contact.prototype);
b2CircleContact.prototype._super = b2Contact.prototype;
b2CircleContact.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2CircleContact.prototype.__varz = function() {
};
b2CircleContact.Create = function(allocator) {
  return new b2CircleContact
};
b2CircleContact.Destroy = function(contact, allocator) {
};
b2CircleContact.prototype.Evaluate = function() {
  var bA = this.m_fixtureA.GetBody();
  var bB = this.m_fixtureB.GetBody();
  b2Collision.CollideCircles(this.m_manifold, this.m_fixtureA.GetShape(), bA.m_xf, this.m_fixtureB.GetShape(), bB.m_xf)
};
b2CircleContact.prototype.Reset = function(fixtureA, fixtureB) {
  this._super.Reset.apply(this, [fixtureA, fixtureB])
};var b2EdgeAndCircleContact = function() {
  b2Contact.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2EdgeAndCircleContact.prototype, b2Contact.prototype);
b2EdgeAndCircleContact.prototype._super = b2Contact.prototype;
b2EdgeAndCircleContact.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2EdgeAndCircleContact.prototype.__varz = function() {
};
b2EdgeAndCircleContact.Create = function(allocator) {
  return new b2EdgeAndCircleContact
};
b2EdgeAndCircleContact.Destroy = function(contact, allocator) {
};
b2EdgeAndCircleContact.prototype.Evaluate = function() {
  var bA = this.m_fixtureA.GetBody();
  var bB = this.m_fixtureB.GetBody();
  this.b2CollideEdgeAndCircle(this.m_manifold, this.m_fixtureA.GetShape(), bA.m_xf, this.m_fixtureB.GetShape(), bB.m_xf)
};
b2EdgeAndCircleContact.prototype.b2CollideEdgeAndCircle = function(manifold, edge, xf1, circle, xf2) {
};
b2EdgeAndCircleContact.prototype.Reset = function(fixtureA, fixtureB) {
  this._super.Reset.apply(this, [fixtureA, fixtureB])
};var b2ContactManager = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactManager.prototype.__constructor = function() {
  this.m_world = null;
  this.m_contactCount = 0;
  this.m_contactFilter = b2ContactFilter.b2_defaultFilter;
  this.m_contactListener = b2ContactListener.b2_defaultListener;
  this.m_contactFactory = new b2ContactFactory(this.m_allocator);
  this.m_broadPhase = new b2DynamicTreeBroadPhase
};
b2ContactManager.prototype.__varz = function() {
};
b2ContactManager.s_evalCP = new b2ContactPoint;
b2ContactManager.prototype.AddPair = function(proxyUserDataA, proxyUserDataB) {
  var fixtureA = proxyUserDataA;
  var fixtureB = proxyUserDataB;
  var bodyA = fixtureA.GetBody();
  var bodyB = fixtureB.GetBody();
  if(bodyA == bodyB) {
    return
  }
  var edge = bodyB.GetContactList();
  while(edge) {
    if(edge.other == bodyA) {
      var fA = edge.contact.GetFixtureA();
      var fB = edge.contact.GetFixtureB();
      if(fA == fixtureA && fB == fixtureB) {
        return
      }
      if(fA == fixtureB && fB == fixtureA) {
        return
      }
    }
    edge = edge.next
  }
  if(bodyB.ShouldCollide(bodyA) == false) {
    return
  }
  if(this.m_contactFilter.ShouldCollide(fixtureA, fixtureB) == false) {
    return
  }
  var c = this.m_contactFactory.Create(fixtureA, fixtureB);
  fixtureA = c.GetFixtureA();
  fixtureB = c.GetFixtureB();
  bodyA = fixtureA.m_body;
  bodyB = fixtureB.m_body;
  c.m_prev = null;
  c.m_next = this.m_world.m_contactList;
  if(this.m_world.m_contactList != null) {
    this.m_world.m_contactList.m_prev = c
  }
  this.m_world.m_contactList = c;
  c.m_nodeA.contact = c;
  c.m_nodeA.other = bodyB;
  c.m_nodeA.prev = null;
  c.m_nodeA.next = bodyA.m_contactList;
  if(bodyA.m_contactList != null) {
    bodyA.m_contactList.prev = c.m_nodeA
  }
  bodyA.m_contactList = c.m_nodeA;
  c.m_nodeB.contact = c;
  c.m_nodeB.other = bodyA;
  c.m_nodeB.prev = null;
  c.m_nodeB.next = bodyB.m_contactList;
  if(bodyB.m_contactList != null) {
    bodyB.m_contactList.prev = c.m_nodeB
  }
  bodyB.m_contactList = c.m_nodeB;
  ++this.m_world.m_contactCount;
  return
};
b2ContactManager.prototype.FindNewContacts = function() {
  var that = this;
  this.m_broadPhase.UpdatePairs(function(a, b) {
    return that.AddPair(a, b)
  })
};
b2ContactManager.prototype.Destroy = function(c) {
  var fixtureA = c.GetFixtureA();
  var fixtureB = c.GetFixtureB();
  var bodyA = fixtureA.GetBody();
  var bodyB = fixtureB.GetBody();
  if(c.IsTouching()) {
    this.m_contactListener.EndContact(c)
  }
  if(c.m_prev) {
    c.m_prev.m_next = c.m_next
  }
  if(c.m_next) {
    c.m_next.m_prev = c.m_prev
  }
  if(c == this.m_world.m_contactList) {
    this.m_world.m_contactList = c.m_next
  }
  if(c.m_nodeA.prev) {
    c.m_nodeA.prev.next = c.m_nodeA.next
  }
  if(c.m_nodeA.next) {
    c.m_nodeA.next.prev = c.m_nodeA.prev
  }
  if(c.m_nodeA == bodyA.m_contactList) {
    bodyA.m_contactList = c.m_nodeA.next
  }
  if(c.m_nodeB.prev) {
    c.m_nodeB.prev.next = c.m_nodeB.next
  }
  if(c.m_nodeB.next) {
    c.m_nodeB.next.prev = c.m_nodeB.prev
  }
  if(c.m_nodeB == bodyB.m_contactList) {
    bodyB.m_contactList = c.m_nodeB.next
  }
  this.m_contactFactory.Destroy(c);
  --this.m_contactCount
};
b2ContactManager.prototype.Collide = function() {
  var c = this.m_world.m_contactList;
  while(c) {
    var fixtureA = c.GetFixtureA();
    var fixtureB = c.GetFixtureB();
    var bodyA = fixtureA.GetBody();
    var bodyB = fixtureB.GetBody();
    if(bodyA.IsAwake() == false && bodyB.IsAwake() == false) {
      c = c.GetNext();
      continue
    }
    if(c.m_flags & b2Contact.e_filterFlag) {
      if(bodyB.ShouldCollide(bodyA) == false) {
        var cNuke = c;
        c = cNuke.GetNext();
        this.Destroy(cNuke);
        continue
      }
      if(this.m_contactFilter.ShouldCollide(fixtureA, fixtureB) == false) {
        cNuke = c;
        c = cNuke.GetNext();
        this.Destroy(cNuke);
        continue
      }
      c.m_flags &= ~b2Contact.e_filterFlag
    }
    var proxyA = fixtureA.m_proxy;
    var proxyB = fixtureB.m_proxy;
    var overlap = this.m_broadPhase.TestOverlap(proxyA, proxyB);
    if(overlap == false) {
      cNuke = c;
      c = cNuke.GetNext();
      this.Destroy(cNuke);
      continue
    }
    c.Update(this.m_contactListener);
    c = c.GetNext()
  }
};
b2ContactManager.prototype.m_world = null;
b2ContactManager.prototype.m_broadPhase = null;
b2ContactManager.prototype.m_contactList = null;
b2ContactManager.prototype.m_contactCount = 0;
b2ContactManager.prototype.m_contactFilter = null;
b2ContactManager.prototype.m_contactListener = null;
b2ContactManager.prototype.m_contactFactory = null;
b2ContactManager.prototype.m_allocator = null;var b2World = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2World.prototype.__constructor = function(gravity, doSleep) {
  this.m_destructionListener = null;
  this.m_debugDraw = null;
  this.m_bodyList = null;
  this.m_contactList = null;
  this.m_jointList = null;
  this.m_controllerList = null;
  this.m_bodyCount = 0;
  this.m_contactCount = 0;
  this.m_jointCount = 0;
  this.m_controllerCount = 0;
  b2World.m_warmStarting = true;
  b2World.m_continuousPhysics = true;
  this.m_allowSleep = doSleep;
  this.m_gravity = gravity;
  this.m_inv_dt0 = 0;
  this.m_contactManager.m_world = this;
  var bd = new b2BodyDef;
  this.m_groundBody = this.CreateBody(bd)
};
b2World.prototype.__varz = function() {
  this.s_stack = new Array;
  this.m_contactManager = new b2ContactManager;
  this.m_contactSolver = new b2ContactSolver;
  this.m_island = new b2Island
};
b2World.s_timestep2 = new b2TimeStep;
b2World.s_backupA = new b2Sweep;
b2World.s_backupB = new b2Sweep;
b2World.s_timestep = new b2TimeStep;
b2World.s_queue = new Array;
b2World.e_newFixture = 1;
b2World.e_locked = 2;
b2World.s_xf = new b2Transform;
b2World.s_jointColor = new b2Color(0.5, 0.8, 0.8);
b2World.m_warmStarting = null;
b2World.m_continuousPhysics = null;
b2World.prototype.Solve = function(step) {
  var b;
  for(var controller = this.m_controllerList;controller;controller = controller.m_next) {
    controller.Step(step)
  }
  var island = this.m_island;
  island.Initialize(this.m_bodyCount, this.m_contactCount, this.m_jointCount, null, this.m_contactManager.m_contactListener, this.m_contactSolver);
  for(b = this.m_bodyList;b;b = b.m_next) {
    b.m_flags &= ~b2Body.e_islandFlag
  }
  for(var c = this.m_contactList;c;c = c.m_next) {
    c.m_flags &= ~b2Contact.e_islandFlag
  }
  for(var j = this.m_jointList;j;j = j.m_next) {
    j.m_islandFlag = false
  }
  var stackSize = this.m_bodyCount;
  var stack = this.s_stack;
  for(var seed = this.m_bodyList;seed;seed = seed.m_next) {
    if(seed.m_flags & b2Body.e_islandFlag) {
      continue
    }
    if(seed.IsAwake() == false || seed.IsActive() == false) {
      continue
    }
    if(seed.GetType() == b2Body.b2_staticBody) {
      continue
    }
    island.Clear();
    var stackCount = 0;
    stack[stackCount++] = seed;
    seed.m_flags |= b2Body.e_islandFlag;
    while(stackCount > 0) {
      b = stack[--stackCount];
      island.AddBody(b);
      if(b.IsAwake() == false) {
        b.SetAwake(true)
      }
      if(b.GetType() == b2Body.b2_staticBody) {
        continue
      }
      var other;
      for(var ce = b.m_contactList;ce;ce = ce.next) {
        if(ce.contact.m_flags & b2Contact.e_islandFlag) {
          continue
        }
        if(ce.contact.IsSensor() == true || ce.contact.IsEnabled() == false || ce.contact.IsTouching() == false) {
          continue
        }
        island.AddContact(ce.contact);
        ce.contact.m_flags |= b2Contact.e_islandFlag;
        other = ce.other;
        if(other.m_flags & b2Body.e_islandFlag) {
          continue
        }
        stack[stackCount++] = other;
        other.m_flags |= b2Body.e_islandFlag
      }
      for(var jn = b.m_jointList;jn;jn = jn.next) {
        if(jn.joint.m_islandFlag == true) {
          continue
        }
        other = jn.other;
        if(other.IsActive() == false) {
          continue
        }
        island.AddJoint(jn.joint);
        jn.joint.m_islandFlag = true;
        if(other.m_flags & b2Body.e_islandFlag) {
          continue
        }
        stack[stackCount++] = other;
        other.m_flags |= b2Body.e_islandFlag
      }
    }
    island.Solve(step, this.m_gravity, this.m_allowSleep);
    for(var i = 0;i < island.m_bodyCount;++i) {
      b = island.m_bodies[i];
      if(b.GetType() == b2Body.b2_staticBody) {
        b.m_flags &= ~b2Body.e_islandFlag
      }
    }
  }
  for(i = 0;i < stack.length;++i) {
    if(!stack[i]) {
      break
    }
    stack[i] = null
  }
  for(b = this.m_bodyList;b;b = b.m_next) {
    if(b.IsAwake() == false || b.IsActive() == false) {
      continue
    }
    if(b.GetType() == b2Body.b2_staticBody) {
      continue
    }
    b.SynchronizeFixtures()
  }
  this.m_contactManager.FindNewContacts()
};
b2World.prototype.SolveTOI = function(step) {
  var b;
  var fA;
  var fB;
  var bA;
  var bB;
  var cEdge;
  var j;
  var island = this.m_island;
  island.Initialize(this.m_bodyCount, b2Settings.b2_maxTOIContactsPerIsland, b2Settings.b2_maxTOIJointsPerIsland, null, this.m_contactManager.m_contactListener, this.m_contactSolver);
  var queue = b2World.s_queue;
  for(b = this.m_bodyList;b;b = b.m_next) {
    b.m_flags &= ~b2Body.e_islandFlag;
    b.m_sweep.t0 = 0
  }
  var c;
  for(c = this.m_contactList;c;c = c.m_next) {
    c.m_flags &= ~(b2Contact.e_toiFlag | b2Contact.e_islandFlag)
  }
  for(j = this.m_jointList;j;j = j.m_next) {
    j.m_islandFlag = false
  }
  for(;;) {
    var minContact = null;
    var minTOI = 1;
    for(c = this.m_contactList;c;c = c.m_next) {
      if(c.IsSensor() == true || c.IsEnabled() == false || c.IsContinuous() == false) {
        continue
      }
      var toi = 1;
      if(c.m_flags & b2Contact.e_toiFlag) {
        toi = c.m_toi
      }else {
        fA = c.m_fixtureA;
        fB = c.m_fixtureB;
        bA = fA.m_body;
        bB = fB.m_body;
        if((bA.GetType() != b2Body.b2_dynamicBody || bA.IsAwake() == false) && (bB.GetType() != b2Body.b2_dynamicBody || bB.IsAwake() == false)) {
          continue
        }
        var t0 = bA.m_sweep.t0;
        if(bA.m_sweep.t0 < bB.m_sweep.t0) {
          t0 = bB.m_sweep.t0;
          bA.m_sweep.Advance(t0)
        }else {
          if(bB.m_sweep.t0 < bA.m_sweep.t0) {
            t0 = bA.m_sweep.t0;
            bB.m_sweep.Advance(t0)
          }
        }
        toi = c.ComputeTOI(bA.m_sweep, bB.m_sweep);
        b2Settings.b2Assert(0 <= toi && toi <= 1);
        if(toi > 0 && toi < 1) {
          toi = (1 - toi) * t0 + toi;
          if(toi > 1) {
            toi = 1
          }
        }
        c.m_toi = toi;
        c.m_flags |= b2Contact.e_toiFlag
      }
      if(Number.MIN_VALUE < toi && toi < minTOI) {
        minContact = c;
        minTOI = toi
      }
    }
    if(minContact == null || 1 - 100 * Number.MIN_VALUE < minTOI) {
      break
    }
    fA = minContact.m_fixtureA;
    fB = minContact.m_fixtureB;
    bA = fA.m_body;
    bB = fB.m_body;
    b2World.s_backupA.Set(bA.m_sweep);
    b2World.s_backupB.Set(bB.m_sweep);
    bA.Advance(minTOI);
    bB.Advance(minTOI);
    minContact.Update(this.m_contactManager.m_contactListener);
    minContact.m_flags &= ~b2Contact.e_toiFlag;
    if(minContact.IsSensor() == true || minContact.IsEnabled() == false) {
      bA.m_sweep.Set(b2World.s_backupA);
      bB.m_sweep.Set(b2World.s_backupB);
      bA.SynchronizeTransform();
      bB.SynchronizeTransform();
      continue
    }
    if(minContact.IsTouching() == false) {
      continue
    }
    var seed = bA;
    if(seed.GetType() != b2Body.b2_dynamicBody) {
      seed = bB
    }
    island.Clear();
    var queueStart = 0;
    var queueSize = 0;
    queue[queueStart + queueSize++] = seed;
    seed.m_flags |= b2Body.e_islandFlag;
    while(queueSize > 0) {
      b = queue[queueStart++];
      --queueSize;
      island.AddBody(b);
      if(b.IsAwake() == false) {
        b.SetAwake(true)
      }
      if(b.GetType() != b2Body.b2_dynamicBody) {
        continue
      }
      for(cEdge = b.m_contactList;cEdge;cEdge = cEdge.next) {
        if(island.m_contactCount == island.m_contactCapacity) {
          break
        }
        if(cEdge.contact.m_flags & b2Contact.e_islandFlag) {
          continue
        }
        if(cEdge.contact.IsSensor() == true || cEdge.contact.IsEnabled() == false || cEdge.contact.IsTouching() == false) {
          continue
        }
        island.AddContact(cEdge.contact);
        cEdge.contact.m_flags |= b2Contact.e_islandFlag;
        var other = cEdge.other;
        if(other.m_flags & b2Body.e_islandFlag) {
          continue
        }
        if(other.GetType() != b2Body.b2_staticBody) {
          other.Advance(minTOI);
          other.SetAwake(true)
        }
        queue[queueStart + queueSize] = other;
        ++queueSize;
        other.m_flags |= b2Body.e_islandFlag
      }
      for(var jEdge = b.m_jointList;jEdge;jEdge = jEdge.next) {
        if(island.m_jointCount == island.m_jointCapacity) {
          continue
        }
        if(jEdge.joint.m_islandFlag == true) {
          continue
        }
        other = jEdge.other;
        if(other.IsActive() == false) {
          continue
        }
        island.AddJoint(jEdge.joint);
        jEdge.joint.m_islandFlag = true;
        if(other.m_flags & b2Body.e_islandFlag) {
          continue
        }
        if(other.GetType() != b2Body.b2_staticBody) {
          other.Advance(minTOI);
          other.SetAwake(true)
        }
        queue[queueStart + queueSize] = other;
        ++queueSize;
        other.m_flags |= b2Body.e_islandFlag
      }
    }
    var subStep = b2World.s_timestep;
    subStep.warmStarting = false;
    subStep.dt = (1 - minTOI) * step.dt;
    subStep.inv_dt = 1 / subStep.dt;
    subStep.dtRatio = 0;
    subStep.velocityIterations = step.velocityIterations;
    subStep.positionIterations = step.positionIterations;
    island.SolveTOI(subStep);
    var i = 0;
    for(i = 0;i < island.m_bodyCount;++i) {
      b = island.m_bodies[i];
      b.m_flags &= ~b2Body.e_islandFlag;
      if(b.IsAwake() == false) {
        continue
      }
      if(b.GetType() != b2Body.b2_dynamicBody) {
        continue
      }
      b.SynchronizeFixtures();
      for(cEdge = b.m_contactList;cEdge;cEdge = cEdge.next) {
        cEdge.contact.m_flags &= ~b2Contact.e_toiFlag
      }
    }
    for(i = 0;i < island.m_contactCount;++i) {
      c = island.m_contacts[i];
      c.m_flags &= ~(b2Contact.e_toiFlag | b2Contact.e_islandFlag)
    }
    for(i = 0;i < island.m_jointCount;++i) {
      j = island.m_joints[i];
      j.m_islandFlag = false
    }
    this.m_contactManager.FindNewContacts()
  }
};
b2World.prototype.DrawJoint = function(joint) {
  var b1 = joint.GetBodyA();
  var b2 = joint.GetBodyB();
  var xf1 = b1.m_xf;
  var xf2 = b2.m_xf;
  var x1 = xf1.position;
  var x2 = xf2.position;
  var p1 = joint.GetAnchorA();
  var p2 = joint.GetAnchorB();
  var color = b2World.s_jointColor;
  switch(joint.m_type) {
    case b2Joint.e_distanceJoint:
      this.m_debugDraw.DrawSegment(p1, p2, color);
      break;
    case b2Joint.e_pulleyJoint:
      var pulley = joint;
      var s1 = pulley.GetGroundAnchorA();
      var s2 = pulley.GetGroundAnchorB();
      this.m_debugDraw.DrawSegment(s1, p1, color);
      this.m_debugDraw.DrawSegment(s2, p2, color);
      this.m_debugDraw.DrawSegment(s1, s2, color);
      break;
    case b2Joint.e_mouseJoint:
      this.m_debugDraw.DrawSegment(p1, p2, color);
      break;
    default:
      if(b1 != this.m_groundBody) {
        this.m_debugDraw.DrawSegment(x1, p1, color)
      }
      this.m_debugDraw.DrawSegment(p1, p2, color);
      if(b2 != this.m_groundBody) {
        this.m_debugDraw.DrawSegment(x2, p2, color)
      }
  }
};
b2World.prototype.DrawShape = function(shape, xf, color) {
  switch(shape.m_type) {
    case b2Shape.e_circleShape:
      var circle = shape;
      var center = b2Math.MulX(xf, circle.m_p);
      var radius = circle.m_radius;
      var axis = xf.R.col1;
      this.m_debugDraw.DrawSolidCircle(center, radius, axis, color);
      break;
    case b2Shape.e_polygonShape:
      var i = 0;
      var poly = shape;
      var vertexCount = poly.GetVertexCount();
      var localVertices = poly.GetVertices();
      var vertices = new Array(vertexCount);
      for(i = 0;i < vertexCount;++i) {
        vertices[i] = b2Math.MulX(xf, localVertices[i])
      }
      this.m_debugDraw.DrawSolidPolygon(vertices, vertexCount, color);
      break;
    case b2Shape.e_edgeShape:
      var edge = shape;
      this.m_debugDraw.DrawSegment(b2Math.MulX(xf, edge.GetVertex1()), b2Math.MulX(xf, edge.GetVertex2()), color);
      break
  }
};
b2World.prototype.SetDestructionListener = function(listener) {
  this.m_destructionListener = listener
};
b2World.prototype.SetContactFilter = function(filter) {
  this.m_contactManager.m_contactFilter = filter
};
b2World.prototype.SetContactListener = function(listener) {
  this.m_contactManager.m_contactListener = listener
};
b2World.prototype.SetDebugDraw = function(debugDraw) {
  this.m_debugDraw = debugDraw
};
b2World.prototype.SetBroadPhase = function(broadPhase) {
  var oldBroadPhase = this.m_contactManager.m_broadPhase;
  this.m_contactManager.m_broadPhase = broadPhase;
  for(var b = this.m_bodyList;b;b = b.m_next) {
    for(var f = b.m_fixtureList;f;f = f.m_next) {
      f.m_proxy = broadPhase.CreateProxy(oldBroadPhase.GetFatAABB(f.m_proxy), f)
    }
  }
};
b2World.prototype.Validate = function() {
  this.m_contactManager.m_broadPhase.Validate()
};
b2World.prototype.GetProxyCount = function() {
  return this.m_contactManager.m_broadPhase.GetProxyCount()
};
b2World.prototype.CreateBody = function(def) {
  if(this.IsLocked() == true) {
    return null
  }
  var b = new b2Body(def, this);
  b.m_prev = null;
  b.m_next = this.m_bodyList;
  if(this.m_bodyList) {
    this.m_bodyList.m_prev = b
  }
  this.m_bodyList = b;
  ++this.m_bodyCount;
  return b
};
b2World.prototype.DestroyBody = function(b) {
  if(this.IsLocked() == true) {
    return
  }
  var jn = b.m_jointList;
  while(jn) {
    var jn0 = jn;
    jn = jn.next;
    if(this.m_destructionListener) {
      this.m_destructionListener.SayGoodbyeJoint(jn0.joint)
    }
    this.DestroyJoint(jn0.joint)
  }
  var coe = b.m_controllerList;
  while(coe) {
    var coe0 = coe;
    coe = coe.nextController;
    coe0.controller.RemoveBody(b)
  }
  var ce = b.m_contactList;
  while(ce) {
    var ce0 = ce;
    ce = ce.next;
    this.m_contactManager.Destroy(ce0.contact)
  }
  b.m_contactList = null;
  var f = b.m_fixtureList;
  while(f) {
    var f0 = f;
    f = f.m_next;
    if(this.m_destructionListener) {
      this.m_destructionListener.SayGoodbyeFixture(f0)
    }
    f0.DestroyProxy(this.m_contactManager.m_broadPhase);
    f0.Destroy()
  }
  b.m_fixtureList = null;
  b.m_fixtureCount = 0;
  if(b.m_prev) {
    b.m_prev.m_next = b.m_next
  }
  if(b.m_next) {
    b.m_next.m_prev = b.m_prev
  }
  if(b == this.m_bodyList) {
    this.m_bodyList = b.m_next
  }
  --this.m_bodyCount
};
b2World.prototype.CreateJoint = function(def) {
  var j = b2Joint.Create(def, null);
  j.m_prev = null;
  j.m_next = this.m_jointList;
  if(this.m_jointList) {
    this.m_jointList.m_prev = j
  }
  this.m_jointList = j;
  ++this.m_jointCount;
  j.m_edgeA.joint = j;
  j.m_edgeA.other = j.m_bodyB;
  j.m_edgeA.prev = null;
  j.m_edgeA.next = j.m_bodyA.m_jointList;
  if(j.m_bodyA.m_jointList) {
    j.m_bodyA.m_jointList.prev = j.m_edgeA
  }
  j.m_bodyA.m_jointList = j.m_edgeA;
  j.m_edgeB.joint = j;
  j.m_edgeB.other = j.m_bodyA;
  j.m_edgeB.prev = null;
  j.m_edgeB.next = j.m_bodyB.m_jointList;
  if(j.m_bodyB.m_jointList) {
    j.m_bodyB.m_jointList.prev = j.m_edgeB
  }
  j.m_bodyB.m_jointList = j.m_edgeB;
  var bodyA = def.bodyA;
  var bodyB = def.bodyB;
  if(def.collideConnected == false) {
    var edge = bodyB.GetContactList();
    while(edge) {
      if(edge.other == bodyA) {
        edge.contact.FlagForFiltering()
      }
      edge = edge.next
    }
  }
  return j
};
b2World.prototype.DestroyJoint = function(j) {
  var collideConnected = j.m_collideConnected;
  if(j.m_prev) {
    j.m_prev.m_next = j.m_next
  }
  if(j.m_next) {
    j.m_next.m_prev = j.m_prev
  }
  if(j == this.m_jointList) {
    this.m_jointList = j.m_next
  }
  var bodyA = j.m_bodyA;
  var bodyB = j.m_bodyB;
  bodyA.SetAwake(true);
  bodyB.SetAwake(true);
  if(j.m_edgeA.prev) {
    j.m_edgeA.prev.next = j.m_edgeA.next
  }
  if(j.m_edgeA.next) {
    j.m_edgeA.next.prev = j.m_edgeA.prev
  }
  if(j.m_edgeA == bodyA.m_jointList) {
    bodyA.m_jointList = j.m_edgeA.next
  }
  j.m_edgeA.prev = null;
  j.m_edgeA.next = null;
  if(j.m_edgeB.prev) {
    j.m_edgeB.prev.next = j.m_edgeB.next
  }
  if(j.m_edgeB.next) {
    j.m_edgeB.next.prev = j.m_edgeB.prev
  }
  if(j.m_edgeB == bodyB.m_jointList) {
    bodyB.m_jointList = j.m_edgeB.next
  }
  j.m_edgeB.prev = null;
  j.m_edgeB.next = null;
  b2Joint.Destroy(j, null);
  --this.m_jointCount;
  if(collideConnected == false) {
    var edge = bodyB.GetContactList();
    while(edge) {
      if(edge.other == bodyA) {
        edge.contact.FlagForFiltering()
      }
      edge = edge.next
    }
  }
};
b2World.prototype.AddController = function(c) {
  c.m_next = this.m_controllerList;
  c.m_prev = null;
  this.m_controllerList = c;
  c.m_world = this;
  this.m_controllerCount++;
  return c
};
b2World.prototype.RemoveController = function(c) {
  if(c.m_prev) {
    c.m_prev.m_next = c.m_next
  }
  if(c.m_next) {
    c.m_next.m_prev = c.m_prev
  }
  if(this.m_controllerList == c) {
    this.m_controllerList = c.m_next
  }
  this.m_controllerCount--
};
b2World.prototype.CreateController = function(controller) {
  if(controller.m_world != this) {
    throw new Error("Controller can only be a member of one world");
  }
  controller.m_next = this.m_controllerList;
  controller.m_prev = null;
  if(this.m_controllerList) {
    this.m_controllerList.m_prev = controller
  }
  this.m_controllerList = controller;
  ++this.m_controllerCount;
  controller.m_world = this;
  return controller
};
b2World.prototype.DestroyController = function(controller) {
  controller.Clear();
  if(controller.m_next) {
    controller.m_next.m_prev = controller.m_prev
  }
  if(controller.m_prev) {
    controller.m_prev.m_next = controller.m_next
  }
  if(controller == this.m_controllerList) {
    this.m_controllerList = controller.m_next
  }
  --this.m_controllerCount
};
b2World.prototype.SetWarmStarting = function(flag) {
  b2World.m_warmStarting = flag
};
b2World.prototype.SetContinuousPhysics = function(flag) {
  b2World.m_continuousPhysics = flag
};
b2World.prototype.GetBodyCount = function() {
  return this.m_bodyCount
};
b2World.prototype.GetJointCount = function() {
  return this.m_jointCount
};
b2World.prototype.GetContactCount = function() {
  return this.m_contactCount
};
b2World.prototype.SetGravity = function(gravity) {
  this.m_gravity = gravity
};
b2World.prototype.GetGravity = function() {
  return this.m_gravity
};
b2World.prototype.GetGroundBody = function() {
  return this.m_groundBody
};
b2World.prototype.Step = function(dt, velocityIterations, positionIterations) {
  if(this.m_flags & b2World.e_newFixture) {
    this.m_contactManager.FindNewContacts();
    this.m_flags &= ~b2World.e_newFixture
  }
  this.m_flags |= b2World.e_locked;
  var step = b2World.s_timestep2;
  step.dt = dt;
  step.velocityIterations = velocityIterations;
  step.positionIterations = positionIterations;
  if(dt > 0) {
    step.inv_dt = 1 / dt
  }else {
    step.inv_dt = 0
  }
  step.dtRatio = this.m_inv_dt0 * dt;
  step.warmStarting = b2World.m_warmStarting;
  this.m_contactManager.Collide();
  if(step.dt > 0) {
    this.Solve(step)
  }
  if(b2World.m_continuousPhysics && step.dt > 0) {
    this.SolveTOI(step)
  }
  if(step.dt > 0) {
    this.m_inv_dt0 = step.inv_dt
  }
  this.m_flags &= ~b2World.e_locked
};
b2World.prototype.ClearForces = function() {
  for(var body = this.m_bodyList;body;body = body.m_next) {
    body.m_force.SetZero();
    body.m_torque = 0
  }
};
b2World.prototype.DrawDebugData = function() {
  if(this.m_debugDraw == null) {
    return
  }
  this.m_debugDraw.Clear();
  var flags = this.m_debugDraw.GetFlags();
  var i = 0;
  var b;
  var f;
  var s;
  var j;
  var bp;
  var invQ = new b2Vec2;
  var x1 = new b2Vec2;
  var x2 = new b2Vec2;
  var xf;
  var b1 = new b2AABB;
  var b2 = new b2AABB;
  var vs = [new b2Vec2, new b2Vec2, new b2Vec2, new b2Vec2];
  var color = new b2Color(0, 0, 0);
  if(flags & b2DebugDraw.e_shapeBit) {
    for(b = this.m_bodyList;b;b = b.m_next) {
      xf = b.m_xf;
      for(f = b.GetFixtureList();f;f = f.m_next) {
        s = f.GetShape();
        if(b.IsActive() == false) {
          color.Set(0.5, 0.5, 0.3);
          this.DrawShape(s, xf, color)
        }else {
          if(b.GetType() == b2Body.b2_staticBody) {
            color.Set(0.5, 0.9, 0.5);
            this.DrawShape(s, xf, color)
          }else {
            if(b.GetType() == b2Body.b2_kinematicBody) {
              color.Set(0.5, 0.5, 0.9);
              this.DrawShape(s, xf, color)
            }else {
              if(b.IsAwake() == false) {
                color.Set(0.6, 0.6, 0.6);
                this.DrawShape(s, xf, color)
              }else {
                color.Set(0.9, 0.7, 0.7);
                this.DrawShape(s, xf, color)
              }
            }
          }
        }
      }
    }
  }
  if(flags & b2DebugDraw.e_jointBit) {
    for(j = this.m_jointList;j;j = j.m_next) {
      this.DrawJoint(j)
    }
  }
  if(flags & b2DebugDraw.e_controllerBit) {
    for(var c = this.m_controllerList;c;c = c.m_next) {
      c.Draw(this.m_debugDraw)
    }
  }
  if(flags & b2DebugDraw.e_pairBit) {
    color.Set(0.3, 0.9, 0.9);
    for(var contact = this.m_contactManager.m_contactList;contact;contact = contact.GetNext()) {
      var fixtureA = contact.GetFixtureA();
      var fixtureB = contact.GetFixtureB();
      var cA = fixtureA.GetAABB().GetCenter();
      var cB = fixtureB.GetAABB().GetCenter();
      this.m_debugDraw.DrawSegment(cA, cB, color)
    }
  }
  if(flags & b2DebugDraw.e_aabbBit) {
    bp = this.m_contactManager.m_broadPhase;
    vs = [new b2Vec2, new b2Vec2, new b2Vec2, new b2Vec2];
    for(b = this.m_bodyList;b;b = b.GetNext()) {
      if(b.IsActive() == false) {
        continue
      }
      for(f = b.GetFixtureList();f;f = f.GetNext()) {
        var aabb = bp.GetFatAABB(f.m_proxy);
        vs[0].Set(aabb.lowerBound.x, aabb.lowerBound.y);
        vs[1].Set(aabb.upperBound.x, aabb.lowerBound.y);
        vs[2].Set(aabb.upperBound.x, aabb.upperBound.y);
        vs[3].Set(aabb.lowerBound.x, aabb.upperBound.y);
        this.m_debugDraw.DrawPolygon(vs, 4, color)
      }
    }
  }
  if(flags & b2DebugDraw.e_centerOfMassBit) {
    for(b = this.m_bodyList;b;b = b.m_next) {
      xf = b2World.s_xf;
      xf.R = b.m_xf.R;
      xf.position = b.GetWorldCenter();
      this.m_debugDraw.DrawTransform(xf)
    }
  }
};
b2World.prototype.QueryAABB = function(callback, aabb) {
  var broadPhase = this.m_contactManager.m_broadPhase;
  function WorldQueryWrapper(proxy) {
    return callback(broadPhase.GetUserData(proxy))
  }
  broadPhase.Query(WorldQueryWrapper, aabb)
};
b2World.prototype.QueryShape = function(callback, shape, transform) {
  if(transform == null) {
    transform = new b2Transform;
    transform.SetIdentity()
  }
  var broadPhase = this.m_contactManager.m_broadPhase;
  function WorldQueryWrapper(proxy) {
    var fixture = broadPhase.GetUserData(proxy);
    if(b2Shape.TestOverlap(shape, transform, fixture.GetShape(), fixture.GetBody().GetTransform())) {
      return callback(fixture)
    }
    return true
  }
  var aabb = new b2AABB;
  shape.ComputeAABB(aabb, transform);
  broadPhase.Query(WorldQueryWrapper, aabb)
};
b2World.prototype.QueryPoint = function(callback, p) {
  var broadPhase = this.m_contactManager.m_broadPhase;
  function WorldQueryWrapper(proxy) {
    var fixture = broadPhase.GetUserData(proxy);
    if(fixture.TestPoint(p)) {
      return callback(fixture)
    }
    return true
  }
  var aabb = new b2AABB;
  aabb.lowerBound.Set(p.x - b2Settings.b2_linearSlop, p.y - b2Settings.b2_linearSlop);
  aabb.upperBound.Set(p.x + b2Settings.b2_linearSlop, p.y + b2Settings.b2_linearSlop);
  broadPhase.Query(WorldQueryWrapper, aabb)
};
b2World.prototype.RayCast = function(callback, point1, point2) {
  var broadPhase = this.m_contactManager.m_broadPhase;
  var output = new b2RayCastOutput;
  function RayCastWrapper(input, proxy) {
    var userData = broadPhase.GetUserData(proxy);
    var fixture = userData;
    var hit = fixture.RayCast(output, input);
    if(hit) {
      var fraction = output.fraction;
      var point = new b2Vec2((1 - fraction) * point1.x + fraction * point2.x, (1 - fraction) * point1.y + fraction * point2.y);
      return callback(fixture, point, output.normal, fraction)
    }
    return input.maxFraction
  }
  var input = new b2RayCastInput(point1, point2);
  broadPhase.RayCast(RayCastWrapper, input)
};
b2World.prototype.RayCastOne = function(point1, point2) {
  var result;
  function RayCastOneWrapper(fixture, point, normal, fraction) {
    result = fixture;
    return fraction
  }
  this.RayCast(RayCastOneWrapper, point1, point2);
  return result
};
b2World.prototype.RayCastAll = function(point1, point2) {
  var result = new Array;
  function RayCastAllWrapper(fixture, point, normal, fraction) {
    result[result.length] = fixture;
    return 1
  }
  this.RayCast(RayCastAllWrapper, point1, point2);
  return result
};
b2World.prototype.GetBodyList = function() {
  return this.m_bodyList
};
b2World.prototype.GetJointList = function() {
  return this.m_jointList
};
b2World.prototype.GetContactList = function() {
  return this.m_contactList
};
b2World.prototype.IsLocked = function() {
  return(this.m_flags & b2World.e_locked) > 0
};
b2World.prototype.s_stack = new Array;
b2World.prototype.m_flags = 0;
b2World.prototype.m_contactManager = new b2ContactManager;
b2World.prototype.m_contactSolver = new b2ContactSolver;
b2World.prototype.m_island = new b2Island;
b2World.prototype.m_bodyList = null;
b2World.prototype.m_jointList = null;
b2World.prototype.m_contactList = null;
b2World.prototype.m_bodyCount = 0;
b2World.prototype.m_contactCount = 0;
b2World.prototype.m_jointCount = 0;
b2World.prototype.m_controllerList = null;
b2World.prototype.m_controllerCount = 0;
b2World.prototype.m_gravity = null;
b2World.prototype.m_allowSleep = null;
b2World.prototype.m_groundBody = null;
b2World.prototype.m_destructionListener = null;
b2World.prototype.m_debugDraw = null;
b2World.prototype.m_inv_dt0 = null;if(typeof exports !== "undefined") {
  exports.b2BoundValues = b2BoundValues;
  exports.b2Math = b2Math;
  exports.b2DistanceOutput = b2DistanceOutput;
  exports.b2Mat33 = b2Mat33;
  exports.b2ContactPoint = b2ContactPoint;
  exports.b2PairManager = b2PairManager;
  exports.b2PositionSolverManifold = b2PositionSolverManifold;
  exports.b2OBB = b2OBB;
  exports.b2CircleContact = b2CircleContact;
  exports.b2PulleyJoint = b2PulleyJoint;
  exports.b2Pair = b2Pair;
  exports.b2TimeStep = b2TimeStep;
  exports.b2FixtureDef = b2FixtureDef;
  exports.b2World = b2World;
  exports.b2PrismaticJoint = b2PrismaticJoint;
  exports.b2Controller = b2Controller;
  exports.b2ContactID = b2ContactID;
  exports.b2RevoluteJoint = b2RevoluteJoint;
  exports.b2JointDef = b2JointDef;
  exports.b2Transform = b2Transform;
  exports.b2GravityController = b2GravityController;
  exports.b2EdgeAndCircleContact = b2EdgeAndCircleContact;
  exports.b2EdgeShape = b2EdgeShape;
  exports.b2BuoyancyController = b2BuoyancyController;
  exports.b2LineJointDef = b2LineJointDef;
  exports.b2Contact = b2Contact;
  exports.b2DistanceJoint = b2DistanceJoint;
  exports.b2Body = b2Body;
  exports.b2DestructionListener = b2DestructionListener;
  exports.b2PulleyJointDef = b2PulleyJointDef;
  exports.b2ContactEdge = b2ContactEdge;
  exports.b2ContactConstraint = b2ContactConstraint;
  exports.b2ContactImpulse = b2ContactImpulse;
  exports.b2DistanceJointDef = b2DistanceJointDef;
  exports.b2ContactResult = b2ContactResult;
  exports.b2EdgeChainDef = b2EdgeChainDef;
  exports.b2Vec2 = b2Vec2;
  exports.b2Vec3 = b2Vec3;
  exports.b2DistanceProxy = b2DistanceProxy;
  exports.b2FrictionJointDef = b2FrictionJointDef;
  exports.b2PolygonContact = b2PolygonContact;
  exports.b2TensorDampingController = b2TensorDampingController;
  exports.b2ContactFactory = b2ContactFactory;
  exports.b2WeldJointDef = b2WeldJointDef;
  exports.b2ConstantAccelController = b2ConstantAccelController;
  exports.b2GearJointDef = b2GearJointDef;
  exports.ClipVertex = ClipVertex;
  exports.b2SeparationFunction = b2SeparationFunction;
  exports.b2ManifoldPoint = b2ManifoldPoint;
  exports.b2Color = b2Color;
  exports.b2PolygonShape = b2PolygonShape;
  exports.b2DynamicTreePair = b2DynamicTreePair;
  exports.b2ContactConstraintPoint = b2ContactConstraintPoint;
  exports.b2FrictionJoint = b2FrictionJoint;
  exports.b2ContactFilter = b2ContactFilter;
  exports.b2ControllerEdge = b2ControllerEdge;
  exports.b2Distance = b2Distance;
  exports.b2Fixture = b2Fixture;
  exports.b2DynamicTreeNode = b2DynamicTreeNode;
  exports.b2MouseJoint = b2MouseJoint;
  exports.b2DistanceInput = b2DistanceInput;
  exports.b2BodyDef = b2BodyDef;
  exports.b2DynamicTreeBroadPhase = b2DynamicTreeBroadPhase;
  exports.b2Settings = b2Settings;
  exports.b2Proxy = b2Proxy;
  exports.b2Point = b2Point;
  exports.b2BroadPhase = b2BroadPhase;
  exports.b2Manifold = b2Manifold;
  exports.b2WorldManifold = b2WorldManifold;
  exports.b2PrismaticJointDef = b2PrismaticJointDef;
  exports.b2RayCastOutput = b2RayCastOutput;
  exports.b2ConstantForceController = b2ConstantForceController;
  exports.b2TimeOfImpact = b2TimeOfImpact;
  exports.b2CircleShape = b2CircleShape;
  exports.b2MassData = b2MassData;
  exports.b2Joint = b2Joint;
  exports.b2GearJoint = b2GearJoint;
  exports.b2DynamicTree = b2DynamicTree;
  exports.b2JointEdge = b2JointEdge;
  exports.b2LineJoint = b2LineJoint;
  exports.b2NullContact = b2NullContact;
  exports.b2ContactListener = b2ContactListener;
  exports.b2RayCastInput = b2RayCastInput;
  exports.b2TOIInput = b2TOIInput;
  exports.Features = Features;
  exports.b2FilterData = b2FilterData;
  exports.b2Island = b2Island;
  exports.b2ContactManager = b2ContactManager;
  exports.b2ContactSolver = b2ContactSolver;
  exports.b2Simplex = b2Simplex;
  exports.b2AABB = b2AABB;
  exports.b2Jacobian = b2Jacobian;
  exports.b2Bound = b2Bound;
  exports.b2RevoluteJointDef = b2RevoluteJointDef;
  exports.b2PolyAndEdgeContact = b2PolyAndEdgeContact;
  exports.b2SimplexVertex = b2SimplexVertex;
  exports.b2WeldJoint = b2WeldJoint;
  exports.b2Collision = b2Collision;
  exports.b2Mat22 = b2Mat22;
  exports.b2SimplexCache = b2SimplexCache;
  exports.b2PolyAndCircleContact = b2PolyAndCircleContact;
  exports.b2MouseJointDef = b2MouseJointDef;
  exports.b2Shape = b2Shape;
  exports.b2Segment = b2Segment;
  exports.b2ContactRegister = b2ContactRegister;
  exports.b2DebugDraw = b2DebugDraw;
  exports.b2Sweep = b2Sweep
}
;

}};
__resources__["/__builtin__/libs/cocos2d/ActionManager.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    console = require('system').console,
    Timer = require('./Scheduler').Timer,
    Scheduler = require('./Scheduler').Scheduler;

var ActionManager = BObject.extend(/** @lends cocos.ActionManager# */{
    targets: null,
    currentTarget: null,
    currentTargetSalvaged: null,

    /**
     * <p>A singleton that manages all the actions. Normally you
     * won't need to use this singleton directly. 99% of the cases you will use the
     * cocos.nodes.Node interface, which uses this singleton. But there are some cases where
     * you might need to use this singleton. Examples:</p>
     *
     * <ul>
     * <li>When you want to run an action where the target is different from a cocos.nodes.Node</li>
     * <li>When you want to pause / resume the actions</li>
     * </ul>
     *
     * @memberOf cocos
     * @constructs
     * @extends BObject
     * @singleton
     */
    init: function () {
        ActionManager.superclass.init.call(this);

        Scheduler.get('sharedScheduler').scheduleUpdate({target: this, priority: 0, paused: false});
        this.targets = [];
    },

    /**
     * Adds an action with a target. If the target is already present, then the
     * action will be added to the existing target. If the target is not
     * present, a new instance of this target will be created either paused or
     * paused, and the action will be added to the newly created target. When
     * the target is paused, the queued actions won't be 'ticked'.
     *
     * @opt {cocos.nodes.Node} target Node to run the action on
     */
    addAction: function (opts) {

        var targetID = opts.target.get('id');
        var element = this.targets[targetID];

        if (!element) {
            element = this.targets[targetID] = {
                paused: false,
                target: opts.target,
                actions: []
            };
        }

        element.actions.push(opts.action);

        opts.action.startWithTarget(opts.target);
    },

    /**
     * Remove an action
     *
     * @param {cocos.actions.Action} action Action to remove
     */
    removeAction: function (action) {
        var targetID = action.originalTarget.get('id'),
            element = this.targets[targetID];

        if (!element) {
            return;
        }

        var actionIndex = element.actions.indexOf(action);

        if (actionIndex == -1) {
            return;
        }

        if (this.currentTarget == element) {
            element.currentActionSalvaged = true;
        } 
        
        element.actions[actionIndex] = null;
        element.actions.splice(actionIndex, 1); // Delete array item

        if (element.actions.length === 0) {
            if (this.currentTarget == element) {
                this.set('currentTargetSalvaged', true);
            }
        }
            
    },

    /**
     * Fetch an action belonging to a cocos.nodes.Node
     *
     * @returns {cocos.actions.Action}
     *
     * @opts {cocos.nodes.Node} target Target of the action
     * @opts {String} tag Tag of the action
     */
    getActionFromTarget: function(opts) {
        var tag = opts.tag,
            targetID = opts.target.get('id');

        var element = this.targets[targetID];
        if (!element) {
            return null;
        }
        for (var i = 0; i < element.actions.length; i++ ) {
            if (element.actions[i] && 
                (element.actions[i].get('tag') === tag)) {
                return element.actions[i];
            }
        }
        // Not found
        return null;
    },
     
    /**
     * Remove all actions for a cocos.nodes.Node
     *
     * @param {cocos.nodes.Node} target Node to remove all actions for
     */
    removeAllActionsFromTarget: function (target) {
        var targetID = target.get('id');

        var element = this.targets[targetID];
        if (!element) {
            return;
        }
        // Delete everything in array but don't replace it incase something else has a reference
        element.actions.splice(0, element.actions.length);
    },

    /**
     * @private
     */
    update: function (dt) {
        var self = this;
        util.each(this.targets, function (currentTarget, i) {

            if (!currentTarget) {
                return;
            }
            self.currentTarget = currentTarget;

            if (!currentTarget.paused) {
                util.each(currentTarget.actions, function (currentAction, j) {
                    if (!currentAction) {
                        return;
                    }

                    currentTarget.currentAction = currentAction;
                    currentTarget.currentActionSalvaged = false;

                    currentTarget.currentAction.step(dt);

                    if (currentTarget.currentAction.get('isDone')) {
                        currentTarget.currentAction.stop();

                        var a = currentTarget.currentAction;
                        currentTarget.currentAction = null;
                        self.removeAction(a);
                    }

                    currentTarget.currentAction = null;

                });
            }

            if (self.currentTargetSalvaged && currentTarget.actions.length === 0) {
                self.targets[i] = null;
                delete self.targets[i];
            }
        });
    },

    pauseTarget: function (target) {
    },

    resumeTarget: function (target) {
        // TODO
    }
});

util.extend(ActionManager, /** @lends cocos.ActionManager */{
    /**
     * Singleton instance of cocos.ActionManager
     * @getter sharedManager
     * @type cocos.ActionManager
     */
    get_sharedManager: function (key) {
        if (!this._instance) {
            this._instance = this.create();
        }

        return this._instance;
    }
});

exports.ActionManager = ActionManager;

}};
__resources__["/__builtin__/libs/cocos2d/actions/Action.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    console = require('system').console,
    geo = require('geometry'),
    ccp = geo.ccp;

/** 
 * @memberOf cocos.actions
 * @class Base class for Actions
 * @extends BObject
 * @constructor
 */
var Action = BObject.extend(/** @lends cocos.actions.Action# */{
    /**
     * The Node the action is being performed on
     * @type cocos.nodes.Node
     */
    target: null,
    originalTarget: null,
    
    /**
     * Unique tag to identify the action
     * @type *
     */
    tag: null,
    
    /**
     * Called every frame with it's delta time.
     *
     * @param {Float} dt The delta time
     */
    step: function (dt) {
        window.console.warn("Action.step() Override me");
    },

    /**
     * Called once per frame.
     *
     * @param {Float} time How much of the animation has played. 0.0 = just started, 1.0 just finished.
     */
    update: function (time) {
        window.console.warn("Action.update() Override me");
    },

    /**
     * Called before the action start. It will also set the target.
     *
     * @param {cocos.nodes.Node} target The Node to run the action on
     */
    startWithTarget: function (target) {
        this.target = this.originalTarget = target;
    },

    /**
     * Called after the action has finished. It will set the 'target' to nil.
     * <strong>Important</strong>: You should never call cocos.actions.Action#stop manually.
     * Instead, use cocos.nodes.Node#stopAction(action)
     */
    stop: function () {
        this.target = null;
    },

    /**
     * @getter isDone
     * @type {Boolean} 
     */
    get_isDone: function (key) {
        return true;
    },


    /**
     * Returns a copy of this Action but in reverse
     *
     * @returns {cocos.actions.Action} A new Action in reverse
     */
    reverse: function () {
    }
});

var RepeatForever = Action.extend(/** @lends cocos.actions.RepeatForever# */{
    other: null,

    /**
     * @memberOf cocos.actions
     * @class Repeats an action forever. To repeat the an action for a limited
     * number of times use the cocos.Repeat action.
     * @extends cocos.actions.Action
     * @param {cocos.actions.Action} action An action to repeat forever
     * @constructs
     */
    init: function (action) {
        RepeatForever.superclass.init(this, action);

        this.other = action;
    },

    startWithTarget: function (target) {
        RepeatForever.superclass.startWithTarget.call(this, target);

        this.other.startWithTarget(this.target);
    },

    step: function (dt) {
        this.other.step(dt);
        if (this.other.get('isDone')) {
            var diff = dt - this.other.get('duration') - this.other.get('elapsed');
            this.other.startWithTarget(this.target);

            this.other.step(diff);
        }
    },

    get_isDone: function () {
        return false;
    },

    reverse: function () {
        return RepeatForever.create(this.other.reverse());
    },

    copy: function () {
        return RepeatForever.create(this.other.copy());
    }
});

var FiniteTimeAction = Action.extend(/** @lends cocos.actions.FiniteTimeAction# */{
    /**
     * Number of seconds to run the Action for
     * @type Float
     */
    duration: 2,

    /** 
     * Repeats an action a number of times. To repeat an action forever use the
     * cocos.RepeatForever action.
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.Action
     */
    init: function () {
        FiniteTimeAction.superclass.init.call(this);
    },

    /** @ignore */
    reverse: function () {
        console.log('FiniteTimeAction.reverse() Override me');
    }
});

var Speed = Action.extend(/** @lends cocos.actions.Speed# */{
    other: null,
    
    /** 
     * speed of the inner function
     * @type Float
     */
    speed: 1.0,
    
    /** 
     * Changes the speed of an action, making it take longer (speed>1)
     * or less (speed<1) time.
     * Useful to simulate 'slow motion' or 'fast forward' effect.
     * @warning This action can't be Sequenceable because it is not an IntervalAction
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.Action
     */
    init: function(opts) {
        Speed.superclass.init.call(this, opts);
        
        this.other = opts.action;
        this.speed = opts.speed;
    },
    
    startWithTarget: function(target) {
        Speed.superclass.startWithTarget.call(this, target);
        this.other.startWithTarget(this.target);
    },
    
    setSpeed: function(speed) {
        this.speed = speed;
    },
    
    stop: function() {
        this.other.stop();
        Speed.superclass.stop.call(this);
    },
    
    step: function(dt) {
        this.other.step(dt * this.speed);
    },
    
    get_isDone: function() {
        return this.other.get_isDone();
    },
    
    copy: function() {
        return Speed.create({action: this.other.copy(), speed: this.speed});
    },
    
    reverse: function() {
        return Speed.create({action: this.other.reverse(), speed: this.speed});
    }
});

var Follow = Action.extend(/** @lends cocos.actions.Follow# */{
    /**
     * node to follow
     */
    followedNode: null,
    
    /**
     * whether camera should be limited to certain area
     * @type {Boolean}
     */
    boundarySet: false,
    
    /**
     * if screensize is bigger than the boundary - update not needed 
     * @type {Boolean}
     */
    boundaryFullyCovered: false,
    
    /**
     * fast access to the screen dimensions 
     * @type {geometry.Point}
     */
    halfScreenSize: null,
    fullScreenSize: null,
    
    /**
     * world boundaries
     * @type {Float}
     */
    leftBoundary: 0,
    rightBoundary: 0,
    topBoundary: 0,
    bottomBoundary: 0,
    
    /** 
     * @class Follow an action that "follows" a node.
     *
     * Eg:
     * layer.runAction(cocos.actions.Follow.create({target: hero}))
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.Action
     *
     * @opt {cocos.nodes.Node} target
     * @opt {geometry.Rect} worldBoundary
     */
    init: function(opts) {
        Follow.superclass.init.call(this, opts);
        
        this.followedNode = opts.target;
        
        var s = require('../Director').Director.get('sharedDirector').get('winSize');
        this.fullScreenSize = geo.ccp(s.width, s.height);
        this.halfScreenSize = geo.ccpMult(this.fullScreenSize, geo.ccp(0.5, 0.5));
        
        if (opts.worldBoundary !== undefined) {
            this.boundarySet = true;
            this.leftBoundary = -((opts.worldBoundary.origin.x + opts.worldBoundary.size.width) - this.fullScreenSize.x);
            this.rightBoundary = -opts.worldBoundary.origin.x;
            this.topBoundary = -opts.worldBoundary.origin.y;
            this.bottomBoundary = -((opts.worldBoundary.origin.y+opts.worldBoundary.size.height) - this.fullScreenSize.y);
            
            if (this.rightBoundary < this.leftBoundary) {
                // screen width is larger than world's boundary width
                //set both in the middle of the world
                this.rightBoundary = this.leftBoundary = (this.leftBoundary + this.rightBoundary) / 2;
            }
            if (this.topBoundary < this.bottomBoundary)
            {
                // screen width is larger than world's boundary width
                //set both in the middle of the world
                this.topBoundary = this.bottomBoundary = (this.topBoundary + this.bottomBoundary) / 2;
            }
            if ((this.topBoundary == this.bottomBoundary) && (this.leftBoundary == this.rightBoundary)) {
                this.boundaryFullyCovered = true;
            }
        }
    },
    
    step: function(dt) {
        if (this.boundarySet) {
            // whole map fits inside a single screen, no need to modify the position - unless map boundaries are increased
            if (this.boundaryFullyCovered) {
                return;
            }
            var tempPos = geo.ccpSub(this.halfScreenSize, this.followedNode.get('position'));
            this.target.set('position', ccp(
                Math.min(Math.max(tempPos.x, this.leftBoundary), this.rightBoundary),
                Math.min(Math.max(tempPos.y, this.bottomBoundary), this.topBoundary))
            );
        } else {
            this.target.set('position', geo.ccpSub(this.halfScreenSize, this.followedNode.get('position')));
        }
    },
    
    get_isDone: function() {
        return !this.followedNode.get('isRunning');
    }
});


exports.Action = Action;
exports.RepeatForever = RepeatForever;
exports.FiniteTimeAction = FiniteTimeAction;
exports.Speed = Speed;
exports.Follow = Follow;

}};
__resources__["/__builtin__/libs/cocos2d/actions/ActionEase.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    ActionInterval = require('./ActionInterval').ActionInterval,
    geo = require('geometry'),
    ccp = geo.ccp;

var ActionEase = ActionInterval.extend(/** @lends cocos.actions.ActionEase# */{
    other: null,
    
    /**
     * @class Base class for Easing actions
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.ActionInterval
     *
     * @opt {cocos.actions.ActionInterval} action
     */
    init: function(opts) {
        if (!opts.action) {
            throw "Ease: action argument must be non-nil";
        }
        ActionEase.superclass.init.call(this, {duration: opts.action.duration});
        
        this.other = opts.action;
    },
    
    startWithTarget: function(target) {
        ActionEase.superclass.startWithTarget.call(this, target);
        this.other.startWithTarget(this.target);
    },
    
    stop: function() {
        this.other.stop();
        ActionEase.superclass.stop.call(this);
    },
    /*
    update: function(t) {
        this.other.update(t);
    },
    */
    copy: function() {
        return ActionEase.create({action: this.other.copy()});
    },
    
    reverse: function() {
        return ActionEase.create({action: this.other.reverse()});
    }
});

var EaseRate = ActionEase.extend(/** @lends cocos.actions.EaseRate# */{
    /**
     * rate value for the actions 
     * @type {Float} 
     */
    rate: 0,
    
    /**
    * @class Base class for Easing actions with rate parameter
    *
    * @memberOf cocos.actions
    * @constructs
    * @extends cocos.actions.ActionEase
    *
    * @opt {cocos.actions.ActionInterval} action
    * @opt {Float} rate
    */
    init: function(opts) {
        EaseRate.superclass.init.call(this, opts);

        this.rate = opts.rate;
    },
    
    copy: function() {
        return EaseRate.create({action: this.other.copy(), rate: this.rate});
    },
    
    reverse: function() {
        return EaseRate.create({action: this.other.reverse(), rate: 1 / this.rate});
    }
});

/**
 * @class EaseIn action with a rate
 */
var EaseIn = EaseRate.extend(/** @lends cocos.actions.EaseIn# */{
    update: function(t) {
        this.other.update(Math.pow(t, this.rate));
    },
    
    copy: function() {
        return EaseIn.create({action: this.other.copy(), rate: this.rate});
    },
    
    reverse: function() {
        return EaseIn.create({action: this.other.reverse(), rate: 1 / this.rate});
    }
});

/**
 * @class EaseOut action with a rate
 */
var EaseOut = EaseRate.extend(/** @lends cocos.actions.EaseOut# */{
    update: function(t) {
        this.other.update(Math.pow(t, 1/this.rate));
    },
    
    copy: function() {
        return EaseOut.create({action: this.other.copy(), rate: this.rate});
    },
    
    reverse: function() {
        return EaseOut.create({action: this.other.reverse(), rate: 1 / this.rate});
    }
});

/**
 * @class EaseInOut action with a rate
 */
var EaseInOut = EaseRate.extend(/** @lends cocos.actions.EaseInOut# */{
    update: function(t) {
        var sign = 1;
        var r = Math.floor(this.rate);
        if (r % 2 == 0) {
            sign = -1;
        }
        t *= 2;
        if (t < 1) {
            this.other.update(0.5 * Math.pow(t, this.rate));
        } else {
            this.other.update(sign * 0.5 * (Math.pow(t-2, this.rate) + sign * 2));
        }
    },
    
    copy: function() {
        return EaseInOut.create({action: this.other.copy(), rate: this.rate});
    },
    
    reverse: function() {
        return EaseInOut.create({action: this.other.reverse(), rate: this.rate});
    }
});

/**
 * @class EaseExponentialIn action
 */
var EaseExponentialIn = ActionEase.extend(/** @lends cocos.actions.EaseExponentialIn# */{
    update: function(t) {
        this.other.update((t == 0) ? 0 : (Math.pow(2, 10 * (t/1 - 1)) - 1 * 0.001));
    },
    
    copy: function() {
        return EaseExponentialIn.create({action: this.other.copy()});
    },
    
    reverse: function() {
        return exports.EaseExponentialOut.create({action: this.other.reverse()});
    }
});

/**
 * @class EaseExponentialOut action
 */
var EaseExponentialOut = ActionEase.extend(/** @lends cocos.actions.EaseExponentialOut# */{
    update: function(t) {
        this.other.update((t == 1) ? 1 : (-Math.pow(2, -10 * t/1) + 1));
    },
    
    copy: function() {
        return EaseExponentialOut.create({action: this.other.copy()});
    },
    
    reverse: function() {
        return exports.EaseExponentialIn.create({action: this.other.reverse()});
    }
});

/**
 * @class EaseExponentialInOut action
 */
var EaseExponentialInOut = ActionEase.extend(/** @lends cocos.actions.EaseExponentialInOut# */{
    update: function(t) {
        t /= 0.5;
        if (t < 1) {
            t = 0.5 * Math.pow(2, 10 * (t - 1));
        } else {
            t = 0.5 * (-Math.pow(2, -10 * (t - 1)) + 2);
        }
        this.other.update(t);
    },
    
    copy: function() {
        return EaseExponentialInOut.create({action: this.other.copy()});
    },
    
    reverse: function() {
        return EaseExponentialInOut.create({action: this.other.reverse()});
    }
});

/**
 * @class EaseSineIn action
 */
var EaseSineIn = ActionEase.extend(/** @lends cocos.actions.EaseSineIn# */{
    update: function(t) {
        this.other.update(-1 * Math.cos(t * Math.PI_2) + 1);
    },
    
    copy: function() {
        return EaseSineIn.create({action: this.other.copy()});
    },
    
    reverse: function() {
        return exports.EaseSineOut.create({action: this.other.reverse()});
    }
});

/**
 * @class EaseSineOut action
 */
var EaseSineOut = ActionEase.extend(/** @lends cocos.actions.EaseSineOut# */{
    update: function(t) {
        this.other.update(Math.sin(t * Math.PI_2));
    },
    
    copy: function() {
        return EaseSineOut.create({action: this.other.copy()});
    },
    
    reverse: function() {
        return exports.EaseSineIn.create({action: this.other.reverse()});
    }
});

/**
 * @class EaseSineInOut action
 */
var EaseSineInOut = ActionEase.extend(/** @lends cocos.actions.EaseSineInOut# */{
    update: function(t) {
        this.other.update(-0.5 * (Math.cos(t * Math.PI) - 1));
    },
    
    copy: function() {
        return EaseSineInOut.create({action: this.other.copy()});
    },
    
    reverse: function() {
        return EaseSineInOut.create({action: this.other.reverse()});
    }
});

var EaseElastic = ActionEase.extend(/** @lends cocos.actions.EaseElastic# */{
    /**
    * period of the wave in radians. default is 0.3
    * @type {Float}
    */
    period: 0.3,

    /**
    * @class EaseElastic Ease Elastic abstract class
    *
    * @memberOf cocos.actions
    * @constructs
    * @extends cocos.actions.ActionEase
    *
    * @opt {cocos.actions.ActionInterval} action
    * @opt {Float} period
    */
    init: function(opts) {
        EaseElastic.superclass.init.call(this, {action: opts.action});

        if (opts.period !== undefined) {
            this.period = opts.period;
        }
    },

    copy: function() {
        return EaseElastic.create({action: this.other.copy(), period: this.period});
    },

    reverse: function() {
        window.console.warn("EaseElastic reverse(): Override me");
        return null;
    }
});

var EaseElasticIn = EaseElastic.extend(/** @lends cocos.actions.EaseElasticIn# */{
    /** 
     * @class EaseElasticIn Ease Elastic In action
     */
    update: function(t) {
        var newT = 0;
        if (t == 0 || t == 1) {
            newT = t;
        } else {
            var s = this.period / 4;
            t -= 1;
            newT = -Math.pow(2, 10 * t) * Math.sin((t - s) * Math.PI*2 / this.period);
        }
        this.other.update(newT);
    },
    
    // Wish we could use base class's copy
    copy: function() {
        return EaseElasticIn.create({action: this.other.copy(), period: this.period});
    },
    
    reverse: function() {
        return exports.EaseElasticOut.create({action: this.other.reverse(), period: this.period});
    }
});

var EaseElasticOut = EaseElastic.extend(/** @lends cocos.actions.EaseElasticOut# */{
    /** 
     * @class EaseElasticOut Ease Elastic Out action
     */
    update: function(t) {
        var newT = 0;
        if (t == 0 || t == 1) {
            newT = t;
        } else {
            var s = this.period / 4;
            newT = Math.pow(2, -10 * t) * Math.sin((t - s) * Math.PI*2 / this.period) + 1;
        }
        this.other.update(newT);
    },
    
    copy: function() {
        return EaseElasticOut.create({action: this.other.copy(), period: this.period});
    },
    
    reverse: function() {
        return exports.EaseElasticIn.create({action: this.other.reverse(), period: this.period});
    }
});

var EaseElasticInOut = EaseElastic.extend(/** @lends cocos.actions.EaseElasticInOut# */{
    /** 
     * @class EaseElasticInOut Ease Elastic InOut action
     */
    update: function(t) {
        var newT = 0;
        if (t == 0 || t == 1) {
            newT = t;
        } else {
            t *= 2;
            if (this.period == 0) {
                this.period = 0.3 * 1.5;
            }
            var s = this.period / 4;
            
            t -= 1;
            if (t < 0) {
                newT = -0.5 * Math.pow(2, 10 * t) * Math.sin((t - s) * Math.PI*2 / this.period);
            } else {
                newT = Math.pow(2, -10 * t) * Math.sin((t - s) * Math.PI*2 / this.period) * 0.5 + 1;
            }
        }
        this.other.update(newT);
    },
    
    copy: function() {
        return EaseElasticInOut.create({action: this.other.copy(), period: this.period});
    },
    
    reverse: function() {
        return EaseElasticInOut.create({action: this.other.reverse(), period: this.period});
    }
});

var EaseBounce = ActionEase.extend(/** @lends cocos.actions.EaseBounce# */{
    /** 
     * @class EaseBounce abstract class
     */
    bounceTime: function(t) {
        // Direct cut & paste from CCActionEase.m, obviously.
        // Glad someone else figured out all this math...
        if (t < 1 / 2.75) {
            return 7.5625 * t * t;
        }
        else if (t < 2 / 2.75) {
            t -= 1.5 / 2.75;
            return 7.5625 * t * t + 0.75;
        }
        else if (t < 2.5 / 2.75) {
            t -= 2.25 / 2.75;
            return 7.5625 * t * t + 0.9375;
        }

        t -= 2.625 / 2.75;
        return 7.5625 * t * t + 0.984375;
    }
});

var EaseBounceIn = EaseBounce.extend(/** @lends cocos.actions.EaseBounceIn# */{
    /** 
     * @class EaseBounceIn EaseBounceIn action
     */
    update: function(t) {
        var newT = 1 - this.bounceTime(1-t);
        this.other.update(newT);
    },
    
    copy: function() {
        return EaseBounceIn.create({action: this.other.copy()});
    },
    
    reverse: function() {
        return exports.EaseBounceOut.create({action: this.other.reverse()});
    }
});

var EaseBounceOut = EaseBounce.extend(/** @lends cocos.actions.EaseBounceOut# */{
    /** 
     * @class EaseBounceOut EaseBounceOut action
     */
    update: function(t) {
        var newT = this.bounceTime(t);
        this.other.update(newT);
    },
    
    copy: function() {
        return EaseBounceOut.create({action: this.other.copy()});
    },
    
    reverse: function() {
        return exports.EaseBounceIn.create({action: this.other.reverse()});
    }
});

var EaseBounceInOut = EaseBounce.extend(/** @lends cocos.actions.EaseBounceInOut# */{
    /** 
     * @class EaseBounceInOut EaseBounceInOut action
     */
    update: function(t) {
        var newT = 0;
        if (t < 0.5) {
            t *= 2;
            newT = (1 - this.bounceTime(1 - t)) * 0.5;
        } else {
            newT = this.bounceTime(t * 2 - 1) * 0.5 + 0.5;
        }
        this.other.update(newT);
    },
    
    copy: function() {
        return EaseBounceInOut.create({action: this.other.copy()});
    },
    
    reverse: function() {
        return EaseBounceInOut.create({action: this.other.reverse()});
    }
});

var EaseBackIn = ActionEase.extend(/** @lends cocos.actions.EaseBackIn# */{
    /** 
     * @class EaseBackIn EaseBackIn action
     */
    update: function(t) {
        var overshoot = 1.70158;
        this.other.update(t * t * ((overshoot + 1) * t - overshoot));
    },
    
    copy: function() {
        return EaseBackIn.create({action: this.other.copy()});
    },
    
    reverse: function() {
        return exports.EaseBackOut.create({action: this.other.reverse()});
    }
});

var EaseBackOut = ActionEase.extend(/** @lends cocos.actions.EaseBackOut# */{
    /** 
     * @class EaseBackOut EaseBackOut action
     */
    update: function(t) {
        var overshoot = 1.70158;
        t -= 1;
        this.other.update(t * t * ((overshoot + 1) * t + overshoot) + 1);
    },
    
    copy: function() {
        return EaseBackOut.create({action: this.other.copy()});
    },
    
    reverse: function() {
        return exports.EaseBackIn.create({action: this.other.reverse()});
    }
});

var EaseBackInOut = ActionEase.extend(/** @lends cocos.actions.EaseBackInOut# */{
    /** 
     * @class EaseBackInOut EaseBackInOut action
     */
    update: function(t) {
        // Where do these constants come from?
        var overshoot = 1.70158 * 1.525;
        t *= 2;
        if (t < 1) {
            this.other.update((t * t * ((overshoot + 1) * t - overshoot)) / 2);
        } else {
            t -= 2;
            this.other.update((t * t * ((overshoot + 1) * t + overshoot)) / 2 + 1);
        }
    },
    
    copy: function() {
        return EaseBackInOut.create({action: this.other.copy()});
    },
    
    reverse: function() {
        return EaseBackInOut.create({action: this.other.reverse()});
    }
});

exports.ActionEase = ActionEase;
exports.EaseRate = EaseRate;
exports.EaseIn = EaseIn;
exports.EaseOut = EaseOut;
exports.EaseInOut = EaseInOut;
exports.EaseExponentialIn = EaseExponentialIn;
exports.EaseExponentialOut = EaseExponentialOut;
exports.EaseExponentialInOut = EaseExponentialInOut;
exports.EaseSineIn = EaseSineIn;
exports.EaseSineOut = EaseSineOut;
exports.EaseSineInOut = EaseSineInOut;
exports.EaseElastic = EaseElastic;
exports.EaseElasticIn = EaseElasticIn;
exports.EaseElasticOut = EaseElasticOut;
exports.EaseElasticInOut = EaseElasticInOut;
exports.EaseBounce = EaseBounce;
exports.EaseBounceIn = EaseBounceIn;
exports.EaseBounceOut = EaseBounceOut;
exports.EaseBounceInOut = EaseBounceInOut;
exports.EaseBackIn = EaseBackIn;
exports.EaseBackOut = EaseBackOut;
exports.EaseBackInOut = EaseBackInOut;


}};
__resources__["/__builtin__/libs/cocos2d/actions/ActionInstant.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    act = require('./Action'),
    ccp = require('geometry').ccp;

var ActionInstant = act.FiniteTimeAction.extend(/** @lends cocos.actions.ActionInstant */{
    /**
     * @class Base class for actions that triggers instantly. They have no duration.
     *
     * @memberOf cocos.actions
     * @extends cocos.actions.FiniteTimeAction
     * @constructs
     */
    init: function (opts) {
        ActionInstant.superclass.init.call(this, opts);

        this.duration = 0;
    },
    
    get_isDone: function () {
        return true;
    },
    
    step: function (dt) {
        this.update(1);
    },
    
    update: function (t) {
        // ignore
    },
    
    copy: function() {
        return this;
    },
    
    reverse: function () {
        return this.copy();
    }
});

var Show = ActionInstant.extend(/** @lends cocos.actions.Show# */{
    /** 
    * @class Show Show the node
    **/
    startWithTarget: function(target) {
        Show.superclass.startWithTarget.call(this, target);
        this.target.set('visible', true);
    },

    copy: function() {
        return Show.create();
    },
    
    reverse: function() {
        return exports.Hide.create();
    }
});

var Hide = ActionInstant.extend(/** @lends cocos.actions.Hide# */{
    /** 
    * @class Hide Hide the node
    **/
    startWithTarget: function(target) {
        Show.superclass.startWithTarget.call(this, target);
        this.target.set('visible', false);
    },

    copy: function() {
        return Hide.create();
    },
    
    reverse: function() {
        return exports.Show.create();
    }
});

var ToggleVisibility = ActionInstant.extend(/** @lends cocos.actions.ToggleVisibility# */{
    /** 
    * @class ToggleVisibility Toggles the visibility of a node
    **/
    startWithTarget: function(target) {
        ToggleVisibility.superclass.startWithTarget.call(this, target);
        var vis = this.target.get('visible');
        this.target.set('visible', !vis);
    },
    
    copy: function() {
        return ToggleVisibility.create();
    }
});

var FlipX = ActionInstant.extend(/** @lends cocos.actions.FlipX# */{
    flipX: false,

    /**
     * @class FlipX Flips a sprite horizontally
     *
     * @memberOf cocos.actions
     * @extends cocos.actions.ActionInstant
     * @constructs
     *
     * @opt {Boolean} flipX Should the sprite be flipped
     */
    init: function (opts) {
        FlipX.superclass.init.call(this, opts);

        this.flipX = opts.flipX;
    },
    
    startWithTarget: function (target) {
        FlipX.superclass.startWithTarget.call(this, target);

        target.set('flipX', this.flipX);
    },
    
    reverse: function () {
        return FlipX.create({flipX: !this.flipX});
    },
    
    copy: function () {
        return FlipX.create({flipX: this.flipX});
    }
});

var FlipY = ActionInstant.extend(/** @lends cocos.actions.FlipY# */{
    flipY: false,

    /**
     * @class FlipY Flips a sprite vertically
     *
     * @memberOf cocos.actions
     * @extends cocos.actions.ActionInstant
     * @constructs
     *
     * @opt {Boolean} flipY Should the sprite be flipped
     */
    init: function (opts) {
        FlipY.superclass.init.call(this, opts);

        this.flipY = opts.flipY;
    },
    
    startWithTarget: function (target) {
        FlipY.superclass.startWithTarget.call(this, target);

        target.set('flipY', this.flipY);
    },
    
    reverse: function () {
        return FlipY.create({flipY: !this.flipY});
    },
    
    copy: function () {
        return FlipY.create({flipY: this.flipY});
    }
});

var Place = ActionInstant.extend(/** @lends cocos.actions.Place# */{
    position: null,
    
    /**
	 * @class Place Places the node in a certain position
	 *
     * @memberOf cocos.actions
     * @extends cocos.actions.ActionInstant
     * @constructs
     *
     * @opt {geometry.Point} position
     */
    init: function(opts) {
        Place.superclass.init.call(this, opts);
        this.set('position', util.copy(opts.position));
    },
    
    startWithTarget: function(target) {
        Place.superclass.startWithTarget.call(this, target);
        this.target.set('position', this.position);
    },
    
    copy: function() {
        return Place.create({position: this.position});
    }
});

var CallFunc = ActionInstant.extend(/** @lends cocos.actions.CallFunc# */{
	callback: null,
    target: null,
    method: null,
    
	/**
	 * @class CallFunc Calls a 'callback'
	 *
     * @memberOf cocos.actions
     * @extends cocos.actions.ActionInstant
     * @constructs
     *
     * @opt {BObject} target
     * @opt {String|Function} method
     */
	init: function(opts) {
		CallFunc.superclass.init.call(this, opts);
		
		// Save target & method so that copy() can recreate callback
		this.target = opts.target;
		this.method = opts.method;
		this.callback = util.callback(this.target, this.method);
	},
	
	startWithTarget: function(target) {
		CallFunc.superclass.startWithTarget.call(this, target);
		this.execute(target);
	},
	
	execute: function(target) {
	    // Pass target to callback
		this.callback.call(this, target);
	},
	
	copy: function() {
	    return CallFunc.create({target: this.target, method: this.method});
	}
});

exports.ActionInstant = ActionInstant;
exports.Show = Show;
exports.Hide = Hide;
exports.ToggleVisibility = ToggleVisibility;
exports.FlipX = FlipX;
exports.FlipY = FlipY;
exports.Place = Place;
exports.CallFunc = CallFunc;


}};
__resources__["/__builtin__/libs/cocos2d/actions/ActionInterval.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    act = require('./Action'),
    geo = require('geometry'),
    ccp = geo.ccp;


var ActionInterval = act.FiniteTimeAction.extend(/** @lends cocos.actions.ActionInterval# */{
    /**
     * Number of seconds that have elapsed
     * @type Float
     */
    elapsed: 0.0,

    _firstTick: true,

    /**
     * Base class actions that do have a finite time duration.
     *
     * Possible actions:
     *
     * - An action with a duration of 0 seconds
     * - An action with a duration of 35.5 seconds Infinite time actions are valid
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.FiniteTimeAction
     *
     * @opt {Float} duration Number of seconds to run action for
     */
    init: function (opts) {
        ActionInterval.superclass.init.call(this, opts);

        var dur = opts.duration || 0;
        if (dur === 0) {
            dur = 0.0000001;
        }

        this.set('duration', dur);
        this.set('elapsed', 0);
        this._firstTick = true;
    },

    get_isDone: function () {
        return (this.elapsed >= this.duration);
    },

    step: function (dt) {
        if (this._firstTick) {
            this._firstTick = false;
            this.elapsed = 0;
        } else {
            this.elapsed += dt;
        }

        this.update(Math.min(1, this.elapsed / this.duration));
    },

    startWithTarget: function (target) {
        ActionInterval.superclass.startWithTarget.call(this, target);

        this.elapsed = 0.0;
        this._firstTick = true;
    },

    copy: function() {
        throw "copy() not implemented";
    },
    
    reverse: function () {
        throw "Reverse Action not implemented";
    }
});

var DelayTime = ActionInterval.extend(/** @lends cocos.actions.DelayTime# */{
    /**
     * @class DelayTime Delays the action a certain amount of seconds
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.ActionInterval
     */
    update: function (t) {
        if (t === 1.0) {
            this.stop();
        }
    },

    copy: function () {
        return DelayTime.create({duration: this.get('duration')});
    },

    reverse: function () {
        return DelayTime.create({duration: this.get('duration')});
    }
});


var ScaleTo = ActionInterval.extend(/** @lends cocos.actions.ScaleTo# */{
    /**
     * Current X Scale
     * @type Float
     */
    scaleX: 1,

    /**
     * Current Y Scale
     * @type Float
     */
    scaleY: 1,

    /**
     * Initial X Scale
     * @type Float
     */
    startScaleX: 1,

    /**
     * Initial Y Scale
     * @type Float
     */
    startScaleY: 1,

    /**
     * Final X Scale
     * @type Float
     */
    endScaleX: 1,

    /**
     * Final Y Scale
     * @type Float
     */
    endScaleY: 1,

    /**
     * Delta X Scale
     * @type Float
     * @private
     */
    deltaX: 0.0,

    /**
     * Delta Y Scale
     * @type Float
     * @private
     */
    deltaY: 0.0,

    /**
     * @class ScaleTo Scales a cocos.Node object to a zoom factor by modifying it's scale attribute.
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.ActionInterval
     *
     * @opt {Float} duration Number of seconds to run action for
     * @opt {Float} [scale] Size to scale Node to
     * @opt {Float} [scaleX] Size to scale width of Node to
     * @opt {Float} [scaleY] Size to scale height of Node to
     */
    init: function (opts) {
        ScaleTo.superclass.init.call(this, opts);

        if (opts.scale !== undefined) {
            this.endScaleX = this.endScaleY = opts.scale;
        } else {
            this.endScaleX = opts.scaleX;
            this.endScaleY = opts.scaleY;
        }


    },

    startWithTarget: function (target) {
        ScaleTo.superclass.startWithTarget.call(this, target);

        this.startScaleX = this.target.get('scaleX');
        this.startScaleY = this.target.get('scaleY');
        this.deltaX = this.endScaleX - this.startScaleX;
        this.deltaY = this.endScaleY - this.startScaleY;
    },

    update: function (t) {
        if (!this.target) {
            return;
        }

        this.target.set('scaleX', this.startScaleX + this.deltaX * t);
        this.target.set('scaleY', this.startScaleY + this.deltaY * t);
    },

    copy: function () {
        return ScaleTo.create({duration: this.get('duration'),
                                 scaleX: this.get('endScaleX'),
                                 scaleY: this.get('endScaleY')});
    }
});

var ScaleBy = ScaleTo.extend(/** @lends cocos.actions.ScaleBy# */{
    /**
     * @class ScaleBy Scales a cocos.Node object to a zoom factor by modifying it's scale attribute.
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.ScaleTo
     *
     * @opt {Float} duration Number of seconds to run action for
     * @opt {Float} [scale] Size to scale Node by
     * @opt {Float} [scaleX] Size to scale width of Node by
     * @opt {Float} [scaleY] Size to scale height of Node by
     */
    init: function (opts) {
        ScaleBy.superclass.init.call(this, opts);
    },

    startWithTarget: function (target) {
        ScaleBy.superclass.startWithTarget.call(this, target);

        this.deltaX = this.startScaleX * this.endScaleX - this.startScaleX;
        this.deltaY = this.startScaleY * this.endScaleY - this.startScaleY;
    },

    reverse: function () {
        return ScaleBy.create({duration: this.get('duration'), scaleX: 1 / this.endScaleX, scaleY: 1 / this.endScaleY});
    }
});


var RotateTo = ActionInterval.extend(/** @lends cocos.actions.RotateTo# */{
    /**
     * Final angle
     * @type Float
     */
    dstAngle: 0,

    /**
     * Initial angle
     * @type Float
     */
    startAngle: 0,

    /**
     * Angle delta
     * @type Float
     */
    diffAngle: 0,

    /**
     * @class RotateTo Rotates a cocos.Node object to a certain angle by modifying its rotation
     * attribute. The direction will be decided by the shortest angle.
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.ActionInterval
     *
     * @opt {Float} duration Number of seconds to run action for
     * @opt {Float} angle Angle in degrees to rotate to
     */
    init: function (opts) {
        RotateTo.superclass.init.call(this, opts);

        this.dstAngle = opts.angle;
    },

    startWithTarget: function (target) {
        RotateTo.superclass.startWithTarget.call(this, target);

        this.startAngle = target.get('rotation');

        if (this.startAngle > 0) {
            this.startAngle = (this.startAngle % 360);
        } else {
            this.startAngle = (this.startAngle % -360);
        }

        this.diffAngle = this.dstAngle - this.startAngle;
        if (this.diffAngle > 180) {
            this.diffAngle -= 360;
        } else if (this.diffAngle < -180) {
            this.diffAngle += 360;
        }
    },

    update: function (t) {
        this.target.set('rotation', this.startAngle + this.diffAngle * t);
    },

    copy: function () {
        return RotateTo.create({duration: this.get('duration'), angle: this.get('dstAngle')});
    }
});

var RotateBy = RotateTo.extend(/** @lends cocos.actions.RotateBy# */{
    /**
     * Number of degrees to rotate by
     * @type Float
     */
    angle: 0,

    /**
     * @class RotateBy Rotates a cocos.Node object to a certain angle by modifying its rotation
     * attribute. The direction will be decided by the shortest angle.
     *
     * @memberOf cocos.action
     * @constructs
     * @extends cocos.actions.RotateTo
     *
     * @opt {Float} duration Number of seconds to run action for
     * @opt {Float} angle Angle in degrees to rotate by
     */
    init: function (opts) {
        RotateBy.superclass.init.call(this, opts);

        this.angle = opts.angle;
    },

    startWithTarget: function (target) {
        RotateBy.superclass.startWithTarget.call(this, target);

        this.startAngle = this.target.get('rotation');
    },

    update: function (t) {
        this.target.set('rotation', this.startAngle + this.angle * t);
    },

    copy: function () {
        return RotateBy.create({duration: this.get('duration'), angle: this.angle});
    },
    
    reverse: function () {
        return RotateBy.create({duration: this.get('duration'), angle: -this.angle});
    }
});

var MoveTo = ActionInterval.extend(/** @lends cocos.actions.MoveTo# */{
    delta: null,
    startPosition: null,
    endPosition: null,

    /**
     * @class MoveTo Animates moving a cocos.nodes.Node object to a another point.
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.ActionInterval
     *
     * @opt {Float} duration Number of seconds to run action for
     * @opt {geometry.Point} position Destination position
     */
    init: function (opts) {
        MoveTo.superclass.init.call(this, opts);

        this.set('endPosition', util.copy(opts.position));
    },

    startWithTarget: function (target) {
        MoveTo.superclass.startWithTarget.call(this, target);

        this.set('startPosition', util.copy(target.get('position')));
        this.set('delta', geo.ccpSub(this.get('endPosition'), this.get('startPosition')));
    },

    update: function (t) {
        var startPosition = this.get('startPosition'),
            delta = this.get('delta');
        this.target.set('position', ccp(startPosition.x + delta.x * t, startPosition.y + delta.y * t));
    },
    
    copy: function() {
        return MoveTo.create({duration: this.get('duration'), position: this.get('endPosition')});
    }
});

var MoveBy = MoveTo.extend(/** @lends cocos.actions.MoveBy# */{
    /**
     * @class MoveBy Animates moving a cocos.node.Node object by a given number of pixels
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.MoveTo
     *
     * @opt {Float} duration Number of seconds to run action for
     * @opt {geometry.Point} position Number of pixels to move by
     */
    init: function (opts) {
        MoveBy.superclass.init.call(this, opts);

        this.set('delta', util.copy(opts.position));
    },

    startWithTarget: function (target) {
        var dTmp = this.get('delta');
        MoveBy.superclass.startWithTarget.call(this, target);
        this.set('delta', dTmp);
    },
    
    copy: function() {
         return MoveBy.create({duration: this.get('duration'), position: this.get('delta')});
    },
    
    reverse: function() {
        var delta = this.get('delta');
        return MoveBy.create({duration: this.get('duration'), position: geo.ccp(-delta.x, -delta.y)});
    }
});

var JumpBy = ActionInterval.extend(/** @lends cocos.actions.JumpBy# */{
    /**
     * Number of pixels to jump by
     * @type geometry.Point
     */
    delta: null,
    
    /**
     * Height of jump
     * @type Float
     */
    height: 0,
    
    /**
     * Number of times to jump
     * @type Integer
     */
    jumps: 0,
    
    /**
     * Starting point
     * @type geometry.Point
     */
    startPosition: null,
    
    /**
     * @class JumpBy Moves a CCNode object simulating a parabolic jump movement by modifying it's position attribute.
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.ActionInterval
     *
     * @opt {Float} duration Number of seconds to run action for
     * @opt {geometry.Point} startPosition Point at which jump starts
     * @opt {geometry.Point} delta Number of pixels to jump by
     * @opt {Float} height Height of jump
     * @opt {Int} jumps Number of times to repeat
     */
    init: function(opts) {
        JumpBy.superclass.init.call(this, opts);
        
        this.delta  = util.copy(opts.delta);
        this.height = opts.height;
        this.jumps  = opts.jumps;
    },
    
    copy: function() {
        return JumpBy.create({duration: this.duration, 
                                 delta: this.delta,
                                height: this.height,
                                 jumps: this.jumps});
    },
    
    startWithTarget: function(target) {
        JumpBy.superclass.startWithTarget.call(this, target);
        this.set('startPosition', target.get('position'));
    },
    
    update: function(t) {
        // parabolic jump
        var frac = (t * this.jumps) % 1.0;
        var y = this.height * 4 * frac * (1 - frac);
        y += this.delta.y * t;
        var x = this.delta.x * t;
        this.target.set('position', geo.ccp(this.startPosition.x + x, this.startPosition.y + y));
    },
    
    reverse: function() {
        return JumpBy.create({duration: this.duration,
                                 delta: geo.ccp(-this.delta.x, -this.delta.y),
                                height: this.height,
                                 jumps: this.jumps});
    }
});

var JumpTo = JumpBy.extend(/** @lends cocos.actions.JumpTo# */{
    /**
     * @class JumpTo Moves a Node object to a parabolic position simulating a jump 
     * movement by modifying it's position attribute.
     *
     * @memberOf cocos.actions
     * @extends cocos.actions.JumpBy
     */
    startWithTarget: function(target) {
        JumpTo.superclass.startWithTarget.call(this, target);
        this.delta = geo.ccp(this.delta.x - this.startPosition.x, this.delta.y - this.startPosition.y);
    }
});

var BezierBy = ActionInterval.extend(/** @lends cocos.actions.BezierBy# */{
    /**
     * @type {geometry.BezierConfig}
     */
    config: null,
    
    startPosition: null,
    
    /**
     * @class BezierBy An action that moves the target with a cubic Bezier curve by a certain distance.
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.ActionInterval
     *
     * @opts {geometry.BezierConfig} bezier Bezier control points object
     * @opts {Float} duration
     */
    init: function(opts) {
        BezierBy.superclass.init.call(this, opts);
        
        this.config = util.copy(opts.bezier);
    },
    
    startWithTarget: function(target) {
        BezierBy.superclass.startWithTarget.call(this, target);
        this.set('startPosition', this.target.get('position'));
    },
    
    update: function(t) {
        var c = this.get('config');
        var xa = 0,
            xb = c.controlPoint1.x,
            xc = c.controlPoint2.x,
            xd = c.endPosition.x,
            ya = 0,
            yb = c.controlPoint1.y,
            yc = c.controlPoint2.y,
            yd = c.endPosition.y;
        
        var x = BezierBy.bezierat(xa, xb, xc, xd, t);
        var y = BezierBy.bezierat(ya, yb, yc, yd, t);
        
        this.target.set('position', geo.ccpAdd(this.get('startPosition'), geo.ccp(x, y)));
    },
    
    copy: function() {
        return BezierBy.create({bezier: this.get('config'), duration: this.get('duration')});
    },
    
    reverse: function() {
        var c = this.get('config'),
            bc = new geo.BezierConfig();
            
        bc.endPosition = geo.ccpNeg(c.endPosition);
        bc.controlPoint1 = geo.ccpAdd(c.controlPoint2, geo.ccpNeg(c.endPosition));
        bc.controlPoint2 = geo.ccpAdd(c.controlPoint1, geo.ccpNeg(c.endPosition));
        
        return BezierBy.create({bezier: bc, duration: this.get('duration')});
    }
});

util.extend(BezierBy, {
    /**
     * Bezier cubic formula
     * ((1 - t) + t)3 = 1 
     */
    bezierat: function(a, b, c, d, t) {
       return Math.pow(1-t, 3) * a + 
            3 * t * Math.pow(1-t, 2) * b +
            3 * Math.pow(t, 2) * (1 - t) * c +
            Math.pow(t, 3) * d;
    }
});

var BezierTo = BezierBy.extend(/** @lends cocos.actions.BezierTo# */{
    /**
     * @class BezierTo An action that moves the target with a cubic Bezier curve to a destination point.
     *
     * @memberOf cocos.actions
     * @extends cocos.actions.BezierBy
     */
    startWithTarget: function(target) {
        BezierTo.superclass.startWithTarget.call(this, target);
        
        var c = this.get('config');
        c.controlPoint1 = geo.ccpSub(c.controlPoint1, this.get('startPosition'));
        c.controlPoint2 = geo.ccpSub(c.controlPoint2, this.get('startPosition'));
        c.endPosition = geo.ccpSub(c.endPosition, this.get('startPosition'));
    }
});

var Blink = ActionInterval.extend(/** @lends cocos.actions.Blink# */{
    /**
     * @type {Integer}
     */
    times: 1,
    
    /**
     * @class Blink Blinks a Node object by modifying it's visible attribute
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.ActionInterval
     *
     * @opts {Integer} blinks Number of times to blink
     * @opts {Float} duration
     */
    init: function(opts) {
        Blink.superclass.init.call(this, opts);
        this.times = opts.blinks;
    },
    
    update: function(t) {
        if (! this.get_isDone()) {
            var slice = 1 / this.times;
            var m = t % slice;
            this.target.set('visible', (m > slice/2));
        }
    },
    
    copy: function() {
        return Blink.create({duration: this.get('duration'), blinks: this.get('times')});
    },
    
    reverse: function() {
        return this.copy();
    }
});

var FadeOut = ActionInterval.extend(/** @lends cocos.actions.FadeOut# */{
   /**
    * @class FadeOut Fades out a cocos.nodes.Node to zero opacity
    *
    * @memberOf cocos.actions
    * @extends cocos.actions.ActionInterval
    */     
    update: function (t) {
        var target = this.get('target');
        if (!target) return;
        target.set('opacity', 255 - (255 * t));
    },

    copy: function () {
        return FadeOut.create({duration: this.get('duration')});
    },
    
    reverse: function () {
        return exports.FadeIn.create({duration: this.get('duration')});
    }
});


var FadeIn = ActionInterval.extend(/** @lends cocos.actions.FadeIn# */{
    /**
     * @class FadeIn Fades in a cocos.nodes.Node to 100% opacity
     *
     * @memberOf cocos.actions
     * @extends cocos.actions.ActionInterval
     */
    update: function (t) {
        var target = this.get('target');
        if (!target) return;
        target.set('opacity', t * 255);
    },

    copy: function () {
        return FadeIn.create({duration: this.get('duration')});
    },
    
    reverse: function () {
        return exports.FadeOut.create({duration: this.get('duration')});
    }
});

var FadeTo = ActionInterval.extend(/** @lends cocos.actions.FadeTo# */{
    /**
     * The final opacity
     * @type Float
     */
    toOpacity: null,

    /**
     * The initial opacity
     * @type Float
     */
    fromOpacity: null,

    /**
     * @class FadeTo Fades a cocos.nodes.Node to a given opacity
     *
     * @memberOf cocos.actions
     * @constructor
     * @extends cocos.actions.ActionInterval
     */
    init: function (opts) {
        FadeTo.superclass.init.call(this, opts);
        this.set('toOpacity', opts.toOpacity);
    },

    startWithTarget: function (target) {
        FadeTo.superclass.startWithTarget.call(this, target);
        this.set('fromOpacity', this.target.get('opacity'));
    },

    update: function (t) {
        var target = this.get('target');
        if (!target) return;

        target.set('opacity', this.fromOpacity + ( this.toOpacity - this.fromOpacity ) * t);
    },
    
    copy: function() {
        return FadeTo.create({duration: this.get('duration'), toOpacity: this.get('toOpacity')});
    }
});

var Sequence = ActionInterval.extend(/** @lends cocos.actions.Sequence# */{
    /**
     * Array of actions to run
     * @type cocos.nodes.Node[]
     */
    actions: null,

    split: 0,
    last: 0,
    
    /**
     * Runs a pair of actions sequentially, one after another
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.ActionInterval
     *
     * @opt {cocos.actions.FiniteTimeAction} one 1st action to run
     * @opt {cocos.actions.FiniteTimeAction} two 2nd action to run
     */
    init: function (opts) {
        if (!opts.one) {
            throw "Sequence argument one must be non-nil";
        }
        if (!opts.two) {
            throw "Sequence argument two must be non-nil";
        }
        this.actions = [];
        
        var d = opts.one.get('duration') + opts.two.get('duration');
        
        Sequence.superclass.init.call(this, {duration: d});
        
        this.actions[0] = opts.one;
        this.actions[1] = opts.two;
    },
    
    startWithTarget: function (target) {
        Sequence.superclass.startWithTarget.call(this, target);
        this.split = this.actions[0].get('duration') / this.get('duration');
        this.last = -1;
    },

    stop: function () {
        this.actions[0].stop();
        this.actions[1].stop();
        Sequence.superclass.stop.call(this);
    },

    update: function (t) {
        // This is confusing but will hopefully work better in conjunction
        // with modifer actions like Repeat & Spawn...
        var found = 0;
        var new_t = 0;
        
        if (t >= this.split) {
            found = 1;
            if (this.split == 1) {
                new_t = 1;
            } else {
                new_t = (t - this.split) / (1 - this.split);
            }
        } else {
            found = 0;
            if (this.split != 0) {
                new_t = t / this.split;
            } else {
                new_t = 1;
            }
        }
        if (this.last == -1 && found == 1) {
            this.actions[0].startWithTarget(this.target);
            this.actions[0].update(1);
            this.actions[0].stop();
        }
        if (this.last != found) {
            if (this.last != -1) {
                this.actions[this.last].update(1);
                this.actions[this.last].stop();
            }
            this.actions[found].startWithTarget(this.target);
        }
        this.actions[found].update(new_t);
        this.last = found;
    },

    copy: function () {
        // Constructor will copy actions 
        return Sequence.create({actions: this.get('actions')});
    },

    reverse: function() {
        return Sequence.create({actions: [this.actions[1].reverse(), this.actions[0].reverse()]});
    }
});

util.extend(Sequence, {
    /** 
     * Override BObject.create in order to implement recursive construction
     * of actions array
     */
    create: function() {
        // Don't copy actions array, copy the actions
        var actions = arguments[0].actions;
        var prev = actions[0].copy();
        
        // Recursively create Sequence with pair of actions
        for (var i=1; i<actions.length; i++) {
            var now = actions[i].copy();
            if (now) {
                prev = this.initFromPair(prev, now);
            } else {
                break;
            }
        }
        return prev;
    },
    
    /** 
     * Create sequence object from a pair of actions
     */
    initFromPair: function(a1, a2) {
        var ret = new this();
        ret.init.apply(ret, [{one: a1, two: a2}]);
        return ret;
    }
});

var Repeat = ActionInterval.extend(/** @lends cocos.actions.Repeat# */{
    times: 1,
    total: 0,
    other: null,
    
    /**
     * @class Repeat Repeats an action a number of times.
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.ActionInterval
     *
     * @opt {cocos.actions.FiniteTimeAction} action Action to repeat
     * @opt {Number} times Number of times to repeat
     */
     init: function(opts) {
         var d = opts.action.get('duration') * opts.times;

         Repeat.superclass.init.call(this, {duration: d});
         
         this.times = opts.times;
         this.other = opts.action.copy();
         this.total = 0;
     },
     
     startWithTarget: function(target) {
         this.total = 0;
         Repeat.superclass.startWithTarget.call(this, target);
         this.other.startWithTarget(target);
     },
     
     stop: function() {
         this.other.stop();
         Repeat.superclass.stop.call(this);
     },
     
     update: function(dt) {
         var t = dt * this.times;
         
         if (t > (this.total+1)) {
             this.other.update(1);
             this.total += 1;
             this.other.stop();
             this.other.startWithTarget(this.target);
             
             // If repeat is over
             if (this.total == this.times) {
                 // set it in the original position
                 this.other.update(0);
             } else {
                 // otherwise start next repeat
                 this.other.update(t - this.total);
             }
         } else {
             var r = t % 1.0;
             
             // fix last repeat position otherwise it could be 0
             if (dt == 1) {
                 r = 1;
                 this.total += 1;
             }
             this.other.update(Math.min(r, 1));
         }
     },
     
     get_isDone: function() {
         return this.total == this.times;
     },
     
     copy: function() {
         // Constructor copies action
         return Repeat.create({action: this.other, times: this.times});
     },
     
     reverse: function() {
         return Repeat.create({action: this.other.reverse(), times: this.times});
     }
});

var Spawn = ActionInterval.extend(/** @lends cocos.actions.Spawn# */{
    one: null,
    two: null,

    /**
     * @class Spawn Executes multiple actions simultaneously
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.ActionInterval
     *
     * @opt {cocos.actions.FiniteTimeAction} one: first action to spawn
     * @opt {cocos.actions.FiniteTimeAction} two: second action to spawn
     */
    init: function (opts) {
        var action1 = opts.one, 
            action2 = opts.two;
            
        if (!action1 || !action2) {
            throw "cocos.actions.Spawn: required actions missing";
        }
        var d1 = action1.get('duration'), 
            d2 = action2.get('duration');
        
        Spawn.superclass.init.call(this, {duration: Math.max(d1, d2)});
        
        this.set('one', action1);
        this.set('two', action2);
        
        if (d1 > d2) {
            this.set('two', Sequence.create({actions: [
                action2, 
                DelayTime.create({duration: d1-d2})
            ]}));
        } else if (d1 < d2) {
            this.set('one', Sequence.create({actions: [
                action1,
                DelayTime.create({duration: d2-d1})
            ]}));
        }
    },
    
    startWithTarget: function (target) {
        Spawn.superclass.startWithTarget.call(this, target);
        this.get('one').startWithTarget(this.target);
        this.get('two').startWithTarget(this.target);
    },
    
    stop: function () {
        this.get('one').stop();
        this.get('two').stop();
        Spawn.superclass.stop.call(this);
    },
    
    step: function (dt) {
        if (this._firstTick) {
            this._firstTick = false;
            this.elapsed = 0;
        } else {
            this.elapsed += dt;
        }
        this.get('one').step(dt);
        this.get('two').step(dt);
    },
    
    update: function (t) {
        this.get('one').update(t);
        this.get('two').update(t);
    },
    
    copy: function () {
        return Spawn.create({one: this.get('one').copy(), two: this.get('two').copy()});
    },
    
    reverse: function () {
        return Spawn.create({one: this.get('one').reverse(), two: this.get('two').reverse()});
    }
});

util.extend(Spawn, {
    /**
     * Helper class function to create Spawn object from array of actions
     *
     * @opt {Array} actions: list of actions to run simultaneously
     */
    initWithActions: function (opts) {
        var now, prev = opts.actions.shift();
        while (opts.actions.length > 0) {
            now = opts.actions.shift();
            if (now) {
                prev = this.create({one: prev, two: now});
            } else {
                break;
            }
        }
        return prev;
    }
});

var Animate = ActionInterval.extend(/** @lends cocos.actions.Animate# */{
    animation: null,
    restoreOriginalFrame: true,
    origFrame: null,


    /**
     * Animates a sprite given the name of an Animation
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.ActionInterval
     *
     * @opt {Float} duration Number of seconds to run action for
     * @opt {cocos.Animation} animation Animation to run
     * @opt {Boolean} [restoreOriginalFrame=true] Return to first frame when finished
     */
    init: function (opts) {
        this.animation = opts.animation;
        this.restoreOriginalFrame = opts.restoreOriginalFrame !== false;
        opts.duration = this.animation.frames.length * this.animation.delay;

        Animate.superclass.init.call(this, opts);
    },

    startWithTarget: function (target) {
        Animate.superclass.startWithTarget.call(this, target);

        if (this.restoreOriginalFrame) {
            this.set('origFrame', this.target.get('displayedFrame'));
        }
    },

    stop: function () {
        if (this.target && this.restoreOriginalFrame) {
            var sprite = this.target;
            sprite.set('displayFrame', this.origFrame);
        }

        Animate.superclass.stop.call(this);
    },

    update: function (t) {
        var frames = this.animation.get('frames'),
            numberOfFrames = frames.length,
            idx = Math.floor(t * numberOfFrames);

        if (idx >= numberOfFrames) {
            idx = numberOfFrames - 1;
        }

        var sprite = this.target;
        if (!sprite.isFrameDisplayed(frames[idx])) {
            sprite.set('displayFrame', frames[idx]);
        }
    },

    copy: function () {
        return Animate.create({animation: this.animation, restoreOriginalFrame: this.restoreOriginalFrame});
    }

});

exports.ActionInterval = ActionInterval;
exports.DelayTime = DelayTime;
exports.ScaleTo = ScaleTo;
exports.ScaleBy = ScaleBy;
exports.RotateTo = RotateTo;
exports.RotateBy = RotateBy;
exports.MoveTo = MoveTo;
exports.MoveBy = MoveBy;
exports.JumpBy = JumpBy;
exports.JumpTo = JumpTo;
exports.BezierBy = BezierBy;
exports.BezierTo = BezierTo;
exports.Blink = Blink;
exports.FadeIn = FadeIn;
exports.FadeOut = FadeOut;
exports.FadeTo = FadeTo;
exports.Spawn = Spawn;
exports.Sequence = Sequence;
exports.Repeat = Repeat;
exports.Animate = Animate;

}};
__resources__["/__builtin__/libs/cocos2d/actions/index.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    path = require('path');

var modules = 'Action ActionInterval ActionInstant ActionEase'.w();

/**
 * @memberOf cocos
 * @namespace Actions used to animate or change a Node
 */
var actions = {};

util.each(modules, function (mod, i) {
    util.extend(actions, require('./' + mod));
});

module.exports = actions;

}};
__resources__["/__builtin__/libs/cocos2d/Animation.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util');

var Animation = BObject.extend(/** @lends cocos.Animation# */{
    name: null,
    delay: 0.0,
    frames: null,

    /** 
     * A cocos.Animation object is used to perform animations on the Sprite objects.
     * 
     * The Animation object contains cocos.SpriteFrame objects, and a possible delay between the frames.
     * You can animate a cocos.Animation object by using the cocos.actions.Animate action.
     * 
     * @memberOf cocos
     * @constructs
     * @extends BObject
     *
     * @opt {cocos.SpriteFrame[]} frames Frames to animate
     * @opt {Float} [delay=0.0] Delay between each frame
     * 
     * @example
     * var animation = cocos.Animation.create({frames: [f1, f2, f3], delay: 0.1});
     * sprite.runAction(cocos.actions.Animate.create({animation: animation}));
     */
    init: function (opts) {
        Animation.superclass.init.call(this, opts);

        this.frames = opts.frames || [];
        this.delay  = opts.delay  || 0.0;
    }
});

exports.Animation = Animation;

}};
__resources__["/__builtin__/libs/cocos2d/AnimationCache.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    Plist = require('Plist').Plist;

var AnimationCache = BObject.extend(/** @lends cocos.AnimationCache# */{
    /**
     * Cached animations
     * @type Object
     */
    animations: null,

    /**
     * @memberOf cocos
     * @constructs
     * @extends BObject
     * @singleton
     */
    init: function () {
        AnimationCache.superclass.init.call(this);

        this.set('animations', {});
    },

    /**
     * Add an animation to the cache
     *
     * @opt {String} name Unique name of the animation
     * @opt {cocos.Animcation} animation Animation to cache
     */
    addAnimation: function (opts) {
        var name = opts.name,
            animation = opts.animation;

        this.get('animations')[name] = animation;
    },

    /**
     * Remove an animation from the cache
     *
     * @opt {String} name Unique name of the animation
     */
    removeAnimation: function (opts) {
        var name = opts.name;

        delete this.get('animations')[name];
    },

    /**
     * Get an animation from the cache
     *
     * @opt {String} name Unique name of the animation
     * @returns {cocos.Animation} Cached animation
     */
    getAnimation: function (opts) {
        var name = opts.name;

        return this.get('animations')[name];
    }
});

/**
 * Class methods
 */
util.extend(AnimationCache, /** @lends cocos.AnimationCache */{
    /**
     * @getter sharedAnimationCache
     * @type cocos.AnimationCache
     */
    get_sharedAnimationCache: function (key) {
        if (!this._instance) {
            this._instance = this.create();
        }

        return this._instance;
    }
});

exports.AnimationCache = AnimationCache;

}};
__resources__["/__builtin__/libs/cocos2d/Director.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray FLIP_Y_AXIS SHOW_REDRAW_REGIONS*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    geo = require('geometry'),
    ccp = geo.ccp,
    events    = require('events'),
    Scheduler = require('./Scheduler').Scheduler,
    EventDispatcher = require('./EventDispatcher').EventDispatcher,
    Scene = require('./nodes/Scene').Scene;


/**
 * requestAnimationFrame for smart animating
 * @see http://paulirish.com/2011/requestanimationframe-for-smart-animating/
 */
window.requestAnimFrame = (function (){
    return  window.requestAnimationFrame       || 
            window.webkitRequestAnimationFrame || 
            window.mozRequestAnimationFrame    || 
            window.oRequestAnimationFrame      || 
            window.msRequestAnimationFrame     || 
            function (callback) {
                window.setTimeout(callback, 1000 / 30);
            };
})();

var Director = BObject.extend(/** @lends cocos.Director# */{
    backgroundColor: 'rgb(0, 0, 0)',
    canvas: null,
    context: null,
    sceneStack: null,
    winSize: null,
    isPaused: false,
    maxFrameRate: 30,
    displayFPS: false,
    preloadScene: null,
    isReady: false,

    // Time delta
    dt: 0,
    nextDeltaTimeZero: false,
    lastUpdate: 0,

    _nextScene: null,

    /**
     * <p>Creates and handles the main view and manages how and when to execute the
     * Scenes.</p>
     *
     * <p>This class is a singleton so don't instantiate it yourself, instead use
     * cocos.Director.get('sharedDirector') to return the instance.</p>
     *
     * @memberOf cocos
     * @constructs
     * @extends BObject
     * @singleton
     */
    init: function () {
        Director.superclass.init.call(this);

        this.set('sceneStack', []);
    },

    /**
     * Append to a HTML element. It will create a canvas tag
     *
     * @param {HTMLElement} view Any HTML element to add the application to
     */
    attachInView: function (view) {
        if (!view.tagName) {
            throw "Director.attachInView must be given a HTML DOM Node";
        }

        while (view.firstChild) {
            view.removeChild(view.firstChild);
        }


        var canvas = document.createElement('canvas');
        this.set('canvas', canvas);
        canvas.setAttribute('width', view.clientWidth);
        canvas.setAttribute('height', view.clientHeight);

        var context = canvas.getContext('2d');
        this.set('context', context);

        if (FLIP_Y_AXIS) {
            context.translate(0, view.clientHeight);
            context.scale(1, -1);
        }

        view.appendChild(canvas);

        this.set('winSize', {width: view.clientWidth, height: view.clientHeight});


        // Setup event handling

        // Mouse events
        var eventDispatcher = EventDispatcher.get('sharedDispatcher');
        var self = this;
        function mouseDown(evt) {
            evt.locationInWindow = ccp(evt.clientX, evt.clientY);
            evt.locationInCanvas = self.convertEventToCanvas(evt);

            function mouseDragged(evt) {
                evt.locationInWindow = ccp(evt.clientX, evt.clientY);
                evt.locationInCanvas = self.convertEventToCanvas(evt);

                eventDispatcher.mouseDragged(evt);
            }
            function mouseUp(evt) {
                evt.locationInWindow = ccp(evt.clientX, evt.clientY);
                evt.locationInCanvas = self.convertEventToCanvas(evt);

                document.body.removeEventListener('mousemove', mouseDragged, false);
                document.body.removeEventListener('mouseup',   mouseUp,   false);


                eventDispatcher.mouseUp(evt);
            }

            document.body.addEventListener('mousemove', mouseDragged, false);
            document.body.addEventListener('mouseup',   mouseUp,   false);

            eventDispatcher.mouseDown(evt);
        }
        function mouseMoved(evt) {
            evt.locationInWindow = ccp(evt.clientX, evt.clientY);
            evt.locationInCanvas = self.convertEventToCanvas(evt);

            eventDispatcher.mouseMoved(evt);
        }
        canvas.addEventListener('mousedown', mouseDown, false);
        canvas.addEventListener('mousemove', mouseMoved, false);

        // Keyboard events
        function keyDown(evt) {
            this._keysDown = this._keysDown || {};
            eventDispatcher.keyDown(evt);
        }
        function keyUp(evt) {
            eventDispatcher.keyUp(evt);
        }

        document.documentElement.addEventListener('keydown', keyDown, false);
        document.documentElement.addEventListener('keyup', keyUp, false);
    },

    runPreloadScene: function () {
        var preloader = this.get('preloadScene');
        if (!preloader) {
            var PreloadScene = require('./nodes/PreloadScene').PreloadScene;
            preloader = PreloadScene.create();
            this.set('preloadScene', preloader);
        }

        events.addListener(preloader, 'complete', util.callback(this, function (preloader) {
            this.isReady = true;
            events.trigger(this, 'ready', this);
        }));

        this.pushScene(preloader);
        this.startAnimation();
    },

    /**
     * Enters the Director's main loop with the given Scene. Call it to run
     * only your FIRST scene. Don't call it if there is already a running
     * scene.
     *
     * @param {cocos.Scene} scene The scene to start
     */
    runWithScene: function (scene) {
        if (!(scene instanceof Scene)) {
            throw "Director.runWithScene must be given an instance of Scene";
        }

        if (this._runningScene) {
            throw "You can't run a Scene if another Scene is already running. Use replaceScene or pushScene instead";
        }

        this.pushScene(scene);
        this.startAnimation();
    },

    /**
     * Replaces the running scene with a new one. The running scene is
     * terminated. ONLY call it if there is a running scene.
     *
     * @param {cocos.Scene} scene The scene to replace with
     */
    replaceScene: function (scene) {
        var index = this.sceneStack.length;

        this._sendCleanupToScene = true;
        this.sceneStack.pop();
        this.sceneStack.push(scene);
        this._nextScene = scene;
    },

    /**
     * Pops out a scene from the queue. This scene will replace the running
     * one. The running scene will be deleted. If there are no more scenes in
     * the stack the execution is terminated. ONLY call it if there is a
     * running scene.
     */
    popScene: function () {
    },

    /**
     * Suspends the execution of the running scene, pushing it on the stack of
     * suspended scenes. The new scene will be executed. Try to avoid big
     * stacks of pushed scenes to reduce memory allocation. ONLY call it if
     * there is a running scene.
     *
     * @param {cocos.Scene} scene The scene to add to the stack
     */
    pushScene: function (scene) {
        this._nextScene = scene;
    },

    /**
     * The main loop is triggered again. Call this function only if
     * cocos.Directory#stopAnimation was called earlier.
     */
    startAnimation: function () {
        this.animate();
    },

    animate: function() {
        this.drawScene();
        window.requestAnimFrame(util.callback(this, 'animate'), this.canvas);
    },

    /**
     * Stops the animation. Nothing will be drawn. The main loop won't be
     * triggered anymore. If you want to pause your animation call
     * cocos.Directory#pause instead.
     */
    stopAnimation: function () {
        if (this._animationTimer) {
            clearInterval(this._animationTimer);
            this._animationTimer = null;
        }
    },

    /**
     * Calculate time since last call
     * @private
     */
    calculateDeltaTime: function () {
        var now = (new Date()).getTime() / 1000;

        if (this.nextDeltaTimeZero) {
            this.dt = 0;
            this.nextDeltaTimeZero = false;
        }

        this.dt = Math.max(0, now - this.lastUpdate);

        this.lastUpdate = now;
    },

    /**
     * The main run loop
     * @private
     */
    drawScene: function () {
        this.calculateDeltaTime();
        
        if (!this.isPaused) {
            Scheduler.get('sharedScheduler').tick(this.dt);
        }


        var context = this.get('context');
        context.fillStyle = this.get('backgroundColor');
        context.fillRect(0, 0, this.winSize.width, this.winSize.height);
        //this.canvas.width = this.canvas.width


        if (this._nextScene) {
            this.setNextScene();
        }

        var rect = new geo.Rect(0, 0, this.winSize.width, this.winSize.height);

        if (rect) {
            context.beginPath();
            context.rect(rect.origin.x, rect.origin.y, rect.size.width, rect.size.height);
            context.clip();
            context.closePath();
        }

        this._runningScene.visit(context, rect);

        if (SHOW_REDRAW_REGIONS) {
            if (rect) {
                context.beginPath();
                context.rect(rect.origin.x, rect.origin.y, rect.size.width, rect.size.height);
                context.fillStyle = "rgba(255, 0, 0, 0.5)";
                //context.fill();
                context.closePath();
            }
        }

        if (this.get('displayFPS')) {
            this.showFPS();
        }
    },

    /**
     * Initialises the next scene
     * @private
     */
    setNextScene: function () {
        // TODO transitions

        if (this._runningScene) {
            this._runningScene.onExit();
            if (this._sendCleanupToScene) {
                this._runningScene.cleanup();
            }
        }

        this._runningScene = this._nextScene;

        this._nextScene = null;

        this._runningScene.onEnter();
    },

    convertEventToCanvas: function (evt) {
        var x = this.canvas.offsetLeft - document.documentElement.scrollLeft,
            y = this.canvas.offsetTop - document.documentElement.scrollTop;

        var o = this.canvas;
        while ((o = o.offsetParent)) {
            x += o.offsetLeft - o.scrollLeft;
            y += o.offsetTop - o.scrollTop;
        }

        var p = geo.ccpSub(evt.locationInWindow, ccp(x, y));
        if (FLIP_Y_AXIS) {
            p.y = this.canvas.height - p.y;
        }

        return p;
    },

    showFPS: function () {
        if (!this._fpsLabel) {
            var Label = require('./nodes/Label').Label;
            this._fpsLabel = Label.create({string: '', fontSize: 16});
            this._fpsLabel.set('anchorPoint', ccp(0, 1));
            this._frames = 0;
            this._accumDt = 0;
        }


        this._frames++;
        this._accumDt += this.get('dt');
        
        if (this._accumDt > 1.0 / 3.0)  {
            var frameRate = this._frames / this._accumDt;
            this._frames = 0;
            this._accumDt = 0;

            this._fpsLabel.set('string', 'FPS: ' + (Math.round(frameRate * 100) / 100).toString());
        }


        var s = this.get('winSize');
        this._fpsLabel.set('position', ccp(10, s.height - 10));

        this._fpsLabel.visit(this.get('context'));
    }

});

/**
 * Class methods
 */
util.extend(Director, /** @lends cocos.Director */{
    /**
     * A shared singleton instance of cocos.Director
     *
     * @getter sharedDirector
     * @type cocos.Director
     */
    get_sharedDirector: function (key) {
        if (!Director._instance) {
            Director._instance = this.create();
        }

        return Director._instance;
    }
});

/**
 * @memberOf cocos
 * @class Pretends to run at a constant frame rate even if it slows down
 * @extends cocos.Director
 */
var DirectorFixedSpeed = Director.extend(/** @lends cocos.DirectorFixedSpeed */{
    /**
     * Frames per second to draw.
     * @type Integer
     */
    frameRate: 60,

    /**
     * Calculate time since last call
     * @private
     */
    calculateDeltaTime: function () {
        if (this.nextDeltaTimeZero) {
            this.dt = 0;
            this.nextDeltaTimeZero = false;
        }

        this.dt = 1.0 / this.get('frameRate');
    },

    /**
     * The main loop is triggered again. Call this function only if
     * cocos.Directory#stopAnimation was called earlier.
     */
    startAnimation: function () {
        this._animationTimer = setInterval(util.callback(this, 'drawScene'), 1000 / this.get('frameRate'));
        this.drawScene();
    }

});

exports.Director = Director;
exports.DirectorFixedSpeed = DirectorFixedSpeed;

}};
__resources__["/__builtin__/libs/cocos2d/EventDispatcher.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray FLIP_Y_AXIS*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    geo = require('geometry');

var EventDispatcher = BObject.extend(/** @lends cocos.EventDispatcher# */{
    dispatchEvents: true,
    keyboardDelegates: null,
    mouseDelegates: null,
    _keysDown: null,
    
    /**
     * This singleton is responsible for dispatching Mouse and Keyboard events.
     *
     * @memberOf cocos
     * @constructs
     * @extends BObject
     * @singleton
     */
    init: function () {
        EventDispatcher.superclass.init.call(this);

        this.keyboardDelegates = [];
        this.mouseDelegates = [];

        this._keysDown = {};
    },

    addDelegate: function (opts) {
        var delegate = opts.delegate,
            priority = opts.priority,
            flags    = opts.flags,
            list     = opts.list;

        var listElement = {
            delegate: delegate,
            priority: priority,
            flags: flags
        };

        var added = false;
        for (var i = 0; i < list.length; i++) {
            var elem = list[i];
            if (priority < elem.priority) {
                // Priority is lower, so insert before elem
                list.splice(i, 0, listElement);
                added = true;
                break;
            }
        }

        // High priority; append to array
        if (!added) {
            list.push(listElement);
        }
    },

    removeDelegate: function (opts) {
        var delegate = opts.delegate,
            list = opts.list;

        var idx = -1,
            i;
        for (i = 0; i < list.length; i++) {
            var l = list[i];
            if (l.delegate == delegate) {
                idx = i;
                break;
            }
        }
        if (idx == -1) {
            return;
        }
        list.splice(idx, 1);
    },
    removeAllDelegates: function (opts) {
        var list = opts.list;

        list.splice(0, list.length - 1);
    },

    addMouseDelegate: function (opts) {
        var delegate = opts.delegate,
            priority = opts.priority;

        var flags = 0;

        // TODO flags

        this.addDelegate({delegate: delegate, priority: priority, flags: flags, list: this.mouseDelegates});
    },

    removeMouseDelegate: function (opts) {
        var delegate = opts.delegate;

        this.removeDelegate({delegate: delegate, list: this.mouseDelegates});
    },

    removeAllMouseDelegate: function () {
        this.removeAllDelegates({list: this.mouseDelegates});
    },

    addKeyboardDelegate: function (opts) {
        var delegate = opts.delegate,
            priority = opts.priority;

        var flags = 0;

        // TODO flags

        this.addDelegate({delegate: delegate, priority: priority, flags: flags, list: this.keyboardDelegates});
    },

    removeKeyboardDelegate: function (opts) {
        var delegate = opts.delegate;

        this.removeDelegate({delegate: delegate, list: this.keyboardDelegates});
    },

    removeAllKeyboardDelegate: function () {
        this.removeAllDelegates({list: this.keyboardDelegates});
    },



    // Mouse Events

    mouseDown: function (evt) {
        if (!this.dispatchEvents) {
            return;
        }

        this._previousMouseMovePosition = geo.ccp(evt.clientX, evt.clientY);
        this._previousMouseDragPosition = geo.ccp(evt.clientX, evt.clientY);

        for (var i = 0; i < this.mouseDelegates.length; i++) {
            var entry = this.mouseDelegates[i];
            if (entry.delegate.mouseDown) {
                var swallows = entry.delegate.mouseDown(evt);
                if (swallows) {
                    break;
                }
            }
        }
    },
    mouseMoved: function (evt) {
        if (!this.dispatchEvents) {
            return;
        }

        if (this._previousMouseMovePosition) {
            evt.deltaX = evt.clientX - this._previousMouseMovePosition.x;
            evt.deltaY = evt.clientY - this._previousMouseMovePosition.y;
            if (FLIP_Y_AXIS) {
                evt.deltaY *= -1;
            }
        } else {
            evt.deltaX = 0;
            evt.deltaY = 0;
        }
        this._previousMouseMovePosition = geo.ccp(evt.clientX, evt.clientY);

        for (var i = 0; i < this.mouseDelegates.length; i++) {
            var entry = this.mouseDelegates[i];
            if (entry.delegate.mouseMoved) {
                var swallows = entry.delegate.mouseMoved(evt);
                if (swallows) {
                    break;
                }
            }
        }
    },
    mouseDragged: function (evt) {
        if (!this.dispatchEvents) {
            return;
        }

        if (this._previousMouseDragPosition) {
            evt.deltaX = evt.clientX - this._previousMouseDragPosition.x;
            evt.deltaY = evt.clientY - this._previousMouseDragPosition.y;
            if (FLIP_Y_AXIS) {
                evt.deltaY *= -1;
            }
        } else {
            evt.deltaX = 0;
            evt.deltaY = 0;
        }
        this._previousMouseDragPosition = geo.ccp(evt.clientX, evt.clientY);

        for (var i = 0; i < this.mouseDelegates.length; i++) {
            var entry = this.mouseDelegates[i];
            if (entry.delegate.mouseDragged) {
                var swallows = entry.delegate.mouseDragged(evt);
                if (swallows) {
                    break;
                }
            }
        }
    },
    mouseUp: function (evt) {
        if (!this.dispatchEvents) {
            return;
        }

        for (var i = 0; i < this.mouseDelegates.length; i++) {
            var entry = this.mouseDelegates[i];
            if (entry.delegate.mouseUp) {
                var swallows = entry.delegate.mouseUp(evt);
                if (swallows) {
                    break;
                }
            }
        }
    },

    // Keyboard events
    keyDown: function (evt) {
        var kc = evt.keyCode;
        if (!this.dispatchEvents || this._keysDown[kc]) {
            return;
        }

        this._keysDown[kc] = true;

        for (var i = 0; i < this.keyboardDelegates.length; i++) {
            var entry = this.keyboardDelegates[i];
            if (entry.delegate.keyDown) {
                var swallows = entry.delegate.keyDown(evt);
                if (swallows) {
                    break;
                }
            }
        }
    },

    keyUp: function (evt) {
        if (!this.dispatchEvents) {
            return;
        }

        var kc = evt.keyCode;
        if (this._keysDown[kc]) {
            delete this._keysDown[kc];
        }

        for (var i = 0; i < this.keyboardDelegates.length; i++) {
            var entry = this.keyboardDelegates[i];
            if (entry.delegate.keyUp) {
                var swallows = entry.delegate.keyUp(evt);
                if (swallows) {
                    break;
                }
            }
        }
    }

});

/**
 * Class methods
 */
util.extend(EventDispatcher, /** @lends cocos.EventDispatcher */{
    /**
     * A shared singleton instance of cocos.EventDispatcher
     *
     * @getter sharedDispatcher
     * @type cocos.EventDispatcher
     */
    get_sharedDispatcher: function (key) {
        if (!this._instance) {
            this._instance = this.create();
        }

        return this._instance;
    }
});
exports.EventDispatcher = EventDispatcher;

}};
__resources__["/__builtin__/libs/cocos2d/index.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    path = require('path');

var modules = 'TextureAtlas Texture2D Preloader RemoteImage RemoteResource SpriteFrame SpriteFrameCache Director Animation AnimationCache Scheduler ActionManager TMXXMLParser'.w();

/**
 * @namespace All cocos2d objects live in this namespace
 */
var cocos = {
    nodes: require('./nodes'),
    actions: require('./actions')
};

util.each(modules, function (mod, i) {
    util.extend(cocos, require('./' + mod));
});

module.exports = cocos;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/AtlasNode.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var SpriteBatchNode = require('./BatchNode').SpriteBatchNode,
    TextureAtlas = require('../TextureAtlas').TextureAtlas,
    geo   = require('geometry');

var AtlasNode = SpriteBatchNode.extend(/** @lends cocos.AtlasNode# */{
    /**
     * Characters per row
     * @type Integer
     */
    itemsPerRow: 0,

    /**
     * Characters per column
     * @type Integer
     */
    itemsPerColumn: 0,

    /**
     * Width of a character
     * @type Integer
     */
    itemWidth: 0,

    /**
     * Height of a character
     * @type Integer
     */
    itemHeight: 0,


    /**
     * @type cocos.TextureAtlas
     */
     textureAtlas: null,

    /**
     * @class
     * It knows how to render a TextureAtlas object. If you are going to
     * render a TextureAtlas consider subclassing cocos.nodes.AtlasNode (or a
     * subclass of cocos.nodes.AtlasNode)
     * @memberOf cocos
     * @extends cocos.nodes.SpriteBatchNode
     * @constructs
     *
     * @opt {String} file Path to Atals image
     * @opt {Integer} itemWidth Character width
     * @opt {Integer} itemHeight Character height
     * @opt {Integer} itemsToRender Quantity of items to render
     */
    init: function (opts) {
        AtlasNode.superclass.init.call(this, opts);

        this.itemWidth = opts.itemWidth;
        this.itemHeight = opts.itemHeight;
        
        this.textureAtlas = TextureAtlas.create({file: opts.file, capacity: opts.itemsToRender});


        this._calculateMaxItems();
    },

    updateAtlasValues: function () {
        throw "cocos.nodes.AtlasNode:Abstract - updateAtlasValue not overriden";
    },

    _calculateMaxItems: function () {
        var s = this.textureAtlas.get('texture.contentSize');
        this.itemsPerColumn = s.height / this.itemHeight;
        this.itemsPerRow = s.width / this.itemWidth;
    }
});

exports.AtlasNode = AtlasNode;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/BatchNode.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray SHOW_REDRAW_REGIONS*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    evt = require('events'),
    geo = require('geometry'),
    ccp = geo.ccp,
    TextureAtlas = require('../TextureAtlas').TextureAtlas,
    RenderTexture = require('./RenderTexture').RenderTexture,
    Node = require('./Node').Node;

var BatchNode = Node.extend(/** @lends cocos.nodes.BatchNode# */{
    partialDraw: false,
    contentRect: null,
    renderTexture: null,
    dirty: true,

    /**
     * Region to redraw
     * @type geometry.Rect
     */
    dirtyRegion: null,
    dynamicResize: false,

    /** @private
     * Areas that need redrawing
     *
     * Not implemented
     */
    _dirtyRects: null,


    /**
     * Draws all children to an in-memory canvas and only redraws when something changes
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.Node
     *
     * @opt {geometry.Size} size The size of the in-memory canvas used for drawing to
     * @opt {Boolean} [partialDraw=false] Draw only the area visible on screen. Small maps may be slower in some browsers if this is true.
     */
    init: function (opts) {
        BatchNode.superclass.init.call(this, opts);

        var size = opts.size || geo.sizeMake(1, 1);
        this.set('partialDraw', opts.partialDraw);

        evt.addListener(this, 'contentsize_changed', util.callback(this, this._resizeCanvas));
        
        this._dirtyRects = [];
        this.set('contentRect', geo.rectMake(0, 0, size.width, size.height));
        this.renderTexture = RenderTexture.create(size);
        this.renderTexture.sprite.set('isRelativeAnchorPoint', false);
        this.addChild({child: this.renderTexture});
    },

    addChild: function (opts) {
        BatchNode.superclass.addChild.call(this, opts);

        var child = opts.child,
            z     = opts.z;

        if (child == this.renderTexture) {
            return;
        }

        // TODO handle texture resize

        // Watch for changes in child
        var watchEvents = ['position_before_changed',
                           'scalex_before_changed',
                           'scaley_before_changed',
                           'rotation_before_changed',
                           'anchorpoint_before_changed',
                           'opacity_before_changed',
                           'visible_before_changed'];
        evt.addListener(child, watchEvents, util.callback(this, function () {
            this.addDirtyRegion(child.get('boundingBox'));
        }));

        this.addDirtyRegion(child.get('boundingBox'));
    },

    removeChild: function (opts) {
        BatchNode.superclass.removeChild.call(this, opts);

        // TODO remove istransformdirty_changed and visible_changed listeners

        this.set('dirty', true);
    },

    addDirtyRegion: function (rect) {
        // Increase rect slightly to compensate for subpixel artifacts
        rect = util.copy(rect);
        rect.origin.x -= 2;
        rect.origin.y -= 2;
        rect.size.width += 4;
        rect.size.height += 4;

        var region = this.get('dirtyRegion');
        if (!region) {
            region = rect;
        } else {
            region = geo.rectUnion(region, rect);
        }

        this.set('dirtyRegion', region);
        this.set('dirty', true);
    },

    _resizeCanvas: function (oldSize) {
        var size = this.get('contentSize');

        if (geo.sizeEqualToSize(size, oldSize)) {
            return; // No change
        }


        this.renderTexture.set('contentSize', size);
        this.set('dirty', true);
    },

    update: function () {

    },

    visit: function (context) {
        if (!this.visible) {
            return;
        }

        context.save();

        this.transform(context);

        var rect = this.get('dirtyRegion');
        // Only redraw if something changed
        if (this.dirty) {

            if (rect) {
                if (this.get('partialDraw')) {
                    // Clip region to visible area
                    var s = require('../Director').Director.get('sharedDirector').get('winSize'),
                        p = this.get('position');
                    var r = new geo.Rect(
                        0, 0,
                        s.width, s.height
                    );
                    r = geo.rectApplyAffineTransform(r, this.worldToNodeTransform());
                    rect = geo.rectIntersection(r, rect);
                }

                this.renderTexture.clear(rect);

                this.renderTexture.context.save();
                this.renderTexture.context.beginPath();
                this.renderTexture.context.rect(rect.origin.x, rect.origin.y, rect.size.width, rect.size.height);
                this.renderTexture.context.clip();
                this.renderTexture.context.closePath();
            } else {
                this.renderTexture.clear();
            }

            for (var i = 0, childLen = this.children.length; i < childLen; i++) {
                var c = this.children[i];
                if (c == this.renderTexture) {
                    continue;
                }

                // Draw children inside rect
                if (!rect || geo.rectOverlapsRect(c.get('boundingBox'), rect)) {
                    c.visit(this.renderTexture.context, rect);
                }
            }

            if (SHOW_REDRAW_REGIONS) {
                if (rect) {
                    this.renderTexture.context.beginPath();
                    this.renderTexture.context.rect(rect.origin.x, rect.origin.y, rect.size.width, rect.size.height);
                    this.renderTexture.context.fillStyle = "rgba(0, 0, 255, 0.5)";
                    this.renderTexture.context.fill();
                    this.renderTexture.context.closePath();
                }
            }

            if (rect) {
                this.renderTexture.context.restore();
            }

            this.set('dirty', false);
            this.set('dirtyRegion', null);
        }

        this.renderTexture.visit(context);

        context.restore();
    },

    draw: function (ctx) {
    },

    onEnter: function () {
        if (this.get('partialDraw')) {
            evt.addListener(this.get('parent'), 'istransformdirty_changed', util.callback(this, function () {
                var box = this.get('visibleRect');
                this.addDirtyRegion(box);
            }));
        }
    }
});

var SpriteBatchNode = BatchNode.extend(/** @lends cocos.nodes.SpriteBatchNode# */{
    textureAtlas: null,

    /**
     * @memberOf cocos.nodes
     * @class A BatchNode that accepts only Sprite using the same texture
     * @extends cocos.nodes.BatchNode
     * @constructs
     *
     * @opt {String} file (Optional) Path to image to use as sprite atlas
     * @opt {Texture2D} texture (Optional) Texture to use as sprite atlas
     * @opt {cocos.TextureAtlas} textureAtlas (Optional) TextureAtlas to use as sprite atlas
     */
    init: function (opts) {
        SpriteBatchNode.superclass.init.call(this, opts);

        var file         = opts.file,
            textureAtlas = opts.textureAtlas,
            texture      = opts.texture;

        if (file || texture) {
            textureAtlas = TextureAtlas.create({file: file, texture: texture});
        }

        this.set('textureAtlas', textureAtlas);
    },

    /**
     * @getter texture
     * @type cocos.Texture2D
     */
    get_texture: function () {
        return this.textureAtlas ? this.textureAtlas.texture : null;
    },

    set_opacity: function (newOpacity) {
        this.opacity = newOpacity;
        for (var i = 0, len = this.children.length; i < len; i++) {
            var child = this.children[i];
            child.set('opacity', newOpacity);
        }
    }

});

exports.BatchNode = BatchNode;
exports.SpriteBatchNode = SpriteBatchNode;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/index.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    path = require('path');

var modules = 'AtlasNode LabelAtlas ProgressBar PreloadScene Node Layer Scene Label Sprite TMXTiledMap BatchNode RenderTexture Menu MenuItem Transition'.w();

/** 
 * @memberOf cocos
 * @namespace All cocos2d nodes. i.e. anything that can be added to a Scene
 */
var nodes = {};

util.each(modules, function (mod, i) {
    util.extend(nodes, require('./' + mod));
});

module.exports = nodes;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/Label.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray FLIP_Y_AXIS*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    console = require('system').console,
    Director = require('../Director').Director,
    Node = require('./Node').Node,
    ccp = require('geometry').ccp;

var Label = Node.extend(/** @lends cocos.nodes.Label# */{
    string:   '',
    fontName: 'Helvetica',
    fontSize: 16,
    fontColor: 'white',

    /**
     * Renders a simple text label
     *
     * @constructs
     * @extends cocos.nodes.Node
     *
     * @opt {String} [string=""] The text string to draw
     * @opt {Float} [fontSize=16] The size of the font
     * @opt {String} [fontName="Helvetica"] The name of the font to use
     * @opt {String} [fontColor="white"] The color of the text
     */
    init: function (opts) {
        Label.superclass.init.call(this, opts);

        util.each('fontSize fontName fontColor string'.w(), util.callback(this, function (name) {
            // Set property on init
            if (opts[name]) {
                this.set(name, opts[name]);
            }

            // Update content size
            this._updateLabelContentSize();
        }));
    },

    /** 
     * String of the font name and size to use in a format &lt;canvas&gt; understands
     *
     * @getter font
     * @type String
     */
    get_font: function (key) {
        return this.get('fontSize') + 'px ' + this.get('fontName');
    },

    draw: function (context) {
        if (FLIP_Y_AXIS) {
            context.save();

            // Flip Y axis
            context.scale(1, -1);
            context.translate(0, -this.get('fontSize'));
        }


        context.fillStyle = this.get('fontColor');
        context.font = this.get('font');
        context.textBaseline = 'top';
        if (context.fillText) {
            context.fillText(this.get('string'), 0, 0);
        } else if (context.mozDrawText) {
            context.mozDrawText(this.get('string'));
        }

        if (FLIP_Y_AXIS) {
            context.restore();
        }
    },

    /**
     * @private
     */
    _updateLabelContentSize: function () {
        var ctx = Director.get('sharedDirector').get('context');
        var size = {width: 0, height: this.get('fontSize')};

        var prevFont = ctx.font;
        ctx.font = this.get('font');

        if (ctx.measureText) {
            var txtSize = ctx.measureText(this.get('string'));
            size.width = txtSize.width;
        } else if (ctx.mozMeasureText) {
            size.width = ctx.mozMeasureText(this.get('string'));
        }

        ctx.font = prevFont;

        this.set('contentSize', size);
    }
});

module.exports.Label = Label;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/LabelAtlas.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var AtlasNode = require('./AtlasNode').AtlasNode,
    Sprite = require('./Sprite').Sprite,
    geo   = require('geometry');

var LabelAtlas = AtlasNode.extend(/** @lends cocos.nodes.LabelAtlas# */{
    string: '',

    mapStartChar: '',

    /**
     * @memberOf cocos.nodes
     * @extends cocos.nodes.BatchNode
     * @constructs
     *
     * @opt {String} [string=] Initial text to draw
     * @opt {String} charMapFile
     * @opt {Integer} itemWidth
     * @opt {Integer} itemHeight
     * @opt {String} startCharMap Single character
     */
    init: function (opts) {
        LabelAtlas.superclass.init.call(this, {
            file: opts.charMapFile,
            itemWidth: opts.itemWidth,
            itemHeight: opts.itemHeight,
            itemsToRender: opts.string.length,
            size: new geo.Size(opts.itemWidth * opts.string.length, opts.itemHeight)
        });


        this.mapStartChar = opts.startCharMap.charCodeAt(0);
        this.set('string', opts.string);
    },

    updateAtlasValue: function () {
        var n = this.string.length,
            s = this.get('string');
    
        // FIXME this should reuse children to improve performance
        while (this.children.length > 0) {
            this.removeChild(this.children[0]);
        }
        for (var i = 0; i < n; i++) {
            var a = s.charCodeAt(i) - this.mapStartChar,
                row = (a % this.itemsPerRow),
                col = Math.floor(a / this.itemsPerRow);
    
            var left = row * this.itemWidth,
                top  = col * this.itemHeight;

            var tile = Sprite.create({rect: new geo.Rect(left, top, this.itemWidth, this.itemHeight),
                              textureAtlas: this.textureAtlas});

            tile.set('position', new geo.Point(i * this.itemWidth, 0));
            tile.set('anchorPoint', new geo.Point(0, 0));
            tile.set('opacity', this.get('opacity'));
            
            this.addChild({child: tile});
        }
    },

    set_string: function (newString) {
        this.string = newString;

        this.updateAtlasValue();
    }
});


exports.LabelAtlas = LabelAtlas;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/Layer.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var Node = require('./Node').Node,
    util = require('util'),
    evt = require('events'),
    Director = require('../Director').Director,
    ccp    = require('geometry').ccp,
    EventDispatcher = require('../EventDispatcher').EventDispatcher;

var Layer = Node.extend(/** @lends cocos.nodes.Layer# */{
    isMouseEnabled: false,
    isKeyboardEnabled: false,
    mouseDelegatePriority: 0,
    keyboardDelegatePriority: 0,

    /** 
     * A fullscreen Node. You need at least 1 layer in your app to add other nodes to.
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.Node
     */
    init: function () {
        Layer.superclass.init.call(this);

        var s = Director.get('sharedDirector').get('winSize');

        this.set('isRelativeAnchorPoint', false);
        this.anchorPoint = ccp(0.5, 0.5);
        this.set('contentSize', s);

        evt.addListener(this, 'ismouseenabled_changed', util.callback(this, function () {
            if (this.isRunning) {
                if (this.isMouseEnabled) {
                    EventDispatcher.get('sharedDispatcher').addMouseDelegate({delegate: this, priority: this.get('mouseDelegatePriority')});
                } else {
                    EventDispatcher.get('sharedDispatcher').removeMouseDelegate({delegate: this});
                }
            }
        }));


        evt.addListener(this, 'iskeyboardenabled_changed', util.callback(this, function () {
            if (this.isRunning) {
                if (this.isKeyboardEnabled) {
                    EventDispatcher.get('sharedDispatcher').addKeyboardDelegate({delegate: this, priority: this.get('keyboardDelegatePriority')});
                } else {
                    EventDispatcher.get('sharedDispatcher').removeKeyboardDelegate({delegate: this});
                }
            }
        }));
    },

    onEnter: function () {
        if (this.isMouseEnabled) {
            EventDispatcher.get('sharedDispatcher').addMouseDelegate({delegate: this, priority: this.get('mouseDelegatePriority')});
        }
        if (this.isKeyboardEnabled) {
            EventDispatcher.get('sharedDispatcher').addKeyboardDelegate({delegate: this, priority: this.get('keyboardDelegatePriority')});
        }
				
        Layer.superclass.onEnter.call(this);
    },

    onExit: function () {
        if (this.isMouseEnabled) {
            EventDispatcher.get('sharedDispatcher').removeMouseDelegate({delegate: this});
        }
        if (this.isKeyboardEnabled) {
            EventDispatcher.get('sharedDispatcher').removeKeyboardDelegate({delegate: this});
        }

        Layer.superclass.onExit.call(this);
    }
});

module.exports.Layer = Layer;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/Menu.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    Layer = require('./Layer').Layer,
    Director = require('../Director').Director,
    MenuItem = require('./MenuItem').MenuItem,
    geom = require('geometry'), ccp = geom.ccp;

/**
 * @private
 * @constant
 */
var kMenuStateWaiting = 0;

/**
 * @private
 * @constant
 */
var kMenuStateTrackingTouch = 1;
    

var Menu = Layer.extend(/** @lends cocos.nodes.Menu# */{
    mouseDelegatePriority: (-Number.MAX_VALUE + 1),
    state: kMenuStateWaiting,
    selectedItem: null,
    color: null,

    /**
     * A fullscreen node used to render a selection of menu options
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.Layer
     *
     * @opt {cocos.nodes.MenuItem[]} items An array of MenuItems to draw on the menu
     */
    init: function (opts) {
        Menu.superclass.init.call(this, opts);

        var items = opts.items;

        this.set('isMouseEnabled', true);
        
        var s = Director.get('sharedDirector').get('winSize');

        this.set('isRelativeAnchorPoint', false);
        this.anchorPoint = ccp(0.5, 0.5);
        this.set('contentSize', s);

        this.set('position', ccp(s.width / 2, s.height / 2));


        if (items) {
            var z = 0;
            util.each(items, util.callback(this, function (item) {
                this.addChild({child: item, z: z++});
            }));
        }

        
    },

    addChild: function (opts) {
        if (!opts.child instanceof MenuItem) {
            throw "Menu only supports MenuItem objects as children";
        }

        Menu.superclass.addChild.call(this, opts);
    },

    itemForMouseEvent: function (event) {
        var location = event.locationInCanvas;

        var children = this.get('children');
        for (var i = 0, len = children.length; i < len; i++) {
            var item = children[i];

            if (item.get('visible') && item.get('isEnabled')) {
                var local = item.convertToNodeSpace(location);
                
                var r = item.get('rect');
                r.origin = ccp(0, 0);

                if (geom.rectContainsPoint(r, local)) {
                    return item;
                }

            }
        }

        return null;
    },

    mouseUp: function (event) {
        var selItem = this.get('selectedItem');

        if (selItem) {
            selItem.unselected();
            selItem.activate();
        }

        if (this.state != kMenuStateWaiting) {
            this.set('state', kMenuStateWaiting);
        }
        if (selItem) {
            return true;
        }
        return false;

    },
    mouseDown: function (event) {
        if (this.state != kMenuStateWaiting || !this.visible) {
            return false;
        }

        var selectedItem = this.itemForMouseEvent(event);
        this.set('selectedItem', selectedItem);
        if (selectedItem) {
            selectedItem.selected()
            this.set('state', kMenuStateTrackingTouch);

            return true;
        }

        return false;
    },

    mouseDragged: function (event) {
        var currentItem = this.itemForMouseEvent(event);

        if (currentItem != this.selectedItem) {
            if (this.selectedItem) {
                this.selectedItem.unselected();
            }
            this.set('selectedItem', currentItem);
            if (this.selectedItem) {
                this.selectedItem.selected();
            }
        }

        if (currentItem && this.state == kMenuStateTrackingTouch) {
            return true;
        }

        return false;
        
    }

});

exports.Menu = Menu;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/MenuItem.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    Node = require('./Node').Node,
    Sprite = require('./Sprite').Sprite,
    rectMake = require('geometry').rectMake,
    ccp = require('geometry').ccp;

var MenuItem = Node.extend(/** @lends cocos.nodes.MenuItem# */{
    isEnabled: true,
    isSelected: false,
    callback: null,

    /**
     * Base class for any buttons or options in a menu
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.Node
     *
     * @opt {Function} callback Function to call when menu item is activated
     */
    init: function (opts) {
        MenuItem.superclass.init.call(this, opts);

        var callback = opts.callback;

        this.set('anchorPoint', ccp(0.5, 0.5));
        this.set('callback', callback);
    },

    activate: function () {
        if (this.isEnabled && this.callback) {
            this.callback(this);
        }
    },

    /**
     * @getter rect
     * @type geometry.Rect
     */
    get_rect: function () {
        return rectMake(
            this.position.x - this.contentSize.width  * this.anchorPoint.x,
            this.position.y - this.contentSize.height * this.anchorPoint.y,
            this.contentSize.width,
            this.contentSize.height
        );
    },

    selected: function () {
        this.isSelected = true;
    },

    unselected: function () {
        this.isSelected = false;
    }
});

var MenuItemSprite = MenuItem.extend(/** @lends cocos.nodes.MenuItemSprite# */{
    normalImage: null,
    selectedImage: null,
    disabledImage: null,

    /**
     * A menu item that accepts any cocos.nodes.Node
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.MenuItem
     *
     * @opt {cocos.nodes.Node} normalImage Main Node to draw
     * @opt {cocos.nodes.Node} selectedImage Node to draw when menu item is selected
     * @opt {cocos.nodes.Node} disabledImage Node to draw when menu item is disabled
     */
    init: function (opts) {
        MenuItemSprite.superclass.init.call(this, opts);

        var normalImage   = opts.normalImage,
            selectedImage = opts.selectedImage,
            disabledImage = opts.disabledImage;

        this.set('normalImage', normalImage);
        this.set('selectedImage', selectedImage);
        this.set('disabledImage', disabledImage);

        this.set('contentSize', normalImage.get('contentSize'));
    },

    set_normalImage: function (image) {
        if (image != this.normalImage) {
            image.set('anchorPoint', ccp(0, 0));
            image.set('visible', true);
            this.removeChild({child: this.normalImage, cleanup: true});
            this.addChild(image);

            this.normalImage = image;
        }
    },

    set_selectedImage: function (image) {
        if (image != this.selectedImage) {
            image.set('anchorPoint', ccp(0, 0));
            image.set('visible', false);
            this.removeChild({child: this.selectedImage, cleanup: true});
            this.addChild(image);

            this.selectedImage = image;
        }
    },

    set_disabledImage: function (image) {
        if (image != this.disabledImage) {
            image.set('anchorPoint', ccp(0, 0));
            image.set('visible', false);
            this.removeChild({child: this.disabledImage, cleanup: true});
            this.addChild(image);

            this.disabledImage = image;
        }
    },

    selected: function () {
        MenuItemSprite.superclass.selected.call(this);

        if (this.selectedImage) {
            this.normalImage.set('visible',   false);
            this.selectedImage.set('visible', true);
            if (this.disabledImage) this.disabledImage.set('visible', false);
        } else {
            this.normalImage.set('visible',   true);
            if (this.disabledImage) this.disabledImage.set('visible', false);
        }
    },

    unselected: function () {
        MenuItemSprite.superclass.unselected.call(this);

        this.normalImage.set('visible',   true);
        if (this.selectedImage) this.selectedImage.set('visible', false);
        if (this.disabledImage) this.disabledImage.set('visible', false);
    },

    set_isEnabled: function (enabled) {
        this.isEnabled = enabled;

        if (enabled) {
            this.normalImage.set('visible',   true);
            if (this.selectedImage) this.selectedImage.set('visible', false);
            if (this.disabledImage) this.disabledImage.set('visible', false);
        } else {
            if (this.disabledImage) {
                this.normalImage.set('visible',   false);
                if (this.selectedImage) this.selectedImage.set('visible', false);
                this.disabledImage.set('visible', true);
            } else {
                this.normalImage.set('visible',   true);
                if (this.selectedImage) this.selectedImage.set('visible', false);
            }
        }
    }

});

var MenuItemImage = MenuItemSprite.extend(/** @lends cocos.nodes.MenuItemImage# */{

    /**
     * MenuItem that accepts image files
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.MenuItemSprite
     *
     * @opt {String} normalImage Main image file to draw
     * @opt {String} selectedImage Image file to draw when menu item is selected
     * @opt {String} disabledImage Image file to draw when menu item is disabled
     */
    init: function (opts) {
        var normalI   = opts.normalImage,
            selectedI = opts.selectedImage,
            disabledI = opts.disabledImage,
            callback  = opts.callback;

        var normalImage = Sprite.create({file: normalI}),
            selectedImage = Sprite.create({file: selectedI}),
            disabledImage = null;

        if (disabledI) {
            disabledImage = Sprite.create({file: disabledI});
        }

        return MenuItemImage.superclass.init.call(this, {normalImage: normalImage, selectedImage: selectedImage, disabledImage: disabledImage, callback: callback});
    }
});

exports.MenuItem = MenuItem;
exports.MenuItemImage = MenuItemImage;
exports.MenuItemSprite = MenuItemSprite;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/Node.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    evt = require('events'),
    Scheduler = require('../Scheduler').Scheduler,
    ActionManager = require('../ActionManager').ActionManager,
    geo = require('geometry'), ccp = geo.ccp;

var Node = BObject.extend(/** @lends cocos.nodes.Node# */{
    isCocosNode: true,

    /**
     * Is the node visible
     * @type boolean
     */
    visible: true,

    /**
     * Position relative to parent node
     * @type geometry.Point
     */
    position: null,

    /**
     * Parent node
     * @type cocos.nodes.Node
     */
    parent: null,

    /**
     * Unique tag to identify the node
     * @type *
     */
    tag: null,

    /**
     * Size of the node
     * @type geometry.Size
     */
    contentSize: null,

    /**
     * Nodes Z index. i.e. draw order
     * @type Integer
     */
    zOrder: 0,

    /**
     * Anchor point for scaling and rotation. 0x0 is top left and 1x1 is bottom right
     * @type geometry.Point
     */
    anchorPoint: null,

    /**
     * Anchor point for scaling and rotation in pixels from top left
     * @type geometry.Point
     */
    anchorPointInPixels: null,

    /**
     * Rotation angle in degrees
     * @type Float
     */
    rotation: 0,

    /**
     * X scale factor
     * @type Float
     */
    scaleX: 1,

    /**
     * Y scale factor
     * @type Float
     */
    scaleY: 1,

    /**
     * Opacity of the Node. 0 is totally transparent, 255 is totally opaque
     * @type Float
     */
    opacity: 255,

    isRunning: false,
    isRelativeAnchorPoint: true,

    isTransformDirty: true,
    isInverseDirty: true,
    inverse: null,
    transformMatrix: null,

    /**
     * The child Nodes
     * @type cocos.nodes.Node[]
     */
    children: null,

    /**
     * @memberOf cocos.nodes
     * @class The base class all visual elements extend from
     * @extends BObject
     * @constructs
     */
    init: function () {
        Node.superclass.init.call(this);
        this.set('contentSize', {width: 0, height: 0});
        this.anchorPoint = ccp(0.5, 0.5);
        this.anchorPointInPixels = ccp(0, 0);
        this.position = ccp(0, 0);
        this.children = [];

        util.each(['scaleX', 'scaleY', 'rotation', 'position', 'anchorPoint', 'contentSize', 'isRelativeAnchorPoint'], util.callback(this, function (key) {
            evt.addListener(this, key.toLowerCase() + '_changed', util.callback(this, this._dirtyTransform));
        }));
        evt.addListener(this, 'anchorpoint_changed', util.callback(this, this._updateAnchorPointInPixels));
        evt.addListener(this, 'contentsize_changed', util.callback(this, this._updateAnchorPointInPixels));
    },

    /**
     * Calculates the anchor point in pixels and updates the
     * anchorPointInPixels property
     * @private
     */
    _updateAnchorPointInPixels: function () {
        var ap = this.get('anchorPoint'),
            cs = this.get('contentSize');
        this.set('anchorPointInPixels', ccp(cs.width * ap.x, cs.height * ap.y));
    },

    /**
     * Add a child Node
     *
     * @opt {cocos.nodes.Node} child The child node to add
     * @opt {Integer} [z] Z Index for the child
     * @opt {Integer|String} [tag] A tag to reference the child with
     * @returns {cocos.nodes.Node} The node the child was added to. i.e. 'this'
     */
    addChild: function (opts) {
        if (opts.isCocosNode) {
            return this.addChild({child: opts});
        }

        var child = opts.child,
            z = opts.z,
            tag = opts.tag;

        if (z === undefined || z === null) {
            z = child.get('zOrder');
        }

        //this.insertChild({child: child, z:z});
        var added = false;


        for (var i = 0, childLen = this.children.length; i < childLen; i++) {
            var c = this.children[i];
            if (c.zOrder > z) {
                added = true;
                this.children.splice(i, 0, child);
                break;
            }
        }

        if (!added) {
            this.children.push(child);
        }

        child.set('tag', tag);
        child.set('zOrder', z);
        child.set('parent', this);

        if (this.isRunning) {
            child.onEnter();
        }

        return this;
    },
    getChild: function (opts) {
        var tag = opts.tag;

        for (var i = 0; i < this.children.length; i++) {
            if (this.children[i].tag == tag) {
                return this.children[i];
            }
        }

        return null;
    },

    removeChild: function (opts) {
        if (opts.isCocosNode) {
            return this.removeChild({child: opts});
        }

        var child = opts.child,
            cleanup = opts.cleanup;

        if (!child) {
            return;
        }

        var children = this.get('children'),
            idx = children.indexOf(child);

        if (idx > -1) {
            this.detatchChild({child: child, cleanup: cleanup});
        }
    },

    removeChildren: function(opts) {
        var children = this.get('children'),
            isRunning = this.get('isRunning');
        
        // Perform cleanup on each child but can't call removeChild() 
        // due to Array.splice's destructive nature during iteration.
        for (var i = 0; i < children.length; i++) {
            if (opts.cleanup) {
                children[i].cleanup();
            }
            if (isRunning) {
                children[i].onExit();
            }
            children[i].set('parent', null);
        }
        // Now safe to empty children list
        this.children = [];
    },
    
    detatchChild: function (opts) {
        var child = opts.child,
            cleanup = opts.cleanup;

        var children = this.get('children'),
            isRunning = this.get('isRunning'),
            idx = children.indexOf(child);

        if (isRunning) {
            child.onExit();
        }

        if (cleanup) {
            child.cleanup();
        }

        child.set('parent', null);
        children.splice(idx, 1);
    },

    reorderChild: function (opts) {
        var child = opts.child,
            z     = opts.z;

        var pos = this.children.indexOf(child);
        if (pos == -1) {
            throw "Node isn't a child of this node";
        }

        child.set('zOrder', z);

        // Remove child
        this.children.splice(pos, 1);

        // Add child back at correct location
        var added = false;
        for (var i = 0, childLen = this.children.length; i < childLen; i++) {
            var c = this.children[i];
            if (c.zOrder > z) {
                added = true;
                this.children.splice(i, 0, child);
                break;
            }
        }

        if (!added) {
            this.children.push(child);
        }
    },

    /**
     * Draws the node. Override to do custom drawing. If it's less efficient to
     * draw only the area inside the rect then don't bother. The result will be
     * clipped to that area anyway.
     *
     * @param {CanvasRenderingContext2D|WebGLRenderingContext} context Canvas rendering context
     * @param {geometry.Rect} rect Rectangular region that needs redrawing. Limit drawing to this area only if it's more efficient to do so.
     */
    draw: function (context, rect) {
        // All draw code goes here
    },

    /**
     * @getter scale
     * @type Float
     */
    get_scale: function () {
        if (this.scaleX != this.scaleY) {
            throw "scaleX and scaleY aren't identical";
        }

        return this.scaleX;
    },

    /**
     * @setter scale
     * @type Float
     */
    set_scale: function (val) {
        this.set('scaleX', val);
        this.set('scaleY', val);
    },
		
    scheduleUpdate: function (opts) {
        opts = opts || {};
        var priority = opts.priority || 0;

        Scheduler.get('sharedScheduler').scheduleUpdate({target: this, priority: priority, paused: !this.get('isRunning')});
    },

    /**
     * Triggered when the node is added to a scene
     *
     * @event
     */
    onEnter: function () {
        util.each(this.children, function (child) {
            child.onEnter();
        });

        this.resumeSchedulerAndActions();
        this.set('isRunning', true);
    },

    /**
     * Triggered when the node is removed from a scene
     *
     * @event
     */
    onExit: function () {
        this.pauseSchedulerAndActions();
        this.set('isRunning', false);

        util.each(this.children, function (child) {
            child.onExit();
        });
    },

    cleanup: function () {
        this.stopAllActions();
        this.unscheduleAllSelectors();
        util.each(this.children, function (child) {
            child.cleanup();
        });
    },

    resumeSchedulerAndActions: function () {
        Scheduler.get('sharedScheduler').resumeTarget(this);
        ActionManager.get('sharedManager').resumeTarget(this);
    },
    pauseSchedulerAndActions: function () {
        Scheduler.get('sharedScheduler').pauseTarget(this);
        ActionManager.get('sharedManager').pauseTarget(this);
    },
    unscheduleSelector: function (selector) {
        Scheduler.get('sharedScheduler').unschedule({target: this, method: selector});
    },
    unscheduleAllSelectors: function () {
        Scheduler.get('sharedScheduler').unscheduleAllSelectorsForTarget(this);
    },
    stopAllActions: function () {
        ActionManager.get('sharedManager').removeAllActionsFromTarget(this);
    },

    visit: function (context, rect) {
        if (!this.visible) {
            return;
        }

        context.save();

        this.transform(context);

        // Set alpha value (global only for now)
        context.globalAlpha = this.get('opacity') / 255.0;
        
        // Adjust redraw region by nodes position
        if (rect) {
            var pos = this.get('position');
            rect = new geo.Rect(rect.origin.x - pos.x, rect.origin.y - pos.y, rect.size.width, rect.size.height);
        }

        // Draw background nodes
        util.each(this.children, function (child, i) {
            if (child.zOrder < 0) {
                child.visit(context, rect);
            }
        });
        
        this.draw(context, rect);

        // Draw foreground nodes
        util.each(this.children, function (child, i) {
            if (child.zOrder >= 0) {
                child.visit(context, rect);
            }
        });

        context.restore();
    },
    transform: function (context) {
        // Translate
        if (this.isRelativeAnchorPoint && (this.anchorPointInPixels.x !== 0 || this.anchorPointInPixels.y !== 0)) {
            context.translate(Math.round(-this.anchorPointInPixels.x), Math.round(-this.anchorPointInPixels.y));
        }

        if (this.anchorPointInPixels.x !== 0 || this.anchorPointInPixels.y !== 0) {
            context.translate(Math.round(this.position.x + this.anchorPointInPixels.x), Math.round(this.position.y + this.anchorPointInPixels.y));
        } else {
            context.translate(Math.round(this.position.x), Math.round(this.position.y));
        }

        // Rotate
        context.rotate(geo.degreesToRadians(this.get('rotation')));

        // Scale
        context.scale(this.scaleX, this.scaleY);

        if (this.anchorPointInPixels.x !== 0 || this.anchorPointInPixels.y !== 0) {
            context.translate(Math.round(-this.anchorPointInPixels.x), Math.round(-this.anchorPointInPixels.y));
        }
    },

    runAction: function (action) {
        ActionManager.get('sharedManager').addAction({action: action, target: this, paused: this.get('isRunning')});
    },
    
    /**
     * @opts {String} tag Tag of the action to return
     */
    getAction: function(opts) {
        return ActionManager.get('sharedManager').getActionFromTarget({target: this, tag: opts.tag});
    },
    
    nodeToParentTransform: function () {
        if (this.isTransformDirty) {
            this.transformMatrix = geo.affineTransformIdentity();

            if (!this.isRelativeAnchorPoint && !geo.pointEqualToPoint(this.anchorPointInPixels, ccp(0, 0))) {
                this.transformMatrix = geo.affineTransformTranslate(this.transformMatrix, this.anchorPointInPixels.x, this.anchorPointInPixels.y);
            }

            if (!geo.pointEqualToPoint(this.position, ccp(0, 0))) {
                this.transformMatrix = geo.affineTransformTranslate(this.transformMatrix, this.position.x, this.position.y);
            }

            if (this.rotation !== 0) {
                this.transformMatrix = geo.affineTransformRotate(this.transformMatrix, -geo.degreesToRadians(this.rotation));
            }
            if (!(this.scaleX == 1 && this.scaleY == 1)) {
                this.transformMatrix = geo.affineTransformScale(this.transformMatrix, this.scaleX, this.scaleY);
            }

            if (!geo.pointEqualToPoint(this.anchorPointInPixels, ccp(0, 0))) {
                this.transformMatrix = geo.affineTransformTranslate(this.transformMatrix, -this.anchorPointInPixels.x, -this.anchorPointInPixels.y);
            }

            this.set('isTransformDirty', false);

        }

        return this.transformMatrix;
    },

    parentToNodeTransform: function () {
        // TODO
    },

    nodeToWorldTransform: function () {
        var t = this.nodeToParentTransform();

        var p;
        for (p = this.get('parent'); p; p = p.get('parent')) {
            t = geo.affineTransformConcat(t, p.nodeToParentTransform());
        }

        return t;
    },

    worldToNodeTransform: function () {
        return geo.affineTransformInvert(this.nodeToWorldTransform());
    },

    convertToNodeSpace: function (worldPoint) {
        return geo.pointApplyAffineTransform(worldPoint, this.worldToNodeTransform());
    },

    /**
     * @getter boundingBox
     * @type geometry.Rect
     */
    get_boundingBox: function () {
        var cs = this.get('contentSize');
        var rect = geo.rectMake(0, 0, cs.width, cs.height);
        rect = geo.rectApplyAffineTransform(rect, this.nodeToParentTransform());
        return rect;
    },

    /**
     * @getter worldBoundingBox
     * @type geometry.Rect
     */
    get_worldBoundingBox: function () {
        var cs = this.get('contentSize');

        var rect = geo.rectMake(0, 0, cs.width, cs.height);
        rect = geo.rectApplyAffineTransform(rect, this.nodeToWorldTransform());
        return rect;
    },

    /**
     * The area of the node currently visible on screen. Returns an rect even
     * if visible is false.
     *
     * @getter visibleRect
     * @type geometry.Rect
     */
    get_visibleRect: function () {
        var s = require('../Director').Director.get('sharedDirector').get('winSize');
        var rect = new geo.Rect(
            0, 0,
            s.width, s.height
        );

        return geo.rectApplyAffineTransform(rect, this.worldToNodeTransform());
    },

    /**
     * @private
     */
    _dirtyTransform: function () {
        this.set('isTransformDirty', true);
    },

    /**
     * Schedules a custom method with an interval time in seconds.
     * If time is 0 it will be ticked every frame.
     * If time is 0, it is recommended to use 'scheduleUpdate' instead.
     * 
     * If the method is already scheduled, then the interval parameter will
     * be updated without scheduling it again.
     *
     * @opt {String|Function} method Function of method name to schedule
     * @opt {Float} [interval=0] Interval in seconds
     */
    schedule: function (opts) {
        if (typeof opts == 'string') {
            return this.schedule({method: opts, interval: 0});
        }

        opts.interval = opts.interval || 0;

        Scheduler.get('sharedScheduler').schedule({target: this, method: opts.method, interval: opts.interval, paused: this.isRunning});
    },

    /**
     * Unschedules a custom method
     *
     * @param {String|Function} method
     */
    unschedule: function (method) {
        if (!method) {
            return;
        }

        if (typeof method == 'string') {
            method = this[method];
        }
        
        Scheduler.get('sharedScheduler').unschedule({target: this, method: method});
    }

});

module.exports.Node = Node;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/PreloadScene.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var Scene       = require('./Scene').Scene,
    Director    = require('../Director').Director,
    Label       = require('./Label').Label,
    ProgressBar = require('./ProgressBar').ProgressBar,
    Preloader   = require('../Preloader').Preloader,
    RemoteResource = require('../RemoteResource').RemoteResource,
    geo         = require('geometry'),
    util        = require('util'),
    events      = require('events');

var PreloadScene = Scene.extend(/** @lends cocos.nodes.PreloadScene# */{
    progressBar: null,
    label: null,
    preloader: null,
    isReady: false, // True when both progress bar images have loaded
    emptyImage: "/__builtin__/libs/cocos2d/resources/progress-bar-empty.png",
    fullImage:  "/__builtin__/libs/cocos2d/resources/progress-bar-full.png",

    /**
     * @memberOf cocos.nodes
     * @extends cocos.nodes.Scene
     * @constructs
     */
    init: function (opts) {
        PreloadScene.superclass.init.call(this, opts);
        var size = Director.get('sharedDirector').get('winSize');

        // Setup 'please wait' label
        var label = Label.create({
            fontSize: 14,
            fontName: 'Helvetica',
            fontColor: '#ffffff',
            string: 'Please wait...'
        });
        label.set('position', new geo.Point(size.width / 2, (size.height / 2) + 32));
        this.set('label', label);
        this.addChild({child: label});

        // Setup preloader
        var preloader = Preloader.create();
        this.set('preloader', preloader);
        var self = this;

        // Listen for preload events
        events.addListener(preloader, 'load', function (uri, preloader) {
            var loaded = preloader.get('loaded'),
                count = preloader.get('count');
            //console.log("Loaded: %d%% -- %d of %d -- %s", (loaded / count) * 100, loaded, count, uri);
            events.trigger(self, 'load', uri, preloader);
        });

        events.addListener(preloader, 'complete', function (preloader) {
            events.trigger(self, 'complete', preloader);
        });


        // Load the images used by the progress bar
        var emptyImage = resource(this.get('emptyImage')),
            fullImage  = resource(this.get('fullImage'));


        var loaded = 0;
        function imageLoaded() {
            if (loaded == 2) {
                this.isReady = true;
                this.createProgressBar();
                if (this.get('isRunning')) {
                    preloader.load();
                }
            }
        }

        if (emptyImage instanceof RemoteResource) {
            events.addListener(emptyImage, 'load', util.callback(this, function() {
                loaded++;
                imageLoaded.call(this);
            }));
            emptyImage.load();
        } else {
            loaded++;
            imageLoaded.call(this);
        }
        if (fullImage instanceof RemoteResource) {
            events.addListener(fullImage, 'load', util.callback(this, function() {
                loaded++;
                imageLoaded.call(this);
            }));
            fullImage.load();
        } else {
            loaded++;
            imageLoaded.call(this);
        }

    },

    createProgressBar: function () {
        var preloader = this.get('preloader'),
            size = Director.get('sharedDirector').get('winSize');

        var progressBar = ProgressBar.create({
            emptyImage: "/__builtin__/libs/cocos2d/resources/progress-bar-empty.png",
            fullImage:  "/__builtin__/libs/cocos2d/resources/progress-bar-full.png"
        });

        progressBar.set('position', new geo.Point(size.width / 2, size.height / 2));

        this.set('progressBar', progressBar);
        this.addChild({child: progressBar});

        progressBar.bindTo('maxValue', preloader, 'count');
        progressBar.bindTo('value',    preloader, 'loaded');
    },

    onEnter: function () {
        PreloadScene.superclass.onEnter.call(this);
        var preloader = this.get('preloader');

        // Preload everything
        if (this.isReady) {
            preloader.load();
        }
    }
});

exports.PreloadScene = PreloadScene;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/ProgressBar.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var Node   = require('./Node').Node,
    util   = require('util'),
    geo    = require('geometry'),
    events = require('events'),
    Sprite = require('./Sprite').Sprite;

var ProgressBar = Node.extend(/** @lends cocos.nodes.ProgressBar# */{
    emptySprite: null,
    fullSprite: null,
    maxValue: 100,
    value: 0,

    /**
     * @memberOf cocos.nodes
     * @extends cocos.nodes.Node
     * @constructs
     */
    init: function (opts) {
        ProgressBar.superclass.init.call(this, opts);
        var size = new geo.Size(272, 32);
        this.set('contentSize', size);

        var s;
        if (opts.emptyImage) {
            s = Sprite.create({file: opts.emptyImage, rect: new geo.Rect(0, 0, size.width, size.height)});
            s.set('anchorPoint', new geo.Point(0, 0));
            this.set('emptySprite', s);
            this.addChild({child: s});
        }
        if (opts.fullImage) {
            s = Sprite.create({file: opts.fullImage, rect: new geo.Rect(0, 0, 0, size.height)});
            s.set('anchorPoint', new geo.Point(0, 0));
            this.set('fullSprite', s);
            this.addChild({child: s});
        }

        events.addListener(this, 'maxvalue_changed', util.callback(this, 'updateImages'));
        events.addListener(this, 'value_changed', util.callback(this, 'updateImages'));

        this.updateImages();
    },

    updateImages: function () {
        var empty = this.get('emptySprite'),
            full  = this.get('fullSprite'),
            value = this.get('value'),
            size  = this.get('contentSize'),
            maxValue = this.get('maxValue'),
            ratio = (value / maxValue);

        var diff = Math.round(size.width * ratio);
        if (diff === 0) {
            full.set('visible', false);
        } else {
            full.set('visible', true);
            full.set('rect', new geo.Rect(0, 0, diff, size.height));
            full.set('contentSize', new geo.Size(diff, size.height));
        }

        if ((size.width - diff) === 0) {
            empty.set('visible', false);
        } else {
            empty.set('visible', true);
            empty.set('rect', new geo.Rect(diff, 0, size.width - diff, size.height));
            empty.set('position', new geo.Point(diff, 0));
            empty.set('contentSize', new geo.Size(size.width - diff, size.height));
        }
    }
});

exports.ProgressBar = ProgressBar;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/RenderTexture.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray FLIP_Y_AXIS*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    evt = require('events'),
    Node = require('./Node').Node,
    geo = require('geometry'),
    Sprite = require('./Sprite').Sprite,
    TextureAtlas = require('../TextureAtlas').TextureAtlas,
    ccp = geo.ccp;

var RenderTexture = Node.extend(/** @lends cocos.nodes.RenderTexture# */{
    canvas: null,
    context: null,
    sprite: null,

    /** 
     * An in-memory canvas which can be drawn to in the background before drawing on screen
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.Node
     *
     * @opt {Integer} width The width of the canvas
     * @opt {Integer} height The height of the canvas
     */
    init: function (opts) {
        RenderTexture.superclass.init.call(this, opts);

        var width = opts.width,
            height = opts.height;

        evt.addListener(this, 'contentsize_changed', util.callback(this, this._resizeCanvas));

        this.canvas = document.createElement('canvas');
        this.context = this.canvas.getContext('2d');

        var atlas = TextureAtlas.create({canvas: this.canvas});
        this.sprite = Sprite.create({textureAtlas: atlas, rect: {origin: ccp(0, 0), size: {width: width, height: height}}});

        this.set('contentSize', geo.sizeMake(width, height));
        this.addChild(this.sprite);
        this.set('anchorPoint', ccp(0, 0));
        this.sprite.set('anchorPoint', ccp(0, 0));

    },

    /**
     * @private
     */
    _resizeCanvas: function () {
        var size = this.get('contentSize'),
            canvas = this.get('canvas');

        canvas.width  = size.width;
        canvas.height = size.height;
        if (FLIP_Y_AXIS) {
            this.context.scale(1, -1);
            this.context.translate(0, -canvas.height);
        }

        var s = this.get('sprite');
        if (s) {
            s.set('textureRect', {rect: geo.rectMake(0, 0, size.width, size.height)});
        }
    },

    /**
     * Clear the canvas
     */
    clear: function (rect) {
        if (rect) {
            this.context.clearRect(rect.origin.x, rect.origin.y, rect.size.width, rect.size.height);
        } else {
            this.canvas.width = this.canvas.width;
            if (FLIP_Y_AXIS) {
                this.context.scale(1, -1);
                this.context.translate(0, -this.canvas.height);
            }
        }
    }
});

module.exports.RenderTexture = RenderTexture;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/Scene.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var Node = require('./Node').Node,
    geo = require('geometry');

var Scene = Node.extend(/** @lends cocos.nodes.Scene */{
    /**
     * Everything in your view will be a child of this object. You need at least 1 scene per app.
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.Node
     */
    init: function () {
        Scene.superclass.init.call(this);


        var Director = require('../Director').Director;
        var s = Director.get('sharedDirector').get('winSize');
        this.set('isRelativeAnchorPoint', false);
        this.anchorPoint = new geo.Point(0.5, 0.5);
        this.set('contentSize', s);
    }

});

module.exports.Scene = Scene;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/Sprite.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    evt = require('events'),
    Director = require('../Director').Director,
    TextureAtlas = require('../TextureAtlas').TextureAtlas,
    Node = require('./Node').Node,
    geo = require('geometry'),
    ccp = geo.ccp;

var Sprite = Node.extend(/** @lends cocos.nodes.Sprite# */{
    textureAtlas: null,
    rect: null,
    dirty: true,
    recursiveDirty: true,
    quad: null,
    flipX: false,
    flipY: false,
    offsetPosition: null,
    unflippedOffsetPositionFromCenter: null,
    untrimmedSize: null,

    /**
     * A small 2D graphics than can be animated
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.Node
     *
     * @opt {String} file Path to image to use as sprite atlas
     * @opt {Rect} [rect] The rect in the sprite atlas image file to use as the sprite
     */
    init: function (opts) {
        Sprite.superclass.init.call(this, opts);

        opts = opts || {};

        var file         = opts.file,
            textureAtlas = opts.textureAtlas,
            texture      = opts.texture,
            frame        = opts.frame,
            spritesheet  = opts.spritesheet,
            rect         = opts.rect;

        this.set('offsetPosition', ccp(0, 0));
        this.set('unflippedOffsetPositionFromCenter', ccp(0, 0));


        if (frame) {
            texture = frame.get('texture');
            rect    = frame.get('rect');
        }

        util.each(['scale', 'scaleX', 'scaleY', 'rect', 'flipX', 'flipY', 'contentSize'], util.callback(this, function (key) {
            evt.addListener(this, key.toLowerCase() + '_changed', util.callback(this, this._updateQuad));
        }));
        evt.addListener(this, 'textureatlas_changed', util.callback(this, this._updateTextureQuad));

        if (file || texture) {
            textureAtlas = TextureAtlas.create({file: file, texture: texture});
        } else if (spritesheet) {
            textureAtlas = spritesheet.get('textureAtlas');
            this.set('useSpriteSheet', true);
        } else if (!textureAtlas) {
            //throw "Sprite has no texture";
        }

        if (!rect && textureAtlas) {
            rect = {origin: ccp(0, 0), size: {width: textureAtlas.texture.size.width, height: textureAtlas.texture.size.height}};
        }

        if (rect) {
            this.set('rect', rect);
            this.set('contentSize', rect.size);

            this.quad = {
                drawRect: {origin: ccp(0, 0), size: rect.size},
                textureRect: rect
            };
        }

        this.set('textureAtlas', textureAtlas);

        if (frame) {
            this.set('displayFrame', frame);
        }
    },

    /**
     * @private
     */
    _updateTextureQuad: function (obj, key, texture, oldTexture) {
        if (oldTexture) {
            oldTexture.removeQuad({quad: this.get('quad')});
        }

        if (texture) {
            texture.insertQuad({quad: this.get('quad')});
        }
    },

    /**
     * @setter textureCoords
     * @type geometry.Rect
     */
    set_textureCoords: function (rect) {
        var quad = this.get('quad');
        if (!quad) {
            quad = {
                drawRect: geo.rectMake(0, 0, 0, 0), 
                textureRect: geo.rectMake(0, 0, 0, 0)
            };
        }

        quad.textureRect = util.copy(rect);

        this.set('quad', quad);
    },

    /**
     * @setter textureRect
     * @type geometry.Rect
     */
    set_textureRect: function (opts) {
        var rect = opts.rect,
            rotated = !!opts.rotated,
            untrimmedSize = opts.untrimmedSize || rect.size;

        this.set('contentSize', untrimmedSize);
        this.set('rect', util.copy(rect));
        this.set('textureCoords', rect);

        var quad = this.get('quad');

        var relativeOffset = util.copy(this.get('unflippedOffsetPositionFromCenter'));

        if (this.get('flipX')) {
            relativeOffset.x = -relativeOffset.x;
        }
        if (this.get('flipY')) {
            relativeOffset.y = -relativeOffset.y;
        }

        var offsetPosition = util.copy(this.get('offsetPosition'));
        offsetPosition.x =  relativeOffset.x + (this.get('contentSize').width  - rect.size.width) / 2;
        offsetPosition.y = -relativeOffset.y + (this.get('contentSize').height - rect.size.height) / 2;

        quad.drawRect.origin = util.copy(offsetPosition);
        quad.drawRect.size = util.copy(rect.size);
        if (this.flipX) {
            quad.drawRect.size.width *= -1;
            quad.drawRect.origin.x = -rect.size.width;
        }
        if (this.flipY) {
            quad.drawRect.size.height *= -1;
            quad.drawRect.origin.y = -rect.size.height;
        }

        this.set('quad', quad);
    },

    /**
     * @private
     */
    _updateQuad: function () {
        if (!this.get('rect')) {
            return;
        }
        if (!this.quad) {
            this.quad = {
                drawRect: geo.rectMake(0, 0, 0, 0), 
                textureRect: geo.rectMake(0, 0, 0, 0)
            };
        }

        var relativeOffset = util.copy(this.get('unflippedOffsetPositionFromCenter'));

        if (this.get('flipX')) {
            relativeOffset.x = -relativeOffset.x;
        }
        if (this.get('flipY')) {
            relativeOffset.y = -relativeOffset.y;
        }

        var offsetPosition = util.copy(this.get('offsetPosition'));
        offsetPosition.x = relativeOffset.x + (this.get('contentSize').width  - this.get('rect').size.width) / 2;
        offsetPosition.y = relativeOffset.y + (this.get('contentSize').height - this.get('rect').size.height) / 2;

        this.quad.textureRect = util.copy(this.rect);
        this.quad.drawRect.origin = util.copy(offsetPosition);
        this.quad.drawRect.size = util.copy(this.rect.size);

        if (this.flipX) {
            this.quad.drawRect.size.width *= -1;
            this.quad.drawRect.origin.x = -this.rect.size.width;
        }
        if (this.flipY) {
            this.quad.drawRect.size.height *= -1;
            this.quad.drawRect.origin.y = -this.rect.size.height;
        }
    },

    updateTransform: function (ctx) {
        if (!this.useSpriteSheet) {
            throw "updateTransform is only valid when Sprite is being rendered using a SpriteSheet";
        }

        if (!this.visible) {
            this.set('dirty', false);
            this.set('recursiveDirty', false);
            return;
        }

        // TextureAtlas has hard reference to this quad so we can just update it directly
        this.quad.drawRect.origin = {
            x: this.position.x - this.anchorPointInPixels.x * this.scaleX,
            y: this.position.y - this.anchorPointInPixels.y * this.scaleY
        };
        this.quad.drawRect.size = {
            width: this.rect.size.width * this.scaleX,
            height: this.rect.size.height * this.scaleY
        };

        this.set('dirty', false);
        this.set('recursiveDirty', false);
    },

    draw: function (ctx) {
        if (!this.quad) {
            return;
        }
        this.get('textureAtlas').drawQuad(ctx, this.quad);
    },

    isFrameDisplayed: function (frame) {
        if (!this.rect || !this.textureAtlas) {
            return false;
        }
        return (frame.texture === this.textureAtlas.texture && geo.rectEqualToRect(frame.rect, this.rect));
    },


    /**
     * @setter displayFrame
     * @type cocos.SpriteFrame
     */
    set_displayFrame: function (frame) {
        if (!frame) {
            delete this.quad;
            return;
        }
        this.set('unflippedOffsetPositionFromCenter', util.copy(frame.offset));


        // change texture
        if (!this.textureAtlas || frame.texture !== this.textureAtlas.texture) {
            this.set('textureAtlas', TextureAtlas.create({texture: frame.texture}));
        }

        this.set('textureRect', {rect: frame.rect, rotated: frame.rotated, untrimmedSize: frame.originalSize});
    }
});

module.exports.Sprite = Sprite;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/TMXLayer.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray FLIP_Y_AXIS*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    SpriteBatchNode = require('./BatchNode').SpriteBatchNode,
    Sprite = require('./Sprite').Sprite,
    TMXOrientationOrtho = require('../TMXOrientation').TMXOrientationOrtho,
    TMXOrientationHex   = require('../TMXOrientation').TMXOrientationHex,
    TMXOrientationIso   = require('../TMXOrientation').TMXOrientationIso,
    geo    = require('geometry'),
    ccp    = geo.ccp,
    Node = require('./Node').Node;

var TMXLayer = SpriteBatchNode.extend(/** @lends cocos.nodes.TMXLayer# */{
    layerSize: null,
    layerName: '',
    tiles: null,
    tilset: null,
    layerOrientation: 0,
    mapTileSize: null,
    properties: null,

    /** 
     * A tile map layer loaded from a TMX file. This will probably automatically be made by cocos.TMXTiledMap
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.SpriteBatchNode
     *
     * @opt {cocos.TMXTilesetInfo} tilesetInfo
     * @opt {cocos.TMXLayerInfo} layerInfo
     * @opt {cocos.TMXMapInfo} mapInfo
     */
    init: function (opts) {
        var tilesetInfo = opts.tilesetInfo,
            layerInfo = opts.layerInfo,
            mapInfo = opts.mapInfo;

        var size = layerInfo.get('layerSize'),
            totalNumberOfTiles = size.width * size.height;

        var tex = null;
        if (tilesetInfo) {
            tex = tilesetInfo.sourceImage;
        }

        TMXLayer.superclass.init.call(this, {file: tex});

        this.set('anchorPoint', ccp(0, 0));

        this.layerName = layerInfo.get('name');
        this.layerSize = layerInfo.get('layerSize');
        this.tiles = layerInfo.get('tiles');
        this.minGID = layerInfo.get('minGID');
        this.maxGID = layerInfo.get('maxGID');
        this.opacity = layerInfo.get('opacity');
        this.properties = util.copy(layerInfo.properties);

        this.tileset = tilesetInfo;
        this.mapTileSize = mapInfo.get('tileSize');
        this.layerOrientation = mapInfo.get('orientation');

        var offset = this.calculateLayerOffset(layerInfo.get('offset'));
        this.set('position', offset);

        this.set('contentSize', geo.sizeMake(this.layerSize.width * this.mapTileSize.width, (this.layerSize.height * (this.mapTileSize.height - 1)) + this.tileset.tileSize.height));
    },

    calculateLayerOffset: function (pos) {
        var ret = ccp(0, 0);

        switch (this.layerOrientation) {
        case TMXOrientationOrtho:
            ret = ccp(pos.x * this.mapTileSize.width, pos.y * this.mapTileSize.height);
            break;
        case TMXOrientationIso:
            // TODO
            break;
        case TMXOrientationHex:
            // TODO
            break;
        }

        return ret;
    },

    setupTiles: function () {
        this.tileset.bindTo('imageSize', this.get('texture'), 'contentSize');


        for (var y = 0; y < this.layerSize.height; y++) {
            for (var x = 0; x < this.layerSize.width; x++) {
                
                var pos = x + this.layerSize.width * y,
                    gid = this.tiles[pos];
                
                if (gid !== 0) {
                    this.appendTile({gid: gid, position: ccp(x, y)});
                    
                    // Optimization: update min and max GID rendered by the layer
                    this.minGID = Math.min(gid, this.minGID);
                    this.maxGID = Math.max(gid, this.maxGID);
                }
            }
        }
    },
    appendTile: function (opts) {
        var gid = opts.gid,
            pos = opts.position;

        var z = pos.x + pos.y * this.layerSize.width;
            
        var rect = this.tileset.rectForGID(gid);
        var tile = Sprite.create({rect: rect, textureAtlas: this.textureAtlas});
        tile.set('position', this.positionAt(pos));
        tile.set('anchorPoint', ccp(0, 0));
        tile.set('opacity', this.get('opacity'));
        
        this.addChild({child: tile, z: 0, tag: z});
    },
    positionAt: function (pos) {
        switch (this.layerOrientation) {
        case TMXOrientationOrtho:
            return this.positionForOrthoAt(pos);
        case TMXOrientationIso:
            return this.positionForIsoAt(pos);
        /*
        case TMXOrientationHex:
            // TODO
        */
        default:
            return ccp(0, 0);
        }
    },
    positionForOrthoAt: function (pos) {
        var overlap = this.mapTileSize.height - this.tileset.tileSize.height;
        var x = Math.floor(pos.x * this.mapTileSize.width + 0.49);
        var y;
        if (FLIP_Y_AXIS) {
            y = Math.floor((this.get('layerSize').height - pos.y - 1) * this.mapTileSize.height + 0.49);
        } else {
            y = Math.floor(pos.y * this.mapTileSize.height + 0.49) + overlap;
        }
        return ccp(x, y);
    },

    positionForIsoAt: function (pos) {
        var mapTileSize = this.get('mapTileSize'),
            layerSize = this.get('layerSize');

        if (FLIP_Y_AXIS) {
            return ccp(
                mapTileSize.width  / 2 * (layerSize.width + pos.x - pos.y - 1),
                mapTileSize.height / 2 * ((layerSize.height * 2 - pos.x - pos.y) - 2)
            );
        } else {
            throw "Isometric tiles without FLIP_Y_AXIS is currently unsupported";
        }
    },

    /**
     * Get the tile at a specifix tile coordinate
     *
     * @param {geometry.Point} pos Position of tile to get in tile coordinates (not pixels)
     * @returns {cocos.nodes.Sprite} The tile
     */
    tileAt: function (pos) {
        var layerSize = this.get('layerSize'),
            tiles = this.get('tiles');

        if (pos.x < 0 || pos.y < 0 || pos.x >= layerSize.width || pos.y >= layerSize.height) {
            throw "TMX Layer: Invalid position";
        }

        var tile,
            gid = this.tileGIDAt(pos);

        // if GID is 0 then no tile exists at that point
        if (gid) {
            var z = pos.x + pos.y * layerSize.width;
            tile = this.getChild({tag: z});
        }

        return tile;
    },


    tileGID: function (pos) {
        var tilesPerRow = this.get('layerSize').width,
            tilePos = pos.x + (pos.y * tilesPerRow);

        return this.tiles[tilePos];
    },
    tileGIDAt: function (pos) {
        return this.tileGID(pos);
    },

    removeTile: function (pos) {
        var gid = this.tileGID(pos);
        if (gid === 0) {
            // Tile is already blank
            return;
        }

        var tiles = this.get('tiles'),
            tilesPerRow = this.get('layerSize').width,
            tilePos = pos.x + (pos.y * tilesPerRow);


        tiles[tilePos] = 0;

        var sprite = this.getChild({tag: tilePos});
        if (sprite) {
            this.removeChild({child: sprite});
        }
    }
});

exports.TMXLayer = TMXLayer;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/TMXTiledMap.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray console*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    geo = require('geometry'),
    ccp = geo.ccp,
    Node = require('./Node').Node,
    TMXOrientationOrtho = require('../TMXOrientation').TMXOrientationOrtho,
    TMXOrientationHex   = require('../TMXOrientation').TMXOrientationHex,
    TMXOrientationIso   = require('../TMXOrientation').TMXOrientationIso,
    TMXLayer   = require('./TMXLayer').TMXLayer,
    TMXMapInfo = require('../TMXXMLParser').TMXMapInfo;

var TMXTiledMap = Node.extend(/** @lends cocos.nodes.TMXTiledMap# */{
    mapSize: null,
    tileSize: null,
    mapOrientation: 0,
    objectGroups: null,
    properties: null,
    tileProperties: null,

    /**
     * A TMX Map loaded from a .tmx file
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.Node
     *
     * @opt {String} file The file path of the TMX map to load
     */
    init: function (opts) {
        TMXTiledMap.superclass.init.call(this, opts);

        this.set('anchorPoint', ccp(0, 0));

        var mapInfo = TMXMapInfo.create(opts.file);

        this.mapSize        = mapInfo.get('mapSize');
        this.tileSize       = mapInfo.get('tileSize');
        this.mapOrientation = mapInfo.get('orientation');
        this.objectGroups   = mapInfo.get('objectGroups');
        this.properties     = mapInfo.get('properties');
        this.tileProperties = mapInfo.get('tileProperties');

        // Add layers to map
        var idx = 0;
        util.each(mapInfo.layers, util.callback(this, function (layerInfo) {
            if (layerInfo.get('visible')) {
                var child = this.parseLayer({layerInfo: layerInfo, mapInfo: mapInfo});
                this.addChild({child: child, z: idx, tag: idx});

                var childSize   = child.get('contentSize');
                var currentSize = this.get('contentSize');
                currentSize.width  = Math.max(currentSize.width,  childSize.width);
                currentSize.height = Math.max(currentSize.height, childSize.height);
                this.set('contentSize', currentSize);

                idx++;
            }
        }));
    },
    
    parseLayer: function (opts) {
        var tileset = this.tilesetForLayer(opts);
        var layer = TMXLayer.create({tilesetInfo: tileset, layerInfo: opts.layerInfo, mapInfo: opts.mapInfo});

        layer.setupTiles();

        return layer;
    },

    tilesetForLayer: function (opts) {
        var layerInfo = opts.layerInfo,
            mapInfo = opts.mapInfo,
            size = layerInfo.get('layerSize');

        // Reverse loop
        var tileset;
        for (var i = mapInfo.tilesets.length - 1; i >= 0; i--) {
            tileset = mapInfo.tilesets[i];

            for (var y = 0; y < size.height; y++) {
                for (var x = 0; x < size.width; x++) {
                    var pos = x + size.width * y, 
                        gid = layerInfo.tiles[pos];

                    if (gid !== 0 && gid >= tileset.firstGID) {
                        return tileset;
                    }
                } // for (var x
            } // for (var y
        } // for (var i

        //console.log("cocos2d: Warning: TMX Layer '%s' has no tiles", layerInfo.name);
        return tileset;
    },

    /**
     * Get a layer
     *
     * @opt {String} name The name of the layer to get
     * @returns {cocos.nodes.TMXLayer} The layer requested
     */
    getLayer: function (opts) {
        var layerName = opts.name,
            layer = null;

        this.get('children').forEach(function (item) {
            if (item instanceof TMXLayer && item.layerName == layerName) {
                layer = item;
            }
        });
        if (layer !== null) {
            return layer;
        }
    },
    
    /**
     * Return the ObjectGroup for the secific group
     *
     * @opt {String} name The object group name
     * @returns {cocos.TMXObjectGroup} The object group
     */
    getObjectGroup: function (opts) {
        var objectGroupName = opts.name,
            objectGroup = null;

        this.objectGroups.forEach(function (item) {
            if (item.name == objectGroupName) {
                objectGroup = item;
            }
        });
        if (objectGroup !== null) {
            return objectGroup;
        }
    },

    /**
     * @deprected Since v0.2. You should now use cocos.TMXTiledMap#getObjectGroup.
     */
    objectGroupNamed: function (opts) {
        console.warn('TMXTiledMap#objectGroupNamed is deprected. Use TMXTiledMap#getObjectGroup instread');
        return this.getObjectGroup(opts);
    }
});

exports.TMXTiledMap = TMXTiledMap;


}};
__resources__["/__builtin__/libs/cocos2d/nodes/Transition.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var geo             = require('geometry'),
    util            = require('util'),
    actions         = require('../actions'),
    Scene           = require('./Scene').Scene,
    Director        = require('../Director').Director,
    EventDispatcher = require('../EventDispatcher').EventDispatcher,
    Scheduler       = require('../Scheduler').Scheduler;

/** Orientation Type used by some transitions
 */
var tOrientation = {
    kOrientationLeftOver: 0,
    kOrientationRightOver: 1,
    kOrientationUpOver: 0,
    kOrientationDownOver: 1
};

/**
 */
var TransitionScene = Scene.extend(/** @lends cocos.nodes.TransitionScene */{
    /**
     * Incoming scene
     * @type {cocos.nodes.Scene}
     */
    inScene: null,

    /**
     * Outgoing (current) scene
     * @type {cocos.nodes.Scene}
     */
    outScene: null,

    /**
     * transition duration
     * @type Float
     */
    duration: null,

    inSceneOnTop: null,
    sendCleanupToScene: null,

    /**
     * @class Base class for Transition scenes
     * @memberOf cocos.nodes
     * @extends cocos.nodes.Scene
     * @constructs
     *
     * @opt {Float} duration How long the transition should last
     * @opt {cocos.nodes.Scene} scene Income scene
     */
    init: function (opts) {
        TransitionScene.superclass.init.call(this, opts);

        this.set('duration', opts.duration);
        if (!opts.scene) {
            throw "TransitionScene requires scene property";
        }
        this.set('inScene', opts.scene);
        this.set('outScene', Director.get('sharedDirector')._runningScene);

        if (this.inScene == this.outScene) {
            throw "Incoming scene must be different from the outgoing scene";
        }
        EventDispatcher.get('sharedDispatcher').set('dispatchEvents', false);
        this.sceneOrder();
    },

    /**
     * Called after the transition finishes
     */
    finish: function () {
        var is = this.get('inScene'),
            os = this.get('outScene');

        /* clean up */
        is.set('visible', true);
        is.set('position', geo.PointZero());
        is.set('scale', 1.0);
        is.set('rotation', 0);

        os.set('visible', false);
        os.set('position', geo.PointZero());
        os.set('scale', 1.0);
        os.set('rotation', 0);

        Scheduler.get('sharedScheduler').schedule({
            target: this,
            method: this.setNewScene,
            interval: 0
        });
    },

    /**
     * Used by some transitions to hide the outer scene
     */
    hideOutShowIn: function () {
        this.get('inScene').set('visible', true);
        this.get('outScene').set('visible', false);
    },
    
    setNewScene: function (dt) {
        var dir = Director.get('sharedDirector');
        
        this.unscheduleSelector(this.setNewScene);
        // Save 'send cleanup to scene'
        // Not sure if it's cool to be accessing all these Director privates like this...
        this.set('sendCleanupToScene', dir._sendCleanupToScene);
        
        dir.replaceScene(this.get('inScene'));
        
        // enable events while transitions
        EventDispatcher.get('sharedDispatcher').set('dispatchEvents', true);

        // issue #267 
        this.get('outScene').set('visible', true);
    },

    sceneOrder: function () {
        this.set('inSceneOnTop', true);
    },

    draw: function (context, rect) {
        if (this.get('inSceneOnTop')) {
            this.get('outScene').visit(context, rect);
            this.get('inScene').visit(context, rect);
        } else {
            this.get('inScene').visit(context, rect);
            this.get('outScene').visit(context, rect);
        }
    },
    
    onEnter: function () {
        TransitionScene.superclass.onEnter.call(this);
        this.get('inScene').onEnter();
        // outScene_ should not receive the onEnter callback
    },

    onExit: function () {
        TransitionScene.superclass.onExit.call(this);
        this.get('outScene').onExit();
        // inScene_ should not receive the onExit callback
        // only the onEnterTransitionDidFinish
        if (this.get('inScene').hasOwnProperty('onEnterTransitionDidFinish')) {
            this.get('inScene').onEnterTransitionDidFinish();
        }
    },

    cleanup: function () {
        TransitionScene.superclass.cleanup.call(this);

        if (this.get('sendCleanupToScene')) {
            this.get('outScene').cleanup();
        }
    }
});

/**
 * @class Rotate and zoom out the outgoing scene, and then rotate and zoom in the incoming 
 * @memberOf cocos.nodes
 * @extends cocos.nodes.TransitionScene
 */
var TransitionRotoZoom = TransitionScene.extend(/** @lends cocos.nodes.TransitionRotoZoom */{
    onEnter: function() {
        TransitionRotoZoom.superclass.onEnter.call(this);
        
        var dur = this.get('duration');
        this.get('inScene').set('scale', 0.001);
        this.get('outScene').set('scale', 1.0);
        
        this.get('inScene').set('anchorPoint', geo.ccp(0.5, 0.5));
        this.get('outScene').set('anchorPoint', geo.ccp(0.5, 0.5));
        
        var outzoom = [
            actions.Spawn.initWithActions({actions: [
                actions.ScaleBy.create({scale: 0.001, duration: dur/2}),
                actions.RotateBy.create({angle: 360*2, duration: dur/2})
                ]}),
            actions.DelayTime.create({duration: dur/2})];
        
        // Can't nest sequences or reverse them very easily, so incoming scene actions must be put 
        // together manually for now...
        var inzoom = [
            actions.DelayTime.create({duration: dur/2}),
            
            actions.Spawn.initWithActions({actions: [
                actions.ScaleTo.create({scale: 1.0, duration: dur/2}),
                actions.RotateBy.create({angle: -360*2, duration: dur/2})
                ]}),
            actions.CallFunc.create({
                target: this,
                method: this.finish
            })
        ];
        
        // Sequence init() copies actions
        this.get('outScene').runAction(actions.Sequence.create({actions: outzoom}));
        this.get('inScene').runAction(actions.Sequence.create({actions: inzoom}));
    }
});

/**
 * @class Move in from to the left the incoming scene.
 * @memberOf cocos.nodes
 * @extends cocos.nodes.TransitionScene
 */
var TransitionMoveInL = TransitionScene.extend(/** @lends cocos.nodes.TransitionMoveInL */{
    onEnter: function () {
        TransitionMoveInL.superclass.onEnter.call(this);

        this.initScenes();

        this.get('inScene').runAction(actions.Sequence.create({actions: [
            this.action(),
            actions.CallFunc.create({
                target: this,
                method: this.finish
            })]
        }));
    },
    
    action: function () {
        return actions.MoveTo.create({
            position: geo.ccp(0, 0),
            duration: this.get('duration')
        });
    },
    
    initScenes: function () {
        var s = Director.get('sharedDirector').get('winSize');
        this.get('inScene').set('position', geo.ccp(-s.width, 0));
    }
});
    
/**
 * @class Move in from to the right the incoming scene.
 * @memberOf cocos.nodes
 * @extends cocos.nodes.TransitionMoveInL
 */
var TransitionMoveInR = TransitionMoveInL.extend(/** @lends cocos.nodes.TransitionMoveInR */{
    initScenes: function () {
        var s = Director.get('sharedDirector').get('winSize');
        this.get('inScene').set('position', geo.ccp(s.width, 0));
    }
});

/**
 * @class Move the incoming scene in from the top.
 * @memberOf cocos.nodes
 * @extends cocos.nodes.TransitionMoveInL
 */
var TransitionMoveInT = TransitionMoveInL.extend(/** @lends cocos.nodes.TransitionMoveInT */{
    initScenes: function () {
        var s = Director.get('sharedDirector').get('winSize');
        this.get('inScene').set('position', geo.ccp(0, s.height));
    }
});

/**
 * @class Move the incoming scene in from the bottom.
 * @memberOf cocos.nodes
 * @extends cocos.nodes.TransitionMoveInL
 */
var TransitionMoveInB = TransitionMoveInL.extend(/** @lends cocos.nodes.TransitionMoveInB */{
    initScenes: function () {
        var s = Director.get('sharedDirector').get('winSize');
        this.get('inScene').set('position', geo.ccp(0, -s.height));
    }
});

/**
 * @class Slide in the incoming scene from the left.
 * @memberOf cocos.nodes
 * @extends cocos.nodes.TransitionScene
 */
var TransitionSlideInL = TransitionScene.extend(/** @lends cocos.nodes.TransitionSlideInL */{
    onEnter: function () {
        TransitionSlideInL.superclass.onEnter.call(this);

        this.initScenes();

        var movein = this.action();
        var moveout = this.action();
        var outAction = actions.Sequence.create({
            actions: [
            moveout, 
            actions.CallFunc.create({
                target: this,
                method: this.finish
            })]
        });
        this.get('inScene').runAction(movein);
        this.get('outScene').runAction(outAction);
    },

    sceneOrder: function () {
        this.set('inSceneOnTop', false);
    },

    initScenes: function () {
        var s = Director.get('sharedDirector').get('winSize');
        this.get('inScene').set('position', geo.ccp(-s.width, 0));
    },
    
    action: function () {
        var s = Director.get('sharedDirector').get('winSize');
        return actions.MoveBy.create({
            position: geo.ccp(s.width, 0),
            duration: this.get('duration')
        });
    }
});

/** 
 * @class Slide in the incoming scene from the right.
 * @memberOf cocos.nodes
 * @extends cocos.nodes.TransitionSlideInL
 */
var TransitionSlideInR = TransitionSlideInL.extend(/** @lends cocos.nodes.TransitionSlideInR */{
    sceneOrder: function () {
        this.set('inSceneOnTop', true);
    },

    initScenes: function () {
        var s = Director.get('sharedDirector').get('winSize');
        this.get('inScene').set('position', geo.ccp(s.width, 0));
    },
    
    action: function () {
        var s = Director.get('sharedDirector').get('winSize');
        return actions.MoveBy.create({
            position: geo.ccp(-s.width, 0),
            duration: this.get('duration')
        });
    }
});

/**
 * @class Slide in the incoming scene from the top.
 * @memberOf cocos.nodes
 * @extends cocos.nodes.TransitionSlideInL
 */
var TransitionSlideInT = TransitionSlideInL.extend(/** @lends cocos.nodes.TransitionSlideInT */{
    sceneOrder: function () {
        this.set('inSceneOnTop', false);
    },

    initScenes: function () {
        var s = Director.get('sharedDirector').get('winSize');
        this.get('inScene').set('position', geo.ccp(0, s.height));
    },
    
    action: function () {
        var s = Director.get('sharedDirector').get('winSize');
        return actions.MoveBy.create({
            position: geo.ccp(0, -s.height),
            duration: this.get('duration')
        });
    }
});

/**
 * @class Slide in the incoming scene from the bottom.
 * @memberOf cocos.nodes
 * @extends cocos.nodes.TransitionSlideInL
 */
var TransitionSlideInB = TransitionSlideInL.extend(/** @lends cocos.nodes.TransitionSlideInB */{
    sceneOrder: function () {
        this.set('inSceneOnTop', true);
    },

    initScenes: function () {
        var s = Director.get('sharedDirector').get('winSize');
        this.get('inScene').set('position', geo.ccp(0, -s.height));
    },
    
    action: function () {
        var s = Director.get('sharedDirector').get('winSize');
        return actions.MoveBy.create({
            position: geo.ccp(0, s.height),
            duration: this.get('duration')
        });
    }
});

exports.TransitionScene = TransitionScene;
exports.TransitionRotoZoom = TransitionRotoZoom;
exports.TransitionMoveInL = TransitionMoveInL;
exports.TransitionMoveInR = TransitionMoveInR;
exports.TransitionMoveInT = TransitionMoveInT;
exports.TransitionMoveInB = TransitionMoveInB;
exports.TransitionSlideInL = TransitionSlideInL;
exports.TransitionSlideInR = TransitionSlideInR;
exports.TransitionSlideInT = TransitionSlideInT;
exports.TransitionSlideInB = TransitionSlideInB;

}};
__resources__["/__builtin__/libs/cocos2d/Preloader.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    events = require('events');

var Preloader = BObject.extend(/** @lends cocos.Preloader# */{
    /**
     * Total number of resources.
     * @type Integer
     */
    count: -1,

    /**
     * Number of resources that have finished loading
     * @type Integer
     */
    loaded: 0,

    _listeners: null,

    /**
     * @class Preloads all remote resources
     * @memberOf cocos
     * @extends BObject
     * @constructs
     */
    init: function (opts) {
        Preloader.superclass.init.call(this, opts);

        this._listeners = {};
        this.set('count', Object.keys(__remote_resources__).length);
    },

    load: function() {
        this.set('loaded', 0);
        this.set('count', Object.keys(__remote_resources__).length);

        for (var uri in __remote_resources__) {
            if (__remote_resources__.hasOwnProperty(uri)) {
                if (__resources__[uri]) {
                    // Already loaded
                    this.didLoadResource(uri);
                    continue;
                }
                var file = resource(uri);

                // Notify when a resource has loaded
                this._listeners[uri] = events.addListener(file, 'load', util.callback(this, (function(uri) {
                    return function () { this.didLoadResource(uri); };
                })(uri)));

                file.load()
            }
        }
    },
    
    didLoadResource: function(uri) {
        this.set('loaded', this.get('loaded') +1);
        if (this._listeners[uri]) {
            events.removeListener(this._listeners[uri]);
        }
        events.trigger(this, 'load', uri, this);

        if (this.get('loaded') >= this.get('count')) {
            events.trigger(this, 'complete', this);
        }
    }
});

exports.Preloader = Preloader;

}};
__resources__["/__builtin__/libs/cocos2d/RemoteImage.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    events = require('events'),
    RemoteResource = require('./RemoteResource').RemoteResource;

var RemoteImage = RemoteResource.extend(/** @lends cocos.RemoteImage# */{
    /**
     * @memberOf cocos
     * @extends cocos.RemoteResource
     * @constructs
     */
    init: function (opts) {
        RemoteImage.superclass.init.call(this, opts);
    },

    /**
     * Load a remote image
     * @returns Image
     */
    load: function () {
        var img = new Image();
        var self = this;
        img.onload = function () {
            var path = self.get('path');

            var r = __remote_resources__[path];
            __resources__[path] = util.copy(r);
            __resources__[path].data = img;
            __resources__[path].meta.remote = true;

            events.trigger(self, 'load', self);
        };
        
        img.src = this.get('url');

        return img;
    }
});

exports.RemoteImage = RemoteImage;

}};
__resources__["/__builtin__/libs/cocos2d/RemoteResource.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    events = require('events');

var RemoteResource = BObject.extend(/** @lends cocos.RemoteResource# */{
    /**
     * The URL to the remote resource
     * @type String
     */
    url: null,

    /**
     * The path used to reference the resource in the app
     * @type String
     */
    path: null,

    /**
     * @memberOf cocos
     * @extends BObject
     * @constructs
     */
    init: function (opts) {
        RemoteResource.superclass.init.call(this, opts);

        this.set('url', opts.url);
        this.set('path', opts.path);
        
    },

    /**
     * Load the remote resource via ajax
     */
    load: function () {
        var xhr = new XMLHttpRequest();
        var self = this;
        xhr.onreadystatechange = function() {
            if (xhr.readyState == 4) {
                var path = self.get('path');

                var r = __remote_resources__[path];
                __resources__[path] = util.copy(r);
                __resources__[path].data = xhr.responseText;
                __resources__[path].meta.remote = true;

                events.trigger(self, 'load', self);
            }
        };

        xhr.open('GET', this.get('url'), true);  
        xhr.send(null);
    }
});


exports.RemoteResource = RemoteResource;

}};
__resources__["/__builtin__/libs/cocos2d/resources/progress-bar-empty.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARAAAAAgCAYAAADaBycMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAwRJREFUeNrsnbFLW1EUxm9cpP0HLDgUC4JDhoJuOggdBYcg7Sw4BSl0K0inItSpUMSp4NxSHAqOBQfdInTIIAQMDoX4D7TNlJ6PnGtOg76mwUXf7wcf5N28LAfy8d6593630uv10ojMmhZNC6aqacY0ZZpMAHBX6ZouTW1T09QwnZhao/y4MoKBLJtqplXTY+oNcO+5MH01HZiOxjWQJ6YN07rpETUFKB0d077po+n8fwzkmemVaSWM6cZvpmPTqenM9MO/+0WtAe4kD0zTpjnTvGnJ//+VcM+h6b3///9pIHpVeZP6vY7MZ9Mnf6QBgPuNWhYvTM/DmHojb/3V5kYDkfO8C+ahx5Zd017qN1sAoBxocqRu2kz9dkY2kdfxSSQaiG76EF5bvpu2TV+oJUBpWTNtmZ6G15mX/nCRJsKNG8E8zjEPAHAP2E6DJuqKe0WKBrKc+rMtmV3MAwCCieyG63X3jCsDUdMkT9WqYbpHzQAgsOfekNwratlAtMJ01b9QQ0SzLTRMASDSdW/ITVN5xqwMRMvT8wpTdVeZqgWA6zhIgxkYecaiDCSu9zimRgBQQPSIBRlINQycUh8AKCB6RFUGMhMGzqgPABQQPWJGC8l+p8GW/IeJfS0AcDPaO/PTP3cnqAcAjIsM5DJcT1MSACggesSlDKQdBuaoDwAUED2iLQNphoF56gMABUSPaMpAGmFgifoAQAHRIxoyEAWoXviA8kBq1AgArqHmHpHcM05kIEpfzilDijFTEhFJ6wAQmXRvyFGH8oxWnsbVGveOf1aMWZ16AUCgngYRhx33jKvt/Eepn76cUYzZGjUDAPeCzXC9757xVyKZotsP/bPiDbcwEQDMw70g56IeulekYQNRZJmi2/OsjDIQd1L/eAd6IgDlYtL/+ztpkIfacI+4OiOGYx0AYJixj3XIcLAUQDm49YOlMhxtCVBuxj7aMrKcOFwboEzcyuHawyh8Wfmp6o0oxUxBRFOJBivAXUZhydqRr0212henXodWp7dG+fEfAQYAt2e24R/QqdsAAAAASUVORK5CYII=")};
__resources__["/__builtin__/libs/cocos2d/resources/progress-bar-full.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARAAAAAgCAYAAADaBycMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA5lJREFUeNrsnT9IlVEYxo8uUdTSYmAQBoKDQ6KTf0BocAgcLpKrgjSIBC1mRVNU6hKEOISgaxENQUNDIKh3UmxwEARFKNClpaicbs/D9x6/t4vR9eJy73l+8MDx3O9zeOE8nO8957ynoVQqhQpphXqgLqgdaoGaoHNBCFGrHEGH0B60Ba1Da9BOJS83VGAg/VABGoSuKd5C1D370HvoHbRcrYFch8agUeiKYipEchxAi9ACtHsaA7kJ3YNuuT4++AlahTagbeir/fZLsRaiJjkPNUNtUCfUa+O/wT3zAXph4/+/BsJPlcchy3VE3kCvbUojhKhvmLIYhm67PuZGntinzT8NhM4z7cyD05Y5aD5kyRYhRBpwcWQcmghZOiOayJSfiXgD4UMv3WfLZ+gp9Nb906vQANQHddg7FxVrIWqWHzZR2IRWoI/QF/f7EPQIuuE+Z+7aO38ZyDPogZt53Hfmwe8hJlRHoG7FXIi6pQgthSxxWnImMuNmIs+hh2w0Wkd/yFZbInPOPC7bZ80rmYcQdU+3jfVpG/vBvGDOPTNqnnFsIEyaxKVaJkzn3cyDM5FJxVWIpJi0sR9XY+bNG4J5RSEaCHeYDtoPnLJwtSUmTMdkHkIkbSJj1j4yb4ifNfSMVhoIt6fHHabMrsalWiZMRxRDIZJmxLwgmDfEFRh6Rg8NxO/3WHXtgaCchxCp021ecJJHdNFA2l3Hhmv3KXZCiDIv8B7RTgNpcR3brt2huAkhyrzAe0QL94H8DvmR/AshP9fyPWiTmBAi22x2ydo8O/PT2keNio0QolpoIIfu72bX3lV4hBBlXuA94pAGsuc62lx7U3ETQpR5gfeIPRrIluvodO0VxU0IUeYF3iO2aCDrrqPXtXkqr6jYCZE0RfOCkzxinQbCAqr71sF6IAVr80jvkuInRNIshfx4f8E8IphnrNFAWH05VhniwRlWIorLujzSO6sYCpEks+YBwTxhOOSH6+gZO3EZl3vcD6zNMmbj1ubBmRmZiBBJmsdMyA/PjYe8xOGBecbxcf7lkFVfjrCM2ZC1v4WsjNmdoJyIEPVO0cb6lI39YF4w4Z5ZNM9QSUMhEufMShoSFVUWQpBTF1WO6FoHIdKm6msd/ExEF0sJUf+c+cVSEV1tKUTaVH21pac/6HJtIVLiTC7XLofFl1k/lbkRVjFjIaKmkG86E0LUHlwc4Yl8HqrluTjmOrg7faeSl/8IMABgRvK9Q/ireQAAAABJRU5ErkJggg==")};
__resources__["/__builtin__/libs/cocos2d/Scheduler.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util');

/** @ignore */
function HashUpdateEntry() {
    this.timers = [];
    this.timerIndex = 0;
    this.currentTimer = null;
    this.currentTimerSalvaged = false;
    this.paused = false;
}

/** @ignore */
function HashMethodEntry() {
    this.timers = [];
    this.timerIndex = 0;
    this.currentTimer = null;
    this.currentTimerSalvaged = false;
    this.paused = false;
}

var Timer = BObject.extend(/** @lends cocos.Timer# */{
    callback: null,
    interval: 0,
    elapsed: -1,

    /**
     * Runs a function repeatedly at a fixed interval
     *
     * @memberOf cocos
     * @constructs
     * @extends BObject
     *
     * @opt {Function} callback The function to run at each interval
     * @opt {Float} interval Number of milliseconds to wait between each exectuion of callback
     */
    init: function (opts) {
        Timer.superclass.init(this, opts);

        this.set('callback', opts.callback);
        this.set('interval', opts.interval || 0);
        this.set('elapsed', -1);
    },

    /**
     * @private
     */
    update: function (dt) {
        if (this.elapsed == -1) {
            this.elapsed = 0;
        } else {
            this.elapsed += dt;
        }

        if (this.elapsed >= this.interval) {
            this.callback(this.elapsed);
            this.elapsed = 0;
        }
    }
});


var Scheduler = BObject.extend(/** @lends cocos.Scheduler# */{
    updates0: null,
    updatesNeg: null,
    updatesPos: null,
    hashForUpdates: null,
    hashForMethods: null,
    timeScale: 1.0,

    /**
     * Runs the timers
     *
     * @memberOf cocos
     * @constructs
     * @extends BObject
     * @singleton
     * @private
     */
    init: function () {
        this.updates0 = [];
        this.updatesNeg = [];
        this.updatesPos = [];
        this.hashForUpdates = {};
        this.hashForMethods = {};
    },

    /**
     * The scheduled method will be called every 'interval' seconds.
     * If paused is YES, then it won't be called until it is resumed.
     * If 'interval' is 0, it will be called every frame, but if so, it recommened to use 'scheduleUpdateForTarget:' instead.
     * If the selector is already scheduled, then only the interval parameter will be updated without re-scheduling it again.
     */
    schedule: function (opts) {
        var target   = opts.target,
            method   = opts.method,
            interval = opts.interval,
            paused   = opts.paused || false;

        var element = this.hashForMethods[target.get('id')];

        if (!element) {
            element = new HashMethodEntry();
            this.hashForMethods[target.get('id')] = element;
            element.target = target;
            element.paused = paused;
        } else if (element.paused != paused) {
            throw "cocos.Scheduler. Trying to schedule a method with a pause value different than the target";
        }

        var timer = Timer.create({callback: util.callback(target, method), interval: interval});
        element.timers.push(timer);
    },

    /**
     * Schedules the 'update' selector for a given target with a given priority.
     * The 'update' selector will be called every frame.
     * The lower the priority, the earlier it is called.
     */
    scheduleUpdate: function (opts) {
        var target   = opts.target,
            priority = opts.priority,
            paused   = opts.paused;

        var i, len;
        var entry = {target: target, priority: priority, paused: paused};
        var added = false;

        if (priority === 0) {
            this.updates0.push(entry);
        } else if (priority < 0) {
            for (i = 0, len = this.updatesNeg.length; i < len; i++) {
                if (priority < this.updatesNeg[i].priority) {
                    this.updatesNeg.splice(i, 0, entry);
                    added = true;
                    break;
                }
            }

            if (!added) {
                this.updatesNeg.push(entry);
            }
        } else /* priority > 0 */{
            for (i = 0, len = this.updatesPos.length; i < len; i++) {
                if (priority < this.updatesPos[i].priority) {
                    this.updatesPos.splice(i, 0, entry);
                    added = true;
                    break;
                }
            }

            if (!added) {
                this.updatesPos.push(entry);
            }
        }

        this.hashForUpdates[target.get('id')] = entry;
    },

    /**
     * 'tick' the scheduler.
     * You should NEVER call this method, unless you know what you are doing.
     */
    tick: function (dt) {
        var i, len, x;
        if (this.timeScale != 1.0) {
            dt *= this.timeScale;
        }

        var entry;
        for (i = 0, len = this.updatesNeg.length; i < len; i++) {
            entry = this.updatesNeg[i];
            if (entry && !entry.paused) {
                entry.target.update(dt);
            }
        }

        for (i = 0, len = this.updates0.length; i < len; i++) {
            entry = this.updates0[i];
            if (entry && !entry.paused) {
                entry.target.update(dt);
            }
        }

        for (i = 0, len = this.updatesPos.length; i < len; i++) {
            entry = this.updatesPos[i];
            if (entry && !entry.paused) {
                entry.target.update(dt);
            }
        }

        for (x in this.hashForMethods) {
            if (this.hashForMethods.hasOwnProperty(x)) {
                entry = this.hashForMethods[x];

                if (entry) {
                    for (i = 0, len = entry.timers.length; i < len; i++) {
                        var timer = entry.timers[i];
                        if (timer) {
                            timer.update(dt);
                        }
                    }
                }
            }
        }

    },

    /**
     * Unshedules a selector for a given target.
     * If you want to unschedule the "update", use unscheduleUpdateForTarget.
     */
    unschedule: function (opts) {
        if (!opts.target || !opts.method) {
            return;
        }
        var element = this.hashForMethods[opts.target.get('id')];
        if (element) {
            for (var i=0; i<element.timers.length; i++) {
                // Compare callback function
                if (element.timers[i].callback == util.callback(opts.target, opts.method)) {
                    var timer = element.timers.splice(i, 1);
                    timer = null;
                }
            }
        }
    },

    /**
     * Unschedules the update selector for a given target
     */
    unscheduleUpdateForTarget: function (target) {
        if (!target) {
            return;
        }
        var id = target.get('id'),
            elementUpdate = this.hashForUpdates[id];
        if (elementUpdate) {
            // Remove from updates list
            if (elementUpdate.priority === 0) {
                this.updates0.splice(this.updates0.indexOf(elementUpdate), 1);
            } else if (elementUpdate.priority < 0) {
                this.updatesNeg.splice(this.updatesNeg.indexOf(elementUpdate), 1);
            } else /* priority > 0 */{
                this.updatesPos.splice(this.updatesPos.indexOf(elementUpdate), 1);
            }
        }
        // Release HashMethodEntry object
        this.hashForUpdates[id] = null;
    },

    /**
     * Unschedules all selectors from all targets.
     * You should NEVER call this method, unless you know what you are doing.
     */
    unscheduleAllSelectors: function () {
        var i, x, entry;

        // Custom selectors
        for (x in this.hashForMethods) {
            if (this.hashForMethods.hasOwnProperty(x)) {
                entry = this.hashForMethods[x];
                this.unscheduleAllSelectorsForTarget(entry.target);
            }
        }
        // Updates selectors
        for (i = 0, len = this.updatesNeg.length; i < len; i++) {
            entry = this.updatesNeg[i];
            if (entry) {
                this.unscheduleUpdateForTarget(entry.target);
            }
        }

        for (i = 0, len = this.updates0.length; i < len; i++) {
            entry = this.updates0[i];
            if (entry) {
                this.unscheduleUpdateForTarget(entry.target);
            }
        }

        for (i = 0, len = this.updatesPos.length; i < len; i++) {
            entry = this.updatesPos[i];
            if (entry) {
                this.unscheduleUpdateForTarget(entry.target);
            }
        }
    },

    /**
     * Unschedules all selectors for a given target.
     * This also includes the "update" selector.
     */
    unscheduleAllSelectorsForTarget: function (target) {
        if (!target) {
            return;
        }
        // Custom selector
        var element = this.hashForMethods[target.get('id')];
        if (element) {
            element.paused = true;
            element.timers = []; // Clear all timers
        }
        // Release HashMethodEntry object
        this.hashForMethods[target.get('id')] = null;

        // Update selector
        this.unscheduleUpdateForTarget(target);
    },

    /**
     * Pauses the target.
     * All scheduled selectors/update for a given target won't be 'ticked' until the target is resumed.
     * If the target is not present, nothing happens.
     */

    pauseTarget: function (target) {
        var element = this.hashForMethods[target.get('id')];
        if (element) {
            element.paused = true;
        }

        var elementUpdate = this.hashForUpdates[target.get('id')];
        if (elementUpdate) {
            elementUpdate.paused = true;
        }
    },

    /**
     * Resumes the target.
     * The 'target' will be unpaused, so all schedule selectors/update will be 'ticked' again.
     * If the target is not present, nothing happens.
     */

    resumeTarget: function (target) {
        var element = this.hashForMethods[target.get('id')];
        if (element) {
            element.paused = false;
        }

        var elementUpdate = this.hashForUpdates[target.get('id')];
        //console.log('foo', target.get('id'), elementUpdate);
        if (elementUpdate) {
            elementUpdate.paused = false;
        }
    }
});

util.extend(Scheduler, /** @lends cocos.Scheduler */{
    /**
     * A shared singleton instance of cocos.Scheduler
     * @getter sharedScheduler 
     * @type cocos.Scheduler
     */
    get_sharedScheduler: function (key) {
        if (!this._instance) {
            this._instance = this.create();
        }

        return this._instance;
    }
});

exports.Timer = Timer;
exports.Scheduler = Scheduler;

}};
__resources__["/__builtin__/libs/cocos2d/SpriteFrame.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    geo = require('geometry'),
    ccp = geo.ccp;

var SpriteFrame = BObject.extend(/** @lends cocos.SpriteFrame# */{
    rect: null,
    rotated: false,
    offset: null,
    originalSize: null,
    texture: null,

    /**
     * Represents a single frame of animation for a cocos.Sprite
     *
     * <p>A SpriteFrame has:<br>
     * - texture: A Texture2D that will be used by the Sprite<br>
     * - rectangle: A rectangle of the texture</p>
     *
     * <p>You can modify the frame of a Sprite by doing:</p>
     * 
     * <code>var frame = SpriteFrame.create({texture: texture, rect: rect});
     * sprite.set('displayFrame', frame);</code>
     *
     * @memberOf cocos
     * @constructs
     * @extends BObject
     *
     * @opt {cocos.Texture2D} texture The texture to draw this frame using
     * @opt {geometry.Rect} rect The rectangle inside the texture to draw
     */
    init: function (opts) {
        SpriteFrame.superclass.init(this, opts);

        this.texture      = opts.texture;
        this.rect         = opts.rect;
        this.rotated      = !!opts.rotate;
        this.offset       = opts.offset || ccp(0, 0);
        this.originalSize = opts.originalSize || util.copy(this.rect.size);
    },

    /**
     * @ignore
     */
    toString: function () {
        return "[object SpriteFrame | TextureName=" + this.texture.get('name') + ", Rect = (" + this.rect.origin.x + ", " + this.rect.origin.y + ", " + this.rect.size.width + ", " + this.rect.size.height + ")]";
    },

    /**
     * Make a copy of this frame
     *
     * @returns {cocos.SpriteFrame} Exact copy of this object
     */
    copy: function () {
        return SpriteFrame.create({rect: this.rect, rotated: this.rotated, offset: this.offset, originalSize: this.originalSize, texture: this.texture});
    }

});

exports.SpriteFrame = SpriteFrame;

}};
__resources__["/__builtin__/libs/cocos2d/SpriteFrameCache.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray FLIP_Y_AXIS*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    geo = require('geometry'),
    Plist = require('Plist').Plist,
    SpriteFrame = require('./SpriteFrame').SpriteFrame,
    Texture2D = require('./Texture2D').Texture2D;

var SpriteFrameCache = BObject.extend(/** @lends cocos.SpriteFrameCache# */{
    /**
     * List of sprite frames
     * @type Object
     */
    spriteFrames: null,

    /**
     * List of sprite frame aliases
     * @type Object
     */
    spriteFrameAliases: null,


    /**
     * @memberOf cocos
     * @extends BObject
     * @constructs
     * @singleton
     */
    init: function () {
        SpriteFrameCache.superclass.init.call(this);

        this.set('spriteFrames', {});
        this.set('spriteFrameAliases', {});
    },

    /**
     * Add SpriteFrame(s) to the cache
     *
     * @param {String} opts.file The filename of a Zwoptex .plist containing the frame definiitons.
     */
    addSpriteFrames: function (opts) {
        var plistPath = opts.file,
            plist = Plist.create({file: plistPath}),
            plistData = plist.get('data');


        var metaDataDict = plistData.metadata,
            framesDict = plistData.frames;

        var format = 0,
            texturePath = null;

        if (metaDataDict) {
            format = metaDataDict.format;
            // Get texture path from meta data
            texturePath = metaDataDict.textureFileName;
        }

        if (!texturePath) {
            // No texture path so assuming it's the same name as the .plist but ending in .png
            texturePath = plistPath.replace(/\.plist$/i, '.png');
        }


        var texture = Texture2D.create({file: texturePath});

        // Add frames
        for (var frameDictKey in framesDict) {
            if (framesDict.hasOwnProperty(frameDictKey)) {
                var frameDict = framesDict[frameDictKey],
                    spriteFrame = null;

                switch (format) {
                case 0:
                    var x = frameDict.x,
                        y =  frameDict.y,
                        w =  frameDict.width,
                        h =  frameDict.height,
                        ox = frameDict.offsetX,
                        oy = frameDict.offsetY,
                        ow = frameDict.originalWidth,
                        oh = frameDict.originalHeight;

                    // check ow/oh
                    if (!ow || !oh) {
                        //console.log("cocos2d: WARNING: originalWidth/Height not found on the CCSpriteFrame. AnchorPoint won't work as expected. Regenerate the .plist");
                    }

                    if (FLIP_Y_AXIS) {
                        oy *= -1;
                    }

                    // abs ow/oh
                    ow = Math.abs(ow);
                    oh = Math.abs(oh);

                    // create frame
                    spriteFrame = SpriteFrame.create({texture: texture,
                                                         rect: geo.rectMake(x, y, w, h),
                                                       rotate: false,
                                                       offset: geo.ccp(ox, oy),
                                                 originalSize: geo.sizeMake(ow, oh)});
                    break;

                case 1:
                case 2:
                    var frame      = geo.rectFromString(frameDict.frame),
                        rotated    = !!frameDict.rotated,
                        offset     = geo.pointFromString(frameDict.offset),
                        sourceSize = geo.sizeFromString(frameDict.sourceSize);

                    if (FLIP_Y_AXIS) {
                        offset.y *= -1;
                    }


                    // create frame
                    spriteFrame = SpriteFrame.create({texture: texture,
                                                         rect: frame,
                                                       rotate: rotated,
                                                       offset: offset,
                                                 originalSize: sourceSize});
                    break;

                case 3:
                    var spriteSize       = geo.sizeFromString(frameDict.spriteSize),
                        spriteOffset     = geo.pointFromString(frameDict.spriteOffset),
                        spriteSourceSize = geo.sizeFromString(frameDict.spriteSourceSize),
                        textureRect      = geo.rectFromString(frameDict.textureRect),
                        textureRotated   = frameDict.textureRotated;
                    

                    if (FLIP_Y_AXIS) {
                        spriteOffset.y *= -1;
                    }

                    // get aliases
                    var aliases = frameDict.aliases;
                    for (var i = 0, len = aliases.length; i < len; i++) {
                        var alias = aliases[i];
                        this.get('spriteFrameAliases')[frameDictKey] = alias;
                    }
                    
                    // create frame
                    spriteFrame = SpriteFrame.create({texture: texture,
                                                         rect: geo.rectMake(textureRect.origin.x, textureRect.origin.y, spriteSize.width, spriteSize.height),
                                                       rotate: textureRotated,
                                                       offset: spriteOffset,
                                                 originalSize: spriteSourceSize});
                    break;

                default:
                    throw "Unsupported Zwoptex format: " + format;
                }

                // Add sprite frame
                this.get('spriteFrames')[frameDictKey] = spriteFrame;
            }
        }
    },

    /**
     * Get a single SpriteFrame
     *
     * @param {String} opts.name The name of the sprite frame
     * @returns {cocos.SpriteFrame} The sprite frame
     */
    getSpriteFrame: function (opts) {
        var name = opts.name;

        var frame = this.get('spriteFrames')[name];

        if (!frame) {
            // No frame, look for an alias
            var key = this.get('spriteFrameAliases')[name];

            if (key) {
                frame = this.get('spriteFrames')[key];
            }

            if (!frame) {
                throw "Unable to find frame: " + name;
            }
        }

        return frame;
    }
});

/**
 * Class methods
 */
util.extend(SpriteFrameCache, /** @lends cocos.SpriteFrameCache */{
    /**
     * @field
     * @name cocos.SpriteFrameCache.sharedSpriteFrameCache
     * @type cocos.SpriteFrameCache
     */
    get_sharedSpriteFrameCache: function (key) {
        if (!this._instance) {
            this._instance = this.create();
        }

        return this._instance;
    }
});

exports.SpriteFrameCache = SpriteFrameCache;

}};
__resources__["/__builtin__/libs/cocos2d/Texture2D.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    events = require('events'),
    RemoteResource = require('./RemoteResource').RemoteResource;

var Texture2D = BObject.extend(/** @lends cocos.Texture2D# */{
    imgElement: null,
    size: null,
    name: null,
    isLoaded: false,

    /**
     * @memberOf cocos
     * @constructs
     * @extends BObject
     *
     * @opt {String} [file] The file path of the image to use as a texture
     * @opt {Texture2D|HTMLImageElement} [data] Image data to read from
     */
    init: function (opts) {
        var file = opts.file,
            data = opts.data,
            texture = opts.texture;

        if (file) {
            this.name = file;
            data = resource(file);
        } else if (texture) {
            this.name = texture.get('name');
            data = texture.get('imgElement');
        }

        this.size = {width: 0, height: 0};

        if (data instanceof RemoteResource) {
            events.addListener(data, 'load', util.callback(this, this.dataDidLoad));
            this.set('imgElement', data.load());
        } else {
            this.set('imgElement', data);
            this.dataDidLoad(data);
        }
    },

    dataDidLoad: function (data) {
        this.isLoaded = true;
        this.set('size', {width: this.imgElement.width, height: this.imgElement.height});
        events.trigger(self, 'load', self);
    },

    drawAtPoint: function (ctx, point) {
        if (!this.isLoaded) {
            return;
        }
        ctx.drawImage(this.imgElement, point.x, point.y);
    },
    drawInRect: function (ctx, rect) {
        if (!this.isLoaded) {
            return;
        }
        ctx.drawImage(this.imgElement,
            rect.origin.x, rect.origin.y,
            rect.size.width, rect.size.height
        );
    },

    /**
     * @getter data
     * @type {String} Base64 encoded image data
     */
    get_data: function () {
        return this.imgElement ? this.imgElement.src : null;
    },

    /**
     * @getter contentSize
     * @type {geometry.Size} Size of the texture
     */
    get_contentSize: function () {
        return this.size;
    },

    get_pixelsWide: function () {
        return this.size.width;
    },

    get_pixelsHigh: function () {
        return this.size.height;
    }
});

exports.Texture2D = Texture2D;

}};
__resources__["/__builtin__/libs/cocos2d/TextureAtlas.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray FLIP_Y_AXIS*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    Texture2D = require('./Texture2D').Texture2D;


/* QUAD STRUCTURE
 quad = {
     drawRect: <rect>, // Where the quad is drawn to
     textureRect: <rect>  // The slice of the texture to draw in drawRect
 }
*/

var TextureAtlas = BObject.extend(/** @lends cocos.TextureAtlas# */{
    quads: null,
    imgElement: null,
    texture: null,

    /**
     * A single texture that can represent lots of smaller images
     *
     * @memberOf cocos
     * @constructs
     * @extends BObject
     *
     * @opt {String} file The file path of the image to use as a texture
     * @opt {Texture2D|HTMLImageElement} [data] Image data to read from
     * @opt {CanvasElement} [canvas] A canvas to use as a texture
     */
    init: function (opts) {
        var file = opts.file,
            data = opts.data,
            texture = opts.texture,
            canvas = opts.canvas;

        if (canvas) {
            // If we've been given a canvas element then we'll use that for our image
            this.imgElement = canvas;
        } else {
            texture = Texture2D.create({texture: texture, file: file, data: data});
            this.set('texture', texture);
            this.imgElement = texture.get('imgElement');
        }

        this.quads = [];
    },

    insertQuad: function (opts) {
        var quad = opts.quad,
            index = opts.index || 0;

        this.quads.splice(index, 0, quad);
    },
    removeQuad: function (opts) {
        var index = opts.index;

        this.quads.splice(index, 1);
    },


    drawQuads: function (ctx) {
        util.each(this.quads, util.callback(this, function (quad) {
            if (!quad) {
                return;
            }

            this.drawQuad(ctx, quad);
        }));
    },

    drawQuad: function (ctx, quad) {
        var sx = quad.textureRect.origin.x,
            sy = quad.textureRect.origin.y,
            sw = quad.textureRect.size.width, 
            sh = quad.textureRect.size.height;

        var dx = quad.drawRect.origin.x,
            dy = quad.drawRect.origin.y,
            dw = quad.drawRect.size.width, 
            dh = quad.drawRect.size.height;


        var scaleX = 1;
        var scaleY = 1;

        if (FLIP_Y_AXIS) {
            dy -= dh;
            dh *= -1;
        }

            
        if (dw < 0) {
            dw *= -1;
            scaleX = -1;
        }
            
        if (dh < 0) {
            dh *= -1;
            scaleY = -1;
        }

        ctx.scale(scaleX, scaleY);

        var img = this.get('imgElement');
        ctx.drawImage(img, 
            sx, sy, // Draw slice from x,y
            sw, sh, // Draw slice size
            dx, dy, // Draw at 0, 0
            dw, dh  // Draw size
        );
        ctx.scale(1, 1);
    }
});

exports.TextureAtlas = TextureAtlas;

}};
__resources__["/__builtin__/libs/cocos2d/TMXOrientation.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

/**
 * @memberOf cocos
 * @namespace
 */
var TMXOrientation = /** @lends cocos.TMXOrientation */{
    /**
     * Orthogonal orientation
     * @constant
     */
    TMXOrientationOrtho: 1,

    /**
     * Hexagonal orientation
     * @constant
     */
    TMXOrientationHex: 2,

    /**
     * Isometric orientation
     * @constant
     */
    TMXOrientationIso: 3
};

module.exports = TMXOrientation;

}};
__resources__["/__builtin__/libs/cocos2d/TMXXMLParser.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray DOMParser console*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    path = require('path'),
    ccp = require('geometry').ccp,
    base64 = require('base64'),
    gzip   = require('gzip'),
    TMXOrientationOrtho = require('./TMXOrientation').TMXOrientationOrtho,
    TMXOrientationHex = require('./TMXOrientation').TMXOrientationHex,
    TMXOrientationIso = require('./TMXOrientation').TMXOrientationIso;

var TMXTilesetInfo = BObject.extend(/** @lends cocos.TMXTilesetInfo# */{
    name: '',
    firstGID: 0,
    tileSize: null,
    spacing: 0,
    margin: 0,
    sourceImage: null,

    /**
     * @memberOf cocos
     * @constructs
     * @extends BObject
     */
    init: function () {
        TMXTilesetInfo.superclass.init.call(this);
    },

    rectForGID: function (gid) {
        var rect = {size: {}, origin: ccp(0, 0)};
        rect.size = util.copy(this.tileSize);
        
        gid = gid - this.firstGID;

        var imgSize = this.get('imageSize');
        
        var maxX = Math.floor((imgSize.width - this.margin * 2 + this.spacing) / (this.tileSize.width + this.spacing));
        
        rect.origin.x = (gid % maxX) * (this.tileSize.width + this.spacing) + this.margin;
        rect.origin.y = Math.floor(gid / maxX) * (this.tileSize.height + this.spacing) + this.margin;
        
        return rect;
    }
});

var TMXLayerInfo = BObject.extend(/** @lends cocos.TMXLayerInfo# */{
    name: '',
    layerSize: null,
    tiles: null,
    visible: true,
    opacity: 255,
    minGID: 100000,
    maxGID: 0,
    properties: null,
    offset: null,

    /**
     * @memberOf cocos
     * @constructs
     * @extends BObject
     */
    init: function () {
        TMXLayerInfo.superclass.init.call(this);

        this.properties = {};
        this.offset = ccp(0, 0);
    }
});

var TMXObjectGroup = BObject.extend(/** @lends cocos.TMXObjectGroup# */{
    name: '',
    properties: null,
    offset: null,
    objects: null,

    /**
     * @memberOf cocos
     * @constructs
     * @extends BObject
     */
    init: function () {
        TMXObjectGroup.superclass.init.call(this);

        this.properties = {};
        this.objects = {};
        this.offset = ccp(0, 0);
    },

    /**
     * Get the value for the specific property name
     *
     * @opt {String} name Property name
     * @returns {String} Property value
     */
    getProperty: function (opts) {
        var propertyName = opts.name;
        return this.properties[propertyName];
    },

    /**
     * @deprected Since v0.2. You should now use cocos.TMXObjectGroup#getProperty
     */
    propertyNamed: function (opts) {
        console.warn('TMXObjectGroup#propertyNamed is deprected. Use TMXTiledMap#getProperty instread');
        return this.getProperty(opts);
    },

    /**
     * Get the object for the specific object name. It will return the 1st
     * object found on the array for the given name.
     *
     * @opt {String} name Object name
     * @returns {Object} Object
     */
    getObject: function (opts) {
        var objectName = opts.name;
        var object = null;
        
        this.objects.forEach(function (item) {
            if (item.name == objectName) {
                object = item;
            }
        });
        if (object !== null) {
            return object;
        }
    },

    /**
     * @deprected Since v0.2. You should now use cocos.TMXObjectGroup#getProperty
     */
    objectNamed: function (opts) {
        console.warn('TMXObjectGroup#objectNamed is deprected. Use TMXObjectGroup#getObject instread');
        return this.getObject(opts);
    }
});

var TMXMapInfo = BObject.extend(/** @lends cocos.TMXMapInfo# */{
    filename: '',
    orientation: 0,
    mapSize: null,
    tileSize: null,
    layer: null,
    tilesets: null,
    objectGroups: null,
    properties: null,
    tileProperties: null,

    /**
     * @memberOf cocos
     * @constructs
     * @extends BObject
     *
     * @param {String} tmxFile The file path of the TMX file to load
     */
    init: function (tmxFile) {
        TMXMapInfo.superclass.init.call(this, tmxFile);

        this.tilesets = [];
        this.layers = [];
        this.objectGroups = [];
        this.properties = {};
        this.tileProperties = {};
        this.filename = tmxFile;

        this.parseXMLFile(tmxFile);
    },

    parseXMLFile: function (xmlFile) {
        var parser = new DOMParser(),
            doc = parser.parseFromString(resource(xmlFile), 'text/xml');

        // PARSE <map>
        var map = doc.documentElement;

        // Set Orientation
        switch (map.getAttribute('orientation')) {
        case 'orthogonal':
            this.orientation = TMXOrientationOrtho;
            break;
        case 'isometric':
            this.orientation = TMXOrientationIso;
            break;
        case 'hexagonal':
            this.orientation = TMXOrientationHex;
            break;
        default:
            throw "cocos2d: TMXFomat: Unsupported orientation: " + map.getAttribute('orientation');
        }
        this.mapSize = {width: parseInt(map.getAttribute('width'), 10), height: parseInt(map.getAttribute('height'), 10)};
        this.tileSize = {width: parseInt(map.getAttribute('tilewidth'), 10), height: parseInt(map.getAttribute('tileheight'), 10)};


        // PARSE <tilesets>
        var tilesets = map.getElementsByTagName('tileset');
        var i, j, len, jen, s;
        for (i = 0, len = tilesets.length; i < len; i++) {
            var t = tilesets[i];

            var tileset = TMXTilesetInfo.create();
            tileset.set('name', t.getAttribute('name'));
            tileset.set('firstGID', parseInt(t.getAttribute('firstgid'), 10));
            if (t.getAttribute('spacing')) {
                tileset.set('spacing', parseInt(t.getAttribute('spacing'), 10));
            }
            if (t.getAttribute('margin')) {
                tileset.set('margin', parseInt(t.getAttribute('margin'), 10));
            }

            s = {};
            s.width = parseInt(t.getAttribute('tilewidth'), 10);
            s.height = parseInt(t.getAttribute('tileheight'), 10);
            tileset.set('tileSize', s);

            // PARSE <image> We assume there's only 1
            var image = t.getElementsByTagName('image')[0];
            tileset.set('sourceImage', path.join(path.dirname(this.filename), image.getAttribute('source')));

            this.tilesets.push(tileset);
        }

        // PARSE <layers>
        var layers = map.getElementsByTagName('layer');
        for (i = 0, len = layers.length; i < len; i++) {
            var l = layers[i];
            var data = l.getElementsByTagName('data')[0];
            var layer = TMXLayerInfo.create();

            layer.set('name', l.getAttribute('name'));
            if (l.getAttribute('visible') !== false) {
                layer.set('visible', true);
            } else {
                layer.set('visible', !!parseInt(l.getAttribute('visible'), 10));
            }

            s = {};
            s.width = parseInt(l.getAttribute('width'), 10);
            s.height = parseInt(l.getAttribute('height'), 10);
            layer.set('layerSize', s);

            var opacity = l.getAttribute('opacity');
            if (!opacity && opacity !== 0) {
                layer.set('opacity', 255);
            } else {
                layer.set('opacity', 255 * parseFloat(opacity));
            }

            var x = parseInt(l.getAttribute('x'), 10),
                y = parseInt(l.getAttribute('y'), 10);
            if (isNaN(x)) {
                x = 0;
            }
            if (isNaN(y)) {
                y = 0;
            }
            layer.set('offset', ccp(x, y));


            // Firefox has a 4KB limit on node values. It will split larger
            // nodes up into multiple nodes. So, we'll stitch them back
            // together.
            var nodeValue = '';
            for (j = 0, jen = data.childNodes.length; j < jen; j++) {
                nodeValue += data.childNodes[j].nodeValue;
            }

            // Unpack the tilemap data
            var compression = data.getAttribute('compression');
            switch (compression) {
            case 'gzip':
                layer.set('tiles', gzip.unzipBase64AsArray(nodeValue, 4));
                break;
                
            // Uncompressed
            case null:
            case '': 
                layer.set('tiles', base64.decodeAsArray(nodeValue, 4));
                break;

            default: 
                throw "Unsupported TMX Tile Map compression: " + compression;
            }

            this.layers.push(layer);
        }

        // TODO PARSE <tile>

        // PARSE <objectgroup>
        var objectgroups = map.getElementsByTagName('objectgroup');
        for (i = 0, len = objectgroups.length; i < len; i++) {
            var g = objectgroups[i],
                objectGroup = TMXObjectGroup.create();

            objectGroup.set('name', g.getAttribute('name'));
            
            var properties = g.querySelectorAll('objectgroup > properties property'),
                propertiesValue = {},
                property;
            
            for (j = 0; j < properties.length; j++) {
                property = properties[j];
                if (property.getAttribute('name')) {
                    propertiesValue[property.getAttribute('name')] = property.getAttribute('value');
                }
            }
           
            objectGroup.set('properties', propertiesValue);

            var objectsArray = [],
                objects = g.querySelectorAll('object');

            for (j = 0; j < objects.length; j++) {
                var object = objects[j];
                var objectValue = {
                    x       : parseInt(object.getAttribute('x'), 10),
                    y       : parseInt(object.getAttribute('y'), 10),
                    width   : parseInt(object.getAttribute('width'), 10),
                    height  : parseInt(object.getAttribute('height'), 10)
                };
                if (object.getAttribute('name')) {
                    objectValue.name = object.getAttribute('name');
                }
                if (object.getAttribute('type')) {
                    objectValue.type = object.getAttribute('type');
                }
                properties = object.querySelectorAll('property');
                for (var k = 0; k < properties.length; k++) {
                    property = properties[k];
                    if (property.getAttribute('name')) {
                        objectValue[property.getAttribute('name')] = property.getAttribute('value');
                    }
                }
                objectsArray.push(objectValue);

            }
            objectGroup.set('objects', objectsArray);
            this.objectGroups.push(objectGroup);
        }


        // PARSE <map><property>
        var properties = doc.querySelectorAll('map > properties > property');

        for (i = 0; i < properties.length; i++) {
            var property = properties[i];
            if (property.getAttribute('name')) {
                this.properties[property.getAttribute('name')] = property.getAttribute('value');
            }
        }
    }
});

exports.TMXMapInfo = TMXMapInfo;
exports.TMXLayerInfo = TMXLayerInfo;
exports.TMXTilesetInfo = TMXTilesetInfo;
exports.TMXObjectGroup = TMXObjectGroup;

}};
__resources__["/__builtin__/libs/geometry.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util');

var RE_PAIR = /\{\s*([\d.\-]+)\s*,\s*([\d.\-]+)\s*\}/,
    RE_DOUBLE_PAIR = /\{\s*(\{[\s\d,.\-]+\})\s*,\s*(\{[\s\d,.\-]+\})\s*\}/;

Math.PI_2 = 1.57079632679489661923132169163975144     /* pi/2 */

/** @namespace */
var geometry = {
    /**
     * @class
     * A 2D point in space
     *
     * @param {Float} x X value
     * @param {Float} y Y value
     */
    Point: function (x, y) {
        /**
         * X coordinate
         * @type Float
         */
        this.x = x;

        /**
         * Y coordinate
         * @type Float
         */
        this.y = y;
    },

    /**
     * @class
     * A 2D size
     *
     * @param {Float} w Width
     * @param {Float} h Height
     */
    Size: function (w, h) {
        /**
         * Width
         * @type Float
         */
        this.width = w;

        /**
         * Height
         * @type Float
         */
        this.height = h;
    },

    /**
     * @class
     * A rectangle
     *
     * @param {Float} x X value
     * @param {Float} y Y value
     * @param {Float} w Width
     * @param {Float} h Height
     */
    Rect: function (x, y, w, h) {
        /**
         * Coordinate in 2D space
         * @type {geometry.Point}
         */
        this.origin = new geometry.Point(x, y);

        /**
         * Size in 2D space
         * @type {geometry.Size}
         */
        this.size   = new geometry.Size(w, h);
    },

    /**
     * @class
     * Transform matrix
     *
     * @param {Float} a
     * @param {Float} b
     * @param {Float} c
     * @param {Float} d
     * @param {Float} tx
     * @param {Float} ty
     */
    TransformMatrix: function (a, b, c, d, tx, ty) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.tx = tx;
        this.ty = ty;
    },

    /**
     * @class 
     * Bezier curve control object
     *
     * @param {geometry.Point} controlPoint1
     * @param {geometry.Point} controlPoint2
     * @param {geometry.Point} endPoint
     */
    BezierConfig: function(p1, p2, ep) {
        this.controlPoint1 = util.copy(p1);
        this.controlPoint2 = util.copy(p2);
        this.endPosition = util.copy(ep);
    },
    
    /**
     * Creates a geometry.Point instance
     *
     * @param {Float} x X coordinate
     * @param {Float} y Y coordinate
     * @returns {geometry.Point} 
     */
    ccp: function (x, y) {
        return module.exports.pointMake(x, y);
    },

    /**
     * Add the values of two points together
     *
     * @param {geometry.Point} p1 First point
     * @param {geometry.Point} p2 Second point
     * @returns {geometry.Point} New point
     */
    ccpAdd: function (p1, p2) {
        return geometry.ccp(p1.x + p2.x, p1.y + p2.y);
    },

    /**
     * Subtract the values of two points
     *
     * @param {geometry.Point} p1 First point
     * @param {geometry.Point} p2 Second point
     * @returns {geometry.Point} New point
     */
    ccpSub: function (p1, p2) {
        return geometry.ccp(p1.x - p2.x, p1.y - p2.y);
    },

    /**
     * Muliply the values of two points together
     *
     * @param {geometry.Point} p1 First point
     * @param {geometry.Point} p2 Second point
     * @returns {geometry.Point} New point
     */
    ccpMult: function (p1, p2) {
        return geometry.ccp(p1.x * p2.x, p1.y * p2.y);
    },


    /**
     * Invert the values of a geometry.Point
     *
     * @param {geometry.Point} p Point to invert
     * @returns {geometry.Point} New point
     */
    ccpNeg: function (p) {
        return geometry.ccp(-p.x, -p.y);
    },

    /**
     * Round values on a geometry.Point to whole numbers
     *
     * @param {geometry.Point} p Point to round
     * @returns {geometry.Point} New point
     */
    ccpRound: function (p) {
        return geometry.ccp(Math.round(p.x), Math.round(p.y));
    },

    /**
     * Round up values on a geometry.Point to whole numbers
     *
     * @param {geometry.Point} p Point to round
     * @returns {geometry.Point} New point
     */
    ccpCeil: function (p) {
        return geometry.ccp(Math.ceil(p.x), Math.ceil(p.y));
    },

    /**
     * Round down values on a geometry.Point to whole numbers
     *
     * @param {geometry.Point} p Point to round
     * @returns {geometry.Point} New point
     */
    ccpFloor: function (p) {
        return geometry.ccp(Math.floor(p.x), Math.floor(p.y));
    },

    /**
     * A point at 0x0
     *
     * @returns {geometry.Point} New point at 0x0
     */
    PointZero: function () {
        return geometry.ccp(0, 0);
    },

    /**
     * @returns {geometry.Rect}
     */
    rectMake: function (x, y, w, h) {
        return new geometry.Rect(x, y, w, h);
    },

    /**
     * @returns {geometry.Rect}
     */
    rectFromString: function (str) {
        var matches = str.match(RE_DOUBLE_PAIR),
            p = geometry.pointFromString(matches[1]),
            s = geometry.sizeFromString(matches[2]);

        return geometry.rectMake(p.x, p.y, s.width, s.height);
    },

    /**
     * @returns {geometry.Size}
     */
    sizeMake: function (w, h) {
        return new geometry.Size(w, h);
    },

    /**
     * @returns {geometry.Size}
     */
    sizeFromString: function (str) {
        var matches = str.match(RE_PAIR),
            w = parseFloat(matches[1]),
            h = parseFloat(matches[2]);

        return geometry.sizeMake(w, h);
    },

    /**
     * @returns {geometry.Point}
     */
    pointMake: function (x, y) {
        return new geometry.Point(x, y);
    },

    /**
     * @returns {geometry.Point}
     */
    pointFromString: function (str) {
        var matches = str.match(RE_PAIR),
            x = parseFloat(matches[1]),
            y = parseFloat(matches[2]);

        return geometry.pointMake(x, y);
    },

    /**
     * @returns {Boolean}
     */
    rectContainsPoint: function (r, p) {
        return ((p.x >= r.origin.x && p.x <= r.origin.x + r.size.width) &&
                (p.y >= r.origin.y && p.y <= r.origin.y + r.size.height));
    },

    /**
     * Returns the smallest rectangle that contains the two source rectangles.
     *
     * @param {geometry.Rect} r1
     * @param {geometry.Rect} r2
     * @returns {geometry.Rect}
     */
    rectUnion: function (r1, r2) {
        var rect = new geometry.Rect(0, 0, 0, 0);

        rect.origin.x = Math.min(r1.origin.x, r2.origin.x);
        rect.origin.y = Math.min(r1.origin.y, r2.origin.y);
        rect.size.width = Math.max(r1.origin.x + r1.size.width, r2.origin.x + r2.size.width) - rect.origin.x;
        rect.size.height = Math.max(r1.origin.y + r1.size.height, r2.origin.y + r2.size.height) - rect.origin.y;

        return rect;
    },

    /**
     * @returns {Boolean}
     */
    rectOverlapsRect: function (r1, r2) {
        if (r1.origin.x + r1.size.width < r2.origin.x) {
            return false;
        }
        if (r2.origin.x + r2.size.width < r1.origin.x) {
            return false;
        }
        if (r1.origin.y + r1.size.height < r2.origin.y) {
            return false;
        }
        if (r2.origin.y + r2.size.height < r1.origin.y) {
            return false;
        }

        return true;
    },

    /**
     * Returns the overlapping portion of 2 rectangles
     *
     * @param {geometry.Rect} lhsRect First rectangle
     * @param {geometry.Rect} rhsRect Second rectangle
     * @returns {geometry.Rect} The overlapping portion of the 2 rectangles
     */
    rectIntersection: function (lhsRect, rhsRect) {

        var intersection = new geometry.Rect(
            Math.max(geometry.rectGetMinX(lhsRect), geometry.rectGetMinX(rhsRect)),
            Math.max(geometry.rectGetMinY(lhsRect), geometry.rectGetMinY(rhsRect)),
            0,
            0
        );

        intersection.size.width = Math.min(geometry.rectGetMaxX(lhsRect), geometry.rectGetMaxX(rhsRect)) - geometry.rectGetMinX(intersection);
        intersection.size.height = Math.min(geometry.rectGetMaxY(lhsRect), geometry.rectGetMaxY(rhsRect)) - geometry.rectGetMinY(intersection);

        return intersection;
    },

    /**
     * @returns {Boolean}
     */
    pointEqualToPoint: function (point1, point2) {
        return (point1.x == point2.x && point1.y == point2.y);
    },

    /**
     * @returns {Boolean}
     */
    sizeEqualToSize: function (size1, size2) {
        return (size1.width == size2.width && size1.height == size2.height);
    },

    /**
     * @returns {Boolean}
     */
    rectEqualToRect: function (rect1, rect2) {
        return (module.exports.sizeEqualToSize(rect1.size, rect2.size) && module.exports.pointEqualToPoint(rect1.origin, rect2.origin));
    },

    /**
     * @returns {Float}
     */
    rectGetMinX: function (rect) {
        return rect.origin.x;
    },

    /**
     * @returns {Float}
     */
    rectGetMinY: function (rect) {
        return rect.origin.y;
    },

    /**
     * @returns {Float}
     */
    rectGetMaxX: function (rect) {
        return rect.origin.x + rect.size.width;
    },

    /**
     * @returns {Float}
     */
    rectGetMaxY: function (rect) {
        return rect.origin.y + rect.size.height;
    },

    boundingRectMake: function (p1, p2, p3, p4) {
        var minX = Math.min(p1.x, p2.x, p3.x, p4.x);
        var minY = Math.min(p1.y, p2.y, p3.y, p4.y);
        var maxX = Math.max(p1.x, p2.x, p3.x, p4.x);
        var maxY = Math.max(p1.y, p2.y, p3.y, p4.y);

        return new geometry.Rect(minX, minY, (maxX - minX), (maxY - minY));
    },

    /**
     * @returns {geometry.Point}
     */
    pointApplyAffineTransform: function (point, t) {

        /*
        aPoint.x * aTransform.a + aPoint.y * aTransform.c + aTransform.tx,
        aPoint.x * aTransform.b + aPoint.y * aTransform.d + aTransform.ty
        */

        return new geometry.Point(t.a * point.x + t.c * point.y + t.tx, t.b * point.x + t.d * point.y + t.ty);

    },

    /**
     * Apply a transform matrix to a rectangle
     *
     * @param {geometry.Rect} rect Rectangle to transform
     * @param {geometry.TransformMatrix} trans TransformMatrix to apply to rectangle
     * @returns {geometry.Rect} A new transformed rectangle
     */
    rectApplyAffineTransform: function (rect, trans) {

        var p1 = geometry.ccp(geometry.rectGetMinX(rect), geometry.rectGetMinY(rect));
        var p2 = geometry.ccp(geometry.rectGetMaxX(rect), geometry.rectGetMinY(rect));
        var p3 = geometry.ccp(geometry.rectGetMinX(rect), geometry.rectGetMaxY(rect));
        var p4 = geometry.ccp(geometry.rectGetMaxX(rect), geometry.rectGetMaxY(rect));

        p1 = geometry.pointApplyAffineTransform(p1, trans);
        p2 = geometry.pointApplyAffineTransform(p2, trans);
        p3 = geometry.pointApplyAffineTransform(p3, trans);
        p4 = geometry.pointApplyAffineTransform(p4, trans);

        return geometry.boundingRectMake(p1, p2, p3, p4);
    },

    /**
     * Inverts a transform matrix
     *
     * @param {geometry.TransformMatrix} trans TransformMatrix to invert
     * @returns {geometry.TransformMatrix} New transform matrix
     */
    affineTransformInvert: function (trans) {
        var determinant = 1 / (trans.a * trans.d - trans.b * trans.c);

        return new geometry.TransformMatrix(
            determinant * trans.d,
            -determinant * trans.b,
            -determinant * trans.c,
            determinant * trans.a,
            determinant * (trans.c * trans.ty - trans.d * trans.tx),
            determinant * (trans.b * trans.tx - trans.a * trans.ty)
        );
    },

    /**
     * Multiply 2 transform matrices together
     * @param {geometry.TransformMatrix} lhs Left matrix
     * @param {geometry.TransformMatrix} rhs Right matrix
     * @returns {geometry.TransformMatrix} New transform matrix
     */
    affineTransformConcat: function (lhs, rhs) {
        return new geometry.TransformMatrix(
            lhs.a * rhs.a + lhs.b * rhs.c,
            lhs.a * rhs.b + lhs.b * rhs.d,
            lhs.c * rhs.a + lhs.d * rhs.c,
            lhs.c * rhs.b + lhs.d * rhs.d,
            lhs.tx * rhs.a + lhs.ty * rhs.c + rhs.tx,
            lhs.tx * rhs.b + lhs.ty * rhs.d + rhs.ty
        );
    },

    /**
     * @returns {Float}
     */
    degreesToRadians: function (angle) {
        return angle / 180.0 * Math.PI;
    },

    /**
     * @returns {Float}
     */
    radiansToDegrees: function (angle) {
        return angle * (180.0 / Math.PI);
    },

    /**
     * Translate (move) a transform matrix
     *
     * @param {geometry.TransformMatrix} trans TransformMatrix to translate
     * @param {Float} tx Amount to translate along X axis
     * @param {Float} ty Amount to translate along Y axis
     * @returns {geometry.TransformMatrix} A new TransformMatrix
     */
    affineTransformTranslate: function (trans, tx, ty) {
        var newTrans = util.copy(trans);
        newTrans.tx = trans.tx + trans.a * tx + trans.c * ty;
        newTrans.ty = trans.ty + trans.b * tx + trans.d * ty;
        return newTrans;
    },

    /**
     * Rotate a transform matrix
     *
     * @param {geometry.TransformMatrix} trans TransformMatrix to rotate
     * @param {Float} angle Angle in radians
     * @returns {geometry.TransformMatrix} A new TransformMatrix
     */
    affineTransformRotate: function (trans, angle) {
        var sin = Math.sin(angle),
            cos = Math.cos(angle);

        return new geometry.TransformMatrix(
            trans.a * cos + trans.c * sin,
            trans.b * cos + trans.d * sin,
            trans.c * cos - trans.a * sin,
            trans.d * cos - trans.b * sin,
            trans.tx,
            trans.ty
        );
    },

    /**
     * Scale a transform matrix
     *
     * @param {geometry.TransformMatrix} trans TransformMatrix to scale
     * @param {Float} sx X scale factor
     * @param {Float} [sy=sx] Y scale factor
     * @returns {geometry.TransformMatrix} A new TransformMatrix
     */
    affineTransformScale: function (trans, sx, sy) {
        if (sy === undefined) {
            sy = sx;
        }

        return new geometry.TransformMatrix(trans.a * sx, trans.b * sx, trans.c * sy, trans.d * sy, trans.tx, trans.ty);
    },

    /**
     * @returns {geometry.TransformMatrix} identity matrix
     */
    affineTransformIdentity: function () {
        return new geometry.TransformMatrix(1, 0, 0, 1, 0, 0);
    }
};

module.exports = geometry;

}};
__resources__["/__builtin__/libs/gzip.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/**
 * @fileoverview 
 */

/** @ignore */
var JXG = require('./JXGUtil');

/**
 * @namespace
 * Wrappers around JXG's GZip utils
 * @see JXG.Util
 */
var gzip = {
    /**
     * Unpack a gzipped byte array
     *
     * @param {Integer[]} input Byte array
     * @returns {String} Unpacked byte string
     */
    unzip: function(input) {
        return (new JXG.Util.Unzip(input)).unzip()[0][0];
    },

    /**
     * Unpack a gzipped byte string encoded as base64
     *
     * @param {String} input Byte string encoded as base64
     * @returns {String} Unpacked byte string
     */
    unzipBase64: function(input) {
        return (new JXG.Util.Unzip(JXG.Util.Base64.decodeAsArray(input))).unzip()[0][0];
    },

    /**
     * Unpack a gzipped byte string encoded as base64
     *
     * @param {String} input Byte string encoded as base64
     * @param {Integer} bytes Bytes per array item
     * @returns {Integer[]} Unpacked byte array
     */
    unzipBase64AsArray: function(input, bytes) {
        bytes = bytes || 1;

        var dec = this.unzipBase64(input),
            ar = [], i, j, len;
        for (i = 0, len = dec.length/bytes; i < len; i++){
            ar[i] = 0;
            for (j = bytes-1; j >= 0; --j){
                ar[i] += dec.charCodeAt((i *bytes) +j) << (j *8);
            }
        }
        return ar;
    },

    /**
     * Unpack a gzipped byte array
     *
     * @param {Integer[]} input Byte array
     * @param {Integer} bytes Bytes per array item
     * @returns {Integer[]} Unpacked byte array
     */
    unzipAsArray: function (input, bytes) {
        bytes = bytes || 1;

        var dec = this.unzip(input),
            ar = [], i, j, len;
        for (i = 0, len = dec.length/bytes; i < len; i++){
            ar[i] = 0;
            for (j = bytes-1; j >= 0; --j){
                ar[i] += dec.charCodeAt((i *bytes) +j) << (j *8);
            }
        }
        return ar;
    }

};

module.exports = gzip;

}};
__resources__["/__builtin__/libs/JXGUtil.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*
    Copyright 2008,2009
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with JSXGraph.  If not, see <http://www.gnu.org/licenses/>.
*/

/**
 * @fileoverview Utilities for uncompressing and base64 decoding
 */

/** @namespace */
var JXG = {};

/**
  * @class Util class
  * Class for gunzipping, unzipping and base64 decoding of files.
  * It is used for reading GEONExT, Geogebra and Intergeo files.
  *
  * Only Huffman codes are decoded in gunzip.
  * The code is based on the source code for gunzip.c by Pasi Ojala 
  * @see <a href="http://www.cs.tut.fi/~albert/Dev/gunzip/gunzip.c">http://www.cs.tut.fi/~albert/Dev/gunzip/gunzip.c</a>
  * @see <a href="http://www.cs.tut.fi/~albert">http://www.cs.tut.fi/~albert</a>
  */
JXG.Util = {};
                                 
/**
 * Unzip zip files
 */
JXG.Util.Unzip = function (barray){
    var outputArr = [],
        output = "",
        debug = false,
        gpflags,
        files = 0,
        unzipped = [],
        crc,
        buf32k = new Array(32768),
        bIdx = 0,
        modeZIP=false,

        CRC, SIZE,
    
        bitReverse = [
        0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,
        0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
        0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,
        0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,
        0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,
        0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,
        0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,
        0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,
        0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,
        0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
        0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,
        0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,
        0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,
        0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,
        0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,
        0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,
        0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,
        0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,
        0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,
        0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
        0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,
        0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
        0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,
        0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,
        0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,
        0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,
        0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,
        0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,
        0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,
        0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
        0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,
        0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff
    ],
    
    cplens = [
        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
    ],

    cplext = [
        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99
    ], /* 99==invalid */

    cpdist = [
        0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0007, 0x0009, 0x000d,
        0x0011, 0x0019, 0x0021, 0x0031, 0x0041, 0x0061, 0x0081, 0x00c1,
        0x0101, 0x0181, 0x0201, 0x0301, 0x0401, 0x0601, 0x0801, 0x0c01,
        0x1001, 0x1801, 0x2001, 0x3001, 0x4001, 0x6001
    ],

    cpdext = [
        0,  0,  0,  0,  1,  1,  2,  2,
        3,  3,  4,  4,  5,  5,  6,  6,
        7,  7,  8,  8,  9,  9, 10, 10,
        11, 11, 12, 12, 13, 13
    ],
    
    border = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
    
    bA = barray,

    bytepos=0,
    bitpos=0,
    bb = 1,
    bits=0,
    
    NAMEMAX = 256,
    
    nameBuf = [],
    
    fileout;
    
    function readByte(){
        bits+=8;
        if (bytepos<bA.length){
            //if (debug)
            //    document.write(bytepos+": "+bA[bytepos]+"<br>");
            return bA[bytepos++];
        } else
            return -1;
    };

    function byteAlign(){
        bb = 1;
    };
    
    function readBit(){
        var carry;
        bits++;
        carry = (bb & 1);
        bb >>= 1;
        if (bb==0){
            bb = readByte();
            carry = (bb & 1);
            bb = (bb>>1) | 0x80;
        }
        return carry;
    };

    function readBits(a) {
        var res = 0,
            i = a;
    
        while(i--) {
            res = (res<<1) | readBit();
        }
        if(a) {
            res = bitReverse[res]>>(8-a);
        }
        return res;
    };
        
    function flushBuffer(){
        //document.write('FLUSHBUFFER:'+buf32k);
        bIdx = 0;
    };
    function addBuffer(a){
        SIZE++;
        //CRC=updcrc(a,crc);
        buf32k[bIdx++] = a;
        outputArr.push(String.fromCharCode(a));
        //output+=String.fromCharCode(a);
        if(bIdx==0x8000){
            //document.write('ADDBUFFER:'+buf32k);
            bIdx=0;
        }
    };
    
    function HufNode() {
        this.b0=0;
        this.b1=0;
        this.jump = null;
        this.jumppos = -1;
    };

    var LITERALS = 288;
    
    var literalTree = new Array(LITERALS);
    var distanceTree = new Array(32);
    var treepos=0;
    var Places = null;
    var Places2 = null;
    
    var impDistanceTree = new Array(64);
    var impLengthTree = new Array(64);
    
    var len = 0;
    var fpos = new Array(17);
    fpos[0]=0;
    var flens;
    var fmax;
    
    function IsPat() {
        while (1) {
            if (fpos[len] >= fmax)
                return -1;
            if (flens[fpos[len]] == len)
                return fpos[len]++;
            fpos[len]++;
        }
    };

    function Rec() {
        var curplace = Places[treepos];
        var tmp;
        if (debug)
    		document.write("<br>len:"+len+" treepos:"+treepos);
        if(len==17) { //war 17
            return -1;
        }
        treepos++;
        len++;
    	
        tmp = IsPat();
        if (debug)
        	document.write("<br>IsPat "+tmp);
        if(tmp >= 0) {
            curplace.b0 = tmp;    /* leaf cell for 0-bit */
            if (debug)
            	document.write("<br>b0 "+curplace.b0);
        } else {
        /* Not a Leaf cell */
        curplace.b0 = 0x8000;
        if (debug)
        	document.write("<br>b0 "+curplace.b0);
        if(Rec())
            return -1;
        }
        tmp = IsPat();
        if(tmp >= 0) {
            curplace.b1 = tmp;    /* leaf cell for 1-bit */
            if (debug)
            	document.write("<br>b1 "+curplace.b1);
            curplace.jump = null;    /* Just for the display routine */
        } else {
            /* Not a Leaf cell */
            curplace.b1 = 0x8000;
            if (debug)
            	document.write("<br>b1 "+curplace.b1);
            curplace.jump = Places[treepos];
            curplace.jumppos = treepos;
            if(Rec())
                return -1;
        }
        len--;
        return 0;
    };

    function CreateTree(currentTree, numval, lengths, show) {
        var i;
        /* Create the Huffman decode tree/table */
        //document.write("<br>createtree<br>");
        if (debug)
        	document.write("currentTree "+currentTree+" numval "+numval+" lengths "+lengths+" show "+show);
        Places = currentTree;
        treepos=0;
        flens = lengths;
        fmax  = numval;
        for (i=0;i<17;i++)
            fpos[i] = 0;
        len = 0;
        if(Rec()) {
            //fprintf(stderr, "invalid huffman tree\n");
            if (debug)
            	alert("invalid huffman tree\n");
            return -1;
        }
        if (debug){
        	document.write('<br>Tree: '+Places.length);
        	for (var a=0;a<32;a++){
            	document.write("Places["+a+"].b0="+Places[a].b0+"<br>");
            	document.write("Places["+a+"].b1="+Places[a].b1+"<br>");
        	}
        }

        return 0;
    };
    
    function DecodeValue(currentTree) {
        var len, i,
            xtreepos=0,
            X = currentTree[xtreepos],
            b;

        /* decode one symbol of the data */
        while(1) {
            b=readBit();
            if (debug)
            	document.write("b="+b);
            if(b) {
                if(!(X.b1 & 0x8000)){
                	if (debug)
                    	document.write("ret1");
                    return X.b1;    /* If leaf node, return data */
                }
                X = X.jump;
                len = currentTree.length;
                for (i=0;i<len;i++){
                    if (currentTree[i]===X){
                        xtreepos=i;
                        break;
                    }
                }
                //xtreepos++;
            } else {
                if(!(X.b0 & 0x8000)){
                	if (debug)
                    	document.write("ret2");
                    return X.b0;    /* If leaf node, return data */
                }
                //X++; //??????????????????
                xtreepos++;
                X = currentTree[xtreepos];
            }
        }
        if (debug)
        	document.write("ret3");
        return -1;
    };
    
    function DeflateLoop() {
    var last, c, type, i, len;

    do {
        /*if((last = readBit())){
            fprintf(errfp, "Last Block: ");
        } else {
            fprintf(errfp, "Not Last Block: ");
        }*/
        last = readBit();
        type = readBits(2);
        switch(type) {
            case 0:
            	if (debug)
                	alert("Stored\n");
                break;
            case 1:
            	if (debug)
                	alert("Fixed Huffman codes\n");
                break;
            case 2:
            	if (debug)
                	alert("Dynamic Huffman codes\n");
                break;
            case 3:
            	if (debug)
                	alert("Reserved block type!!\n");
                break;
            default:
            	if (debug)
                	alert("Unexpected value %d!\n", type);
                break;
        }

        if(type==0) {
            var blockLen, cSum;

            // Stored 
            byteAlign();
            blockLen = readByte();
            blockLen |= (readByte()<<8);

            cSum = readByte();
            cSum |= (readByte()<<8);

            if(((blockLen ^ ~cSum) & 0xffff)) {
                document.write("BlockLen checksum mismatch\n");
            }
            while(blockLen--) {
                c = readByte();
                addBuffer(c);
            }
        } else if(type==1) {
            var j;

            /* Fixed Huffman tables -- fixed decode routine */
            while(1) {
            /*
                256    0000000        0
                :   :     :
                279    0010111        23
                0   00110000    48
                :    :      :
                143    10111111    191
                280 11000000    192
                :    :      :
                287 11000111    199
                144    110010000    400
                :    :       :
                255    111111111    511
    
                Note the bit order!
                */

            j = (bitReverse[readBits(7)]>>1);
            if(j > 23) {
                j = (j<<1) | readBit();    /* 48..255 */

                if(j > 199) {    /* 200..255 */
                    j -= 128;    /*  72..127 */
                    j = (j<<1) | readBit();        /* 144..255 << */
                } else {        /*  48..199 */
                    j -= 48;    /*   0..151 */
                    if(j > 143) {
                        j = j+136;    /* 280..287 << */
                        /*   0..143 << */
                    }
                }
            } else {    /*   0..23 */
                j += 256;    /* 256..279 << */
            }
            if(j < 256) {
                addBuffer(j);
                //document.write("out:"+String.fromCharCode(j));
                /*fprintf(errfp, "@%d %02x\n", SIZE, j);*/
            } else if(j == 256) {
                /* EOF */
                break;
            } else {
                var len, dist;

                j -= 256 + 1;    /* bytes + EOF */
                len = readBits(cplext[j]) + cplens[j];

                j = bitReverse[readBits(5)]>>3;
                if(cpdext[j] > 8) {
                    dist = readBits(8);
                    dist |= (readBits(cpdext[j]-8)<<8);
                } else {
                    dist = readBits(cpdext[j]);
                }
                dist += cpdist[j];

                /*fprintf(errfp, "@%d (l%02x,d%04x)\n", SIZE, len, dist);*/
                for(j=0;j<len;j++) {
                    var c = buf32k[(bIdx - dist) & 0x7fff];
                    addBuffer(c);
                }
            }
            } // while
        } else if(type==2) {
            var j, n, literalCodes, distCodes, lenCodes;
            var ll = new Array(288+32);    // "static" just to preserve stack
    
            // Dynamic Huffman tables 
    
            literalCodes = 257 + readBits(5);
            distCodes = 1 + readBits(5);
            lenCodes = 4 + readBits(4);
            //document.write("<br>param: "+literalCodes+" "+distCodes+" "+lenCodes+"<br>");
            for(j=0; j<19; j++) {
                ll[j] = 0;
            }
    
            // Get the decode tree code lengths
    
            //document.write("<br>");
            for(j=0; j<lenCodes; j++) {
                ll[border[j]] = readBits(3);
                //document.write(ll[border[j]]+" ");
            }
            //fprintf(errfp, "\n");
            //document.write('<br>ll:'+ll);
            len = distanceTree.length;
            for (i=0; i<len; i++)
                distanceTree[i]=new HufNode();
            if(CreateTree(distanceTree, 19, ll, 0)) {
                flushBuffer();
                return 1;
            }
            if (debug){
            	document.write("<br>distanceTree");
            	for(var a=0;a<distanceTree.length;a++){
                	document.write("<br>"+distanceTree[a].b0+" "+distanceTree[a].b1+" "+distanceTree[a].jump+" "+distanceTree[a].jumppos);
                	/*if (distanceTree[a].jumppos!=-1)
                    	document.write(" "+distanceTree[a].jump.b0+" "+distanceTree[a].jump.b1);
                	*/
            	}
            }
            //document.write('<BR>tree created');
    
            //read in literal and distance code lengths
            n = literalCodes + distCodes;
            i = 0;
            var z=-1;
            if (debug)
            	document.write("<br>n="+n+" bits: "+bits+"<br>");
            while(i < n) {
                z++;
                j = DecodeValue(distanceTree);
                if (debug)
                	document.write("<br>"+z+" i:"+i+" decode: "+j+"    bits "+bits+"<br>");
                if(j<16) {    // length of code in bits (0..15)
                       ll[i++] = j;
                } else if(j==16) {    // repeat last length 3 to 6 times 
                       var l;
                    j = 3 + readBits(2);
                    if(i+j > n) {
                        flushBuffer();
                        return 1;
                    }
                    l = i ? ll[i-1] : 0;
                    while(j--) {
                        ll[i++] = l;
                    }
                } else {
                    if(j==17) {        // 3 to 10 zero length codes
                        j = 3 + readBits(3);
                    } else {        // j == 18: 11 to 138 zero length codes 
                        j = 11 + readBits(7);
                    }
                    if(i+j > n) {
                        flushBuffer();
                        return 1;
                    }
                    while(j--) {
                        ll[i++] = 0;
                    }
                }
            }
            /*for(j=0; j<literalCodes+distCodes; j++) {
                //fprintf(errfp, "%d ", ll[j]);
                if ((j&7)==7)
                    fprintf(errfp, "\n");
            }
            fprintf(errfp, "\n");*/
            // Can overwrite tree decode tree as it is not used anymore
            len = literalTree.length;
            for (i=0; i<len; i++)
                literalTree[i]=new HufNode();
            if(CreateTree(literalTree, literalCodes, ll, 0)) {
                flushBuffer();
                return 1;
            }
            len = literalTree.length;
            for (i=0; i<len; i++)
                distanceTree[i]=new HufNode();
            var ll2 = new Array();
            for (i=literalCodes; i <ll.length; i++){
                ll2[i-literalCodes]=ll[i];
            }    
            if(CreateTree(distanceTree, distCodes, ll2, 0)) {
                flushBuffer();
                return 1;
            }
            if (debug)
           		document.write("<br>literalTree");
            while(1) {
                j = DecodeValue(literalTree);
                if(j >= 256) {        // In C64: if carry set
                    var len, dist;
                    j -= 256;
                    if(j == 0) {
                        // EOF
                        break;
                    }
                    j--;
                    len = readBits(cplext[j]) + cplens[j];
    
                    j = DecodeValue(distanceTree);
                    if(cpdext[j] > 8) {
                        dist = readBits(8);
                        dist |= (readBits(cpdext[j]-8)<<8);
                    } else {
                        dist = readBits(cpdext[j]);
                    }
                    dist += cpdist[j];
                    while(len--) {
                        var c = buf32k[(bIdx - dist) & 0x7fff];
                        addBuffer(c);
                    }
                } else {
                    addBuffer(j);
                }
            }
        }
    } while(!last);
    flushBuffer();

    byteAlign();
    return 0;
};

JXG.Util.Unzip.prototype.unzipFile = function(name) {
    var i;
	this.unzip();
	//alert(unzipped[0][1]);
	for (i=0;i<unzipped.length;i++){
		if(unzipped[i][1]==name) {
			return unzipped[i][0];
		}
	}
	
  };
    
    
JXG.Util.Unzip.prototype.unzip = function() {
	//convertToByteArray(input);
	if (debug)
		alert(bA);
	/*for (i=0;i<bA.length*8;i++){
		document.write(readBit());
		if ((i+1)%8==0)
			document.write(" ");
	}*/
	/*for (i=0;i<bA.length;i++){
		document.write(readByte()+" ");
		if ((i+1)%8==0)
			document.write(" ");
	}
	for (i=0;i<bA.length;i++){
		document.write(bA[i]+" ");
		if ((i+1)%16==0)
			document.write("<br>");
	}	
	*/
	//alert(bA);
	nextFile();
	return unzipped;
  };
    
 function nextFile(){
 	if (debug)
 		alert("NEXTFILE");
 	outputArr = [];
 	var tmp = [];
 	modeZIP = false;
	tmp[0] = readByte();
	tmp[1] = readByte();
	if (debug)
		alert("type: "+tmp[0]+" "+tmp[1]);
	if (tmp[0] == parseInt("78",16) && tmp[1] == parseInt("da",16)){ //GZIP
		if (debug)
			alert("GEONExT-GZIP");
		DeflateLoop();
		if (debug)
			alert(outputArr.join(''));
		unzipped[files] = new Array(2);
    	unzipped[files][0] = outputArr.join('');
    	unzipped[files][1] = "geonext.gxt";
    	files++;
	}
	if (tmp[0] == parseInt("1f",16) && tmp[1] == parseInt("8b",16)){ //GZIP
		if (debug)
			alert("GZIP");
		//DeflateLoop();
		skipdir();
		if (debug)
			alert(outputArr.join(''));
		unzipped[files] = new Array(2);
    	unzipped[files][0] = outputArr.join('');
    	unzipped[files][1] = "file";
    	files++;
	}
	if (tmp[0] == parseInt("50",16) && tmp[1] == parseInt("4b",16)){ //ZIP
		modeZIP = true;
		tmp[2] = readByte();
		tmp[3] = readByte();
		if (tmp[2] == parseInt("3",16) && tmp[3] == parseInt("4",16)){
			//MODE_ZIP
			tmp[0] = readByte();
			tmp[1] = readByte();
			if (debug)
				alert("ZIP-Version: "+tmp[1]+" "+tmp[0]/10+"."+tmp[0]%10);
			
			gpflags = readByte();
			gpflags |= (readByte()<<8);
			if (debug)
				alert("gpflags: "+gpflags);
			
			var method = readByte();
			method |= (readByte()<<8);
			if (debug)
				alert("method: "+method);
			
			readByte();
			readByte();
			readByte();
			readByte();
			
			var crc = readByte();
			crc |= (readByte()<<8);
			crc |= (readByte()<<16);
			crc |= (readByte()<<24);
			
			var compSize = readByte();
			compSize |= (readByte()<<8);
			compSize |= (readByte()<<16);
			compSize |= (readByte()<<24);
			
			var size = readByte();
			size |= (readByte()<<8);
			size |= (readByte()<<16);
			size |= (readByte()<<24);
			
			if (debug)
				alert("local CRC: "+crc+"\nlocal Size: "+size+"\nlocal CompSize: "+compSize);
			
			var filelen = readByte();
			filelen |= (readByte()<<8);
			
			var extralen = readByte();
			extralen |= (readByte()<<8);
			
			if (debug)
				alert("filelen "+filelen);
			i = 0;
			nameBuf = [];
			while (filelen--){ 
				var c = readByte();
				if (c == "/" | c ==":"){
					i = 0;
				} else if (i < NAMEMAX-1)
					nameBuf[i++] = String.fromCharCode(c);
			}
			if (debug)
				alert("nameBuf: "+nameBuf);
			
			//nameBuf[i] = "\0";
			if (!fileout)
				fileout = nameBuf;
			
			var i = 0;
			while (i < extralen){
				c = readByte();
				i++;
			}
				
			CRC = 0xffffffff;
			SIZE = 0;
			
			if (size = 0 && fileOut.charAt(fileout.length-1)=="/"){
				//skipdir
				if (debug)
					alert("skipdir");
			}
			if (method == 8){
				DeflateLoop();
				if (debug)
					alert(outputArr.join(''));
				unzipped[files] = new Array(2);
				unzipped[files][0] = outputArr.join('');
    			unzipped[files][1] = nameBuf.join('');
    			files++;
				//return outputArr.join('');
			}
			skipdir();
		}
	}
 };
	
function skipdir(){
    var crc, 
        tmp = [],
        compSize, size, os, i, c;
    
	if ((gpflags & 8)) {
		tmp[0] = readByte();
		tmp[1] = readByte();
		tmp[2] = readByte();
		tmp[3] = readByte();
		
		if (tmp[0] == parseInt("50",16) && 
            tmp[1] == parseInt("4b",16) && 
            tmp[2] == parseInt("07",16) && 
            tmp[3] == parseInt("08",16))
        {
            crc = readByte();
            crc |= (readByte()<<8);
            crc |= (readByte()<<16);
            crc |= (readByte()<<24);
		} else {
			crc = tmp[0] | (tmp[1]<<8) | (tmp[2]<<16) | (tmp[3]<<24);
		}
		
		compSize = readByte();
		compSize |= (readByte()<<8);
		compSize |= (readByte()<<16);
		compSize |= (readByte()<<24);
		
		size = readByte();
		size |= (readByte()<<8);
		size |= (readByte()<<16);
		size |= (readByte()<<24);
		
		if (debug)
			alert("CRC:");
	}

	if (modeZIP)
		nextFile();
	
	tmp[0] = readByte();
	if (tmp[0] != 8) {
		if (debug)
			alert("Unknown compression method!");
        return 0;	
	}
	
	gpflags = readByte();
	if (debug){
		if ((gpflags & ~(parseInt("1f",16))))
			alert("Unknown flags set!");
	}
	
	readByte();
	readByte();
	readByte();
	readByte();
	
	readByte();
	os = readByte();
	
	if ((gpflags & 4)){
		tmp[0] = readByte();
		tmp[2] = readByte();
		len = tmp[0] + 256*tmp[1];
		if (debug)
			alert("Extra field size: "+len);
		for (i=0;i<len;i++)
			readByte();
	}
	
	if ((gpflags & 8)){
		i=0;
		nameBuf=[];
		while (c=readByte()){
			if(c == "7" || c == ":")
				i=0;
			if (i<NAMEMAX-1)
				nameBuf[i++] = c;
		}
		//nameBuf[i] = "\0";
		if (debug)
			alert("original file name: "+nameBuf);
	}
		
	if ((gpflags & 16)){
		while (c=readByte()){
			//FILE COMMENT
		}
	}
	
	if ((gpflags & 2)){
		readByte();
		readByte();
	}
	
	DeflateLoop();
	
	crc = readByte();
	crc |= (readByte()<<8);
	crc |= (readByte()<<16);
	crc |= (readByte()<<24);
	
	size = readByte();
	size |= (readByte()<<8);
	size |= (readByte()<<16);
	size |= (readByte()<<24);
	
	if (modeZIP)
		nextFile();
	
};

};

/**
*  Base64 encoding / decoding
*  @see <a href="http://www.webtoolkit.info/">http://www.webtoolkit.info/</A>
*/
JXG.Util.Base64 = {

    // private property
    _keyStr : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",

    // public method for encoding
    encode : function (input) {
        var output = [],
            chr1, chr2, chr3, enc1, enc2, enc3, enc4,
            i = 0;

        input = JXG.Util.Base64._utf8_encode(input);

        while (i < input.length) {

            chr1 = input.charCodeAt(i++);
            chr2 = input.charCodeAt(i++);
            chr3 = input.charCodeAt(i++);

            enc1 = chr1 >> 2;
            enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
            enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
            enc4 = chr3 & 63;

            if (isNaN(chr2)) {
                enc3 = enc4 = 64;
            } else if (isNaN(chr3)) {
                enc4 = 64;
            }

            output.push([this._keyStr.charAt(enc1),
                         this._keyStr.charAt(enc2),
                         this._keyStr.charAt(enc3),
                         this._keyStr.charAt(enc4)].join(''));
        }

        return output.join('');
    },

    // public method for decoding
    decode : function (input, utf8) {
        var output = [],
            chr1, chr2, chr3,
            enc1, enc2, enc3, enc4,
            i = 0;

        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

        while (i < input.length) {

            enc1 = this._keyStr.indexOf(input.charAt(i++));
            enc2 = this._keyStr.indexOf(input.charAt(i++));
            enc3 = this._keyStr.indexOf(input.charAt(i++));
            enc4 = this._keyStr.indexOf(input.charAt(i++));

            chr1 = (enc1 << 2) | (enc2 >> 4);
            chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
            chr3 = ((enc3 & 3) << 6) | enc4;

            output.push(String.fromCharCode(chr1));

            if (enc3 != 64) {
                output.push(String.fromCharCode(chr2));
            }
            if (enc4 != 64) {
                output.push(String.fromCharCode(chr3));
            }
        }
        
        output = output.join(''); 
        
        if (utf8) {
            output = JXG.Util.Base64._utf8_decode(output);
        }
        return output;

    },

    // private method for UTF-8 encoding
    _utf8_encode : function (string) {
        string = string.replace(/\r\n/g,"\n");
        var utftext = "";

        for (var n = 0; n < string.length; n++) {

            var c = string.charCodeAt(n);

            if (c < 128) {
                utftext += String.fromCharCode(c);
            }
            else if((c > 127) && (c < 2048)) {
                utftext += String.fromCharCode((c >> 6) | 192);
                utftext += String.fromCharCode((c & 63) | 128);
            }
            else {
                utftext += String.fromCharCode((c >> 12) | 224);
                utftext += String.fromCharCode(((c >> 6) & 63) | 128);
                utftext += String.fromCharCode((c & 63) | 128);
            }

        }

        return utftext;
    },

    // private method for UTF-8 decoding
    _utf8_decode : function (utftext) {
        var string = [],
            i = 0,
            c = 0, c2 = 0, c3 = 0;

        while ( i < utftext.length ) {
            c = utftext.charCodeAt(i);
            if (c < 128) {
                string.push(String.fromCharCode(c));
                i++;
            }
            else if((c > 191) && (c < 224)) {
                c2 = utftext.charCodeAt(i+1);
                string.push(String.fromCharCode(((c & 31) << 6) | (c2 & 63)));
                i += 2;
            }
            else {
                c2 = utftext.charCodeAt(i+1);
                c3 = utftext.charCodeAt(i+2);
                string.push(String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63)));
                i += 3;
            }
        }
        return string.join('');
    },
    
    _destrip: function (stripped, wrap){
        var lines = [], lineno, i,
            destripped = [];
        
        if (wrap==null) 
            wrap = 76;
            
        stripped.replace(/ /g, "");
        lineno = stripped.length / wrap;
        for (i = 0; i < lineno; i++)
            lines[i]=stripped.substr(i * wrap, wrap);
        if (lineno != stripped.length / wrap)
            lines[lines.length]=stripped.substr(lineno * wrap, stripped.length-(lineno * wrap));
            
        for (i = 0; i < lines.length; i++)
            destripped.push(lines[i]);
        return destripped.join('\n');
    },
    
    decodeAsArray: function (input){
        var dec = this.decode(input),
            ar = [], i;
        for (i=0;i<dec.length;i++){
            ar[i]=dec.charCodeAt(i);
        }
        return ar;
    },
    
    decodeGEONExT : function (input) {
        return decodeAsArray(destrip(input),false);
    }
};

/**
 * @private
 */
JXG.Util.asciiCharCodeAt = function(str,i){
	var c = str.charCodeAt(i);
	if (c>255){
    	switch (c) {
			case 8364: c=128;
	    	break;
	    	case 8218: c=130;
	    	break;
	    	case 402: c=131;
	    	break;
	    	case 8222: c=132;
	    	break;
	    	case 8230: c=133;
	    	break;
	    	case 8224: c=134;
	    	break;
	    	case 8225: c=135;
	    	break;
	    	case 710: c=136;
	    	break;
	    	case 8240: c=137;
	    	break;
	    	case 352: c=138;
	    	break;
	    	case 8249: c=139;
	    	break;
	    	case 338: c=140;
	    	break;
	    	case 381: c=142;
	    	break;
	    	case 8216: c=145;
	    	break;
	    	case 8217: c=146;
	    	break;
	    	case 8220: c=147;
	    	break;
	    	case 8221: c=148;
	    	break;
	    	case 8226: c=149;
	    	break;
	    	case 8211: c=150;
	    	break;
	    	case 8212: c=151;
	    	break;
	    	case 732: c=152;
	    	break;
	    	case 8482: c=153;
	    	break;
	    	case 353: c=154;
	    	break;
	    	case 8250: c=155;
	    	break;
	    	case 339: c=156;
	    	break;
	    	case 382: c=158;
	    	break;
	    	case 376: c=159;
	    	break;
	    	default:
	    	break;
	    }
	}
	return c;
};

/**
 * Decoding string into utf-8
 * @param {String} string to decode
 * @return {String} utf8 decoded string
 */
JXG.Util.utf8Decode = function(utftext) {
  var string = [];
  var i = 0;
  var c = 0, c1 = 0, c2 = 0;

  while ( i < utftext.length ) {
    c = utftext.charCodeAt(i);

    if (c < 128) {
      string.push(String.fromCharCode(c));
      i++;
    } else if((c > 191) && (c < 224)) {
      c2 = utftext.charCodeAt(i+1);
      string.push(String.fromCharCode(((c & 31) << 6) | (c2 & 63)));
      i += 2;
    } else {
      c2 = utftext.charCodeAt(i+1);
      c3 = utftext.charCodeAt(i+2);
      string.push(String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63)));
      i += 3;
    }
  };
  return string.join('');
};

// Added to exports for Cocos2d
module.exports = JXG;

}};
__resources__["/__builtin__/libs/Plist.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/**
 * XML Node types
 */
var ELEMENT_NODE                = 1,
    ATTRIBUTE_NODE              = 2,
    TEXT_NODE                   = 3,
    CDATA_SECTION_NODE          = 4,
    ENTITY_REFERENCE_NODE       = 5,
    ENTITY_NODE                 = 6,
    PROCESSING_INSTRUCTION_NODE = 7,
    COMMENT_NODE                = 8,
    DOCUMENT_NODE               = 9,
    DOCUMENT_TYPE_NODE          = 10,
    DOCUMENT_FRAGMENT_NODE      = 11,
    NOTATION_NODE               = 12;


var Plist = BObject.extend (/** @lends Plist# */{
    /**
     * The unserialized data inside the Plist file
     * @type Object
     */
    data: null,

    /**
     * An object representation of an XML Property List file
     *
     * @constructs
     * @extends BObject
     * @param {Options} opts Options
     * @config {String} [file] The path to a .plist file
     * @config {String} [data] The contents of a .plist file
     */
    init: function(opts) {
        var file = opts['file'],
            data = opts['data'];

        if (file && !data) {
            data = resource(file);
        }


        var parser = new DOMParser(),
            doc = parser.parseFromString(data, 'text/xml'),
            plist = doc.documentElement;

        if (plist.tagName != 'plist') {
            throw "Not a plist file";
        }


        // Get first real node
        var node = null;
        for (var i = 0, len = plist.childNodes.length; i < len; i++) {
            node = plist.childNodes[i];
            if (node.nodeType == ELEMENT_NODE) {
                break;
            }
        }

        this.set('data', this.parseNode_(node));
    },


    /**
     * @private
     * Parses an XML node inside the Plist file
     * @returns {Object/Array/String/Integer/Float} A JS representation of the node value
     */
    parseNode_: function(node) {
        var data = null;
        switch(node.tagName) {
        case 'dict':
            data = this.parseDict_(node); 
            break;
        case 'array':
            data = this.parseArray_(node); 
            break;
        case 'string':
            // FIXME - This needs to handle Firefox's 4KB nodeValue limit
            data = node.firstChild.nodeValue;
            break
        case 'false':
            data = false;
            break
        case 'true':
            data = true;
            break
        case 'real':
            data = parseFloat(node.firstChild.nodeValue);
            break
        case 'integer':
            data = parseInt(node.firstChild.nodeValue, 10);
            break
        }

        return data;
    },

    /**
     * @private
     * Parses a <dict> node in a plist file
     *
     * @param {XMLElement}
     * @returns {Object} A simple key/value JS Object representing the <dict>
     */
    parseDict_: function(node) {
        var data = {};

        var key = null;
        for (var i = 0, len = node.childNodes.length; i < len; i++) {
            var child = node.childNodes[i];
            if (child.nodeType != ELEMENT_NODE) {
                continue;
            }

            // Grab the key, next noe should be the value
            if (child.tagName == 'key') {
                key = child.firstChild.nodeValue;
            } else {
                // Parse the value node
                data[key] = this.parseNode_(child);
            }
        }


        return data;
    },

    /**
     * @private
     * Parses an <array> node in a plist file
     *
     * @param {XMLElement}
     * @returns {Array} A simple JS Array representing the <array>
     */
    parseArray_: function(node) {
        var data = [];

        for (var i = 0, len = node.childNodes.length; i < len; i++) {
            var child = node.childNodes[i];
            if (child.nodeType != ELEMENT_NODE) {
                continue;
            }

            data.push(this.parseNode_(child));
        }

        return data;
    }
});


exports.Plist = Plist;

}};
__resources__["/__builtin__/libs/qunit.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*
 * QUnit - A JavaScript Unit Testing Framework
 * 
 * http://docs.jquery.com/QUnit
 *
 * Copyright (c) 2011 John Resig, Jrn Zaefferer
 * Dual licensed under the MIT (MIT-LICENSE.txt)
 * or GPL (GPL-LICENSE.txt) licenses.
 */

(function(window) {

var defined = {
	setTimeout: typeof window.setTimeout !== "undefined",
	sessionStorage: (function() {
		try {
			return !!sessionStorage.getItem;
		} catch(e){
			return false;
		}
  })()
}

var testId = 0;

var Test = function(name, testName, expected, testEnvironmentArg, async, callback) {
	this.name = name;
	this.testName = testName;
	this.expected = expected;
	this.testEnvironmentArg = testEnvironmentArg;
	this.async = async;
	this.callback = callback;
	this.assertions = [];
};
Test.prototype = {
	init: function() {
		var tests = id("qunit-tests");
		if (tests) {
			var b = document.createElement("strong");
				b.innerHTML = "Running " + this.name;
			var li = document.createElement("li");
				li.appendChild( b );
				li.id = this.id = "test-output" + testId++;
			tests.appendChild( li );
		}
	},
	setup: function() {
		if (this.module != config.previousModule) {
			if ( config.previousModule ) {
				QUnit.moduleDone( {
					name: config.previousModule,
					failed: config.moduleStats.bad,
					passed: config.moduleStats.all - config.moduleStats.bad,
					total: config.moduleStats.all
				} );
			}
			config.previousModule = this.module;
			config.moduleStats = { all: 0, bad: 0 };
			QUnit.moduleStart( {
				name: this.module
			} );
		}

		config.current = this;
		this.testEnvironment = extend({
			setup: function() {},
			teardown: function() {}
		}, this.moduleTestEnvironment);
		if (this.testEnvironmentArg) {
			extend(this.testEnvironment, this.testEnvironmentArg);
		}

		QUnit.testStart( {
			name: this.testName
		} );

		// allow utility functions to access the current test environment
		// TODO why??
		QUnit.current_testEnvironment = this.testEnvironment;
		
		try {
			if ( !config.pollution ) {
				saveGlobal();
			}

			this.testEnvironment.setup.call(this.testEnvironment);
		} catch(e) {
			QUnit.ok( false, "Setup failed on " + this.testName + ": " + e.message );
		}
	},
	run: function() {
		if ( this.async ) {
			QUnit.stop();
		}

		if ( config.notrycatch ) {
			this.callback.call(this.testEnvironment);
			return;
		}
		try {
			this.callback.call(this.testEnvironment);
		} catch(e) {
			fail("Test " + this.testName + " died, exception and test follows", e, this.callback);
			QUnit.ok( false, "Died on test #" + (this.assertions.length + 1) + ": " + e.message + " - " + QUnit.jsDump.parse(e) );
			// else next test will carry the responsibility
			saveGlobal();

			// Restart the tests if they're blocking
			if ( config.blocking ) {
				start();
			}
		}
	},
	teardown: function() {
		try {
			checkPollution();
			this.testEnvironment.teardown.call(this.testEnvironment);
		} catch(e) {
			QUnit.ok( false, "Teardown failed on " + this.testName + ": " + e.message );
		}
	},
	finish: function() {
		if ( this.expected && this.expected != this.assertions.length ) {
			QUnit.ok( false, "Expected " + this.expected + " assertions, but " + this.assertions.length + " were run" );
		}
		
		var good = 0, bad = 0,
			tests = id("qunit-tests");

		config.stats.all += this.assertions.length;
		config.moduleStats.all += this.assertions.length;

		if ( tests ) {
			var ol  = document.createElement("ol");

			for ( var i = 0; i < this.assertions.length; i++ ) {
				var assertion = this.assertions[i];

				var li = document.createElement("li");
				li.className = assertion.result ? "pass" : "fail";
				li.innerHTML = assertion.message || (assertion.result ? "okay" : "failed");
				ol.appendChild( li );

				if ( assertion.result ) {
					good++;
				} else {
					bad++;
					config.stats.bad++;
					config.moduleStats.bad++;
				}
			}

			// store result when possible
			defined.sessionStorage && sessionStorage.setItem("qunit-" + this.testName, bad);

			if (bad == 0) {
				ol.style.display = "none";
			}

			var b = document.createElement("strong");
			b.innerHTML = this.name + " <b class='counts'>(<b class='failed'>" + bad + "</b>, <b class='passed'>" + good + "</b>, " + this.assertions.length + ")</b>";
			
			addEvent(b, "click", function() {
				var next = b.nextSibling, display = next.style.display;
				next.style.display = display === "none" ? "block" : "none";
			});
			
			addEvent(b, "dblclick", function(e) {
				var target = e && e.target ? e.target : window.event.srcElement;
				if ( target.nodeName.toLowerCase() == "span" || target.nodeName.toLowerCase() == "b" ) {
					target = target.parentNode;
				}
				if ( window.location && target.nodeName.toLowerCase() === "strong" ) {
					window.location.search = "?" + encodeURIComponent(getText([target]).replace(/\(.+\)$/, "").replace(/(^\s*|\s*$)/g, ""));
				}
			});

			var li = id(this.id);
			li.className = bad ? "fail" : "pass";
			li.style.display = resultDisplayStyle(!bad);
			li.removeChild( li.firstChild );
			li.appendChild( b );
			li.appendChild( ol );

		} else {
			for ( var i = 0; i < this.assertions.length; i++ ) {
				if ( !this.assertions[i].result ) {
					bad++;
					config.stats.bad++;
					config.moduleStats.bad++;
				}
			}
		}

		try {
			QUnit.reset();
		} catch(e) {
			fail("reset() failed, following Test " + this.testName + ", exception and reset fn follows", e, QUnit.reset);
		}

		QUnit.testDone( {
			name: this.testName,
			failed: bad,
			passed: this.assertions.length - bad,
			total: this.assertions.length
		} );
	},
	
	queue: function() {
		var test = this;
		synchronize(function() {
			test.init();
		});
		function run() {
			// each of these can by async
			synchronize(function() {
				test.setup();
			});
			synchronize(function() {
				test.run();
			});
			synchronize(function() {
				test.teardown();
			});
			synchronize(function() {
				test.finish();
			});
		}
		// defer when previous test run passed, if storage is available
		var bad = defined.sessionStorage && +sessionStorage.getItem("qunit-" + this.testName);
		if (bad) {
			run();
		} else {
			synchronize(run);
		};
	}
	
}

var QUnit = {

	// call on start of module test to prepend name to all tests
	module: function(name, testEnvironment) {
		config.currentModule = name;
		config.currentModuleTestEnviroment = testEnvironment;
	},

	asyncTest: function(testName, expected, callback) {
		if ( arguments.length === 2 ) {
			callback = expected;
			expected = 0;
		}

		QUnit.test(testName, expected, callback, true);
	},
	
	test: function(testName, expected, callback, async) {
		var name = '<span class="test-name">' + testName + '</span>', testEnvironmentArg;

		if ( arguments.length === 2 ) {
			callback = expected;
			expected = null;
		}
		// is 2nd argument a testEnvironment?
		if ( expected && typeof expected === 'object') {
			testEnvironmentArg =  expected;
			expected = null;
		}

		if ( config.currentModule ) {
			name = '<span class="module-name">' + config.currentModule + "</span>: " + name;
		}

		if ( !validTest(config.currentModule + ": " + testName) ) {
			return;
		}
		
		var test = new Test(name, testName, expected, testEnvironmentArg, async, callback);
		test.module = config.currentModule;
		test.moduleTestEnvironment = config.currentModuleTestEnviroment;
		test.queue();
	},
	
	/**
	 * Specify the number of expected assertions to gurantee that failed test (no assertions are run at all) don't slip through.
	 */
	expect: function(asserts) {
		config.current.expected = asserts;
	},

	/**
	 * Asserts true.
	 * @example ok( "asdfasdf".length > 5, "There must be at least 5 chars" );
	 */
	ok: function(a, msg) {
		a = !!a;
		var details = {
			result: a,
			message: msg
		};
		msg = escapeHtml(msg);
		QUnit.log(details);
		config.current.assertions.push({
			result: a,
			message: msg
		});
	},

	/**
	 * Checks that the first two arguments are equal, with an optional message.
	 * Prints out both actual and expected values.
	 *
	 * Prefered to ok( actual == expected, message )
	 *
	 * @example equal( format("Received {0} bytes.", 2), "Received 2 bytes." );
	 *
	 * @param Object actual
	 * @param Object expected
	 * @param String message (optional)
	 */
	equal: function(actual, expected, message) {
		QUnit.push(expected == actual, actual, expected, message);
	},

	notEqual: function(actual, expected, message) {
		QUnit.push(expected != actual, actual, expected, message);
	},
	
	deepEqual: function(actual, expected, message) {
		QUnit.push(QUnit.equiv(actual, expected), actual, expected, message);
	},

	notDeepEqual: function(actual, expected, message) {
		QUnit.push(!QUnit.equiv(actual, expected), actual, expected, message);
	},

	strictEqual: function(actual, expected, message) {
		QUnit.push(expected === actual, actual, expected, message);
	},

	notStrictEqual: function(actual, expected, message) {
		QUnit.push(expected !== actual, actual, expected, message);
	},

	raises: function(block, expected, message) {
		var actual, ok = false;
	
		if (typeof expected === 'string') {
			message = expected;
			expected = null;
		}
	
		try {
			block();
		} catch (e) {
			actual = e;
		}
	
		if (actual) {
			// we don't want to validate thrown error
			if (!expected) {
				ok = true;
			// expected is a regexp	
			} else if (QUnit.objectType(expected) === "regexp") {
				ok = expected.test(actual);
			// expected is a constructor	
			} else if (actual instanceof expected) {
				ok = true;
			// expected is a validation function which returns true is validation passed	
			} else if (expected.call({}, actual) === true) {
				ok = true;
			}
		}
			
		QUnit.ok(ok, message);
	},

	start: function() {
		config.semaphore--;
		if (config.semaphore > 0) {
			// don't start until equal number of stop-calls
			return;
		}
		if (config.semaphore < 0) {
			// ignore if start is called more often then stop
			config.semaphore = 0;
		}
		// A slight delay, to avoid any current callbacks
		if ( defined.setTimeout ) {
			window.setTimeout(function() {
				if ( config.timeout ) {
					clearTimeout(config.timeout);
				}

				config.blocking = false;
				process();
			}, 13);
		} else {
			config.blocking = false;
			process();
		}
	},
	
	stop: function(timeout) {
		config.semaphore++;
		config.blocking = true;

		if ( timeout && defined.setTimeout ) {
			clearTimeout(config.timeout);
			config.timeout = window.setTimeout(function() {
				QUnit.ok( false, "Test timed out" );
				QUnit.start();
			}, timeout);
		}
	}

};

// Backwards compatibility, deprecated
QUnit.equals = QUnit.equal;
QUnit.same = QUnit.deepEqual;

// Maintain internal state
var config = {
	// The queue of tests to run
	queue: [],

	// block until document ready
	blocking: true
};

// Load paramaters
(function() {
	var location = window.location || { search: "", protocol: "file:" },
		GETParams = location.search.slice(1).split('&');

	for ( var i = 0; i < GETParams.length; i++ ) {
		GETParams[i] = decodeURIComponent( GETParams[i] );
		if ( GETParams[i] === "noglobals" ) {
			GETParams.splice( i, 1 );
			i--;
			config.noglobals = true;
		} else if ( GETParams[i] === "notrycatch" ) {
			GETParams.splice( i, 1 );
			i--;
			config.notrycatch = true;
		} else if ( GETParams[i].search('=') > -1 ) {
			GETParams.splice( i, 1 );
			i--;
		}
	}
	
	// restrict modules/tests by get parameters
	config.filters = GETParams;
	
	// Figure out if we're running the tests from a server or not
	QUnit.isLocal = !!(location.protocol === 'file:');
})();

// Expose the API as global variables, unless an 'exports'
// object exists, in that case we assume we're in CommonJS
if ( typeof exports === "undefined" || typeof require === "undefined" ) {
	extend(window, QUnit);
	window.QUnit = QUnit;
} else {
	extend(exports, QUnit);
	exports.QUnit = QUnit;
}

// define these after exposing globals to keep them in these QUnit namespace only
extend(QUnit, {
	config: config,

	// Initialize the configuration options
	init: function() {
		extend(config, {
			stats: { all: 0, bad: 0 },
			moduleStats: { all: 0, bad: 0 },
			started: +new Date,
			updateRate: 1000,
			blocking: false,
			autostart: true,
			autorun: false,
			filters: [],
			queue: [],
			semaphore: 0
		});

		var tests = id("qunit-tests"),
			banner = id("qunit-banner"),
			result = id("qunit-testresult");

		if ( tests ) {
			tests.innerHTML = "";
		}

		if ( banner ) {
			banner.className = "";
		}

		if ( result ) {
			result.parentNode.removeChild( result );
		}
	},
	
	/**
	 * Resets the test setup. Useful for tests that modify the DOM.
	 * 
	 * If jQuery is available, uses jQuery's html(), otherwise just innerHTML.
	 */
	reset: function() {
		if ( window.jQuery ) {
			jQuery( "#main, #qunit-fixture" ).html( config.fixture );
		} else {
			var main = id( 'main' ) || id( 'qunit-fixture' );
			if ( main ) {
				main.innerHTML = config.fixture;
			}
		}
	},
	
	/**
	 * Trigger an event on an element.
	 *
	 * @example triggerEvent( document.body, "click" );
	 *
	 * @param DOMElement elem
	 * @param String type
	 */
	triggerEvent: function( elem, type, event ) {
		if ( document.createEvent ) {
			event = document.createEvent("MouseEvents");
			event.initMouseEvent(type, true, true, elem.ownerDocument.defaultView,
				0, 0, 0, 0, 0, false, false, false, false, 0, null);
			elem.dispatchEvent( event );

		} else if ( elem.fireEvent ) {
			elem.fireEvent("on"+type);
		}
	},
	
	// Safe object type checking
	is: function( type, obj ) {
		return QUnit.objectType( obj ) == type;
	},
	
	objectType: function( obj ) {
		if (typeof obj === "undefined") {
				return "undefined";

		// consider: typeof null === object
		}
		if (obj === null) {
				return "null";
		}

		var type = Object.prototype.toString.call( obj )
			.match(/^\[object\s(.*)\]$/)[1] || '';

		switch (type) {
				case 'Number':
						if (isNaN(obj)) {
								return "nan";
						} else {
								return "number";
						}
				case 'String':
				case 'Boolean':
				case 'Array':
				case 'Date':
				case 'RegExp':
				case 'Function':
						return type.toLowerCase();
		}
		if (typeof obj === "object") {
				return "object";
		}
		return undefined;
	},
	
	push: function(result, actual, expected, message) {
		var details = {
			result: result,
			message: message,
			actual: actual,
			expected: expected
		};
		
		message = escapeHtml(message) || (result ? "okay" : "failed");
		message = '<span class="test-message">' + message + "</span>";
		expected = escapeHtml(QUnit.jsDump.parse(expected));
		actual = escapeHtml(QUnit.jsDump.parse(actual));
		var output = message + '<table><tr class="test-expected"><th>Expected: </th><td><pre>' + expected + '</pre></td></tr>';
		if (actual != expected) {
			output += '<tr class="test-actual"><th>Result: </th><td><pre>' + actual + '</pre></td></tr>';
			output += '<tr class="test-diff"><th>Diff: </th><td><pre>' + QUnit.diff(expected, actual) +'</pre></td></tr>';
		}
		if (!result) {
			var source = sourceFromStacktrace();
			if (source) {
				details.source = source;
				output += '<tr class="test-source"><th>Source: </th><td><pre>' + source +'</pre></td></tr>';
			}
		}
		output += "</table>";
		
		QUnit.log(details);
		
		config.current.assertions.push({
			result: !!result,
			message: output
		});
	},
	
	// Logging callbacks; all receive a single argument with the listed properties
	// run test/logs.html for any related changes
	begin: function() {},
	// done: { failed, passed, total, runtime }
	done: function() {},
	// log: { result, actual, expected, message }
	log: function() {},
	// testStart: { name }
	testStart: function() {},
	// testDone: { name, failed, passed, total }
	testDone: function() {},
	// moduleStart: { name }
	moduleStart: function() {},
	// moduleDone: { name, failed, passed, total }
	moduleDone: function() {}
});

if ( typeof document === "undefined" || document.readyState === "complete" ) {
	config.autorun = true;
}

addEvent(window, "load", function() {
	QUnit.begin({});
	
	// Initialize the config, saving the execution queue
	var oldconfig = extend({}, config);
	QUnit.init();
	extend(config, oldconfig);

	config.blocking = false;

	var userAgent = id("qunit-userAgent");
	if ( userAgent ) {
		userAgent.innerHTML = navigator.userAgent;
	}
	var banner = id("qunit-header");
	if ( banner ) {
		var paramsIndex = location.href.lastIndexOf(location.search);
		if ( paramsIndex > -1 ) {
			var mainPageLocation = location.href.slice(0, paramsIndex);
			if ( mainPageLocation == location.href ) {
				banner.innerHTML = '<a href=""> ' + banner.innerHTML + '</a> ';
			} else {
				var testName = decodeURIComponent(location.search.slice(1));
				banner.innerHTML = '<a href="' + mainPageLocation + '">' + banner.innerHTML + '</a> &#8250; <a href="">' + testName + '</a>';
			}
		}
	}
	
	var toolbar = id("qunit-testrunner-toolbar");
	if ( toolbar ) {
		var filter = document.createElement("input");
		filter.type = "checkbox";
		filter.id = "qunit-filter-pass";
		addEvent( filter, "click", function() {
			var li = document.getElementsByTagName("li");
			for ( var i = 0; i < li.length; i++ ) {
				if ( li[i].className.indexOf("pass") > -1 ) {
					li[i].style.display = filter.checked ? "none" : "";
				}
			}
			if ( defined.sessionStorage ) {
				sessionStorage.setItem("qunit-filter-passed-tests", filter.checked ? "true" : "");
			}
		});
		if ( defined.sessionStorage && sessionStorage.getItem("qunit-filter-passed-tests") ) {
			filter.checked = true;
		}
		toolbar.appendChild( filter );

		var label = document.createElement("label");
		label.setAttribute("for", "qunit-filter-pass");
		label.innerHTML = "Hide passed tests";
		toolbar.appendChild( label );
	}

	var main = id('main') || id('qunit-fixture');
	if ( main ) {
		config.fixture = main.innerHTML;
	}

	if (config.autostart) {
		QUnit.start();
	}
});

function done() {
	config.autorun = true;

	// Log the last module results
	if ( config.currentModule ) {
		QUnit.moduleDone( {
			name: config.currentModule,
			failed: config.moduleStats.bad,
			passed: config.moduleStats.all - config.moduleStats.bad,
			total: config.moduleStats.all
		} );
	}

	var banner = id("qunit-banner"),
		tests = id("qunit-tests"),
		runtime = +new Date - config.started,
		passed = config.stats.all - config.stats.bad,
		html = [
			'Tests completed in ',
			runtime,
			' milliseconds.<br/>',
			'<span class="passed">',
			passed,
			'</span> tests of <span class="total">',
			config.stats.all,
			'</span> passed, <span class="failed">',
			config.stats.bad,
			'</span> failed.'
		].join('');

	if ( banner ) {
		banner.className = (config.stats.bad ? "qunit-fail" : "qunit-pass");
	}

	if ( tests ) {	
		var result = id("qunit-testresult");

		if ( !result ) {
			result = document.createElement("p");
			result.id = "qunit-testresult";
			result.className = "result";
			tests.parentNode.insertBefore( result, tests.nextSibling );
		}

		result.innerHTML = html;
	}

	QUnit.done( {
		failed: config.stats.bad,
		passed: passed, 
		total: config.stats.all,
		runtime: runtime
	} );
}

function validTest( name ) {
	var i = config.filters.length,
		run = false;

	if ( !i ) {
		return true;
	}
	
	while ( i-- ) {
		var filter = config.filters[i],
			not = filter.charAt(0) == '!';

		if ( not ) {
			filter = filter.slice(1);
		}

		if ( name.indexOf(filter) !== -1 ) {
			return !not;
		}

		if ( not ) {
			run = true;
		}
	}

	return run;
}

// so far supports only Firefox, Chrome and Opera (buggy)
// could be extended in the future to use something like https://github.com/csnover/TraceKit
function sourceFromStacktrace() {
	try {
		throw new Error();
	} catch ( e ) {
		if (e.stacktrace) {
			// Opera
			return e.stacktrace.split("\n")[6];
		} else if (e.stack) {
			// Firefox, Chrome
			return e.stack.split("\n")[4];
		}
	}
}

function resultDisplayStyle(passed) {
	return passed && id("qunit-filter-pass") && id("qunit-filter-pass").checked ? 'none' : '';
}

function escapeHtml(s) {
	if (!s) {
		return "";
	}
	s = s + "";
	return s.replace(/[\&"<>\\]/g, function(s) {
		switch(s) {
			case "&": return "&amp;";
			case "\\": return "\\\\";
			case '"': return '\"';
			case "<": return "&lt;";
			case ">": return "&gt;";
			default: return s;
		}
	});
}

function synchronize( callback ) {
	config.queue.push( callback );

	if ( config.autorun && !config.blocking ) {
		process();
	}
}

function process() {
	var start = (new Date()).getTime();

	while ( config.queue.length && !config.blocking ) {
		if ( config.updateRate <= 0 || (((new Date()).getTime() - start) < config.updateRate) ) {
			config.queue.shift()();
		} else {
			window.setTimeout( process, 13 );
			break;
		}
	}
  if (!config.blocking && !config.queue.length) {
    done();
  }
}

function saveGlobal() {
	config.pollution = [];
	
	if ( config.noglobals ) {
		for ( var key in window ) {
			config.pollution.push( key );
		}
	}
}

function checkPollution( name ) {
	var old = config.pollution;
	saveGlobal();
	
	var newGlobals = diff( old, config.pollution );
	if ( newGlobals.length > 0 ) {
		ok( false, "Introduced global variable(s): " + newGlobals.join(", ") );
		config.current.expected++;
	}

	var deletedGlobals = diff( config.pollution, old );
	if ( deletedGlobals.length > 0 ) {
		ok( false, "Deleted global variable(s): " + deletedGlobals.join(", ") );
		config.current.expected++;
	}
}

// returns a new Array with the elements that are in a but not in b
function diff( a, b ) {
	var result = a.slice();
	for ( var i = 0; i < result.length; i++ ) {
		for ( var j = 0; j < b.length; j++ ) {
			if ( result[i] === b[j] ) {
				result.splice(i, 1);
				i--;
				break;
			}
		}
	}
	return result;
}

function fail(message, exception, callback) {
	if ( typeof console !== "undefined" && console.error && console.warn ) {
		console.error(message);
		console.error(exception);
		console.warn(callback.toString());

	} else if ( window.opera && opera.postError ) {
		opera.postError(message, exception, callback.toString);
	}
}

function extend(a, b) {
	for ( var prop in b ) {
		a[prop] = b[prop];
	}

	return a;
}

function addEvent(elem, type, fn) {
	if ( elem.addEventListener ) {
		elem.addEventListener( type, fn, false );
	} else if ( elem.attachEvent ) {
		elem.attachEvent( "on" + type, fn );
	} else {
		fn();
	}
}

function id(name) {
	return !!(typeof document !== "undefined" && document && document.getElementById) &&
		document.getElementById( name );
}

// Test for equality any JavaScript type.
// Discussions and reference: http://philrathe.com/articles/equiv
// Test suites: http://philrathe.com/tests/equiv
// Author: Philippe Rath <prathe@gmail.com>
QUnit.equiv = function () {

    var innerEquiv; // the real equiv function
    var callers = []; // stack to decide between skip/abort functions
    var parents = []; // stack to avoiding loops from circular referencing

    // Call the o related callback with the given arguments.
    function bindCallbacks(o, callbacks, args) {
        var prop = QUnit.objectType(o);
        if (prop) {
            if (QUnit.objectType(callbacks[prop]) === "function") {
                return callbacks[prop].apply(callbacks, args);
            } else {
                return callbacks[prop]; // or undefined
            }
        }
    }
    
    var callbacks = function () {

        // for string, boolean, number and null
        function useStrictEquality(b, a) {
            if (b instanceof a.constructor || a instanceof b.constructor) {
                // to catch short annotaion VS 'new' annotation of a declaration
                // e.g. var i = 1;
                //      var j = new Number(1);
                return a == b;
            } else {
                return a === b;
            }
        }

        return {
            "string": useStrictEquality,
            "boolean": useStrictEquality,
            "number": useStrictEquality,
            "null": useStrictEquality,
            "undefined": useStrictEquality,

            "nan": function (b) {
                return isNaN(b);
            },

            "date": function (b, a) {
                return QUnit.objectType(b) === "date" && a.valueOf() === b.valueOf();
            },

            "regexp": function (b, a) {
                return QUnit.objectType(b) === "regexp" &&
                    a.source === b.source && // the regex itself
                    a.global === b.global && // and its modifers (gmi) ...
                    a.ignoreCase === b.ignoreCase &&
                    a.multiline === b.multiline;
            },

            // - skip when the property is a method of an instance (OOP)
            // - abort otherwise,
            //   initial === would have catch identical references anyway
            "function": function () {
                var caller = callers[callers.length - 1];
                return caller !== Object &&
                        typeof caller !== "undefined";
            },

            "array": function (b, a) {
                var i, j, loop;
                var len;

                // b could be an object literal here
                if ( ! (QUnit.objectType(b) === "array")) {
                    return false;
                }   
                
                len = a.length;
                if (len !== b.length) { // safe and faster
                    return false;
                }
                
                //track reference to avoid circular references
                parents.push(a);
                for (i = 0; i < len; i++) {
                    loop = false;
                    for(j=0;j<parents.length;j++){
                        if(parents[j] === a[i]){
                            loop = true;//dont rewalk array
                        }
                    }
                    if (!loop && ! innerEquiv(a[i], b[i])) {
                        parents.pop();
                        return false;
                    }
                }
                parents.pop();
                return true;
            },

            "object": function (b, a) {
                var i, j, loop;
                var eq = true; // unless we can proove it
                var aProperties = [], bProperties = []; // collection of strings

                // comparing constructors is more strict than using instanceof
                if ( a.constructor !== b.constructor) {
                    return false;
                }

                // stack constructor before traversing properties
                callers.push(a.constructor);
                //track reference to avoid circular references
                parents.push(a);
                
                for (i in a) { // be strict: don't ensures hasOwnProperty and go deep
                    loop = false;
                    for(j=0;j<parents.length;j++){
                        if(parents[j] === a[i])
                            loop = true; //don't go down the same path twice
                    }
                    aProperties.push(i); // collect a's properties

                    if (!loop && ! innerEquiv(a[i], b[i])) {
                        eq = false;
                        break;
                    }
                }

                callers.pop(); // unstack, we are done
                parents.pop();

                for (i in b) {
                    bProperties.push(i); // collect b's properties
                }

                // Ensures identical properties name
                return eq && innerEquiv(aProperties.sort(), bProperties.sort());
            }
        };
    }();

    innerEquiv = function () { // can take multiple arguments
        var args = Array.prototype.slice.apply(arguments);
        if (args.length < 2) {
            return true; // end transition
        }

        return (function (a, b) {
            if (a === b) {
                return true; // catch the most you can
            } else if (a === null || b === null || typeof a === "undefined" || typeof b === "undefined" || QUnit.objectType(a) !== QUnit.objectType(b)) {
                return false; // don't lose time with error prone cases
            } else {
                return bindCallbacks(a, callbacks, [b, a]);
            }

        // apply transition with (1..n) arguments
        })(args[0], args[1]) && arguments.callee.apply(this, args.splice(1, args.length -1));
    };

    return innerEquiv;

}();

/**
 * jsDump
 * Copyright (c) 2008 Ariel Flesler - aflesler(at)gmail(dot)com | http://flesler.blogspot.com
 * Licensed under BSD (http://www.opensource.org/licenses/bsd-license.php)
 * Date: 5/15/2008
 * @projectDescription Advanced and extensible data dumping for Javascript.
 * @version 1.0.0
 * @author Ariel Flesler
 * @link {http://flesler.blogspot.com/2008/05/jsdump-pretty-dump-of-any-javascript.html}
 */
QUnit.jsDump = (function() {
	function quote( str ) {
		return '"' + str.toString().replace(/"/g, '\\"') + '"';
	};
	function literal( o ) {
		return o + '';	
	};
	function join( pre, arr, post ) {
		var s = jsDump.separator(),
			base = jsDump.indent(),
			inner = jsDump.indent(1);
		if ( arr.join )
			arr = arr.join( ',' + s + inner );
		if ( !arr )
			return pre + post;
		return [ pre, inner + arr, base + post ].join(s);
	};
	function array( arr ) {
		var i = arr.length,	ret = Array(i);					
		this.up();
		while ( i-- )
			ret[i] = this.parse( arr[i] );				
		this.down();
		return join( '[', ret, ']' );
	};
	
	var reName = /^function (\w+)/;
	
	var jsDump = {
		parse:function( obj, type ) { //type is used mostly internally, you can fix a (custom)type in advance
			var	parser = this.parsers[ type || this.typeOf(obj) ];
			type = typeof parser;			
			
			return type == 'function' ? parser.call( this, obj ) :
				   type == 'string' ? parser :
				   this.parsers.error;
		},
		typeOf:function( obj ) {
			var type;
			if ( obj === null ) {
				type = "null";
			} else if (typeof obj === "undefined") {
				type = "undefined";
			} else if (QUnit.is("RegExp", obj)) {
				type = "regexp";
			} else if (QUnit.is("Date", obj)) {
				type = "date";
			} else if (QUnit.is("Function", obj)) {
				type = "function";
			} else if (typeof obj.setInterval !== undefined && typeof obj.document !== "undefined" && typeof obj.nodeType === "undefined") {
				type = "window";
			} else if (obj.nodeType === 9) {
				type = "document";
			} else if (obj.nodeType) {
				type = "node";
			} else if (typeof obj === "object" && typeof obj.length === "number" && obj.length >= 0) {
				type = "array";
			} else {
				type = typeof obj;
			}
			return type;
		},
		separator:function() {
			return this.multiline ?	this.HTML ? '<br />' : '\n' : this.HTML ? '&nbsp;' : ' ';
		},
		indent:function( extra ) {// extra can be a number, shortcut for increasing-calling-decreasing
			if ( !this.multiline )
				return '';
			var chr = this.indentChar;
			if ( this.HTML )
				chr = chr.replace(/\t/g,'   ').replace(/ /g,'&nbsp;');
			return Array( this._depth_ + (extra||0) ).join(chr);
		},
		up:function( a ) {
			this._depth_ += a || 1;
		},
		down:function( a ) {
			this._depth_ -= a || 1;
		},
		setParser:function( name, parser ) {
			this.parsers[name] = parser;
		},
		// The next 3 are exposed so you can use them
		quote:quote, 
		literal:literal,
		join:join,
		//
		_depth_: 1,
		// This is the list of parsers, to modify them, use jsDump.setParser
		parsers:{
			window: '[Window]',
			document: '[Document]',
			error:'[ERROR]', //when no parser is found, shouldn't happen
			unknown: '[Unknown]',
			'null':'null',
			undefined:'undefined',
			'function':function( fn ) {
				var ret = 'function',
					name = 'name' in fn ? fn.name : (reName.exec(fn)||[])[1];//functions never have name in IE
				if ( name )
					ret += ' ' + name;
				ret += '(';
				
				ret = [ ret, QUnit.jsDump.parse( fn, 'functionArgs' ), '){'].join('');
				return join( ret, QUnit.jsDump.parse(fn,'functionCode'), '}' );
			},
			array: array,
			nodelist: array,
			arguments: array,
			object:function( map ) {
				var ret = [ ];
				QUnit.jsDump.up();
				for ( var key in map )
					ret.push( QUnit.jsDump.parse(key,'key') + ': ' + QUnit.jsDump.parse(map[key]) );
				QUnit.jsDump.down();
				return join( '{', ret, '}' );
			},
			node:function( node ) {
				var open = QUnit.jsDump.HTML ? '&lt;' : '<',
					close = QUnit.jsDump.HTML ? '&gt;' : '>';
					
				var tag = node.nodeName.toLowerCase(),
					ret = open + tag;
					
				for ( var a in QUnit.jsDump.DOMAttrs ) {
					var val = node[QUnit.jsDump.DOMAttrs[a]];
					if ( val )
						ret += ' ' + a + '=' + QUnit.jsDump.parse( val, 'attribute' );
				}
				return ret + close + open + '/' + tag + close;
			},
			functionArgs:function( fn ) {//function calls it internally, it's the arguments part of the function
				var l = fn.length;
				if ( !l ) return '';				
				
				var args = Array(l);
				while ( l-- )
					args[l] = String.fromCharCode(97+l);//97 is 'a'
				return ' ' + args.join(', ') + ' ';
			},
			key:quote, //object calls it internally, the key part of an item in a map
			functionCode:'[code]', //function calls it internally, it's the content of the function
			attribute:quote, //node calls it internally, it's an html attribute value
			string:quote,
			date:quote,
			regexp:literal, //regex
			number:literal,
			'boolean':literal
		},
		DOMAttrs:{//attributes to dump from nodes, name=>realName
			id:'id',
			name:'name',
			'class':'className'
		},
		HTML:false,//if true, entities are escaped ( <, >, \t, space and \n )
		indentChar:'  ',//indentation unit
		multiline:true //if true, items in a collection, are separated by a \n, else just a space.
	};

	return jsDump;
})();

// from Sizzle.js
function getText( elems ) {
	var ret = "", elem;

	for ( var i = 0; elems[i]; i++ ) {
		elem = elems[i];

		// Get the text from text nodes and CDATA nodes
		if ( elem.nodeType === 3 || elem.nodeType === 4 ) {
			ret += elem.nodeValue;

		// Traverse everything else, except comment nodes
		} else if ( elem.nodeType !== 8 ) {
			ret += getText( elem.childNodes );
		}
	}

	return ret;
};

/*
 * Javascript Diff Algorithm
 *  By John Resig (http://ejohn.org/)
 *  Modified by Chu Alan "sprite"
 *
 * Released under the MIT license.
 *
 * More Info:
 *  http://ejohn.org/projects/javascript-diff-algorithm/
 *  
 * Usage: QUnit.diff(expected, actual)
 * 
 * QUnit.diff("the quick brown fox jumped over", "the quick fox jumps over") == "the  quick <del>brown </del> fox <del>jumped </del><ins>jumps </ins> over"
 */
QUnit.diff = (function() {
	function diff(o, n){
		var ns = new Object();
		var os = new Object();
		
		for (var i = 0; i < n.length; i++) {
			if (ns[n[i]] == null) 
				ns[n[i]] = {
					rows: new Array(),
					o: null
				};
			ns[n[i]].rows.push(i);
		}
		
		for (var i = 0; i < o.length; i++) {
			if (os[o[i]] == null) 
				os[o[i]] = {
					rows: new Array(),
					n: null
				};
			os[o[i]].rows.push(i);
		}
		
		for (var i in ns) {
			if (ns[i].rows.length == 1 && typeof(os[i]) != "undefined" && os[i].rows.length == 1) {
				n[ns[i].rows[0]] = {
					text: n[ns[i].rows[0]],
					row: os[i].rows[0]
				};
				o[os[i].rows[0]] = {
					text: o[os[i].rows[0]],
					row: ns[i].rows[0]
				};
			}
		}
		
		for (var i = 0; i < n.length - 1; i++) {
			if (n[i].text != null && n[i + 1].text == null && n[i].row + 1 < o.length && o[n[i].row + 1].text == null &&
			n[i + 1] == o[n[i].row + 1]) {
				n[i + 1] = {
					text: n[i + 1],
					row: n[i].row + 1
				};
				o[n[i].row + 1] = {
					text: o[n[i].row + 1],
					row: i + 1
				};
			}
		}
		
		for (var i = n.length - 1; i > 0; i--) {
			if (n[i].text != null && n[i - 1].text == null && n[i].row > 0 && o[n[i].row - 1].text == null &&
			n[i - 1] == o[n[i].row - 1]) {
				n[i - 1] = {
					text: n[i - 1],
					row: n[i].row - 1
				};
				o[n[i].row - 1] = {
					text: o[n[i].row - 1],
					row: i - 1
				};
			}
		}
		
		return {
			o: o,
			n: n
		};
	}
	
	return function(o, n){
		o = o.replace(/\s+$/, '');
		n = n.replace(/\s+$/, '');
		var out = diff(o == "" ? [] : o.split(/\s+/), n == "" ? [] : n.split(/\s+/));

		var str = "";
		
		var oSpace = o.match(/\s+/g);
		if (oSpace == null) {
			oSpace = [" "];
		}
		else {
			oSpace.push(" ");
		}
		var nSpace = n.match(/\s+/g);
		if (nSpace == null) {
			nSpace = [" "];
		}
		else {
			nSpace.push(" ");
		}
		
		if (out.n.length == 0) {
			for (var i = 0; i < out.o.length; i++) {
				str += '<del>' + out.o[i] + oSpace[i] + "</del>";
			}
		}
		else {
			if (out.n[0].text == null) {
				for (n = 0; n < out.o.length && out.o[n].text == null; n++) {
					str += '<del>' + out.o[n] + oSpace[n] + "</del>";
				}
			}
			
			for (var i = 0; i < out.n.length; i++) {
				if (out.n[i].text == null) {
					str += '<ins>' + out.n[i] + nSpace[i] + "</ins>";
				}
				else {
					var pre = "";
					
					for (n = out.n[i].row + 1; n < out.o.length && out.o[n].text == null; n++) {
						pre += '<del>' + out.o[n] + oSpace[n] + "</del>";
					}
					str += " " + out.n[i].text + nSpace[i] + pre;
				}
			}
		}
		
		return str;
	};
})();

})(this);

}};
__resources__["/__builtin__/libs/util.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
var path = require('path');

/**
 * @namespace
 * Useful utility functions
 */
var util = {
    /**
     * Merge two or more objects and return the result.
     *
     * @param {Object} firstObject First object to merge with
     * @param {Object} secondObject Second object to merge with
     * @param {Object} [...] More objects to merge
     * @returns {Object} A new object containing the properties of all the objects passed in
     */
    merge: function(firstObject, secondObject) {
        var result = {};

        for (var i = 0; i < arguments.length; i++) {
            var obj = arguments[i];

            for (var x in obj) {
                if (!obj.hasOwnProperty(x)) {
                    continue;
                }

                result[x] = obj[x];
            }
        };

        return result;
    },

    /**
     * Creates a deep copy of an object
     *
     * @param {Object} obj The Object to copy
     * @returns {Object} A copy of the original Object
     */
    copy: function(obj) {
        if (obj === null) {
            return null;
        }

        var copy;

        if (obj instanceof Array) {
            copy = [];
            for (var i = 0, len = obj.length; i < len; i++) {
                copy[i] = arguments.callee(obj[i]);
            }
        } else if (typeof(obj) == 'object') {
            if (typeof(obj.copy) == 'function') {
                copy = obj.copy();
            } else {
                copy = {};

                var o, x;
                for (x in obj) {
                    copy[x] = arguments.callee(obj[x]);
                }
            }
        } else {
            // Primative type. Doesn't need copying
            copy = obj;
        }

        return copy;
    },

    /**
     * Iterates over an array and calls a function for each item.
     *
     * @param {Array} arr An Array to iterate over
     * @param {Function} func A function to call for each item in the array
     * @returns {Array} The original array
     */
    each: function(arr, func) {
        var i = 0,
            len = arr.length;
        for (i = 0; i < len; i++) {
            func(arr[i], i);
        }

        return arr;
    },

    /**
     * Iterates over an array, calls a function for each item and returns the results.
     *
     * @param {Array} arr An Array to iterate over
     * @param {Function} func A function to call for each item in the array
     * @returns {Array} The return values from each function call
     */
    map: function(arr, func) {
        var i = 0,
            len = arr.length,
            result = [];

        for (i = 0; i < len; i++) {
            result.push(func(arr[i], i));
        }

        return result;
    },

    extend: function(target, ext) {
        if (arguments.length < 2) {
            throw "You must provide at least a target and 1 object to extend from"
        }

        var i, j, obj, key, val;

        for (i = 1; i < arguments.length; i++) {
            obj = arguments[i];
            for (key in obj) {
                // Don't copy built-ins
                if (!obj.hasOwnProperty(key)) {
                    continue;
                }

                val = obj[key];
                // Don't copy undefineds or references to target (would cause infinite loop)
                if (val === undefined || val === target) {
                    continue;
                }

                // Replace existing function and store reference to it in .base
                if (val instanceof Function && target[key] && val !== target[key]) {
                    val.base = target[key];
                    val._isProperty = val.base._isProperty;
                }
                target[key] = val;

                if (val instanceof Function) {
                    // If this function observes make a reference to it so we can set
                    // them up when this get instantiated
                    if (val._observing) {
                        // Force a COPY of the array or we will probably end up with various
                        // classes sharing the same one.
                        if (!target._observingFunctions) {
                            target._observingFunctions = [];
                        } else {
                            target._observingFunctions = target._observingFunctions.slice(0);
                        }


                        for (j = 0; j<val._observing.length; j++) {
                            target._observingFunctions.push({property:val._observing[j], method: key});
                        }
                    } // if (val._observing)

                    // If this is a computer property then add it to the list so get/set know where to look
                    if (val._isProperty) {
                        if (!target._computedProperties) {
                            target._computedProperties = [];
                        } else {
                            target._computedProperties = target._computedProperties.slice(0);
                        }

                        target._computedProperties.push(key)
                    }
                }
        
            }
        }


        return target;
    },

    beget: function(o) {
        var F = function(){};
        F.prototype = o;
        var ret  = new F();
        F.prototype = null;
        return ret;
    },

    callback: function(target, method) {
        if (typeof(method) == 'string') {
            var methodName = method;
            method = target[method];
            if (!method) {
                throw "Callback to undefined method: " + methodName;
            }
        }
        if (!method) {
            throw "Callback with no method to call";
        }

        return function() {
            method.apply(target, arguments);
        }
    },

    domReady: function() {
        if (this._isReady) {
            return;
        }

        if (!document.body) {
            setTimeout(function() { util.domReady(); }, 13);
        }

        window.__isReady = true;

        if (window.__readyList) {
            var fn, i = 0;
            while ( (fn = window.__readyList[ i++ ]) ) {
                fn.call(document);
            }

            window.__readyList = null;
            delete window.__readyList;
        }
    },


    /**
     * Adapted from jQuery
     * @ignore
     */
    bindReady: function() {

        if (window.__readyBound) {
            return;
        }

        window.__readyBound = true;

        // Catch cases where $(document).ready() is called after the
        // browser event has already occurred.
        if ( document.readyState === "complete" ) {
            return util.domReady();
        }

        // Mozilla, Opera and webkit nightlies currently support this event
        if ( document.addEventListener ) {
            // Use the handy event callback
            //document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false );
            
            // A fallback to window.onload, that will always work
            window.addEventListener( "load", util.domReady, false );

        // If IE event model is used
        } else if ( document.attachEvent ) {
            // ensure firing before onload,
            // maybe late but safe also for iframes
            //document.attachEvent("onreadystatechange", DOMContentLoaded);
            
            // A fallback to window.onload, that will always work
            window.attachEvent( "onload", util.domReady );

            // If IE and not a frame
            /*
            // continually check to see if the document is ready
            var toplevel = false;

            try {
                toplevel = window.frameElement == null;
            } catch(e) {}

            if ( document.documentElement.doScroll && toplevel ) {
                doScrollCheck();
            }
            */
        }
    },



    ready: function(func) {
        if (window.__isReady) {
            func()
        } else {
            if (!window.__readyList) {
                window.__readyList = [];
            }
            window.__readyList.push(func);
        }

        util.bindReady();
    },


    /**
     * Tests if a given object is an Array
     *
     * @param {Array} ar The object to test
     *
     * @returns {Boolean} True if it is an Array, otherwise false
     */
    isArray: function(ar) {
      return ar instanceof Array
          || (ar && ar !== Object.prototype && util.isArray(ar.__proto__));
    },


    /**
     * Tests if a given object is a RegExp
     *
     * @param {RegExp} ar The object to test
     *
     * @returns {Boolean} True if it is an RegExp, otherwise false
     */
    isRegExp: function(re) {
      var s = ""+re;
      return re instanceof RegExp // easy case
          || typeof(re) === "function" // duck-type for context-switching evalcx case
          && re.constructor.name === "RegExp"
          && re.compile
          && re.test
          && re.exec
          && s.charAt(0) === "/"
          && s.substr(-1) === "/";
    },


    /**
     * Tests if a given object is a Date
     *
     * @param {Date} ar The object to test
     *
     * @returns {Boolean} True if it is an Date, otherwise false
     */
    isDate: function(d) {
        if (d instanceof Date) return true;
        if (typeof d !== "object") return false;
        var properties = Date.prototype && Object.getOwnPropertyNames(Date.prototype);
        var proto = d.__proto__ && Object.getOwnPropertyNames(d.__proto__);
        return JSON.stringify(proto) === JSON.stringify(properties);
    },

    /**
     * Utility to populate a namespace's index with its modules
     *
     * @param {Object} parent The module the namespace lives in. parent.exports will be populated automatically
     * @param {String} modules A space separated string of all the module names
     *
     * @returns {Object} The index namespace
     */
    populateIndex: function(parent, modules) {
        var namespace = {};
        modules = modules.split(' ');

        util.each(modules, function(mod, i) {
            // Use the global 'require' which allows overriding the parent module
            util.extend(namespace, window.require('./' + mod, parent));
        });

        util.extend(parent.exports, namespace);

        return namespace;
    }


}

util.extend(String.prototype, /** @scope String.prototype */ {
    /**
     * Create an array of words from a string
     *
     * @returns {String[]} Array of the words in the string
     */
    w: function() {
        return this.split(' ');
    }
});




module.exports = util;

}};
__resources__["/__builtin__/path.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/** @namespace */
var path = {
    /**
     * Returns full directory path for the filename given. The path must be formed using forward slashes '/'.
     *
     * @param {String} path Path to return the directory name of
     * @returns {String} Directory name
     */
    dirname: function(path) {
        var tokens = path.split('/');
        tokens.pop();
        return tokens.join('/');
    },

    /**
     * Returns just the filename portion of a path.
     *
     * @param {String} path Path to return the filename portion of
     * @returns {String} Filename
     */
    basename: function(path) {
        var tokens = path.split('/');
        return tokens[tokens.length-1];
    },

    /**
     * Joins multiple paths together to form a single path
     * @param {String} ... Any number of string arguments to join together
     * @returns {String} The joined path
     */
    join: function () {
        return module.exports.normalize(Array.prototype.join.call(arguments, "/"));
    },

    /**
     * Tests if a path exists
     *
     * @param {String} path Path to test
     * @returns {Boolean} True if the path exists, false if not
     */
    exists: function(path) {
        return (__resources__[path] !== undefined);
    },

    /**
     * @private
     */
    normalizeArray: function (parts, keepBlanks) {
      var directories = [], prev;
      for (var i = 0, l = parts.length - 1; i <= l; i++) {
        var directory = parts[i];

        // if it's blank, but it's not the first thing, and not the last thing, skip it.
        if (directory === "" && i !== 0 && i !== l && !keepBlanks) continue;

        // if it's a dot, and there was some previous dir already, then skip it.
        if (directory === "." && prev !== undefined) continue;

        // if it starts with "", and is a . or .., then skip it.
        if (directories.length === 1 && directories[0] === "" && (
            directory === "." || directory === "..")) continue;

        if (
          directory === ".."
          && directories.length
          && prev !== ".."
          && prev !== "."
          && prev !== undefined
          && (prev !== "" || keepBlanks)
        ) {
          directories.pop();
          prev = directories.slice(-1)[0]
        } else {
          if (prev === ".") directories.pop();
          directories.push(directory);
          prev = directory;
        }
      }
      return directories;
    },

    /**
     * Returns the real path by expanding any '.' and '..' portions
     *
     * @param {String} path Path to normalize
     * @param {Boolean} [keepBlanks=false] Whether to keep blanks. i.e. double slashes in a path
     * @returns {String} Normalized path
     */
    normalize: function (path, keepBlanks) {
      return module.exports.normalizeArray(path.split("/"), keepBlanks).join("/");
    }
};

module.exports = path;

}};
__resources__["/__builtin__/system.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/** @namespace */
var system = {
    /** @namespace */
    stdio: {
        /**
         * Print text and objects to the debug console if the browser has one
         * 
         * @param {*} Any value to output
         */
        print: function() {
            if (console) {
                console.log.apply(console, arguments);
            } else {
                // TODO
            }
        }
    }
};

if (window.console) {
    system.console = window.console
} else {
    system.console = {
        log: function(){}
    }
}

}};
__resources__["/Barrel.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
// Import the cocos2d module
var cocos = require('cocos2d'),
// Import the geometry module
    geo = require('geometry'),
// Import the geometry module
	util = require('util');

var Barrel = cocos.nodes.Node.extend({
    velocity: null,
    mouseConect: false,
    init: function() {
       Barrel.superclass.init.call(this);
       var sprite = cocos.nodes.Sprite.create({
           file: '/resources/sprites.png',
           rect: new geo.Rect(0, 0, 64, 16)
           });
       sprite.set('anchorPointInPixels', new geo.Point(50, 0));
       this.addChild({child: sprite});
       this.set('contentSize', sprite.get('contentSize'));
    }
});

exports.Barrel = Barrel;
}};
__resources__["/Bullet.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
// Import the cocos2d module
var cocos = require('cocos2d'),
// Import the geometry module
    geo = require('geometry'),
// Import the geometry module
	util = require('util');

var Bullet = cocos.nodes.Node.extend({
    velocity: null,
    mouseConect: false,
    init: function() {
       Bullet.superclass.init.call(this);
       var sprite = cocos.nodes.Sprite.create({
           file: '/resources/ball.png',
           rect: new geo.Rect(0, 0, 64, 64)
           });
       sprite.set('anchorPointInPixels', new geo.Point(0, 0));
       this.set('scale',0.5);
       this.addChild({child: sprite});
       this.set('contentSize', sprite.get('contentSize'));
    }
});

exports.Bullet = Bullet;
}};
__resources__["/main.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
// Import the cocos2d module
var cocos = require('cocos2d'),
// Import the geometry module
    geo = require('geometry'),
// Import the geometry module
	util = require('util'),
// Import box2d Physics Engine
	box2d = require('box2d'),
// Import Barrel
	Barrel = require('Barrel').Barrel,
// Import Bullet
	Bullet = require('Bullet').Bullet;
	
// Create a new layer
var Box2ddemo = cocos.nodes.Layer.extend({    
	Barrel: null,
	Bullet: null,
	world: null,
    bodies: null,
    holes: null,
    contact: null,
    selectedBody: null,
    mouseJoint: null,
    init: function() {
        // You must always call the super class version of init
        Box2ddemo.superclass.init.call(this);
        
        this.set('isMouseEnabled', true);
        this.set('bodies', []);
        this.set('holes', []);

        // Get size of canvas
        var s = cocos.Director.get('sharedDirector').get('winSize');
        
        this.demo();
        this.scheduleUpdate();
        
        // Add Barrel
        var barrel = Barrel.create();
        barrel.set('position', new geo.Point(5*420/14+15,6.5*420/14));
        this.addChild({child: barrel,z:20});
        this.set('barrel', barrel);
        
        //Add bullet
        var bullet = Bullet.create();
        bullet.set('position',new geo.Point(5*420/14+15,6.5*420/14));
        this.addChild({child: bullet,z:20});
        this.set('bullet', bullet);
        
        // Add Menu
        var up = cocos.nodes.MenuItemImage.create({normalImage: "/resources/up.png",
                                                    selectedImage:"/resources/sprites.png",
                                                    callback: util.callback(this, 'moveUp')});
        var down = cocos.nodes.MenuItemImage.create({normalImage: "/resources/down.png",
                                                    selectedImage:"/resources/sprites.png",
                                                    callback: util.callback(this, 'moveDown')});
        var right = cocos.nodes.MenuItemImage.create({normalImage: "/resources/right.png",
                                                    selectedImage:"/resources/sprites.png",
                                                    callback: util.callback(this, 'turnRight')});
        var left = cocos.nodes.MenuItemImage.create({normalImage: "/resources/left.png",
                                                    selectedImage:"/resources/sprites.png",
                                                    callback: util.callback(this, 'turnLeft')});
        var shot = cocos.nodes.MenuItemImage.create({normalImage: "/resources/bnx150x64_02.png",
                                                    selectedImage:"/resources/bnx150x64_02.png",
                                                    callback: util.callback(this, 'shotBall')});
        up.set('position',new geo.Point( 32,32)); 
        down.set('position',new geo.Point( 32, 370));
        right.set('position',new geo.Point( 32, 64+32));
        left.set('position',new geo.Point( 32, 370-64));
        shot.set('position',new geo.Point( 32, 64+64+75))
        var menu = cocos.nodes.Menu.create({items: [up,down,right,left,shot]});
        menu.set('position',new geo.Point(0,0));
        this.addChild({child: menu, z: 9});  
    },
    
    createCrate: function(point, scale){
    	scale = scale || 1;
    	var sprite = cocos.nodes.Sprite.create({file:'/resources/crate.jpg'});
    	sprite.set('position',point);
    	sprite.set('scale',scale/2);
    	this.addChild(sprite);
    	return sprite;	
    },
    createBall: function(point, scale){
    	scale = scale || 1;
    	var sprite = cocos.nodes.Sprite.create({file:'/resources/ball.png'});
    	sprite.set('position',point);
    	sprite.set('scale',scale);
    	this.addChild(sprite);
    	return sprite;
    },
    createShot: function(point, scale){
    	scale = scale || 1;
    	var sprite = cocos.nodes.Sprite.create({file:'/resources/ball.png'});
    	sprite.set('position',point);
    	sprite.set('scale',scale);
    	this.addChild(sprite);
    	return sprite;
    },
    createHole: function(point,scale){
    	scale = scale || 1;
    	var sprite = cocos.nodes.Sprite.create({file:'/resources/ball.png'});
    	sprite.set('position',point);
    	sprite.set('scale',scale);
    	this.addChild(sprite);
    	return sprite;
    },
    
    update: function(dt){
    	var world = this.get('world'),
    		mouseJoint = this.get('mouseJoint');
    	
    	world.Step(dt, 10, 10);
    	world.ClearForces();
    	
    	var bodies = this.get('bodies'),
    		holes = this.get('holes');
   		for(var len = bodies.length-1, i = len; i >= 0; i--){
   			var body = bodies[i],
   				pos = body.GetPosition(),
    			angle = geo.radiansToDegrees(body.GetAngle());
   			body.sprite.set('position', new geo.Point(pos.x * 30, pos.y * 30));
   			body.sprite.set('rotation',angle);
   			for(var j = 0, hlen = holes.length; j < hlen; j++){
   				//console.log(bodies.length,i,body);
   				var hole = holes[j],
   					hpos = hole.GetPosition();
    			if(Math.sqrt(Math.pow(pos.x-hpos.x,2)+Math.pow(pos.y-hpos.y,2))<=0.75){
   					this.removeChild({child:body.sprite,cleanup:true});
   					world.DestroyBody(body);
   					bodies.splice(i,1)
   				}
   			}
   		}   		
   	
    	this.testHoleCollision();
    },
    testHoleCollision: function(){
    	var world = this.get('world'),
    		contact = this.get('contact'),
    		bodies = this.get('bodies'),
    		holes = this.get('holes');
    	//console.log(contact.IsTouching());
    	//console.log(holes);
    	//console.log(bodies);
    	//world.DestroyBody(hole);
    	
    },
    
    demo: function() {
    	var world = new box2d.b2World(new box2d.b2Vec2(0,0),true);
    	this.set('world',world);
    	var contact = new box2d.b2Contact;
    	this.set('contact',contact);
    	
    	var fixDef = new box2d.b2FixtureDef;
    	fixDef.density = 1.0;
    	fixDef.friction = 1.0;
    	fixDef.restitution = 1.0;
    	var bodyDef = new box2d.b2BodyDef;
    	
    	//create ground
    	bodyDef.type = box2d.b2Body.b2_staticBody;
        fixDef.shape = new box2d.b2PolygonShape;
        
        fixDef.shape.SetAsBox(20, 2);
        bodyDef.position.Set(10, 400 / 30 + 2);
        world.CreateBody(bodyDef).CreateFixture(fixDef);
        bodyDef.position.Set(10, -2);
        world.CreateBody(bodyDef).CreateFixture(fixDef);
        
        fixDef.shape.SetAsBox(4, 14);
        bodyDef.position.Set(1, 13);
        world.CreateBody(bodyDef).CreateFixture(fixDef);
        bodyDef.position.Set(23, 13);
        world.CreateBody(bodyDef).CreateFixture(fixDef);
    	
    	//create Hole
    	fixDef.shape = new box2d.b2CircleShape(0.5);
    	fixDef.isSensor = true;
    	for(var i = 0; i < 3; i++){
    		bodyDef.position.x = 18;
    		bodyDef.position.y = 14/3*i+14/6;
    		sprite = this.createHole(new geo.Point(bodyDef.position.x * 30, bodyDef.position.y * 30), scale);
    		var hole = world.CreateBody(bodyDef);
            hole.sprite = sprite;
        	this.get('holes').push(hole);
        	hole.CreateFixture(fixDef);	
    	}
    	
        fixDef.isSensor = false;
    	
    	//create some objects
        bodyDef.type = box2d.b2Body.b2_dynamicBody;
        
        /*create shot ball
        bodyDef.position.x = 5;
        bodyDef.position.y = 6.5;
        var scale = 0.5,
            width = scale * 30;
        fixDef.shape = new box2d.b2CircleShape(width/30);
        sprite = this.createBall(new geo.Point(bodyDef.position.x * 30, bodyDef.position.y * 30), scale);

        var bullet = world.CreateBody(bodyDef);
        bullet.sprite = sprite;
        this.get('bodies').push(bullet);
        bullet.CreateFixture(fixDef);
        */
        //create some ball        
        for (var i = 0; i < 9*3; ++i) {
            var sprite;
            //bodyDef.position.x = Math.random() * 15;
            //bodyDef.position.y = Math.random() * 15;
            //var scale = (Math.random() + 0.5),
            //    width = scale * 32;
            //if (Math.random() > 0.5) {
            //    fixDef.shape = new box2d.b2PolygonShape;
            //    fixDef.shape.SetAsBox(width/30, width/30);
            //    sprite = this.createCrate(new geo.Point(bodyDef.position.x * 30, bodyDef.position.y * 30), scale);
            //} else {
            //    fixDef.shape = new box2d.b2CircleShape(width/30);
            //    sprite = this.createBall(new geo.Point(bodyDef.position.x * 30, bodyDef.position.y * 30), scale);
            //}
            if(i<9){
            	bodyDef.position.x = 14;
            	bodyDef.position.y = 2.5+(i*1);
            }else if(i<9*2){
            	bodyDef.position.x = 13;
            	bodyDef.position.y = 2.5+((i-9)*1);
            }else{
            	bodyDef.position.x = 12;
            	bodyDef.position.y = 2.5+((i-18)*1);
            }
            bodyDef.linearDamping = 0.3;
            bodyDef.angularDamping = 0.5;
            var scale = 0.5,
                width = scale * 30;
            fixDef.shape = new box2d.b2CircleShape(width/30);
            sprite = this.createBall(new geo.Point(bodyDef.position.x * 30, bodyDef.position.y * 30), scale);
            
            var bdy = world.CreateBody(bodyDef);
            bdy.sprite = sprite;
            this.get('bodies').push(bdy);
            bdy.CreateFixture(fixDef);
		}
		fixDef.isSensor = true;
    },
    
    getBodyAtPoint: function(point){
    	point = new geo.Point(point.x /30, point.y /30);
        var world = this.get('world');
        var mousePVec = new box2d.b2Vec2(point.x, point.y);
        var aabb = new box2d.b2AABB();
        aabb.lowerBound.Set(point.x - 0.001, point.y - 0.001);
        aabb.upperBound.Set(point.x + 0.001, point.y + 0.001);

        var self = this;
        function getBodyCB(fixture) {
            if(fixture.GetBody().GetType() != box2d.b2Body.b2_staticBody) {
                if(fixture.GetShape().TestPoint(fixture.GetBody().GetTransform(), mousePVec)) {
                    self.set('selectedBody', fixture.GetBody());
                    return false;
                }
            }
            return true;
        }

        // Query the world for overlapping shapes.
        this.set('selectedBody', null);
        world.QueryAABB(getBodyCB, aabb);
        return this.get('selectedBody');
    },
    
    mouseDown: function(evt) {
        var point = evt.locationInCanvas,
            world = this.get('world'),
            mouseJoint = this.get('mouseJoint'),
            barrel = this.get('barrel'),
            bullet = this.get('bullet');
			
        if (!mouseJoint) {
            var body = this.getBodyAtPoint(point);
            if(body) {
                var md = new box2d.b2MouseJointDef();
                md.bodyA = world.GetGroundBody();
                md.bodyB = body;
                md.target.Set(point.x /30, point.y /30);
                md.collideConnected = true;
                md.maxForce = 300.0 * body.GetMass();
                mouseJoint = world.CreateJoint(md);
                body.SetAwake(true);
                this.set('mouseJoint', mouseJoint);
            }
        }
        
        if(!barrel.mouseConect){
        	var pos = util.copy(barrel.get('position')),
        		rot = util.copy(barrel.get('rotaiton')),
        		slope = Math.tan(Math.PI*rot/180),
        		intercept = 16/Math.cos(Math.PI*rot/180);
        	if(point.x>=pos.x-64-16 && point.x<=pos.x-16){
        		if(point.y<=pos.y+8 && point.y>=pos.y-8){
        			barrel.mouseConect=true;	
        		}
        	}
        }
        if(!bullet.mouseConect){
     		var pos = util.copy(bullet.get('position'));  
     		if(Math.sqrt(Math.pow(pos.x-point.x,2)+Math.pow(pos.y-point.y,2))<=16){
     			bullet.mouseConect=true;
     		}
        	
        }
        console.log(barrel.mouseConect,bullet.mouseConect);
    }, 
    mouseDragged: function(evt) {
        var point = evt.locationInCanvas,
            world = this.get('world'),
            mouseJoint = this.get('mouseJoint'),
            barrel = this.get('barrel'),
            bullet = this.get('bullet');
		//console.log(point,mouseJoint);
        if (mouseJoint) {
            mouseJoint.SetTarget(new box2d.b2Vec2(point.x /30, point.y /30));
        }
        if(barrel.mouseConect){
        	var pos = util.copy(barrel.get('position'));
        	pos.y = point.y;
        	barrel.set('position',pos);
        	bullet.set('position',pos);
        }
        if(bullet.mouseConect){
        	var pos = util.copy(barrel.get('position')),
        		rot = util.copy(barrel.get('rotation'));
        	pos.x = -pos.x+point.x;
        	pos.y = -pos.y+point.y;
        	rot = Math.atan2(pos.y,pos.x);
        	barrel.set('rotation',rot*180/Math.PI); 
        	console.log(pos.x,pos.y,rot*180/Math.PI);
        }
    }, 
	mouseUp: function(evt) {
        var mouseJoint = this.get('mouseJoint'),
            world = this.get('world'),
            barrel = this.get('barrel'),
            bullet = this.get('bullet');

        if (mouseJoint) {
            world.DestroyJoint(mouseJoint);
            this.set('mouseJoint', null);
        }
        if(barrel.mouseConect){
        	barrel.mouseConect=false;
        }
        if(bullet.mouseConect){
        	bullet.mouseConect=false;
        	this.shotBall();
        }
        console.log(barrel.mouseConect,bullet.mouseConect);
   },
   
   moveUp: function(){
   		var barrel = this.get('barrel'),
        	pos = util.copy(barrel.get('position')),
        	bullet = this.get('bullet');  
        if(pos.y>(6.5*400/14+10)-10*11){
        	pos.y -= 10;	
        }
        barrel.set('position',pos);
        bullet.set('position',pos);
        
   },
   moveDown: function(){
   		var barrel = this.get('barrel'),
        	pos = util.copy(barrel.get('position')),
        	bullet = this.get('bullet');   
       if(pos.y<(6.5*400/14+10)+10*12){
        	pos.y += 10;	
        }
        barrel.set('position',pos);
        bullet.set('position',pos); 
   },
   turnRight: function(){
   		var barrel = this.get('barrel'),
   			rotation = util.copy(barrel.get('rotation'));
   		rotation -= 5;
   		barrel.set('rotation',rotation); 	
   },
   turnLeft: function(){
   		var barrel = this.get('barrel'),
   			rotation = util.copy(barrel.get('rotation'));
   		rotation += 5;
   		barrel.set('rotation',rotation);
   },
   shotBall: function(){
   		var world = this.get('world');
    	var barrel = this.get('barrel'),
    		position = util.copy(barrel.get('position')), 
    		rotation = util.copy(barrel.get('rotation'));
    	
    	var fixDef = new box2d.b2FixtureDef;
    	fixDef.density = 8.0;
    	fixDef.friction = 1.0;
    	fixDef.restitution = 1.0;
    	var bodyDef = new box2d.b2BodyDef;
    	
   		bodyDef.type = box2d.b2Body.b2_dynamicBody;
   		bodyDef.position.x = 5;
        bodyDef.position.y = (position.y)*14/420;
        bodyDef.linearVelocity.x = 10*Math.cos(Math.PI*rotation/180);
        bodyDef.linearVelocity.y = 10*Math.sin(Math.PI*rotation/180);
        bodyDef.linearDamping = 0.3;
        bodyDef.angularDamping = 0.5;
        var scale = 0.5,
            width = scale * 30;
        fixDef.shape = new box2d.b2CircleShape(width/30);
        sprite = this.createShot(new geo.Point(bodyDef.position.x * 30, bodyDef.position.y * 30), scale);
        var blt = world.CreateBody(bodyDef);
        blt.sprite = sprite;
        this.get('bodies').push(blt);
        blt.CreateFixture(fixDef);
   }
});



exports.main = function() {
    // Initialise application

    // Get director
    var director = cocos.Director.get('sharedDirector');

    // Attach director to our <div> element
    director.attachInView(document.getElementById('box2ddemo_app'));

    director.set('displayFPS', true);
    
    // Create a scene
    var scene = cocos.nodes.Scene.create();

    // Add our layer to the scene
    scene.addChild({child: Box2ddemo.create()});

    // Run the scene
    director.runWithScene(scene);
};

}};
__resources__["/mouseJoint.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {

}};
__resources__["/resources/ball.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,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")};
__resources__["/resources/bnx150x64_02.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,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")};
__resources__["/resources/bnx600x150_02.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,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7jXYZMOGDW7FrVmzxu68807761//KgY7x+pqZ1vEsOE2adIkO/XMM+zsTRfIfVFqvRRtD4vpKx/IDPv868+c6Hz77Xft2ONOsBWrVrqIwIABA/RDLrB+/fo59nr//fftl19+sdraWved+++7n5122ikOYAMUtQ/PiHXR+93338c+//xz+02guGzTJbbPPvvYa2+9aY9sfVJe7hKJt9HO+YpHP08RgkKyDZSTlJyTavsftr+98MrLulWBf17P85PtxfyiRYtsZEq05U2WLjot37lR8orHCpx5bhNw9mwepTTdLNXbxYih+6VIYZbfKU0L+eFnX7W/fGv2/S8/2OeffGV33H6vna7Qy157rbactHQrmVxsX3//DXixG6+73u67+zbnm3rikQftxmtutA2HnWovPvWB3X/LI3bm8efbsvnatrdOO7Ut3Fdb+e5nS2q1V3bL3rZAXvQ5k5QOVKnN3vXaourltqB8sS0oXmCrq5bboXOW2Ml7HKLvgSnRnrdJpW8++4fde/vddtrGU5zUGaMU9t59AxYp44Yb/2z3P/iAhccOdcCKleN0pHLDJkyR5CmeWuIcpBVV2pKkbIKbGMQgyjrZiFlyZuLx9RYJVgQyGH3n559/dko1Nzg6Olp0/qKb+3/+8592/vnna9+8NFuyrEt1i9kOjGefeZZ7n4t/7YM31OVX0fP4wTY0bpgdue4IJ0bXr19va/feywYNkZktSyUvL68bRImJidbV1WWHHHKIRURE2MyZM23J4i4nMnvJchmg85AOcuyZJzlQMFVnn35awOLRKFS2LOzz4hsvOhFJVICFA8PAOoSRNl1zqf3yn58DJMA5tFBCj4iF77//3r12ww03OB/bKFl7WSpnH6MFmKIihiSFWRDFIxSGIUoQkx6ltBX5h6I1JLpHJI5SM16Vxq84UQ7S9WK6ZTY4Ml3zOFQSQIHmEVH26qsvOyb6+dv/yJWgWF4QVLdcf5dAda4tnX+otdXta611e9jMSdrZvkDFL9OXacevNbakYa2t7TzEDltznG3c/xg1EznaFsxaqN5ac8RcCvZPnSPLMMvihydYelSalU8otUvOutjuv+N+e3nry3bBaefZslZt4FBaY8WT5HQummZxI2JskILh3MeRI0faNX+61h6TZz8lUz5IWYcF8mmRbBidkGxTy6aJsUrKnCisaaiRsqvdmxRu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")};
__resources__["/resources/crate.jpg"] = {meta: {mimetype: "image/jpeg"}, data: __imageResource("data:image/jpeg;base64,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")};
__resources__["/resources/down.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAIAAAAlC+aJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAFUSURBVGhD7ZnBEsMgCERr//+f03Qyk7bBirIgmCGnHMTwdkHstGzb9lj5ea6c/Dv3BPB2sFx6oJTinVLr+7Rjf0ooePY7Gc3wRj0QX/5qbX0cWHQg3KiEdoPim0AzvB6jR51F64eGsnUAcBT847dw+F49AArvEp4OuMj+9dF0IB0AFcgSAgWEw2dP4suQxmfz1BKiVwz80jUVoFovIIM/AHj5DQGAMEQBEDNMBWDPHEE/TAXo+dU6yjAbQJ3BAUCXwQdAkcENQIvBE6CHgb3sOQOwDOyh5A/QZmBHRwgA1odGIUUBqDKw8u9RgQAOhiPp82WBJqYp9gh/RsVygNWbLkgAgWiqIemAqpyCzdIBgWiqIemAqpyCzdIBgWiqIemAqpyCzdIBgWiqISYODF3oQRwTADCnoXArAGqCkS0mf/INSQgutnIATKs/PAH6tbJZubwDLzxzaVGhuhsoAAAAAElFTkSuQmCC")};
__resources__["/resources/left.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAIAAAAlC+aJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAG5SURBVGhD7VrREsIwCLP+/z/Ped7t5tZC6EKhOh+9DkhCaDsty7I8Zv48Zy7+XfsNIFrB4ueBUsoenVMirxY6VL8iOX9DEc8FgFOtVcAuACjUgkH4AEbSf4/Rk8wC/ZNNIbCDry9jemA8/UwPDPbuJh1TgVY/OHX/Jx0HQBT9NACCF13p5wAI8e5GWf00GtgSZzFlDSsAUlW/4WnB4Jj4+n6kRmjROg2AFsIbgKq984KKAt6Tm4tIutSnGkctWnveSsTuXAcBzSZOJQvnKKHuNdymv6RAquZhHqddOZaDGzyQkH6DB7J5l3mljN34oBZKS/+qA7SRDQDQLaMOYED1+zljRaK00ODq3y3x/bOIOqAhD6hRAhdIAKxkhMD4XQVy7rtnkTsVsM4KvLuskc0vtpAELfWQZ3GozdPoFN7tPAt5UGilXLnQzEW/4Ti9Lk1I/xHALKNz30WdY/Ri4xIfhwDkbJ6/udRnpr9yI1P/pTRyziLc6TeyzXAjSz+4XEACmbjjokScM3J2FAC3IGI0CEBg86hQIQCImdRMTgsgAE65KWFRALEiCNkNY5RCGD0IqgA9MSvg9ABetNCHXRkFMYAAAAAASUVORK5CYII=")};
__resources__["/resources/right.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAIAAAAlC+aJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAGYSURBVGhD7VjbrsIwDKP8/z+PAdI0ujaXzbmU9TweTUlsx0lKWZblMfLfc+Ti37VPANEKFjsPlFL26IwSWbVQVf2K5PgfiHgmAIxqbQI2AQChVhgED8CT/jlGDzIT9A82hYQdfP0zpAf86Ud6wNm7m3RIBXr9YNT933QYAFH0wwAQXjSlHwMgxLsbZe1rNLAljmLSGjYApKp+w9ODgTHx9X3ERujROgyAHsIJgNXe+IOGAtaTG4uIetSnGkc9Ws/8KhG7uSoB1SZOJQvmlGB3DbbpLymQqnmQ57Qpx3RwhQcS0q/wQDbvIp+UsYtPtAc86dfSkQ7A3rISMLyJPemvBo4kNQNAEiJwhiqmUGyVRHZKgfz0/7UCQ9C/KtAdoyoAknlHu6iXjo3c9oCq+lh/NwAMVP0/mngs+nUKsH4KMcOPB3I+WWAvshCC2aT8NbqGyNk8t3nUZ6a/nkLHWpNXT91CTfecvlhYL56OLHoTb+n91xzbAqIpxPIX+MEEEEj+J/XNFGAt5a/HzRRwvoskguv2gH+HsBlfUMCBXfdKUqcAAAAASUVORK5CYII=")};
__resources__["/resources/sprites.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,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")};
__resources__["/resources/up.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAIAAAAlC+aJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAELSURBVGhD7ZnrCsIwDIX3/i89B4Kw2dUeD0mb8e2f0LQ5t2jnthd/tuL97wCYrSAK3CuwnZ8gqaIUuHT//hiBIWTTo9HaAJrdV1IAAEJYQjKAAiggMNBaioUEAgkxFhLs0iTLrG+WE2KBVUJMiAW7TA/xXbid0KdmQAXwWd9RqQaAzm0OAMoU+ttCKCCOOodpdSLVyMAqU0gUcmh5qgJDHYmLAKCMUZHcoeUogAJDRun8jWLWcyd2CSTEhNj0EBbCQljIZAALmQQyhda0UMRrBWdP4VLvHJNQ+43klIGEDvwjLhgeBMDnJmeH5ypwIMuh0Dylp8D6GH5MIfNbfUp5yE+JTCQAyGS7ddYLEBesTuY6kvQAAAAASUVORK5CYII=")};/*globals module exports resource require window Module __main_module_name__ __resources__*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

function resource(path) {
    // Check for packed resource
    var r = __resources__[path];
    if (r) {
        return r.data;
    }

    // Check for remote resource
    r = __remote_resources__[path];
    if (r) {
        // Load remote image
        if (r.meta.mimetype.split('/')[0] == 'image') {
            return require('cocos2d').RemoteImage.create({url: r.data, path: path});
        } else {
            return require('cocos2d').RemoteResource.create({url: r.data, path: path});
        }
    }

    throw("Unable to find resource: " + path.toString());
}

(function () {
    var process = {};
    var modulePaths = ['/__builtin__', '/__builtin__/libs', '/libs', '/'];

    var path; // Will be loaded further down

    function resolveModulePath(request, parent) {
        // If not a relative path then search the modulePaths for it
        var start = request.substring(0, 2);
        if (start !== "./" && start !== "..") {
            return modulePaths;
        }

        var parentIsIndex = path.basename(parent.filename).match(/^index\.js$/),
            parentPath    = parentIsIndex ? parent.id : path.dirname(parent.id);

        // Relative path so searching inside parent's directory
        return [path.dirname(parent.filename)];
    }

    function findModulePath(id, dirs) {
        if (id.charAt(0) === '/') {
            dirs = [''];
        }
        for (var i = 0; i < dirs.length; i++) {
            var dir = dirs[i];
            var p = path.join(dir, id);

            // Check for index first
            if (path.exists(path.join(p, 'index.js'))) {
                return path.join(p, 'index.js');
            } else if (path.exists(p + '.js')) {
                return p + '.js';
            }
        }

        return false;
    }

    function loadModule(request, parent) {
        parent = parent || process.mainModule;

        var paths    = resolveModulePath(request, parent),
            filename = findModulePath(request, paths);

        if (filename === false) {
            throw "Unable to find module: " + request;
        }


        if (parent) {
            var cachedModule = parent.moduleCache[filename];
            if (cachedModule) {
                return cachedModule;
            }
        }

        //console.log('Loading module: ', filename);

        var module = new Module(filename, parent);

        // Assign main module to process
        if (request == __main_module_name__ && !process.mainModule) {
            process.mainModule = module;
        }

        // Run all the code in the module
        module._initialize(filename);

        return module;
    }

    function Module(id, parent) {
        this.id = id;
        this.parent = parent;
        this.children = [];
        this.exports = {};

        if (parent) {
            this.moduleCache = parent.moduleCache;
            parent.children.push(this);
        } else {
            this.moduleCache = {};
        }
        this.moduleCache[this.id] = this;

        this.filename = null;
        this.dirname = null;
    }

    Module.prototype._initialize = function (filename) {
        var module = this;
        function require(request) {
            return loadModule(request, module).exports;
        }

        this.filename = filename;

        // Work around incase this IS the path module
        if (path) {
            this.dirname = path.dirname(filename);
        } else {
            this.dirname = '';
        }

        require.paths = modulePaths;
        require.main = process.mainModule;

        __resources__[this.filename].data.apply(this.exports, [this.exports, require, this, this.filename, this.dirname]);

        return this;
    };

    // Manually load the path module because we need it to load other modules
    path = (new Module('path'))._initialize('/__builtin__/path.js').exports;

    var util = loadModule('util').exports;
    util.ready(function () {
        // Populate globals
        var globals = loadModule('global').exports;
        for (var x in globals) {
            if (globals.hasOwnProperty(x)) {
                window[x] = globals[x];
            }
        }

        // Add a global require. Useful in the debug console.
        window.require = function require(request, parent) {
            return loadModule(request, parent).exports;
        };
        window.require.paths = modulePaths;

        process.mainModule = loadModule(__main_module_name__);

        window.require.main = process.mainModule;

        if (process.mainModule.exports.main) {
            process.mainModule.exports.main();
        }

    });
})();

// vim:ft=javascript

})();
